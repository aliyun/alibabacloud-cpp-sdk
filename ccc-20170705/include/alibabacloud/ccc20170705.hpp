// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CCC20170705_H_
#define ALIBABACLOUD_CCC20170705_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CCC20170705 {
class AddAgentDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientPort{};
  shared_ptr<string> browserVersion{};
  shared_ptr<string> remark{};

  AddAgentDeviceRequest() {}

  explicit AddAgentDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (browserVersion) {
      res["BrowserVersion"] = boost::any(*browserVersion);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<string>(boost::any_cast<string>(m["ClientPort"]));
    }
    if (m.find("BrowserVersion") != m.end() && !m["BrowserVersion"].empty()) {
      browserVersion = make_shared<string>(boost::any_cast<string>(m["BrowserVersion"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~AddAgentDeviceRequest() = default;
};
class AddAgentDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> agentDeviceId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  AddAgentDeviceResponseBody() {}

  explicit AddAgentDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (agentDeviceId) {
      res["AgentDeviceId"] = boost::any(*agentDeviceId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("AgentDeviceId") != m.end() && !m["AgentDeviceId"].empty()) {
      agentDeviceId = make_shared<long>(boost::any_cast<long>(m["AgentDeviceId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAgentDeviceResponseBody() = default;
};
class AddAgentDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddAgentDeviceResponseBody> body{};

  AddAgentDeviceResponse() {}

  explicit AddAgentDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAgentDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAgentDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~AddAgentDeviceResponse() = default;
};
class AddBulkPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<vector<string>> phoneNumber{};
  shared_ptr<vector<string>> skillGroupId{};

  AddBulkPhoneNumbersRequest() {}

  explicit AddBulkPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddBulkPhoneNumbersRequest() = default;
};
class AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> arrearagePhoneNumber{};

  AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers() {}

  explicit AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrearagePhoneNumber) {
      res["ArrearagePhoneNumber"] = boost::any(*arrearagePhoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArrearagePhoneNumber") != m.end() && !m["ArrearagePhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ArrearagePhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ArrearagePhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      arrearagePhoneNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers() = default;
};
class AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};

  AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup() {}

  explicit AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup() = default;
};
class AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups : public Darabonba::Model {
public:
  shared_ptr<vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup>> skillGroup{};

  AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups() {}

  explicit AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroup) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroup"].type()) {
        vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroup = make_shared<vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup>>(expect1);
      }
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups() = default;
};
class AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};

  AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow() {}

  explicit AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow() = default;
};
class AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups> skillGroups{};
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow> contactFlow{};
  shared_ptr<string> phoneNumberId{};

  AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber() {}

  explicit AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroups) {
      res["SkillGroups"] = skillGroups ? boost::any(skillGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillGroups"].type()) {
        AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillGroups"]));
        skillGroups = make_shared<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups>(model1);
      }
    }
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow>(model1);
      }
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber() = default;
};
class AddBulkPhoneNumbersResponseBodyPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber>> phoneNumber{};

  AddBulkPhoneNumbersResponseBodyPhoneNumbers() {}

  explicit AddBulkPhoneNumbersResponseBodyPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<AddBulkPhoneNumbersResponseBodyPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyPhoneNumbers() = default;
};
class AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedPhoneNumber{};

  AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers() {}

  explicit AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedPhoneNumber) {
      res["FailedPhoneNumber"] = boost::any(*failedPhoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedPhoneNumber") != m.end() && !m["FailedPhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedPhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedPhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedPhoneNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers() = default;
};
class AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> userdPhoneNumber{};

  AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers() {}

  explicit AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userdPhoneNumber) {
      res["UserdPhoneNumber"] = boost::any(*userdPhoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserdPhoneNumber") != m.end() && !m["UserdPhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserdPhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserdPhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userdPhoneNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers() = default;
};
class AddBulkPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers> arrearagePhoneNumbers{};
  shared_ptr<AddBulkPhoneNumbersResponseBodyPhoneNumbers> phoneNumbers{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers> failedPhoneNumbers{};
  shared_ptr<AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers> userdPhoneNumbers{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  AddBulkPhoneNumbersResponseBody() {}

  explicit AddBulkPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arrearagePhoneNumbers) {
      res["ArrearagePhoneNumbers"] = arrearagePhoneNumbers ? boost::any(arrearagePhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (failedPhoneNumbers) {
      res["FailedPhoneNumbers"] = failedPhoneNumbers ? boost::any(failedPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userdPhoneNumbers) {
      res["UserdPhoneNumbers"] = userdPhoneNumbers ? boost::any(userdPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ArrearagePhoneNumbers") != m.end() && !m["ArrearagePhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["ArrearagePhoneNumbers"].type()) {
        AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ArrearagePhoneNumbers"]));
        arrearagePhoneNumbers = make_shared<AddBulkPhoneNumbersResponseBodyArrearagePhoneNumbers>(model1);
      }
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        AddBulkPhoneNumbersResponseBodyPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<AddBulkPhoneNumbersResponseBodyPhoneNumbers>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("FailedPhoneNumbers") != m.end() && !m["FailedPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedPhoneNumbers"].type()) {
        AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedPhoneNumbers"]));
        failedPhoneNumbers = make_shared<AddBulkPhoneNumbersResponseBodyFailedPhoneNumbers>(model1);
      }
    }
    if (m.find("UserdPhoneNumbers") != m.end() && !m["UserdPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserdPhoneNumbers"].type()) {
        AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserdPhoneNumbers"]));
        userdPhoneNumbers = make_shared<AddBulkPhoneNumbersResponseBodyUserdPhoneNumbers>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddBulkPhoneNumbersResponseBody() = default;
};
class AddBulkPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddBulkPhoneNumbersResponseBody> body{};

  AddBulkPhoneNumbersResponse() {}

  explicit AddBulkPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddBulkPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddBulkPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~AddBulkPhoneNumbersResponse() = default;
};
class AddPhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> usage{};
  shared_ptr<string> contactFlowId{};

  AddPhoneNumberRequest() {}

  explicit AddPhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~AddPhoneNumberRequest() = default;
};
class AddPhoneNumberResponseBodyPhoneNumberContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};

  AddPhoneNumberResponseBodyPhoneNumberContactFlow() {}

  explicit AddPhoneNumberResponseBodyPhoneNumberContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~AddPhoneNumberResponseBodyPhoneNumberContactFlow() = default;
};
class AddPhoneNumberResponseBodyPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<AddPhoneNumberResponseBodyPhoneNumberContactFlow> contactFlow{};
  shared_ptr<string> phoneNumberId{};

  AddPhoneNumberResponseBodyPhoneNumber() {}

  explicit AddPhoneNumberResponseBodyPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        AddPhoneNumberResponseBodyPhoneNumberContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<AddPhoneNumberResponseBodyPhoneNumberContactFlow>(model1);
      }
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~AddPhoneNumberResponseBodyPhoneNumber() = default;
};
class AddPhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<AddPhoneNumberResponseBodyPhoneNumber> phoneNumber{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  AddPhoneNumberResponseBody() {}

  explicit AddPhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = phoneNumber ? boost::any(phoneNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumber"].type()) {
        AddPhoneNumberResponseBodyPhoneNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumber"]));
        phoneNumber = make_shared<AddPhoneNumberResponseBodyPhoneNumber>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPhoneNumberResponseBody() = default;
};
class AddPhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddPhoneNumberResponseBody> body{};

  AddPhoneNumberResponse() {}

  explicit AddPhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneNumberResponse() = default;
};
class AddPhoneTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> serviceTag{};
  shared_ptr<string> regionNameProvince{};
  shared_ptr<string> regionNameCity{};
  shared_ptr<long> type{};
  shared_ptr<long> concurrency{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> provider{};
  shared_ptr<string> sipTag{};
  shared_ptr<vector<string>> phoneNumberList{};

  AddPhoneTagsRequest() {}

  explicit AddPhoneTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceTag) {
      res["ServiceTag"] = boost::any(*serviceTag);
    }
    if (regionNameProvince) {
      res["RegionNameProvince"] = boost::any(*regionNameProvince);
    }
    if (regionNameCity) {
      res["RegionNameCity"] = boost::any(*regionNameCity);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (concurrency) {
      res["Concurrency"] = boost::any(*concurrency);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (sipTag) {
      res["SipTag"] = boost::any(*sipTag);
    }
    if (phoneNumberList) {
      res["PhoneNumberList"] = boost::any(*phoneNumberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceTag") != m.end() && !m["ServiceTag"].empty()) {
      serviceTag = make_shared<string>(boost::any_cast<string>(m["ServiceTag"]));
    }
    if (m.find("RegionNameProvince") != m.end() && !m["RegionNameProvince"].empty()) {
      regionNameProvince = make_shared<string>(boost::any_cast<string>(m["RegionNameProvince"]));
    }
    if (m.find("RegionNameCity") != m.end() && !m["RegionNameCity"].empty()) {
      regionNameCity = make_shared<string>(boost::any_cast<string>(m["RegionNameCity"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Concurrency") != m.end() && !m["Concurrency"].empty()) {
      concurrency = make_shared<long>(boost::any_cast<long>(m["Concurrency"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("SipTag") != m.end() && !m["SipTag"].empty()) {
      sipTag = make_shared<string>(boost::any_cast<string>(m["SipTag"]));
    }
    if (m.find("PhoneNumberList") != m.end() && !m["PhoneNumberList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhoneNumberList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhoneNumberList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumberList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddPhoneTagsRequest() = default;
};
class AddPhoneTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  AddPhoneTagsResponseBody() {}

  explicit AddPhoneTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddPhoneTagsResponseBody() = default;
};
class AddPhoneTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddPhoneTagsResponseBody> body{};

  AddPhoneTagsResponse() {}

  explicit AddPhoneTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneTagsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneTagsResponse() = default;
};
class AssignJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<vector<string>> callingNumber{};
  shared_ptr<vector<string>> jobsJson{};

  AssignJobsRequest() {}

  explicit AssignJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (jobsJson) {
      res["JobsJson"] = boost::any(*jobsJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobsJson") != m.end() && !m["JobsJson"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobsJson"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobsJson"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobsJson = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AssignJobsRequest() = default;
};
class AssignJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> groupId{};

  AssignJobsResponseBody() {}

  explicit AssignJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~AssignJobsResponseBody() = default;
};
class AssignJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssignJobsResponseBody> body{};

  AssignJobsResponse() {}

  explicit AssignJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignJobsResponseBody>(model1);
      }
    }
  }


  virtual ~AssignJobsResponse() = default;
};
class AssignUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userRamId{};
  shared_ptr<vector<string>> roleId{};
  shared_ptr<vector<string>> skillGroupId{};
  shared_ptr<vector<int>> skillLevel{};

  AssignUsersRequest() {}

  explicit AssignUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userRamId) {
      res["UserRamId"] = boost::any(*userRamId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserRamId") != m.end() && !m["UserRamId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserRamId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserRamId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userRamId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~AssignUsersRequest() = default;
};
class AssignUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  AssignUsersResponseBody() {}

  explicit AssignUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AssignUsersResponseBody() = default;
};
class AssignUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssignUsersResponseBody> body{};

  AssignUsersResponse() {}

  explicit AssignUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignUsersResponseBody>(model1);
      }
    }
  }


  virtual ~AssignUsersResponse() = default;
};
class CallOnlinePrivacyNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> telA{};
  shared_ptr<string> telB{};

  CallOnlinePrivacyNumberRequest() {}

  explicit CallOnlinePrivacyNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (telA) {
      res["TelA"] = boost::any(*telA);
    }
    if (telB) {
      res["TelB"] = boost::any(*telB);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TelA") != m.end() && !m["TelA"].empty()) {
      telA = make_shared<string>(boost::any_cast<string>(m["TelA"]));
    }
    if (m.find("TelB") != m.end() && !m["TelB"].empty()) {
      telB = make_shared<string>(boost::any_cast<string>(m["TelB"]));
    }
  }


  virtual ~CallOnlinePrivacyNumberRequest() = default;
};
class CallOnlinePrivacyNumberResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> represent{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> callId{};
  shared_ptr<string> dateCreated{};
  shared_ptr<string> telX{};

  CallOnlinePrivacyNumberResponseBodyData() {}

  explicit CallOnlinePrivacyNumberResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (represent) {
      res["Represent"] = boost::any(*represent);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (dateCreated) {
      res["DateCreated"] = boost::any(*dateCreated);
    }
    if (telX) {
      res["TelX"] = boost::any(*telX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Represent") != m.end() && !m["Represent"].empty()) {
      represent = make_shared<string>(boost::any_cast<string>(m["Represent"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("DateCreated") != m.end() && !m["DateCreated"].empty()) {
      dateCreated = make_shared<string>(boost::any_cast<string>(m["DateCreated"]));
    }
    if (m.find("TelX") != m.end() && !m["TelX"].empty()) {
      telX = make_shared<string>(boost::any_cast<string>(m["TelX"]));
    }
  }


  virtual ~CallOnlinePrivacyNumberResponseBodyData() = default;
};
class CallOnlinePrivacyNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<CallOnlinePrivacyNumberResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CallOnlinePrivacyNumberResponseBody() {}

  explicit CallOnlinePrivacyNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CallOnlinePrivacyNumberResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CallOnlinePrivacyNumberResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CallOnlinePrivacyNumberResponseBody() = default;
};
class CallOnlinePrivacyNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CallOnlinePrivacyNumberResponseBody> body{};

  CallOnlinePrivacyNumberResponse() {}

  explicit CallOnlinePrivacyNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CallOnlinePrivacyNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CallOnlinePrivacyNumberResponseBody>(model1);
      }
    }
  }


  virtual ~CallOnlinePrivacyNumberResponse() = default;
};
class CancelJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> all{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};

  CancelJobsRequest() {}

  explicit CancelJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CancelJobsRequest() = default;
};
class CancelJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CancelJobsResponseBody() {}

  explicit CancelJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelJobsResponseBody() = default;
};
class CancelJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CancelJobsResponseBody> body{};

  CancelJobsResponse() {}

  explicit CancelJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelJobsResponseBody>(model1);
      }
    }
  }


  virtual ~CancelJobsResponse() = default;
};
class CheckNumberAvaliableRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};

  CheckNumberAvaliableRequest() {}

  explicit CheckNumberAvaliableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
  }


  virtual ~CheckNumberAvaliableRequest() = default;
};
class CheckNumberAvaliableResponseBodyCallerAvaliable : public Darabonba::Model {
public:
  shared_ptr<bool> avaliable{};
  shared_ptr<string> reason{};

  CheckNumberAvaliableResponseBodyCallerAvaliable() {}

  explicit CheckNumberAvaliableResponseBodyCallerAvaliable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliable) {
      res["Avaliable"] = boost::any(*avaliable);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avaliable") != m.end() && !m["Avaliable"].empty()) {
      avaliable = make_shared<bool>(boost::any_cast<bool>(m["Avaliable"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CheckNumberAvaliableResponseBodyCallerAvaliable() = default;
};
class CheckNumberAvaliableResponseBodyCalleeAvaliable : public Darabonba::Model {
public:
  shared_ptr<bool> avaliable{};
  shared_ptr<string> reason{};

  CheckNumberAvaliableResponseBodyCalleeAvaliable() {}

  explicit CheckNumberAvaliableResponseBodyCalleeAvaliable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avaliable) {
      res["Avaliable"] = boost::any(*avaliable);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avaliable") != m.end() && !m["Avaliable"].empty()) {
      avaliable = make_shared<bool>(boost::any_cast<bool>(m["Avaliable"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CheckNumberAvaliableResponseBodyCalleeAvaliable() = default;
};
class CheckNumberAvaliableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<CheckNumberAvaliableResponseBodyCallerAvaliable> callerAvaliable{};
  shared_ptr<bool> success{};
  shared_ptr<CheckNumberAvaliableResponseBodyCalleeAvaliable> calleeAvaliable{};

  CheckNumberAvaliableResponseBody() {}

  explicit CheckNumberAvaliableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (callerAvaliable) {
      res["CallerAvaliable"] = callerAvaliable ? boost::any(callerAvaliable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (calleeAvaliable) {
      res["CalleeAvaliable"] = calleeAvaliable ? boost::any(calleeAvaliable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CallerAvaliable") != m.end() && !m["CallerAvaliable"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallerAvaliable"].type()) {
        CheckNumberAvaliableResponseBodyCallerAvaliable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallerAvaliable"]));
        callerAvaliable = make_shared<CheckNumberAvaliableResponseBodyCallerAvaliable>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("CalleeAvaliable") != m.end() && !m["CalleeAvaliable"].empty()) {
      if (typeid(map<string, boost::any>) == m["CalleeAvaliable"].type()) {
        CheckNumberAvaliableResponseBodyCalleeAvaliable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CalleeAvaliable"]));
        calleeAvaliable = make_shared<CheckNumberAvaliableResponseBodyCalleeAvaliable>(model1);
      }
    }
  }


  virtual ~CheckNumberAvaliableResponseBody() = default;
};
class CheckNumberAvaliableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CheckNumberAvaliableResponseBody> body{};

  CheckNumberAvaliableResponse() {}

  explicit CheckNumberAvaliableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckNumberAvaliableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckNumberAvaliableResponseBody>(model1);
      }
    }
  }


  virtual ~CheckNumberAvaliableResponse() = default;
};
class CommitContactFlowVersionModificationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> canvas{};
  shared_ptr<string> content{};

  CommitContactFlowVersionModificationRequest() {}

  explicit CommitContactFlowVersionModificationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (canvas) {
      res["Canvas"] = boost::any(*canvas);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("Canvas") != m.end() && !m["Canvas"].empty()) {
      canvas = make_shared<string>(boost::any_cast<string>(m["Canvas"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CommitContactFlowVersionModificationRequest() = default;
};
class CommitContactFlowVersionModificationResponseBodyContactFlowVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> canvas{};
  shared_ptr<string> lockedBy{};
  shared_ptr<string> version{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> lastModifiedBy{};
  shared_ptr<string> contactFlowVersionDescription{};
  shared_ptr<string> content{};

  CommitContactFlowVersionModificationResponseBodyContactFlowVersion() {}

  explicit CommitContactFlowVersionModificationResponseBodyContactFlowVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (canvas) {
      res["Canvas"] = boost::any(*canvas);
    }
    if (lockedBy) {
      res["LockedBy"] = boost::any(*lockedBy);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = boost::any(*lastModifiedBy);
    }
    if (contactFlowVersionDescription) {
      res["ContactFlowVersionDescription"] = boost::any(*contactFlowVersionDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Canvas") != m.end() && !m["Canvas"].empty()) {
      canvas = make_shared<string>(boost::any_cast<string>(m["Canvas"]));
    }
    if (m.find("LockedBy") != m.end() && !m["LockedBy"].empty()) {
      lockedBy = make_shared<string>(boost::any_cast<string>(m["LockedBy"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      lastModifiedBy = make_shared<string>(boost::any_cast<string>(m["LastModifiedBy"]));
    }
    if (m.find("ContactFlowVersionDescription") != m.end() && !m["ContactFlowVersionDescription"].empty()) {
      contactFlowVersionDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CommitContactFlowVersionModificationResponseBodyContactFlowVersion() = default;
};
class CommitContactFlowVersionModificationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CommitContactFlowVersionModificationResponseBodyContactFlowVersion> contactFlowVersion{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CommitContactFlowVersionModificationResponseBody() {}

  explicit CommitContactFlowVersionModificationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (contactFlowVersion) {
      res["ContactFlowVersion"] = contactFlowVersion ? boost::any(contactFlowVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ContactFlowVersion") != m.end() && !m["ContactFlowVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlowVersion"].type()) {
        CommitContactFlowVersionModificationResponseBodyContactFlowVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlowVersion"]));
        contactFlowVersion = make_shared<CommitContactFlowVersionModificationResponseBodyContactFlowVersion>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CommitContactFlowVersionModificationResponseBody() = default;
};
class CommitContactFlowVersionModificationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CommitContactFlowVersionModificationResponseBody> body{};

  CommitContactFlowVersionModificationResponse() {}

  explicit CommitContactFlowVersionModificationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CommitContactFlowVersionModificationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CommitContactFlowVersionModificationResponseBody>(model1);
      }
    }
  }


  virtual ~CommitContactFlowVersionModificationResponse() = default;
};
class CreateBatchJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<bool> submitted{};
  shared_ptr<vector<string>> callingNumber{};

  CreateBatchJobsRequest() {}

  explicit CreateBatchJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (submitted) {
      res["Submitted"] = boost::any(*submitted);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("Submitted") != m.end() && !m["Submitted"].empty()) {
      submitted = make_shared<bool>(boost::any_cast<bool>(m["Submitted"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBatchJobsRequest() = default;
};
class CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime() {}

  explicit CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime() = default;
};
class CreateBatchJobsResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};

  CreateBatchJobsResponseBodyJobGroupStrategy() {}

  explicit CreateBatchJobsResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateBatchJobsResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
  }


  virtual ~CreateBatchJobsResponseBodyJobGroupStrategy() = default;
};
class CreateBatchJobsResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<long> creationTime{};
  shared_ptr<CreateBatchJobsResponseBodyJobGroupStrategy> strategy{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};

  CreateBatchJobsResponseBodyJobGroup() {}

  explicit CreateBatchJobsResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateBatchJobsResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateBatchJobsResponseBodyJobGroupStrategy>(model1);
      }
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
  }


  virtual ~CreateBatchJobsResponseBodyJobGroup() = default;
};
class CreateBatchJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateBatchJobsResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateBatchJobsResponseBody() {}

  explicit CreateBatchJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        CreateBatchJobsResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<CreateBatchJobsResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBatchJobsResponseBody() = default;
};
class CreateBatchJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateBatchJobsResponseBody> body{};

  CreateBatchJobsResponse() {}

  explicit CreateBatchJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBatchJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBatchJobsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBatchJobsResponse() = default;
};
class CreateCabInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> callCenterInstanceId{};

  CreateCabInstanceRequest() {}

  explicit CreateCabInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (callCenterInstanceId) {
      res["CallCenterInstanceId"] = boost::any(*callCenterInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("CallCenterInstanceId") != m.end() && !m["CallCenterInstanceId"].empty()) {
      callCenterInstanceId = make_shared<string>(boost::any_cast<string>(m["CallCenterInstanceId"]));
    }
  }


  virtual ~CreateCabInstanceRequest() = default;
};
class CreateCabInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<string> callCenterInstanceId{};
  shared_ptr<string> owner{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceDescription{};

  CreateCabInstanceResponseBodyInstance() {}

  explicit CreateCabInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (callCenterInstanceId) {
      res["CallCenterInstanceId"] = boost::any(*callCenterInstanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CallCenterInstanceId") != m.end() && !m["CallCenterInstanceId"].empty()) {
      callCenterInstanceId = make_shared<string>(boost::any_cast<string>(m["CallCenterInstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
  }


  virtual ~CreateCabInstanceResponseBodyInstance() = default;
};
class CreateCabInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateCabInstanceResponseBodyInstance> instance{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateCabInstanceResponseBody() {}

  explicit CreateCabInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        CreateCabInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<CreateCabInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCabInstanceResponseBody() = default;
};
class CreateCabInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCabInstanceResponseBody> body{};

  CreateCabInstanceResponse() {}

  explicit CreateCabInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCabInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCabInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCabInstanceResponse() = default;
};
class CreateContactFlowRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> canvas{};
  shared_ptr<string> content{};

  CreateContactFlowRequest() {}

  explicit CreateContactFlowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (canvas) {
      res["Canvas"] = boost::any(*canvas);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Canvas") != m.end() && !m["Canvas"].empty()) {
      canvas = make_shared<string>(boost::any_cast<string>(m["Canvas"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateContactFlowRequest() = default;
};
class CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber() {}

  explicit CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber() = default;
};
class CreateContactFlowResponseBodyContactFlowPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber>> phoneNumber{};

  CreateContactFlowResponseBodyContactFlowPhoneNumbers() {}

  explicit CreateContactFlowResponseBodyContactFlowPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<CreateContactFlowResponseBodyContactFlowPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~CreateContactFlowResponseBodyContactFlowPhoneNumbers() = default;
};
class CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> canvas{};
  shared_ptr<string> lockedBy{};
  shared_ptr<string> version{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> lastModifiedBy{};
  shared_ptr<string> contactFlowVersionDescription{};
  shared_ptr<string> content{};

  CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion() {}

  explicit CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (canvas) {
      res["Canvas"] = boost::any(*canvas);
    }
    if (lockedBy) {
      res["LockedBy"] = boost::any(*lockedBy);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = boost::any(*lastModifiedBy);
    }
    if (contactFlowVersionDescription) {
      res["ContactFlowVersionDescription"] = boost::any(*contactFlowVersionDescription);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Canvas") != m.end() && !m["Canvas"].empty()) {
      canvas = make_shared<string>(boost::any_cast<string>(m["Canvas"]));
    }
    if (m.find("LockedBy") != m.end() && !m["LockedBy"].empty()) {
      lockedBy = make_shared<string>(boost::any_cast<string>(m["LockedBy"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      lastModifiedBy = make_shared<string>(boost::any_cast<string>(m["LastModifiedBy"]));
    }
    if (m.find("ContactFlowVersionDescription") != m.end() && !m["ContactFlowVersionDescription"].empty()) {
      contactFlowVersionDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionDescription"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion() = default;
};
class CreateContactFlowResponseBodyContactFlowVersions : public Darabonba::Model {
public:
  shared_ptr<vector<CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion>> contactFlowVersion{};

  CreateContactFlowResponseBodyContactFlowVersions() {}

  explicit CreateContactFlowResponseBodyContactFlowVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowVersion) {
      vector<boost::any> temp1;
      for(auto item1:*contactFlowVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactFlowVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowVersion") != m.end() && !m["ContactFlowVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactFlowVersion"].type()) {
        vector<CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactFlowVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactFlowVersion = make_shared<vector<CreateContactFlowResponseBodyContactFlowVersionsContactFlowVersion>>(expect1);
      }
    }
  }


  virtual ~CreateContactFlowResponseBodyContactFlowVersions() = default;
};
class CreateContactFlowResponseBodyContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> type{};
  shared_ptr<CreateContactFlowResponseBodyContactFlowPhoneNumbers> phoneNumbers{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<CreateContactFlowResponseBodyContactFlowVersions> versions{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> appliedVersion{};

  CreateContactFlowResponseBodyContactFlow() {}

  explicit CreateContactFlowResponseBodyContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (versions) {
      res["Versions"] = versions ? boost::any(versions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (appliedVersion) {
      res["AppliedVersion"] = boost::any(*appliedVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        CreateContactFlowResponseBodyContactFlowPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<CreateContactFlowResponseBodyContactFlowPhoneNumbers>(model1);
      }
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Versions"].type()) {
        CreateContactFlowResponseBodyContactFlowVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Versions"]));
        versions = make_shared<CreateContactFlowResponseBodyContactFlowVersions>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      appliedVersion = make_shared<string>(boost::any_cast<string>(m["AppliedVersion"]));
    }
  }


  virtual ~CreateContactFlowResponseBodyContactFlow() = default;
};
class CreateContactFlowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<CreateContactFlowResponseBodyContactFlow> contactFlow{};
  shared_ptr<bool> success{};

  CreateContactFlowResponseBody() {}

  explicit CreateContactFlowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        CreateContactFlowResponseBodyContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<CreateContactFlowResponseBodyContactFlow>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateContactFlowResponseBody() = default;
};
class CreateContactFlowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateContactFlowResponseBody> body{};

  CreateContactFlowResponse() {}

  explicit CreateContactFlowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateContactFlowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateContactFlowResponseBody>(model1);
      }
    }
  }


  virtual ~CreateContactFlowResponse() = default;
};
class CreateFaultRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> agentId{};
  shared_ptr<string> connectId{};
  shared_ptr<string> agentOssFileName{};
  shared_ptr<string> agentFilePath{};
  shared_ptr<string> customOssFileName{};
  shared_ptr<string> customFilePath{};
  shared_ptr<string> description{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientPort{};
  shared_ptr<string> operatingSystemVersion{};
  shared_ptr<string> browserVersion{};
  shared_ptr<string> microphoneList{};
  shared_ptr<string> microphoneEquipment{};
  shared_ptr<string> speakerList{};
  shared_ptr<string> speakerEquipment{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> serviceIp{};
  shared_ptr<string> servicePort{};

  CreateFaultRequest() {}

  explicit CreateFaultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (connectId) {
      res["ConnectId"] = boost::any(*connectId);
    }
    if (agentOssFileName) {
      res["AgentOssFileName"] = boost::any(*agentOssFileName);
    }
    if (agentFilePath) {
      res["AgentFilePath"] = boost::any(*agentFilePath);
    }
    if (customOssFileName) {
      res["CustomOssFileName"] = boost::any(*customOssFileName);
    }
    if (customFilePath) {
      res["CustomFilePath"] = boost::any(*customFilePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (operatingSystemVersion) {
      res["OperatingSystemVersion"] = boost::any(*operatingSystemVersion);
    }
    if (browserVersion) {
      res["BrowserVersion"] = boost::any(*browserVersion);
    }
    if (microphoneList) {
      res["MicrophoneList"] = boost::any(*microphoneList);
    }
    if (microphoneEquipment) {
      res["MicrophoneEquipment"] = boost::any(*microphoneEquipment);
    }
    if (speakerList) {
      res["SpeakerList"] = boost::any(*speakerList);
    }
    if (speakerEquipment) {
      res["SpeakerEquipment"] = boost::any(*speakerEquipment);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (serviceIp) {
      res["ServiceIp"] = boost::any(*serviceIp);
    }
    if (servicePort) {
      res["ServicePort"] = boost::any(*servicePort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<long>(boost::any_cast<long>(m["AgentId"]));
    }
    if (m.find("ConnectId") != m.end() && !m["ConnectId"].empty()) {
      connectId = make_shared<string>(boost::any_cast<string>(m["ConnectId"]));
    }
    if (m.find("AgentOssFileName") != m.end() && !m["AgentOssFileName"].empty()) {
      agentOssFileName = make_shared<string>(boost::any_cast<string>(m["AgentOssFileName"]));
    }
    if (m.find("AgentFilePath") != m.end() && !m["AgentFilePath"].empty()) {
      agentFilePath = make_shared<string>(boost::any_cast<string>(m["AgentFilePath"]));
    }
    if (m.find("CustomOssFileName") != m.end() && !m["CustomOssFileName"].empty()) {
      customOssFileName = make_shared<string>(boost::any_cast<string>(m["CustomOssFileName"]));
    }
    if (m.find("CustomFilePath") != m.end() && !m["CustomFilePath"].empty()) {
      customFilePath = make_shared<string>(boost::any_cast<string>(m["CustomFilePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<string>(boost::any_cast<string>(m["ClientPort"]));
    }
    if (m.find("OperatingSystemVersion") != m.end() && !m["OperatingSystemVersion"].empty()) {
      operatingSystemVersion = make_shared<string>(boost::any_cast<string>(m["OperatingSystemVersion"]));
    }
    if (m.find("BrowserVersion") != m.end() && !m["BrowserVersion"].empty()) {
      browserVersion = make_shared<string>(boost::any_cast<string>(m["BrowserVersion"]));
    }
    if (m.find("MicrophoneList") != m.end() && !m["MicrophoneList"].empty()) {
      microphoneList = make_shared<string>(boost::any_cast<string>(m["MicrophoneList"]));
    }
    if (m.find("MicrophoneEquipment") != m.end() && !m["MicrophoneEquipment"].empty()) {
      microphoneEquipment = make_shared<string>(boost::any_cast<string>(m["MicrophoneEquipment"]));
    }
    if (m.find("SpeakerList") != m.end() && !m["SpeakerList"].empty()) {
      speakerList = make_shared<string>(boost::any_cast<string>(m["SpeakerList"]));
    }
    if (m.find("SpeakerEquipment") != m.end() && !m["SpeakerEquipment"].empty()) {
      speakerEquipment = make_shared<string>(boost::any_cast<string>(m["SpeakerEquipment"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ServiceIp") != m.end() && !m["ServiceIp"].empty()) {
      serviceIp = make_shared<string>(boost::any_cast<string>(m["ServiceIp"]));
    }
    if (m.find("ServicePort") != m.end() && !m["ServicePort"].empty()) {
      servicePort = make_shared<string>(boost::any_cast<string>(m["ServicePort"]));
    }
  }


  virtual ~CreateFaultRequest() = default;
};
class CreateFaultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateFaultResponseBody() {}

  explicit CreateFaultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFaultResponseBody() = default;
};
class CreateFaultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFaultResponseBody> body{};

  CreateFaultResponse() {}

  explicit CreateFaultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFaultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFaultResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFaultResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<long> storageMaxDays{};
  shared_ptr<long> storageMaxSize{};
  shared_ptr<string> directoryId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<vector<string>> adminRamId{};
  shared_ptr<vector<string>> phoneNumbers{};
  shared_ptr<vector<string>> userObject{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (storageMaxDays) {
      res["StorageMaxDays"] = boost::any(*storageMaxDays);
    }
    if (storageMaxSize) {
      res["StorageMaxSize"] = boost::any(*storageMaxSize);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (adminRamId) {
      res["AdminRamId"] = boost::any(*adminRamId);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (userObject) {
      res["UserObject"] = boost::any(*userObject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("StorageMaxDays") != m.end() && !m["StorageMaxDays"].empty()) {
      storageMaxDays = make_shared<long>(boost::any_cast<long>(m["StorageMaxDays"]));
    }
    if (m.find("StorageMaxSize") != m.end() && !m["StorageMaxSize"].empty()) {
      storageMaxSize = make_shared<long>(boost::any_cast<long>(m["StorageMaxSize"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("AdminRamId") != m.end() && !m["AdminRamId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminRamId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminRamId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminRamId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhoneNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhoneNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserObject") != m.end() && !m["UserObject"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserObject"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserObject"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userObject = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyInstanceSuccessLoginNames : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successLoginName{};

  CreateInstanceResponseBodyInstanceSuccessLoginNames() {}

  explicit CreateInstanceResponseBodyInstanceSuccessLoginNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successLoginName) {
      res["SuccessLoginName"] = boost::any(*successLoginName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessLoginName") != m.end() && !m["SuccessLoginName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessLoginName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessLoginName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successLoginName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceSuccessLoginNames() = default;
};
class CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber() {}

  explicit CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber() = default;
};
class CreateInstanceResponseBodyInstancePhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber>> phoneNumber{};

  CreateInstanceResponseBodyInstancePhoneNumbers() {}

  explicit CreateInstanceResponseBodyInstancePhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<CreateInstanceResponseBodyInstancePhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~CreateInstanceResponseBodyInstancePhoneNumbers() = default;
};
class CreateInstanceResponseBodyInstanceSuccessPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> successPhoneNumber{};

  CreateInstanceResponseBodyInstanceSuccessPhoneNumbers() {}

  explicit CreateInstanceResponseBodyInstanceSuccessPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successPhoneNumber) {
      res["SuccessPhoneNumber"] = boost::any(*successPhoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessPhoneNumber") != m.end() && !m["SuccessPhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SuccessPhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuccessPhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      successPhoneNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceSuccessPhoneNumbers() = default;
};
class CreateInstanceResponseBodyInstanceFailLoginNames : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failLoginName{};

  CreateInstanceResponseBodyInstanceFailLoginNames() {}

  explicit CreateInstanceResponseBodyInstanceFailLoginNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failLoginName) {
      res["FailLoginName"] = boost::any(*failLoginName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailLoginName") != m.end() && !m["FailLoginName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailLoginName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailLoginName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failLoginName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceFailLoginNames() = default;
};
class CreateInstanceResponseBodyInstanceFailPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failPhoneNumber{};

  CreateInstanceResponseBodyInstanceFailPhoneNumbers() {}

  explicit CreateInstanceResponseBodyInstanceFailPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failPhoneNumber) {
      res["FailPhoneNumber"] = boost::any(*failPhoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailPhoneNumber") != m.end() && !m["FailPhoneNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailPhoneNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailPhoneNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failPhoneNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceFailPhoneNumbers() = default;
};
class CreateInstanceResponseBodyInstanceAdminUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  CreateInstanceResponseBodyInstanceAdminUserDetail() {}

  explicit CreateInstanceResponseBodyInstanceAdminUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceAdminUserDetail() = default;
};
class CreateInstanceResponseBodyInstanceAdminUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<CreateInstanceResponseBodyInstanceAdminUserDetail> detail{};

  CreateInstanceResponseBodyInstanceAdminUser() {}

  explicit CreateInstanceResponseBodyInstanceAdminUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        CreateInstanceResponseBodyInstanceAdminUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<CreateInstanceResponseBodyInstanceAdminUserDetail>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceAdminUser() = default;
};
class CreateInstanceResponseBodyInstanceAdmin : public Darabonba::Model {
public:
  shared_ptr<vector<CreateInstanceResponseBodyInstanceAdminUser>> user{};

  CreateInstanceResponseBodyInstanceAdmin() {}

  explicit CreateInstanceResponseBodyInstanceAdmin(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<CreateInstanceResponseBodyInstanceAdminUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceResponseBodyInstanceAdminUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<CreateInstanceResponseBodyInstanceAdminUser>>(expect1);
      }
    }
  }


  virtual ~CreateInstanceResponseBodyInstanceAdmin() = default;
};
class CreateInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> storageMaxSize{};
  shared_ptr<long> storageMaxDays{};
  shared_ptr<long> maxOnlineAgents{};
  shared_ptr<CreateInstanceResponseBodyInstanceSuccessLoginNames> successLoginNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<CreateInstanceResponseBodyInstancePhoneNumbers> phoneNumbers{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<CreateInstanceResponseBodyInstanceSuccessPhoneNumbers> successPhoneNumbers{};
  shared_ptr<CreateInstanceResponseBodyInstanceFailLoginNames> failLoginNames{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> storageBucket{};
  shared_ptr<CreateInstanceResponseBodyInstanceFailPhoneNumbers> failPhoneNumbers{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> directoryId{};
  shared_ptr<CreateInstanceResponseBodyInstanceAdmin> admin{};
  shared_ptr<string> tenantId{};

  CreateInstanceResponseBodyInstance() {}

  explicit CreateInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (storageMaxSize) {
      res["StorageMaxSize"] = boost::any(*storageMaxSize);
    }
    if (storageMaxDays) {
      res["StorageMaxDays"] = boost::any(*storageMaxDays);
    }
    if (maxOnlineAgents) {
      res["MaxOnlineAgents"] = boost::any(*maxOnlineAgents);
    }
    if (successLoginNames) {
      res["SuccessLoginNames"] = successLoginNames ? boost::any(successLoginNames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (successPhoneNumbers) {
      res["SuccessPhoneNumbers"] = successPhoneNumbers ? boost::any(successPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failLoginNames) {
      res["FailLoginNames"] = failLoginNames ? boost::any(failLoginNames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (storageBucket) {
      res["StorageBucket"] = boost::any(*storageBucket);
    }
    if (failPhoneNumbers) {
      res["FailPhoneNumbers"] = failPhoneNumbers ? boost::any(failPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (admin) {
      res["Admin"] = admin ? boost::any(admin->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("StorageMaxSize") != m.end() && !m["StorageMaxSize"].empty()) {
      storageMaxSize = make_shared<long>(boost::any_cast<long>(m["StorageMaxSize"]));
    }
    if (m.find("StorageMaxDays") != m.end() && !m["StorageMaxDays"].empty()) {
      storageMaxDays = make_shared<long>(boost::any_cast<long>(m["StorageMaxDays"]));
    }
    if (m.find("MaxOnlineAgents") != m.end() && !m["MaxOnlineAgents"].empty()) {
      maxOnlineAgents = make_shared<long>(boost::any_cast<long>(m["MaxOnlineAgents"]));
    }
    if (m.find("SuccessLoginNames") != m.end() && !m["SuccessLoginNames"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessLoginNames"].type()) {
        CreateInstanceResponseBodyInstanceSuccessLoginNames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessLoginNames"]));
        successLoginNames = make_shared<CreateInstanceResponseBodyInstanceSuccessLoginNames>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        CreateInstanceResponseBodyInstancePhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<CreateInstanceResponseBodyInstancePhoneNumbers>(model1);
      }
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("SuccessPhoneNumbers") != m.end() && !m["SuccessPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessPhoneNumbers"].type()) {
        CreateInstanceResponseBodyInstanceSuccessPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessPhoneNumbers"]));
        successPhoneNumbers = make_shared<CreateInstanceResponseBodyInstanceSuccessPhoneNumbers>(model1);
      }
    }
    if (m.find("FailLoginNames") != m.end() && !m["FailLoginNames"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailLoginNames"].type()) {
        CreateInstanceResponseBodyInstanceFailLoginNames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailLoginNames"]));
        failLoginNames = make_shared<CreateInstanceResponseBodyInstanceFailLoginNames>(model1);
      }
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("StorageBucket") != m.end() && !m["StorageBucket"].empty()) {
      storageBucket = make_shared<string>(boost::any_cast<string>(m["StorageBucket"]));
    }
    if (m.find("FailPhoneNumbers") != m.end() && !m["FailPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailPhoneNumbers"].type()) {
        CreateInstanceResponseBodyInstanceFailPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailPhoneNumbers"]));
        failPhoneNumbers = make_shared<CreateInstanceResponseBodyInstanceFailPhoneNumbers>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Admin") != m.end() && !m["Admin"].empty()) {
      if (typeid(map<string, boost::any>) == m["Admin"].type()) {
        CreateInstanceResponseBodyInstanceAdmin model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Admin"]));
        admin = make_shared<CreateInstanceResponseBodyInstanceAdmin>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateInstanceResponseBodyInstance() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateInstanceResponseBodyInstance> instance{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        CreateInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<CreateInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<vector<string>> callingNumber{};

  CreateJobGroupRequest() {}

  explicit CreateJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateJobGroupRequest() = default;
};
class CreateJobGroupResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> from{};
  shared_ptr<string> to{};

  CreateJobGroupResponseBodyJobGroupStrategyWorkingTime() {}

  explicit CreateJobGroupResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupStrategyWorkingTime() = default;
};
class CreateJobGroupResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};

  CreateJobGroupResponseBodyJobGroupStrategy() {}

  explicit CreateJobGroupResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateJobGroupResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateJobGroupResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroupStrategy() = default;
};
class CreateJobGroupResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<long> creationTime{};
  shared_ptr<CreateJobGroupResponseBodyJobGroupStrategy> strategy{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<string> jobGroupName{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> jobGroupDescription{};

  CreateJobGroupResponseBodyJobGroup() {}

  explicit CreateJobGroupResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (jobGroupName) {
      res["JobGroupName"] = boost::any(*jobGroupName);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (jobGroupDescription) {
      res["JobGroupDescription"] = boost::any(*jobGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateJobGroupResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateJobGroupResponseBodyJobGroupStrategy>(model1);
      }
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobGroupName") != m.end() && !m["JobGroupName"].empty()) {
      jobGroupName = make_shared<string>(boost::any_cast<string>(m["JobGroupName"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("JobGroupDescription") != m.end() && !m["JobGroupDescription"].empty()) {
      jobGroupDescription = make_shared<string>(boost::any_cast<string>(m["JobGroupDescription"]));
    }
  }


  virtual ~CreateJobGroupResponseBodyJobGroup() = default;
};
class CreateJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateJobGroupResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateJobGroupResponseBody() {}

  explicit CreateJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        CreateJobGroupResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<CreateJobGroupResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateJobGroupResponseBody() = default;
};
class CreateJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateJobGroupResponseBody> body{};

  CreateJobGroupResponse() {}

  explicit CreateJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateJobGroupResponse() = default;
};
class CreateMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> fileName{};
  shared_ptr<string> type{};
  shared_ptr<string> content{};
  shared_ptr<string> ossFileName{};
  shared_ptr<string> ossFilePath{};
  shared_ptr<string> uploadResult{};

  CreateMediaRequest() {}

  explicit CreateMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    if (ossFilePath) {
      res["OssFilePath"] = boost::any(*ossFilePath);
    }
    if (uploadResult) {
      res["UploadResult"] = boost::any(*uploadResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
    if (m.find("OssFilePath") != m.end() && !m["OssFilePath"].empty()) {
      ossFilePath = make_shared<string>(boost::any_cast<string>(m["OssFilePath"]));
    }
    if (m.find("UploadResult") != m.end() && !m["UploadResult"].empty()) {
      uploadResult = make_shared<string>(boost::any_cast<string>(m["UploadResult"]));
    }
  }


  virtual ~CreateMediaRequest() = default;
};
class CreateMediaResponseBodyMediaUploadParam : public Darabonba::Model {
public:
  shared_ptr<string> instance{};
  shared_ptr<string> ossFilePath{};
  shared_ptr<string> fileName{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> ossFileName{};

  CreateMediaResponseBodyMediaUploadParam() {}

  explicit CreateMediaResponseBodyMediaUploadParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (ossFilePath) {
      res["OssFilePath"] = boost::any(*ossFilePath);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("OssFilePath") != m.end() && !m["OssFilePath"].empty()) {
      ossFilePath = make_shared<string>(boost::any_cast<string>(m["OssFilePath"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
  }


  virtual ~CreateMediaResponseBodyMediaUploadParam() = default;
};
class CreateMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateMediaResponseBodyMediaUploadParam> mediaUploadParam{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateMediaResponseBody() {}

  explicit CreateMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaUploadParam) {
      res["MediaUploadParam"] = mediaUploadParam ? boost::any(mediaUploadParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaUploadParam") != m.end() && !m["MediaUploadParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaUploadParam"].type()) {
        CreateMediaResponseBodyMediaUploadParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaUploadParam"]));
        mediaUploadParam = make_shared<CreateMediaResponseBodyMediaUploadParam>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateMediaResponseBody() = default;
};
class CreateMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMediaResponseBody> body{};

  CreateMediaResponse() {}

  explicit CreateMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaResponse() = default;
};
class CreatePredictiveJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> strategyJson{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<bool> timingSchedule{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<bool> isDraft{};
  shared_ptr<vector<string>> jobsJson{};

  CreatePredictiveJobGroupRequest() {}

  explicit CreatePredictiveJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timingSchedule) {
      res["TimingSchedule"] = boost::any(*timingSchedule);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (isDraft) {
      res["IsDraft"] = boost::any(*isDraft);
    }
    if (jobsJson) {
      res["JobsJson"] = boost::any(*jobsJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TimingSchedule") != m.end() && !m["TimingSchedule"].empty()) {
      timingSchedule = make_shared<bool>(boost::any_cast<bool>(m["TimingSchedule"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("IsDraft") != m.end() && !m["IsDraft"].empty()) {
      isDraft = make_shared<bool>(boost::any_cast<bool>(m["IsDraft"]));
    }
    if (m.find("JobsJson") != m.end() && !m["JobsJson"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobsJson"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobsJson"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobsJson = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreatePredictiveJobGroupRequest() = default;
};
class CreatePredictiveJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreatePredictiveJobGroupResponseBody() {}

  explicit CreatePredictiveJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreatePredictiveJobGroupResponseBody() = default;
};
class CreatePredictiveJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreatePredictiveJobGroupResponseBody> body{};

  CreatePredictiveJobGroupResponse() {}

  explicit CreatePredictiveJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePredictiveJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePredictiveJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePredictiveJobGroupResponse() = default;
};
class CreateScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> strategyJson{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> surveysJson{};

  CreateScenarioRequest() {}

  explicit CreateScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (strategyJson) {
      res["StrategyJson"] = boost::any(*strategyJson);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (surveysJson) {
      res["SurveysJson"] = boost::any(*surveysJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StrategyJson") != m.end() && !m["StrategyJson"].empty()) {
      strategyJson = make_shared<string>(boost::any_cast<string>(m["StrategyJson"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SurveysJson") != m.end() && !m["SurveysJson"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SurveysJson"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SurveysJson"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      surveysJson = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateScenarioRequest() = default;
};
class CreateScenarioResponseBodyScenarioStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  CreateScenarioResponseBodyScenarioStrategyWorkingTime() {}

  explicit CreateScenarioResponseBodyScenarioStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~CreateScenarioResponseBodyScenarioStrategyWorkingTime() = default;
};
class CreateScenarioResponseBodyScenarioStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<CreateScenarioResponseBodyScenarioStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};

  CreateScenarioResponseBodyScenarioStrategy() {}

  explicit CreateScenarioResponseBodyScenarioStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateScenarioResponseBodyScenarioStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioResponseBodyScenarioStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateScenarioResponseBodyScenarioStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
  }


  virtual ~CreateScenarioResponseBodyScenarioStrategy() = default;
};
class CreateScenarioResponseBodyScenarioSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  CreateScenarioResponseBodyScenarioSurveysIntents() {}

  explicit CreateScenarioResponseBodyScenarioSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~CreateScenarioResponseBodyScenarioSurveysIntents() = default;
};
class CreateScenarioResponseBodyScenarioSurveys : public Darabonba::Model {
public:
  shared_ptr<long> round{};
  shared_ptr<string> surveyDescription{};
  shared_ptr<string> beebotId{};
  shared_ptr<vector<CreateScenarioResponseBodyScenarioSurveysIntents>> intents{};
  shared_ptr<string> surveyName{};
  shared_ptr<string> role{};
  shared_ptr<string> surveyId{};

  CreateScenarioResponseBodyScenarioSurveys() {}

  explicit CreateScenarioResponseBodyScenarioSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (surveyDescription) {
      res["SurveyDescription"] = boost::any(*surveyDescription);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (surveyName) {
      res["SurveyName"] = boost::any(*surveyName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SurveyDescription") != m.end() && !m["SurveyDescription"].empty()) {
      surveyDescription = make_shared<string>(boost::any_cast<string>(m["SurveyDescription"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<CreateScenarioResponseBodyScenarioSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioResponseBodyScenarioSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<CreateScenarioResponseBodyScenarioSurveysIntents>>(expect1);
      }
    }
    if (m.find("SurveyName") != m.end() && !m["SurveyName"].empty()) {
      surveyName = make_shared<string>(boost::any_cast<string>(m["SurveyName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~CreateScenarioResponseBodyScenarioSurveys() = default;
};
class CreateScenarioResponseBodyScenarioVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateScenarioResponseBodyScenarioVariables() {}

  explicit CreateScenarioResponseBodyScenarioVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateScenarioResponseBodyScenarioVariables() = default;
};
class CreateScenarioResponseBodyScenario : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> scenarioId{};
  shared_ptr<CreateScenarioResponseBodyScenarioStrategy> strategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> scenarioDescription{};
  shared_ptr<string> scenarioName{};
  shared_ptr<vector<CreateScenarioResponseBodyScenarioSurveys>> surveys{};
  shared_ptr<vector<CreateScenarioResponseBodyScenarioVariables>> variables{};

  CreateScenarioResponseBodyScenario() {}

  explicit CreateScenarioResponseBodyScenario(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (scenarioDescription) {
      res["ScenarioDescription"] = boost::any(*scenarioDescription);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateScenarioResponseBodyScenarioStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateScenarioResponseBodyScenarioStrategy>(model1);
      }
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("ScenarioDescription") != m.end() && !m["ScenarioDescription"].empty()) {
      scenarioDescription = make_shared<string>(boost::any_cast<string>(m["ScenarioDescription"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<CreateScenarioResponseBodyScenarioSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioResponseBodyScenarioSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<CreateScenarioResponseBodyScenarioSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<CreateScenarioResponseBodyScenarioVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioResponseBodyScenarioVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<CreateScenarioResponseBodyScenarioVariables>>(expect1);
      }
    }
  }


  virtual ~CreateScenarioResponseBodyScenario() = default;
};
class CreateScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<CreateScenarioResponseBodyScenario> scenario{};

  CreateScenarioResponseBody() {}

  explicit CreateScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (scenario) {
      res["Scenario"] = scenario ? boost::any(scenario->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenario"].type()) {
        CreateScenarioResponseBodyScenario model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenario"]));
        scenario = make_shared<CreateScenarioResponseBodyScenario>(model1);
      }
    }
  }


  virtual ~CreateScenarioResponseBody() = default;
};
class CreateScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateScenarioResponseBody> body{};

  CreateScenarioResponse() {}

  explicit CreateScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScenarioResponse() = default;
};
class CreateScenarioFromTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> templateId{};
  shared_ptr<string> variables{};

  CreateScenarioFromTemplateRequest() {}

  explicit CreateScenarioFromTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (variables) {
      res["Variables"] = boost::any(*variables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      variables = make_shared<string>(boost::any_cast<string>(m["Variables"]));
    }
  }


  virtual ~CreateScenarioFromTemplateRequest() = default;
};
class CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime() {}

  explicit CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime() = default;
};
class CreateScenarioFromTemplateResponseBodyScenarioStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};

  CreateScenarioFromTemplateResponseBodyScenarioStrategy() {}

  explicit CreateScenarioFromTemplateResponseBodyScenarioStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<CreateScenarioFromTemplateResponseBodyScenarioStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenarioStrategy() = default;
};
class CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents() {}

  explicit CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents() = default;
};
class CreateScenarioFromTemplateResponseBodyScenarioSurveys : public Darabonba::Model {
public:
  shared_ptr<long> round{};
  shared_ptr<string> surveyDescription{};
  shared_ptr<string> beebotId{};
  shared_ptr<vector<CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents>> intents{};
  shared_ptr<string> surveyName{};
  shared_ptr<string> role{};
  shared_ptr<string> surveyId{};

  CreateScenarioFromTemplateResponseBodyScenarioSurveys() {}

  explicit CreateScenarioFromTemplateResponseBodyScenarioSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (surveyDescription) {
      res["SurveyDescription"] = boost::any(*surveyDescription);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (surveyName) {
      res["SurveyName"] = boost::any(*surveyName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SurveyDescription") != m.end() && !m["SurveyDescription"].empty()) {
      surveyDescription = make_shared<string>(boost::any_cast<string>(m["SurveyDescription"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<CreateScenarioFromTemplateResponseBodyScenarioSurveysIntents>>(expect1);
      }
    }
    if (m.find("SurveyName") != m.end() && !m["SurveyName"].empty()) {
      surveyName = make_shared<string>(boost::any_cast<string>(m["SurveyName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenarioSurveys() = default;
};
class CreateScenarioFromTemplateResponseBodyScenarioVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateScenarioFromTemplateResponseBodyScenarioVariables() {}

  explicit CreateScenarioFromTemplateResponseBodyScenarioVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenarioVariables() = default;
};
class CreateScenarioFromTemplateResponseBodyScenario : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> scenarioId{};
  shared_ptr<CreateScenarioFromTemplateResponseBodyScenarioStrategy> strategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> scenarioDescription{};
  shared_ptr<string> scenarioName{};
  shared_ptr<vector<CreateScenarioFromTemplateResponseBodyScenarioSurveys>> surveys{};
  shared_ptr<vector<CreateScenarioFromTemplateResponseBodyScenarioVariables>> variables{};

  CreateScenarioFromTemplateResponseBodyScenario() {}

  explicit CreateScenarioFromTemplateResponseBodyScenario(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (scenarioDescription) {
      res["ScenarioDescription"] = boost::any(*scenarioDescription);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        CreateScenarioFromTemplateResponseBodyScenarioStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<CreateScenarioFromTemplateResponseBodyScenarioStrategy>(model1);
      }
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("ScenarioDescription") != m.end() && !m["ScenarioDescription"].empty()) {
      scenarioDescription = make_shared<string>(boost::any_cast<string>(m["ScenarioDescription"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<CreateScenarioFromTemplateResponseBodyScenarioSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioFromTemplateResponseBodyScenarioSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<CreateScenarioFromTemplateResponseBodyScenarioSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<CreateScenarioFromTemplateResponseBodyScenarioVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateScenarioFromTemplateResponseBodyScenarioVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<CreateScenarioFromTemplateResponseBodyScenarioVariables>>(expect1);
      }
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBodyScenario() = default;
};
class CreateScenarioFromTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<CreateScenarioFromTemplateResponseBodyScenario> scenario{};

  CreateScenarioFromTemplateResponseBody() {}

  explicit CreateScenarioFromTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (scenario) {
      res["Scenario"] = scenario ? boost::any(scenario->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenario"].type()) {
        CreateScenarioFromTemplateResponseBodyScenario model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenario"]));
        scenario = make_shared<CreateScenarioFromTemplateResponseBodyScenario>(model1);
      }
    }
  }


  virtual ~CreateScenarioFromTemplateResponseBody() = default;
};
class CreateScenarioFromTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateScenarioFromTemplateResponseBody> body{};

  CreateScenarioFromTemplateResponse() {}

  explicit CreateScenarioFromTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateScenarioFromTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateScenarioFromTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateScenarioFromTemplateResponse() = default;
};
class CreateSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<bool> allowPrivateOutboundNumber{};
  shared_ptr<vector<string>> outboundPhoneNumberId{};
  shared_ptr<vector<string>> userId{};
  shared_ptr<vector<int>> skillLevel{};

  CreateSkillGroupRequest() {}

  explicit CreateSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (allowPrivateOutboundNumber) {
      res["AllowPrivateOutboundNumber"] = boost::any(*allowPrivateOutboundNumber);
    }
    if (outboundPhoneNumberId) {
      res["OutboundPhoneNumberId"] = boost::any(*outboundPhoneNumberId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("AllowPrivateOutboundNumber") != m.end() && !m["AllowPrivateOutboundNumber"].empty()) {
      allowPrivateOutboundNumber = make_shared<bool>(boost::any_cast<bool>(m["AllowPrivateOutboundNumber"]));
    }
    if (m.find("OutboundPhoneNumberId") != m.end() && !m["OutboundPhoneNumberId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutboundPhoneNumberId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutboundPhoneNumberId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outboundPhoneNumberId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~CreateSkillGroupRequest() = default;
};
class CreateSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateSkillGroupResponseBody() {}

  explicit CreateSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSkillGroupResponseBody() = default;
};
class CreateSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSkillGroupResponseBody> body{};

  CreateSkillGroupResponse() {}

  explicit CreateSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSkillGroupResponse() = default;
};
class CreateSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> corpora{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> globalQuestions{};
  shared_ptr<string> role{};
  shared_ptr<long> round{};

  CreateSurveyRequest() {}

  explicit CreateSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
  }


  virtual ~CreateSurveyRequest() = default;
};
class CreateSurveyResponseBodySurveyAsrCustomModel : public Darabonba::Model {
public:
  shared_ptr<long> customModelStatus{};
  shared_ptr<string> corpora{};

  CreateSurveyResponseBodySurveyAsrCustomModel() {}

  explicit CreateSurveyResponseBodySurveyAsrCustomModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customModelStatus) {
      res["CustomModelStatus"] = boost::any(*customModelStatus);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomModelStatus") != m.end() && !m["CustomModelStatus"].empty()) {
      customModelStatus = make_shared<long>(boost::any_cast<long>(m["CustomModelStatus"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
  }


  virtual ~CreateSurveyResponseBodySurveyAsrCustomModel() = default;
};
class CreateSurveyResponseBodySurveyFlow : public Darabonba::Model {
public:
  shared_ptr<bool> isPublished{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> flowId{};

  CreateSurveyResponseBodySurveyFlow() {}

  explicit CreateSurveyResponseBodySurveyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPublished) {
      res["IsPublished"] = boost::any(*isPublished);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPublished") != m.end() && !m["IsPublished"].empty()) {
      isPublished = make_shared<bool>(boost::any_cast<bool>(m["IsPublished"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~CreateSurveyResponseBodySurveyFlow() = default;
};
class CreateSurveyResponseBodySurvey : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestions{};
  shared_ptr<long> round{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> description{};
  shared_ptr<string> hotWords{};
  shared_ptr<CreateSurveyResponseBodySurveyAsrCustomModel> asrCustomModel{};
  shared_ptr<CreateSurveyResponseBodySurveyFlow> flow{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> scenarioUuid{};
  shared_ptr<string> id{};

  CreateSurveyResponseBodySurvey() {}

  explicit CreateSurveyResponseBodySurvey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotWords) {
      res["HotWords"] = boost::any(*hotWords);
    }
    if (asrCustomModel) {
      res["AsrCustomModel"] = asrCustomModel ? boost::any(asrCustomModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scenarioUuid) {
      res["ScenarioUuid"] = boost::any(*scenarioUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotWords") != m.end() && !m["HotWords"].empty()) {
      hotWords = make_shared<string>(boost::any_cast<string>(m["HotWords"]));
    }
    if (m.find("AsrCustomModel") != m.end() && !m["AsrCustomModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrCustomModel"].type()) {
        CreateSurveyResponseBodySurveyAsrCustomModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrCustomModel"]));
        asrCustomModel = make_shared<CreateSurveyResponseBodySurveyAsrCustomModel>(model1);
      }
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        CreateSurveyResponseBodySurveyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<CreateSurveyResponseBodySurveyFlow>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScenarioUuid") != m.end() && !m["ScenarioUuid"].empty()) {
      scenarioUuid = make_shared<string>(boost::any_cast<string>(m["ScenarioUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateSurveyResponseBodySurvey() = default;
};
class CreateSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateSurveyResponseBodySurvey> survey{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateSurveyResponseBody() {}

  explicit CreateSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (survey) {
      res["Survey"] = survey ? boost::any(survey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Survey") != m.end() && !m["Survey"].empty()) {
      if (typeid(map<string, boost::any>) == m["Survey"].type()) {
        CreateSurveyResponseBodySurvey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Survey"]));
        survey = make_shared<CreateSurveyResponseBodySurvey>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSurveyResponseBody() = default;
};
class CreateSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSurveyResponseBody> body{};

  CreateSurveyResponse() {}

  explicit CreateSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSurveyResponse() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> phone{};
  shared_ptr<string> email{};
  shared_ptr<string> privateOutboundNumberId{};
  shared_ptr<vector<string>> roleId{};
  shared_ptr<vector<string>> skillGroupId{};
  shared_ptr<vector<int>> skillLevel{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (privateOutboundNumberId) {
      res["PrivateOutboundNumberId"] = boost::any(*privateOutboundNumberId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PrivateOutboundNumberId") != m.end() && !m["PrivateOutboundNumberId"].empty()) {
      privateOutboundNumberId = make_shared<string>(boost::any_cast<string>(m["PrivateOutboundNumberId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<string> userId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class CreateVoiceAppraiseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> content{};
  shared_ptr<bool> isAppraise{};

  CreateVoiceAppraiseRequest() {}

  explicit CreateVoiceAppraiseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (isAppraise) {
      res["IsAppraise"] = boost::any(*isAppraise);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("IsAppraise") != m.end() && !m["IsAppraise"].empty()) {
      isAppraise = make_shared<bool>(boost::any_cast<bool>(m["IsAppraise"]));
    }
  }


  virtual ~CreateVoiceAppraiseRequest() = default;
};
class CreateVoiceAppraiseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  CreateVoiceAppraiseResponseBody() {}

  explicit CreateVoiceAppraiseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateVoiceAppraiseResponseBody() = default;
};
class CreateVoiceAppraiseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVoiceAppraiseResponseBody> body{};

  CreateVoiceAppraiseResponse() {}

  explicit CreateVoiceAppraiseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVoiceAppraiseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVoiceAppraiseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVoiceAppraiseResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DeleteJobGroupRequest() {}

  explicit DeleteJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DeleteJobGroupRequest() = default;
};
class DeleteJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeleteJobGroupResponseBody() {}

  explicit DeleteJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteJobGroupResponseBody() = default;
};
class DeleteJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteJobGroupResponseBody> body{};

  DeleteJobGroupResponse() {}

  explicit DeleteJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteJobGroupResponse() = default;
};
class DeleteMediaRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};

  DeleteMediaRequest() {}

  explicit DeleteMediaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DeleteMediaRequest() = default;
};
class DeleteMediaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeleteMediaResponseBody() {}

  explicit DeleteMediaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMediaResponseBody() = default;
};
class DeleteMediaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMediaResponseBody> body{};

  DeleteMediaResponse() {}

  explicit DeleteMediaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMediaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMediaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMediaResponse() = default;
};
class DeletePhoneTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> phoneNumberList{};

  DeletePhoneTagsRequest() {}

  explicit DeletePhoneTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberList) {
      res["PhoneNumberList"] = boost::any(*phoneNumberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberList") != m.end() && !m["PhoneNumberList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PhoneNumberList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PhoneNumberList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      phoneNumberList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeletePhoneTagsRequest() = default;
};
class DeletePhoneTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeletePhoneTagsResponseBody() {}

  explicit DeletePhoneTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeletePhoneTagsResponseBody() = default;
};
class DeletePhoneTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeletePhoneTagsResponseBody> body{};

  DeletePhoneTagsResponse() {}

  explicit DeletePhoneTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePhoneTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePhoneTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePhoneTagsResponse() = default;
};
class DeleteSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  DeleteSkillGroupRequest() {}

  explicit DeleteSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~DeleteSkillGroupRequest() = default;
};
class DeleteSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeleteSkillGroupResponseBody() {}

  explicit DeleteSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSkillGroupResponseBody() = default;
};
class DeleteSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSkillGroupResponseBody> body{};

  DeleteSkillGroupResponse() {}

  explicit DeleteSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSkillGroupResponse() = default;
};
class DeleteSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> surveyId{};

  DeleteSurveyRequest() {}

  explicit DeleteSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~DeleteSurveyRequest() = default;
};
class DeleteSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DeleteSurveyResponseBody() {}

  explicit DeleteSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteSurveyResponseBody() = default;
};
class DeleteSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSurveyResponseBody> body{};

  DeleteSurveyResponse() {}

  explicit DeleteSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSurveyResponse() = default;
};
class DialExRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> caller{};
  shared_ptr<string> callee{};
  shared_ptr<string> routPoint{};
  shared_ptr<long> answerMode{};
  shared_ptr<string> provider{};

  DialExRequest() {}

  explicit DialExRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (routPoint) {
      res["RoutPoint"] = boost::any(*routPoint);
    }
    if (answerMode) {
      res["AnswerMode"] = boost::any(*answerMode);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("RoutPoint") != m.end() && !m["RoutPoint"].empty()) {
      routPoint = make_shared<string>(boost::any_cast<string>(m["RoutPoint"]));
    }
    if (m.find("AnswerMode") != m.end() && !m["AnswerMode"].empty()) {
      answerMode = make_shared<long>(boost::any_cast<long>(m["AnswerMode"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
  }


  virtual ~DialExRequest() = default;
};
class DialExResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> statusDesc{};
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> timeStamp{};

  DialExResponseBody() {}

  explicit DialExResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~DialExResponseBody() = default;
};
class DialExResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DialExResponseBody> body{};

  DialExResponse() {}

  explicit DialExResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DialExResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DialExResponseBody>(model1);
      }
    }
  }


  virtual ~DialExResponse() = default;
};
class DialogueRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> callId{};
  shared_ptr<string> callType{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> utterance{};
  shared_ptr<string> actionKey{};
  shared_ptr<string> actionParams{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> calledNumber{};
  shared_ptr<long> instanceOwnerId{};

  DialogueRequest() {}

  explicit DialogueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (utterance) {
      res["Utterance"] = boost::any(*utterance);
    }
    if (actionKey) {
      res["ActionKey"] = boost::any(*actionKey);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Utterance") != m.end() && !m["Utterance"].empty()) {
      utterance = make_shared<string>(boost::any_cast<string>(m["Utterance"]));
    }
    if (m.find("ActionKey") != m.end() && !m["ActionKey"].empty()) {
      actionKey = make_shared<string>(boost::any_cast<string>(m["ActionKey"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      actionParams = make_shared<string>(boost::any_cast<string>(m["ActionParams"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
  }


  virtual ~DialogueRequest() = default;
};
class DialogueResponseBodyFeedback : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<bool> interruptible{};
  shared_ptr<string> actionParams{};
  shared_ptr<string> content{};

  DialogueResponseBodyFeedback() {}

  explicit DialogueResponseBodyFeedback(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (interruptible) {
      res["Interruptible"] = boost::any(*interruptible);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Interruptible") != m.end() && !m["Interruptible"].empty()) {
      interruptible = make_shared<bool>(boost::any_cast<bool>(m["Interruptible"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      actionParams = make_shared<string>(boost::any_cast<string>(m["ActionParams"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~DialogueResponseBodyFeedback() = default;
};
class DialogueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DialogueResponseBodyFeedback> feedback{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DialogueResponseBody() {}

  explicit DialogueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (feedback) {
      res["Feedback"] = feedback ? boost::any(feedback->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      if (typeid(map<string, boost::any>) == m["Feedback"].type()) {
        DialogueResponseBodyFeedback model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Feedback"]));
        feedback = make_shared<DialogueResponseBodyFeedback>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DialogueResponseBody() = default;
};
class DialogueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DialogueResponseBody> body{};

  DialogueResponse() {}

  explicit DialogueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DialogueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DialogueResponseBody>(model1);
      }
    }
  }


  virtual ~DialogueResponse() = default;
};
class DisableTrunkProvidersRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> providerName{};

  DisableTrunkProvidersRequest() {}

  explicit DisableTrunkProvidersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProviderName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProviderName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      providerName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DisableTrunkProvidersRequest() = default;
};
class DisableTrunkProvidersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DisableTrunkProvidersResponseBody() {}

  explicit DisableTrunkProvidersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DisableTrunkProvidersResponseBody() = default;
};
class DisableTrunkProvidersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableTrunkProvidersResponseBody> body{};

  DisableTrunkProvidersResponse() {}

  explicit DisableTrunkProvidersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableTrunkProvidersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableTrunkProvidersResponseBody>(model1);
      }
    }
  }


  virtual ~DisableTrunkProvidersResponse() = default;
};
class DownloadAllTypeRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactId{};
  shared_ptr<string> channel{};

  DownloadAllTypeRecordingRequest() {}

  explicit DownloadAllTypeRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
  }


  virtual ~DownloadAllTypeRecordingRequest() = default;
};
class DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};
  shared_ptr<string> fileName{};

  DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam() {}

  explicit DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam() = default;
};
class DownloadAllTypeRecordingResponseBodyMediaDownloadParamList : public Darabonba::Model {
public:
  shared_ptr<vector<DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam>> mediaDownloadParam{};

  DownloadAllTypeRecordingResponseBodyMediaDownloadParamList() {}

  explicit DownloadAllTypeRecordingResponseBodyMediaDownloadParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaDownloadParam) {
      vector<boost::any> temp1;
      for(auto item1:*mediaDownloadParam){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaDownloadParam"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaDownloadParam") != m.end() && !m["MediaDownloadParam"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaDownloadParam"].type()) {
        vector<DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaDownloadParam"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaDownloadParam = make_shared<vector<DownloadAllTypeRecordingResponseBodyMediaDownloadParamListMediaDownloadParam>>(expect1);
      }
    }
  }


  virtual ~DownloadAllTypeRecordingResponseBodyMediaDownloadParamList() = default;
};
class DownloadAllTypeRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<DownloadAllTypeRecordingResponseBodyMediaDownloadParamList> mediaDownloadParamList{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DownloadAllTypeRecordingResponseBody() {}

  explicit DownloadAllTypeRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (mediaDownloadParamList) {
      res["MediaDownloadParamList"] = mediaDownloadParamList ? boost::any(mediaDownloadParamList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MediaDownloadParamList") != m.end() && !m["MediaDownloadParamList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDownloadParamList"].type()) {
        DownloadAllTypeRecordingResponseBodyMediaDownloadParamList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDownloadParamList"]));
        mediaDownloadParamList = make_shared<DownloadAllTypeRecordingResponseBodyMediaDownloadParamList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadAllTypeRecordingResponseBody() = default;
};
class DownloadAllTypeRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DownloadAllTypeRecordingResponseBody> body{};

  DownloadAllTypeRecordingResponse() {}

  explicit DownloadAllTypeRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadAllTypeRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadAllTypeRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadAllTypeRecordingResponse() = default;
};
class DownloadCabRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  DownloadCabRecordingRequest() {}

  explicit DownloadCabRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DownloadCabRecordingRequest() = default;
};
class DownloadCabRecordingResponseBodyMediaDownloadParam : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};
  shared_ptr<string> fileName{};

  DownloadCabRecordingResponseBodyMediaDownloadParam() {}

  explicit DownloadCabRecordingResponseBodyMediaDownloadParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~DownloadCabRecordingResponseBodyMediaDownloadParam() = default;
};
class DownloadCabRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<DownloadCabRecordingResponseBodyMediaDownloadParam> mediaDownloadParam{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DownloadCabRecordingResponseBody() {}

  explicit DownloadCabRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaDownloadParam) {
      res["MediaDownloadParam"] = mediaDownloadParam ? boost::any(mediaDownloadParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaDownloadParam") != m.end() && !m["MediaDownloadParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDownloadParam"].type()) {
        DownloadCabRecordingResponseBodyMediaDownloadParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDownloadParam"]));
        mediaDownloadParam = make_shared<DownloadCabRecordingResponseBodyMediaDownloadParam>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadCabRecordingResponseBody() = default;
};
class DownloadCabRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DownloadCabRecordingResponseBody> body{};

  DownloadCabRecordingResponse() {}

  explicit DownloadCabRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadCabRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadCabRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadCabRecordingResponse() = default;
};
class DownloadOriginalStatisticsReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DownloadOriginalStatisticsReportRequest() {}

  explicit DownloadOriginalStatisticsReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DownloadOriginalStatisticsReportRequest() = default;
};
class DownloadOriginalStatisticsReportResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};

  DownloadOriginalStatisticsReportResponseBodyDownloadParams() {}

  explicit DownloadOriginalStatisticsReportResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~DownloadOriginalStatisticsReportResponseBodyDownloadParams() = default;
};
class DownloadOriginalStatisticsReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DownloadOriginalStatisticsReportResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DownloadOriginalStatisticsReportResponseBody() {}

  explicit DownloadOriginalStatisticsReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        DownloadOriginalStatisticsReportResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<DownloadOriginalStatisticsReportResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadOriginalStatisticsReportResponseBody() = default;
};
class DownloadOriginalStatisticsReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DownloadOriginalStatisticsReportResponseBody> body{};

  DownloadOriginalStatisticsReportResponse() {}

  explicit DownloadOriginalStatisticsReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadOriginalStatisticsReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadOriginalStatisticsReportResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadOriginalStatisticsReportResponse() = default;
};
class DownloadRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> fileName{};
  shared_ptr<string> channel{};

  DownloadRecordingRequest() {}

  explicit DownloadRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
  }


  virtual ~DownloadRecordingRequest() = default;
};
class DownloadRecordingResponseBodyMediaDownloadParam : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};
  shared_ptr<string> fileName{};

  DownloadRecordingResponseBodyMediaDownloadParam() {}

  explicit DownloadRecordingResponseBodyMediaDownloadParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~DownloadRecordingResponseBodyMediaDownloadParam() = default;
};
class DownloadRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<DownloadRecordingResponseBodyMediaDownloadParam> mediaDownloadParam{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DownloadRecordingResponseBody() {}

  explicit DownloadRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mediaDownloadParam) {
      res["MediaDownloadParam"] = mediaDownloadParam ? boost::any(mediaDownloadParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MediaDownloadParam") != m.end() && !m["MediaDownloadParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaDownloadParam"].type()) {
        DownloadRecordingResponseBodyMediaDownloadParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaDownloadParam"]));
        mediaDownloadParam = make_shared<DownloadRecordingResponseBodyMediaDownloadParam>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadRecordingResponseBody() = default;
};
class DownloadRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DownloadRecordingResponseBody> body{};

  DownloadRecordingResponse() {}

  explicit DownloadRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadRecordingResponse() = default;
};
class DownloadUnreachableContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  DownloadUnreachableContactsRequest() {}

  explicit DownloadUnreachableContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~DownloadUnreachableContactsRequest() = default;
};
class DownloadUnreachableContactsResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};

  DownloadUnreachableContactsResponseBodyDownloadParams() {}

  explicit DownloadUnreachableContactsResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~DownloadUnreachableContactsResponseBodyDownloadParams() = default;
};
class DownloadUnreachableContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DownloadUnreachableContactsResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DownloadUnreachableContactsResponseBody() {}

  explicit DownloadUnreachableContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        DownloadUnreachableContactsResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<DownloadUnreachableContactsResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadUnreachableContactsResponseBody() = default;
};
class DownloadUnreachableContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DownloadUnreachableContactsResponseBody> body{};

  DownloadUnreachableContactsResponse() {}

  explicit DownloadUnreachableContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadUnreachableContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadUnreachableContactsResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadUnreachableContactsResponse() = default;
};
class FindUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> criteria{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  FindUsersRequest() {}

  explicit FindUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~FindUsersRequest() = default;
};
class FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill() {}

  explicit FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill() = default;
};
class FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel() {}

  explicit FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<FindUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel() = default;
};
class FindUsersResponseBodyUsersListUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel>> skillLevel{};

  FindUsersResponseBodyUsersListUserSkillLevels() {}

  explicit FindUsersResponseBodyUsersListUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<FindUsersResponseBodyUsersListUserSkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserSkillLevels() = default;
};
class FindUsersResponseBodyUsersListUserRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  FindUsersResponseBodyUsersListUserRolesRole() {}

  explicit FindUsersResponseBodyUsersListUserRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserRolesRole() = default;
};
class FindUsersResponseBodyUsersListUserRoles : public Darabonba::Model {
public:
  shared_ptr<vector<FindUsersResponseBodyUsersListUserRolesRole>> role{};

  FindUsersResponseBodyUsersListUserRoles() {}

  explicit FindUsersResponseBodyUsersListUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<FindUsersResponseBodyUsersListUserRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindUsersResponseBodyUsersListUserRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<FindUsersResponseBodyUsersListUserRolesRole>>(expect1);
      }
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserRoles() = default;
};
class FindUsersResponseBodyUsersListUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  FindUsersResponseBodyUsersListUserDetail() {}

  explicit FindUsersResponseBodyUsersListUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~FindUsersResponseBodyUsersListUserDetail() = default;
};
class FindUsersResponseBodyUsersListUser : public Darabonba::Model {
public:
  shared_ptr<FindUsersResponseBodyUsersListUserSkillLevels> skillLevels{};
  shared_ptr<string> privateOutboundNumberId{};
  shared_ptr<string> userId{};
  shared_ptr<FindUsersResponseBodyUsersListUserRoles> roles{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<FindUsersResponseBodyUsersListUserDetail> detail{};

  FindUsersResponseBodyUsersListUser() {}

  explicit FindUsersResponseBodyUsersListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateOutboundNumberId) {
      res["PrivateOutboundNumberId"] = boost::any(*privateOutboundNumberId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        FindUsersResponseBodyUsersListUserSkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<FindUsersResponseBodyUsersListUserSkillLevels>(model1);
      }
    }
    if (m.find("PrivateOutboundNumberId") != m.end() && !m["PrivateOutboundNumberId"].empty()) {
      privateOutboundNumberId = make_shared<string>(boost::any_cast<string>(m["PrivateOutboundNumberId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        FindUsersResponseBodyUsersListUserRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<FindUsersResponseBodyUsersListUserRoles>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        FindUsersResponseBodyUsersListUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<FindUsersResponseBodyUsersListUserDetail>(model1);
      }
    }
  }


  virtual ~FindUsersResponseBodyUsersListUser() = default;
};
class FindUsersResponseBodyUsersList : public Darabonba::Model {
public:
  shared_ptr<vector<FindUsersResponseBodyUsersListUser>> user{};

  FindUsersResponseBodyUsersList() {}

  explicit FindUsersResponseBodyUsersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<FindUsersResponseBodyUsersListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindUsersResponseBodyUsersListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<FindUsersResponseBodyUsersListUser>>(expect1);
      }
    }
  }


  virtual ~FindUsersResponseBodyUsersList() = default;
};
class FindUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<FindUsersResponseBodyUsersList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  FindUsersResponseBodyUsers() {}

  explicit FindUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        FindUsersResponseBodyUsersList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<FindUsersResponseBodyUsersList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindUsersResponseBodyUsers() = default;
};
class FindUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<FindUsersResponseBodyUsers> users{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  FindUsersResponseBody() {}

  explicit FindUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        FindUsersResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<FindUsersResponseBodyUsers>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FindUsersResponseBody() = default;
};
class FindUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindUsersResponseBody> body{};

  FindUsersResponse() {}

  explicit FindUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindUsersResponseBody>(model1);
      }
    }
  }


  virtual ~FindUsersResponse() = default;
};
class GenerateAgentStatisticReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> agentId{};
  shared_ptr<string> startDate{};
  shared_ptr<string> endDate{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GenerateAgentStatisticReportRequest() {}

  explicit GenerateAgentStatisticReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<string>(boost::any_cast<string>(m["StartDate"]));
    }
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<string>(boost::any_cast<string>(m["EndDate"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GenerateAgentStatisticReportRequest() = default;
};
class GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsHandled{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> averageRingTime{};

  GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound() {}

  explicit GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound() = default;
};
class GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> averageDialingTime{};

  GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound() {}

  explicit GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound() = default;
};
class GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> totalCalls{};

  GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall() {}

  explicit GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall() = default;
};
class GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> agentName{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> recordDate{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound> inbound{};
  shared_ptr<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound> outbound{};
  shared_ptr<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall> overall{};

  GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic() {}

  explicit GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordDate) {
      res["RecordDate"] = boost::any(*recordDate);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordDate") != m.end() && !m["RecordDate"].empty()) {
      recordDate = make_shared<string>(boost::any_cast<string>(m["RecordDate"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatisticOverall>(model1);
      }
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic() = default;
};
class GenerateAgentStatisticReportResponseBodyDataListList : public Darabonba::Model {
public:
  shared_ptr<vector<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic>> generateAgentStatistic{};

  GenerateAgentStatisticReportResponseBodyDataListList() {}

  explicit GenerateAgentStatisticReportResponseBodyDataListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateAgentStatistic) {
      vector<boost::any> temp1;
      for(auto item1:*generateAgentStatistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GenerateAgentStatistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateAgentStatistic") != m.end() && !m["GenerateAgentStatistic"].empty()) {
      if (typeid(vector<boost::any>) == m["GenerateAgentStatistic"].type()) {
        vector<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GenerateAgentStatistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        generateAgentStatistic = make_shared<vector<GenerateAgentStatisticReportResponseBodyDataListListGenerateAgentStatistic>>(expect1);
      }
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataListList() = default;
};
class GenerateAgentStatisticReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<GenerateAgentStatisticReportResponseBodyDataListList> list{};

  GenerateAgentStatisticReportResponseBodyDataList() {}

  explicit GenerateAgentStatisticReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GenerateAgentStatisticReportResponseBodyDataListList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GenerateAgentStatisticReportResponseBodyDataListList>(model1);
      }
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBodyDataList() = default;
};
class GenerateAgentStatisticReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GenerateAgentStatisticReportResponseBodyDataList> dataList{};

  GenerateAgentStatisticReportResponseBody() {}

  explicit GenerateAgentStatisticReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (dataList) {
      res["DataList"] = dataList ? boost::any(dataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("DataList") != m.end() && !m["DataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataList"].type()) {
        GenerateAgentStatisticReportResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataList"]));
        dataList = make_shared<GenerateAgentStatisticReportResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~GenerateAgentStatisticReportResponseBody() = default;
};
class GenerateAgentStatisticReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateAgentStatisticReportResponseBody> body{};

  GenerateAgentStatisticReportResponse() {}

  explicit GenerateAgentStatisticReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAgentStatisticReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAgentStatisticReportResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAgentStatisticReportResponse() = default;
};
class GetAgentDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> startDay{};
  shared_ptr<string> endDay{};
  shared_ptr<string> userId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetAgentDataRequest() {}

  explicit GetAgentDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startDay) {
      res["StartDay"] = boost::any(*startDay);
    }
    if (endDay) {
      res["EndDay"] = boost::any(*endDay);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartDay") != m.end() && !m["StartDay"].empty()) {
      startDay = make_shared<string>(boost::any_cast<string>(m["StartDay"]));
    }
    if (m.find("EndDay") != m.end() && !m["EndDay"].empty()) {
      endDay = make_shared<string>(boost::any_cast<string>(m["EndDay"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetAgentDataRequest() = default;
};
class GetAgentDataResponseBodyDataListListInbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsHandled{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> averageRingTime{};

  GetAgentDataResponseBodyDataListListInbound() {}

  explicit GetAgentDataResponseBodyDataListListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
  }


  virtual ~GetAgentDataResponseBodyDataListListInbound() = default;
};
class GetAgentDataResponseBodyDataListListOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> averageDialingTime{};

  GetAgentDataResponseBodyDataListListOutbound() {}

  explicit GetAgentDataResponseBodyDataListListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~GetAgentDataResponseBodyDataListListOutbound() = default;
};
class GetAgentDataResponseBodyDataListListOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> averageHoldTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> totalCalls{};

  GetAgentDataResponseBodyDataListListOverall() {}

  explicit GetAgentDataResponseBodyDataListListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<long>(boost::any_cast<long>(m["AverageHoldTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetAgentDataResponseBodyDataListListOverall() = default;
};
class GetAgentDataResponseBodyDataListList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> agentName{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> recordDate{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<GetAgentDataResponseBodyDataListListInbound> inbound{};
  shared_ptr<GetAgentDataResponseBodyDataListListOutbound> outbound{};
  shared_ptr<GetAgentDataResponseBodyDataListListOverall> overall{};

  GetAgentDataResponseBodyDataListList() {}

  explicit GetAgentDataResponseBodyDataListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordDate) {
      res["RecordDate"] = boost::any(*recordDate);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordDate") != m.end() && !m["RecordDate"].empty()) {
      recordDate = make_shared<string>(boost::any_cast<string>(m["RecordDate"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetAgentDataResponseBodyDataListListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetAgentDataResponseBodyDataListListInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetAgentDataResponseBodyDataListListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetAgentDataResponseBodyDataListListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetAgentDataResponseBodyDataListListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetAgentDataResponseBodyDataListListOverall>(model1);
      }
    }
  }


  virtual ~GetAgentDataResponseBodyDataListList() = default;
};
class GetAgentDataResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<GetAgentDataResponseBodyDataListList>> list{};

  GetAgentDataResponseBodyDataList() {}

  explicit GetAgentDataResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetAgentDataResponseBodyDataListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAgentDataResponseBodyDataListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetAgentDataResponseBodyDataListList>>(expect1);
      }
    }
  }


  virtual ~GetAgentDataResponseBodyDataList() = default;
};
class GetAgentDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetAgentDataResponseBodyDataList> dataList{};

  GetAgentDataResponseBody() {}

  explicit GetAgentDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (dataList) {
      res["DataList"] = dataList ? boost::any(dataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("DataList") != m.end() && !m["DataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataList"].type()) {
        GetAgentDataResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataList"]));
        dataList = make_shared<GetAgentDataResponseBodyDataList>(model1);
      }
    }
  }


  virtual ~GetAgentDataResponseBody() = default;
};
class GetAgentDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetAgentDataResponseBody> body{};

  GetAgentDataResponse() {}

  explicit GetAgentDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAgentDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAgentDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetAgentDataResponse() = default;
};
class GetCallMeasureSummaryReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> intervalType{};
  shared_ptr<long> year{};
  shared_ptr<long> month{};
  shared_ptr<long> day{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetCallMeasureSummaryReportRequest() {}

  explicit GetCallMeasureSummaryReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    if (year) {
      res["Year"] = boost::any(*year);
    }
    if (month) {
      res["Month"] = boost::any(*month);
    }
    if (day) {
      res["Day"] = boost::any(*day);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
    if (m.find("Year") != m.end() && !m["Year"].empty()) {
      year = make_shared<long>(boost::any_cast<long>(m["Year"]));
    }
    if (m.find("Month") != m.end() && !m["Month"].empty()) {
      month = make_shared<long>(boost::any_cast<long>(m["Month"]));
    }
    if (m.find("Day") != m.end() && !m["Day"].empty()) {
      day = make_shared<long>(boost::any_cast<long>(m["Day"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetCallMeasureSummaryReportRequest() = default;
};
class GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport : public Darabonba::Model {
public:
  shared_ptr<long> day{};
  shared_ptr<long> year{};
  shared_ptr<long> inboundDurationByMinute{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> outboundDurationByMinute{};
  shared_ptr<string> number{};
  shared_ptr<long> inboundCount{};
  shared_ptr<long> month{};

  GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport() {}

  explicit GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (day) {
      res["Day"] = boost::any(*day);
    }
    if (year) {
      res["Year"] = boost::any(*year);
    }
    if (inboundDurationByMinute) {
      res["InboundDurationByMinute"] = boost::any(*inboundDurationByMinute);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (outboundDurationByMinute) {
      res["OutboundDurationByMinute"] = boost::any(*outboundDurationByMinute);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (inboundCount) {
      res["InboundCount"] = boost::any(*inboundCount);
    }
    if (month) {
      res["Month"] = boost::any(*month);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Day") != m.end() && !m["Day"].empty()) {
      day = make_shared<long>(boost::any_cast<long>(m["Day"]));
    }
    if (m.find("Year") != m.end() && !m["Year"].empty()) {
      year = make_shared<long>(boost::any_cast<long>(m["Year"]));
    }
    if (m.find("InboundDurationByMinute") != m.end() && !m["InboundDurationByMinute"].empty()) {
      inboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["InboundDurationByMinute"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("OutboundDurationByMinute") != m.end() && !m["OutboundDurationByMinute"].empty()) {
      outboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["OutboundDurationByMinute"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InboundCount") != m.end() && !m["InboundCount"].empty()) {
      inboundCount = make_shared<long>(boost::any_cast<long>(m["InboundCount"]));
    }
    if (m.find("Month") != m.end() && !m["Month"].empty()) {
      month = make_shared<long>(boost::any_cast<long>(m["Month"]));
    }
  }


  virtual ~GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport() = default;
};
class GetCallMeasureSummaryReportResponseBodyNumberReportsList : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport>> numberReport{};

  GetCallMeasureSummaryReportResponseBodyNumberReportsList() {}

  explicit GetCallMeasureSummaryReportResponseBodyNumberReportsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (numberReport) {
      vector<boost::any> temp1;
      for(auto item1:*numberReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NumberReport") != m.end() && !m["NumberReport"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberReport"].type()) {
        vector<GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberReport = make_shared<vector<GetCallMeasureSummaryReportResponseBodyNumberReportsListNumberReport>>(expect1);
      }
    }
  }


  virtual ~GetCallMeasureSummaryReportResponseBodyNumberReportsList() = default;
};
class GetCallMeasureSummaryReportResponseBodyNumberReports : public Darabonba::Model {
public:
  shared_ptr<GetCallMeasureSummaryReportResponseBodyNumberReportsList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetCallMeasureSummaryReportResponseBodyNumberReports() {}

  explicit GetCallMeasureSummaryReportResponseBodyNumberReports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetCallMeasureSummaryReportResponseBodyNumberReportsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetCallMeasureSummaryReportResponseBodyNumberReportsList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetCallMeasureSummaryReportResponseBodyNumberReports() = default;
};
class GetCallMeasureSummaryReportResponseBodySummaryReport : public Darabonba::Model {
public:
  shared_ptr<long> day{};
  shared_ptr<long> year{};
  shared_ptr<long> inboundDurationByMinute{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> outboundDurationByMinute{};
  shared_ptr<long> inboundCount{};
  shared_ptr<long> month{};

  GetCallMeasureSummaryReportResponseBodySummaryReport() {}

  explicit GetCallMeasureSummaryReportResponseBodySummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (day) {
      res["Day"] = boost::any(*day);
    }
    if (year) {
      res["Year"] = boost::any(*year);
    }
    if (inboundDurationByMinute) {
      res["InboundDurationByMinute"] = boost::any(*inboundDurationByMinute);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (outboundDurationByMinute) {
      res["OutboundDurationByMinute"] = boost::any(*outboundDurationByMinute);
    }
    if (inboundCount) {
      res["InboundCount"] = boost::any(*inboundCount);
    }
    if (month) {
      res["Month"] = boost::any(*month);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Day") != m.end() && !m["Day"].empty()) {
      day = make_shared<long>(boost::any_cast<long>(m["Day"]));
    }
    if (m.find("Year") != m.end() && !m["Year"].empty()) {
      year = make_shared<long>(boost::any_cast<long>(m["Year"]));
    }
    if (m.find("InboundDurationByMinute") != m.end() && !m["InboundDurationByMinute"].empty()) {
      inboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["InboundDurationByMinute"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("OutboundDurationByMinute") != m.end() && !m["OutboundDurationByMinute"].empty()) {
      outboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["OutboundDurationByMinute"]));
    }
    if (m.find("InboundCount") != m.end() && !m["InboundCount"].empty()) {
      inboundCount = make_shared<long>(boost::any_cast<long>(m["InboundCount"]));
    }
    if (m.find("Month") != m.end() && !m["Month"].empty()) {
      month = make_shared<long>(boost::any_cast<long>(m["Month"]));
    }
  }


  virtual ~GetCallMeasureSummaryReportResponseBodySummaryReport() = default;
};
class GetCallMeasureSummaryReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetCallMeasureSummaryReportResponseBodyNumberReports> numberReports{};
  shared_ptr<GetCallMeasureSummaryReportResponseBodySummaryReport> summaryReport{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetCallMeasureSummaryReportResponseBody() {}

  explicit GetCallMeasureSummaryReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (numberReports) {
      res["NumberReports"] = numberReports ? boost::any(numberReports->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (summaryReport) {
      res["SummaryReport"] = summaryReport ? boost::any(summaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NumberReports") != m.end() && !m["NumberReports"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberReports"].type()) {
        GetCallMeasureSummaryReportResponseBodyNumberReports model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberReports"]));
        numberReports = make_shared<GetCallMeasureSummaryReportResponseBodyNumberReports>(model1);
      }
    }
    if (m.find("SummaryReport") != m.end() && !m["SummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["SummaryReport"].type()) {
        GetCallMeasureSummaryReportResponseBodySummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SummaryReport"]));
        summaryReport = make_shared<GetCallMeasureSummaryReportResponseBodySummaryReport>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCallMeasureSummaryReportResponseBody() = default;
};
class GetCallMeasureSummaryReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetCallMeasureSummaryReportResponseBody> body{};

  GetCallMeasureSummaryReportResponse() {}

  explicit GetCallMeasureSummaryReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCallMeasureSummaryReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCallMeasureSummaryReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetCallMeasureSummaryReportResponse() = default;
};
class GetConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  GetConfigRequest() {}

  explicit GetConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~GetConfigRequest() = default;
};
class GetConfigResponseBodyConfigItem : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  GetConfigResponseBodyConfigItem() {}

  explicit GetConfigResponseBodyConfigItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetConfigResponseBodyConfigItem() = default;
};
class GetConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetConfigResponseBodyConfigItem> configItem{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetConfigResponseBody() {}

  explicit GetConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (configItem) {
      res["ConfigItem"] = configItem ? boost::any(configItem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ConfigItem") != m.end() && !m["ConfigItem"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigItem"].type()) {
        GetConfigResponseBodyConfigItem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigItem"]));
        configItem = make_shared<GetConfigResponseBodyConfigItem>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetConfigResponseBody() = default;
};
class GetConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetConfigResponseBody> body{};

  GetConfigResponse() {}

  explicit GetConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetConfigResponse() = default;
};
class GetConversationDetailByContactIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetConversationDetailByContactIdRequest() {}

  explicit GetConversationDetailByContactIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetConversationDetailByContactIdRequest() = default;
};
class GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase : public Darabonba::Model {
public:
  shared_ptr<string> words{};
  shared_ptr<long> begin{};
  shared_ptr<string> identity{};
  shared_ptr<long> end{};
  shared_ptr<string> role{};

  GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase() {}

  explicit GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (words) {
      res["Words"] = boost::any(*words);
    }
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Words") != m.end() && !m["Words"].empty()) {
      words = make_shared<string>(boost::any_cast<string>(m["Words"]));
    }
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase() = default;
};
class GetConversationDetailByContactIdResponseBodyDataListList : public Darabonba::Model {
public:
  shared_ptr<vector<GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase>> qualityCheckPhrase{};

  GetConversationDetailByContactIdResponseBodyDataListList() {}

  explicit GetConversationDetailByContactIdResponseBodyDataListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qualityCheckPhrase) {
      vector<boost::any> temp1;
      for(auto item1:*qualityCheckPhrase){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QualityCheckPhrase"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QualityCheckPhrase") != m.end() && !m["QualityCheckPhrase"].empty()) {
      if (typeid(vector<boost::any>) == m["QualityCheckPhrase"].type()) {
        vector<GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QualityCheckPhrase"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qualityCheckPhrase = make_shared<vector<GetConversationDetailByContactIdResponseBodyDataListListQualityCheckPhrase>>(expect1);
      }
    }
  }


  virtual ~GetConversationDetailByContactIdResponseBodyDataListList() = default;
};
class GetConversationDetailByContactIdResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<GetConversationDetailByContactIdResponseBodyDataListList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetConversationDetailByContactIdResponseBodyDataList() {}

  explicit GetConversationDetailByContactIdResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        GetConversationDetailByContactIdResponseBodyDataListList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<GetConversationDetailByContactIdResponseBodyDataListList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetConversationDetailByContactIdResponseBodyDataList() = default;
};
class GetConversationDetailByContactIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConversationDetailByContactIdResponseBodyDataList> dataList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetConversationDetailByContactIdResponseBody() {}

  explicit GetConversationDetailByContactIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataList) {
      res["DataList"] = dataList ? boost::any(dataList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataList") != m.end() && !m["DataList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataList"].type()) {
        GetConversationDetailByContactIdResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataList"]));
        dataList = make_shared<GetConversationDetailByContactIdResponseBodyDataList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetConversationDetailByContactIdResponseBody() = default;
};
class GetConversationDetailByContactIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetConversationDetailByContactIdResponseBody> body{};

  GetConversationDetailByContactIdResponse() {}

  explicit GetConversationDetailByContactIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConversationDetailByContactIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConversationDetailByContactIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetConversationDetailByContactIdResponse() = default;
};
class GetConversationListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};

  GetConversationListRequest() {}

  explicit GetConversationListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetConversationListRequest() = default;
};
class GetConversationListResponseBodyConversationsSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};

  GetConversationListResponseBodyConversationsSummary() {}

  explicit GetConversationListResponseBodyConversationsSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetConversationListResponseBodyConversationsSummary() = default;
};
class GetConversationListResponseBodyConversations : public Darabonba::Model {
public:
  shared_ptr<vector<GetConversationListResponseBodyConversationsSummary>> summary{};
  shared_ptr<string> speaker{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> script{};

  GetConversationListResponseBodyConversations() {}

  explicit GetConversationListResponseBodyConversations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetConversationListResponseBodyConversationsSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConversationListResponseBodyConversationsSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetConversationListResponseBodyConversationsSummary>>(expect1);
      }
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~GetConversationListResponseBodyConversations() = default;
};
class GetConversationListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<GetConversationListResponseBodyConversations>> conversations{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetConversationListResponseBody() {}

  explicit GetConversationListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (conversations) {
      vector<boost::any> temp1;
      for(auto item1:*conversations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversations"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Conversations") != m.end() && !m["Conversations"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversations"].type()) {
        vector<GetConversationListResponseBodyConversations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConversationListResponseBodyConversations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversations = make_shared<vector<GetConversationListResponseBodyConversations>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetConversationListResponseBody() = default;
};
class GetConversationListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetConversationListResponseBody> body{};

  GetConversationListResponse() {}

  explicit GetConversationListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConversationListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConversationListResponseBody>(model1);
      }
    }
  }


  virtual ~GetConversationListResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber() {}

  explicit GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber() = default;
};
class GetInstanceResponseBodyInstancePhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber>> phoneNumber{};

  GetInstanceResponseBodyInstancePhoneNumbers() {}

  explicit GetInstanceResponseBodyInstancePhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<GetInstanceResponseBodyInstancePhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~GetInstanceResponseBodyInstancePhoneNumbers() = default;
};
class GetInstanceResponseBodyInstanceAdminUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  GetInstanceResponseBodyInstanceAdminUserDetail() {}

  explicit GetInstanceResponseBodyInstanceAdminUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstanceAdminUserDetail() = default;
};
class GetInstanceResponseBodyInstanceAdminUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<GetInstanceResponseBodyInstanceAdminUserDetail> detail{};

  GetInstanceResponseBodyInstanceAdminUser() {}

  explicit GetInstanceResponseBodyInstanceAdminUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        GetInstanceResponseBodyInstanceAdminUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<GetInstanceResponseBodyInstanceAdminUserDetail>(model1);
      }
    }
  }


  virtual ~GetInstanceResponseBodyInstanceAdminUser() = default;
};
class GetInstanceResponseBodyInstanceAdmin : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceResponseBodyInstanceAdminUser>> user{};

  GetInstanceResponseBodyInstanceAdmin() {}

  explicit GetInstanceResponseBodyInstanceAdmin(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<GetInstanceResponseBodyInstanceAdminUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyInstanceAdminUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<GetInstanceResponseBodyInstanceAdminUser>>(expect1);
      }
    }
  }


  virtual ~GetInstanceResponseBodyInstanceAdmin() = default;
};
class GetInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> storageMaxSize{};
  shared_ptr<long> storageMaxDays{};
  shared_ptr<long> maxOnlineAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<GetInstanceResponseBodyInstancePhoneNumbers> phoneNumbers{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> storageBucket{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> directoryId{};
  shared_ptr<GetInstanceResponseBodyInstanceAdmin> admin{};
  shared_ptr<string> tenantId{};

  GetInstanceResponseBodyInstance() {}

  explicit GetInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (storageMaxSize) {
      res["StorageMaxSize"] = boost::any(*storageMaxSize);
    }
    if (storageMaxDays) {
      res["StorageMaxDays"] = boost::any(*storageMaxDays);
    }
    if (maxOnlineAgents) {
      res["MaxOnlineAgents"] = boost::any(*maxOnlineAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (storageBucket) {
      res["StorageBucket"] = boost::any(*storageBucket);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (admin) {
      res["Admin"] = admin ? boost::any(admin->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("StorageMaxSize") != m.end() && !m["StorageMaxSize"].empty()) {
      storageMaxSize = make_shared<long>(boost::any_cast<long>(m["StorageMaxSize"]));
    }
    if (m.find("StorageMaxDays") != m.end() && !m["StorageMaxDays"].empty()) {
      storageMaxDays = make_shared<long>(boost::any_cast<long>(m["StorageMaxDays"]));
    }
    if (m.find("MaxOnlineAgents") != m.end() && !m["MaxOnlineAgents"].empty()) {
      maxOnlineAgents = make_shared<long>(boost::any_cast<long>(m["MaxOnlineAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        GetInstanceResponseBodyInstancePhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<GetInstanceResponseBodyInstancePhoneNumbers>(model1);
      }
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("StorageBucket") != m.end() && !m["StorageBucket"].empty()) {
      storageBucket = make_shared<string>(boost::any_cast<string>(m["StorageBucket"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Admin") != m.end() && !m["Admin"].empty()) {
      if (typeid(map<string, boost::any>) == m["Admin"].type()) {
        GetInstanceResponseBodyInstanceAdmin model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Admin"]));
        admin = make_shared<GetInstanceResponseBodyInstanceAdmin>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstance() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetInstanceResponseBodyInstance> instance{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        GetInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<GetInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetInstanceStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceStateRequest() {}

  explicit GetInstanceStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceStateRequest() = default;
};
class GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount : public Darabonba::Model {
public:
  shared_ptr<string> state{};
  shared_ptr<long> count{};

  GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount() {}

  explicit GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount() = default;
};
class GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount>> agentStateCount{};

  GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions() {}

  explicit GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStateCount) {
      vector<boost::any> temp1;
      for(auto item1:*agentStateCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentStateCount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentStateCount") != m.end() && !m["AgentStateCount"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentStateCount"].type()) {
        vector<GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentStateCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentStateCount = make_shared<vector<GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributionsAgentStateCount>>(expect1);
      }
    }
  }


  virtual ~GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions() = default;
};
class GetInstanceStateResponseBodyRealTimeInstanceState : public Darabonba::Model {
public:
  shared_ptr<GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions> agentStateDistributions{};

  GetInstanceStateResponseBodyRealTimeInstanceState() {}

  explicit GetInstanceStateResponseBodyRealTimeInstanceState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStateDistributions) {
      res["AgentStateDistributions"] = agentStateDistributions ? boost::any(agentStateDistributions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentStateDistributions") != m.end() && !m["AgentStateDistributions"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentStateDistributions"].type()) {
        GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentStateDistributions"]));
        agentStateDistributions = make_shared<GetInstanceStateResponseBodyRealTimeInstanceStateAgentStateDistributions>(model1);
      }
    }
  }


  virtual ~GetInstanceStateResponseBodyRealTimeInstanceState() = default;
};
class GetInstanceStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<GetInstanceStateResponseBodyRealTimeInstanceState> realTimeInstanceState{};

  GetInstanceStateResponseBody() {}

  explicit GetInstanceStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (realTimeInstanceState) {
      res["RealTimeInstanceState"] = realTimeInstanceState ? boost::any(realTimeInstanceState->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("RealTimeInstanceState") != m.end() && !m["RealTimeInstanceState"].empty()) {
      if (typeid(map<string, boost::any>) == m["RealTimeInstanceState"].type()) {
        GetInstanceStateResponseBodyRealTimeInstanceState model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RealTimeInstanceState"]));
        realTimeInstanceState = make_shared<GetInstanceStateResponseBodyRealTimeInstanceState>(model1);
      }
    }
  }


  virtual ~GetInstanceStateResponseBody() = default;
};
class GetInstanceStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceStateResponseBody> body{};

  GetInstanceStateResponse() {}

  explicit GetInstanceStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceStateResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceStateResponse() = default;
};
class GetInstanceSummaryReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetInstanceSummaryReportRequest() {}

  explicit GetInstanceSummaryReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetInstanceSummaryReportRequest() = default;
};
class GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall() {}

  explicit GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall() = default;
};
class GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> callsIncomingLine{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWaitTime{};
  shared_ptr<long> callsIncomingQueue{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsIncomingIVR{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> callsAbandonedInQueue{};

  GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound() {}

  explicit GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsIncomingLine) {
      res["CallsIncomingLine"] = boost::any(*callsIncomingLine);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (callsIncomingQueue) {
      res["CallsIncomingQueue"] = boost::any(*callsIncomingQueue);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsIncomingIVR) {
      res["CallsIncomingIVR"] = boost::any(*callsIncomingIVR);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsIncomingLine") != m.end() && !m["CallsIncomingLine"].empty()) {
      callsIncomingLine = make_shared<long>(boost::any_cast<long>(m["CallsIncomingLine"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<long>(boost::any_cast<long>(m["AverageWaitTime"]));
    }
    if (m.find("CallsIncomingQueue") != m.end() && !m["CallsIncomingQueue"].empty()) {
      callsIncomingQueue = make_shared<long>(boost::any_cast<long>(m["CallsIncomingQueue"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsIncomingIVR") != m.end() && !m["CallsIncomingIVR"].empty()) {
      callsIncomingIVR = make_shared<long>(boost::any_cast<long>(m["CallsIncomingIVR"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
  }


  virtual ~GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound() = default;
};
class GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound() {}

  explicit GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound() = default;
};
class GetInstanceSummaryReportResponseBodyInstanceSummaryReport : public Darabonba::Model {
public:
  shared_ptr<GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall> overall{};
  shared_ptr<GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound> inbound{};
  shared_ptr<GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound> outbound{};
  shared_ptr<string> instanceId{};

  GetInstanceSummaryReportResponseBodyInstanceSummaryReport() {}

  explicit GetInstanceSummaryReportResponseBodyInstanceSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetInstanceSummaryReportResponseBodyInstanceSummaryReportOverall>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetInstanceSummaryReportResponseBodyInstanceSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetInstanceSummaryReportResponseBodyInstanceSummaryReportOutbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceSummaryReportResponseBodyInstanceSummaryReport() = default;
};
class GetInstanceSummaryReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetInstanceSummaryReportResponseBodyInstanceSummaryReport> instanceSummaryReport{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetInstanceSummaryReportResponseBody() {}

  explicit GetInstanceSummaryReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceSummaryReport) {
      res["InstanceSummaryReport"] = instanceSummaryReport ? boost::any(instanceSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceSummaryReport") != m.end() && !m["InstanceSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSummaryReport"].type()) {
        GetInstanceSummaryReportResponseBodyInstanceSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSummaryReport"]));
        instanceSummaryReport = make_shared<GetInstanceSummaryReportResponseBodyInstanceSummaryReport>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceSummaryReportResponseBody() = default;
};
class GetInstanceSummaryReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceSummaryReportResponseBody> body{};

  GetInstanceSummaryReportResponse() {}

  explicit GetInstanceSummaryReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceSummaryReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceSummaryReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceSummaryReportResponse() = default;
};
class GetInstanceSummaryReportByIntervalRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetInstanceSummaryReportByIntervalRequest() {}

  explicit GetInstanceSummaryReportByIntervalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalRequest() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> callsIncomingLine{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWaitTime{};
  shared_ptr<long> callsIncomingQueue{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsIncomingIVR{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> callsAbandonedInQueue{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsIncomingLine) {
      res["CallsIncomingLine"] = boost::any(*callsIncomingLine);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (callsIncomingQueue) {
      res["CallsIncomingQueue"] = boost::any(*callsIncomingQueue);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsIncomingIVR) {
      res["CallsIncomingIVR"] = boost::any(*callsIncomingIVR);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsIncomingLine") != m.end() && !m["CallsIncomingLine"].empty()) {
      callsIncomingLine = make_shared<long>(boost::any_cast<long>(m["CallsIncomingLine"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<long>(boost::any_cast<long>(m["AverageWaitTime"]));
    }
    if (m.find("CallsIncomingQueue") != m.end() && !m["CallsIncomingQueue"].empty()) {
      callsIncomingQueue = make_shared<long>(boost::any_cast<long>(m["CallsIncomingQueue"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsIncomingIVR") != m.end() && !m["CallsIncomingIVR"].empty()) {
      callsIncomingIVR = make_shared<long>(boost::any_cast<long>(m["CallsIncomingIVR"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport : public Darabonba::Model {
public:
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall> overall{};
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound> inbound{};
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound> outbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timestamp{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOverall>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReportOutbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport>> instanceSummaryReport{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*instanceSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSummaryReport") != m.end() && !m["InstanceSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceSummaryReport"].type()) {
        vector<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceSummaryReport = make_shared<vector<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalListInstanceSummaryReport>>(expect1);
      }
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList() = default;
};
class GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList> intervalList{};

  GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport() {}

  explicit GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (intervalList) {
      res["IntervalList"] = intervalList ? boost::any(intervalList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IntervalList") != m.end() && !m["IntervalList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntervalList"].type()) {
        GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntervalList"]));
        intervalList = make_shared<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReportIntervalList>(model1);
      }
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport() = default;
};
class GetInstanceSummaryReportByIntervalResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport> instanceTimeIntervalReport{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetInstanceSummaryReportByIntervalResponseBody() {}

  explicit GetInstanceSummaryReportByIntervalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTimeIntervalReport) {
      res["InstanceTimeIntervalReport"] = instanceTimeIntervalReport ? boost::any(instanceTimeIntervalReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTimeIntervalReport") != m.end() && !m["InstanceTimeIntervalReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTimeIntervalReport"].type()) {
        GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTimeIntervalReport"]));
        instanceTimeIntervalReport = make_shared<GetInstanceSummaryReportByIntervalResponseBodyInstanceTimeIntervalReport>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponseBody() = default;
};
class GetInstanceSummaryReportByIntervalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceSummaryReportByIntervalResponseBody> body{};

  GetInstanceSummaryReportByIntervalResponse() {}

  explicit GetInstanceSummaryReportByIntervalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceSummaryReportByIntervalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceSummaryReportByIntervalResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceSummaryReportByIntervalResponse() = default;
};
class GetInstanceSummaryReportSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetInstanceSummaryReportSinceMidnightRequest() {}

  explicit GetInstanceSummaryReportSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightRequest() = default;
};
class GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall() {}

  explicit GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall() = default;
};
class GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> callsIncomingLine{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageWaitTime{};
  shared_ptr<long> callsIncomingQueue{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsIncomingIVR{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> callsAbandonedInQueue{};

  GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound() {}

  explicit GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsIncomingLine) {
      res["CallsIncomingLine"] = boost::any(*callsIncomingLine);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (callsIncomingQueue) {
      res["CallsIncomingQueue"] = boost::any(*callsIncomingQueue);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsIncomingIVR) {
      res["CallsIncomingIVR"] = boost::any(*callsIncomingIVR);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsIncomingLine") != m.end() && !m["CallsIncomingLine"].empty()) {
      callsIncomingLine = make_shared<long>(boost::any_cast<long>(m["CallsIncomingLine"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<long>(boost::any_cast<long>(m["AverageWaitTime"]));
    }
    if (m.find("CallsIncomingQueue") != m.end() && !m["CallsIncomingQueue"].empty()) {
      callsIncomingQueue = make_shared<long>(boost::any_cast<long>(m["CallsIncomingQueue"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsIncomingIVR") != m.end() && !m["CallsIncomingIVR"].empty()) {
      callsIncomingIVR = make_shared<long>(boost::any_cast<long>(m["CallsIncomingIVR"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound() = default;
};
class GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound() {}

  explicit GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound() = default;
};
class GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport : public Darabonba::Model {
public:
  shared_ptr<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall> overall{};
  shared_ptr<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound> inbound{};
  shared_ptr<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound> outbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> timestamp{};

  GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport() {}

  explicit GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOverall>(model1);
      }
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReportOutbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport() = default;
};
class GetInstanceSummaryReportSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport> instanceSummaryReport{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetInstanceSummaryReportSinceMidnightResponseBody() {}

  explicit GetInstanceSummaryReportSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceSummaryReport) {
      res["InstanceSummaryReport"] = instanceSummaryReport ? boost::any(instanceSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceSummaryReport") != m.end() && !m["InstanceSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSummaryReport"].type()) {
        GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSummaryReport"]));
        instanceSummaryReport = make_shared<GetInstanceSummaryReportSinceMidnightResponseBodyInstanceSummaryReport>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponseBody() = default;
};
class GetInstanceSummaryReportSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetInstanceSummaryReportSinceMidnightResponseBody> body{};

  GetInstanceSummaryReportSinceMidnightResponse() {}

  explicit GetInstanceSummaryReportSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceSummaryReportSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceSummaryReportSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceSummaryReportSinceMidnightResponse() = default;
};
class GetJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  GetJobRequest() {}

  explicit GetJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobRequest() = default;
};
class GetJobResponseBodyJobContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetJobResponseBodyJobContacts() {}

  explicit GetJobResponseBodyJobContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetJobResponseBodyJobContacts() = default;
};
class GetJobResponseBodyJobSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};

  GetJobResponseBodyJobSummary() {}

  explicit GetJobResponseBodyJobSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetJobResponseBodyJobSummary() = default;
};
class GetJobResponseBodyJobExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetJobResponseBodyJobExtras() {}

  explicit GetJobResponseBodyJobExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetJobResponseBodyJobExtras() = default;
};
class GetJobResponseBodyJobTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetJobResponseBodyJobTasksContact() {}

  explicit GetJobResponseBodyJobTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetJobResponseBodyJobTasksContact() = default;
};
class GetJobResponseBodyJobTasksConversationSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};

  GetJobResponseBodyJobTasksConversationSummary() {}

  explicit GetJobResponseBodyJobTasksConversationSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetJobResponseBodyJobTasksConversationSummary() = default;
};
class GetJobResponseBodyJobTasksConversation : public Darabonba::Model {
public:
  shared_ptr<vector<GetJobResponseBodyJobTasksConversationSummary>> summary{};
  shared_ptr<string> speaker{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> script{};

  GetJobResponseBodyJobTasksConversation() {}

  explicit GetJobResponseBodyJobTasksConversation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetJobResponseBodyJobTasksConversationSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobTasksConversationSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetJobResponseBodyJobTasksConversationSummary>>(expect1);
      }
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~GetJobResponseBodyJobTasksConversation() = default;
};
class GetJobResponseBodyJobTasks : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> actualTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> scenarioId{};
  shared_ptr<GetJobResponseBodyJobTasksContact> contact{};
  shared_ptr<string> jobId{};
  shared_ptr<string> callId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> brief{};
  shared_ptr<long> duration{};
  shared_ptr<string> taskId{};
  shared_ptr<vector<GetJobResponseBodyJobTasksConversation>> conversation{};

  GetJobResponseBodyJobTasks() {}

  explicit GetJobResponseBodyJobTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversation) {
      vector<boost::any> temp1;
      for(auto item1:*conversation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        GetJobResponseBodyJobTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<GetJobResponseBodyJobTasksContact>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Conversation") != m.end() && !m["Conversation"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversation"].type()) {
        vector<GetJobResponseBodyJobTasksConversation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobTasksConversation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversation = make_shared<vector<GetJobResponseBodyJobTasksConversation>>(expect1);
      }
    }
  }


  virtual ~GetJobResponseBodyJobTasks() = default;
};
class GetJobResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<GetJobResponseBodyJobContacts>> contacts{};
  shared_ptr<vector<GetJobResponseBodyJobSummary>> summary{};
  shared_ptr<long> priority{};
  shared_ptr<string> failureReason{};
  shared_ptr<long> systemPriority{};
  shared_ptr<vector<GetJobResponseBodyJobExtras>> extras{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<vector<GetJobResponseBodyJobTasks>> tasks{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};

  GetJobResponseBodyJob() {}

  explicit GetJobResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<GetJobResponseBodyJobContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<GetJobResponseBodyJobContacts>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetJobResponseBodyJobSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetJobResponseBodyJobSummary>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<GetJobResponseBodyJobExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<GetJobResponseBodyJobExtras>>(expect1);
      }
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<GetJobResponseBodyJobTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobResponseBodyJobTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetJobResponseBodyJobTasks>>(expect1);
      }
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobResponseBodyJob() = default;
};
class GetJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetJobResponseBodyJob> job{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobResponseBody() {}

  explicit GetJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetJobResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetJobResponseBodyJob>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobResponseBody() = default;
};
class GetJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobResponseBody> body{};

  GetJobResponse() {}

  explicit GetJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobResponse() = default;
};
class GetJobDataUploadParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> fileName{};

  GetJobDataUploadParamsRequest() {}

  explicit GetJobDataUploadParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GetJobDataUploadParamsRequest() = default;
};
class GetJobDataUploadParamsResponseBodyUploadParams : public Darabonba::Model {
public:
  shared_ptr<string> signature{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> folder{};
  shared_ptr<string> accessId{};
  shared_ptr<long> expire{};

  GetJobDataUploadParamsResponseBodyUploadParams() {}

  explicit GetJobDataUploadParamsResponseBodyUploadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (folder) {
      res["Folder"] = boost::any(*folder);
    }
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Folder") != m.end() && !m["Folder"].empty()) {
      folder = make_shared<string>(boost::any_cast<string>(m["Folder"]));
    }
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
  }


  virtual ~GetJobDataUploadParamsResponseBodyUploadParams() = default;
};
class GetJobDataUploadParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetJobDataUploadParamsResponseBodyUploadParams> uploadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobDataUploadParamsResponseBody() {}

  explicit GetJobDataUploadParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadParams) {
      res["UploadParams"] = uploadParams ? boost::any(uploadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadParams") != m.end() && !m["UploadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadParams"].type()) {
        GetJobDataUploadParamsResponseBodyUploadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadParams"]));
        uploadParams = make_shared<GetJobDataUploadParamsResponseBodyUploadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobDataUploadParamsResponseBody() = default;
};
class GetJobDataUploadParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobDataUploadParamsResponseBody> body{};

  GetJobDataUploadParamsResponse() {}

  explicit GetJobDataUploadParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobDataUploadParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobDataUploadParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobDataUploadParamsResponse() = default;
};
class GetJobFileUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> fileName{};

  GetJobFileUploadUrlRequest() {}

  explicit GetJobFileUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GetJobFileUploadUrlRequest() = default;
};
class GetJobFileUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> uploadUrl{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobFileUploadUrlResponseBody() {}

  explicit GetJobFileUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (uploadUrl) {
      res["UploadUrl"] = boost::any(*uploadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("UploadUrl") != m.end() && !m["UploadUrl"].empty()) {
      uploadUrl = make_shared<string>(boost::any_cast<string>(m["UploadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobFileUploadUrlResponseBody() = default;
};
class GetJobFileUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobFileUploadUrlResponseBody> body{};

  GetJobFileUploadUrlResponse() {}

  explicit GetJobFileUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobFileUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobFileUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobFileUploadUrlResponse() = default;
};
class GetJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  GetJobGroupRequest() {}

  explicit GetJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~GetJobGroupRequest() = default;
};
class GetJobGroupResponseBodyJobGroupStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  GetJobGroupResponseBodyJobGroupStrategyWorkingTime() {}

  explicit GetJobGroupResponseBodyJobGroupStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~GetJobGroupResponseBodyJobGroupStrategyWorkingTime() = default;
};
class GetJobGroupResponseBodyJobGroupStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<GetJobGroupResponseBodyJobGroupStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> description{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  GetJobGroupResponseBodyJobGroupStrategy() {}

  explicit GetJobGroupResponseBodyJobGroupStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<GetJobGroupResponseBodyJobGroupStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobGroupResponseBodyJobGroupStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<GetJobGroupResponseBodyJobGroupStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetJobGroupResponseBodyJobGroupStrategy() = default;
};
class GetJobGroupResponseBodyJobGroupProgressCategories : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetJobGroupResponseBodyJobGroupProgressCategories() {}

  explicit GetJobGroupResponseBodyJobGroupProgressCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetJobGroupResponseBodyJobGroupProgressCategories() = default;
};
class GetJobGroupResponseBodyJobGroupProgress : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> totalNotAnswered{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<GetJobGroupResponseBodyJobGroupProgressCategories>> categories{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalCompleted{};
  shared_ptr<long> duration{};

  GetJobGroupResponseBodyJobGroupProgress() {}

  explicit GetJobGroupResponseBodyJobGroupProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalNotAnswered) {
      res["TotalNotAnswered"] = boost::any(*totalNotAnswered);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalNotAnswered") != m.end() && !m["TotalNotAnswered"].empty()) {
      totalNotAnswered = make_shared<long>(boost::any_cast<long>(m["TotalNotAnswered"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<GetJobGroupResponseBodyJobGroupProgressCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobGroupResponseBodyJobGroupProgressCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<GetJobGroupResponseBodyJobGroupProgressCategories>>(expect1);
      }
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~GetJobGroupResponseBodyJobGroupProgress() = default;
};
class GetJobGroupResponseBodyJobGroup : public Darabonba::Model {
public:
  shared_ptr<string> scenarioId{};
  shared_ptr<long> creationTime{};
  shared_ptr<GetJobGroupResponseBodyJobGroupStrategy> strategy{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<GetJobGroupResponseBodyJobGroupProgress> progress{};
  shared_ptr<string> description{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  GetJobGroupResponseBodyJobGroup() {}

  explicit GetJobGroupResponseBodyJobGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        GetJobGroupResponseBodyJobGroupStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<GetJobGroupResponseBodyJobGroupStrategy>(model1);
      }
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        GetJobGroupResponseBodyJobGroupProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<GetJobGroupResponseBodyJobGroupProgress>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetJobGroupResponseBodyJobGroup() = default;
};
class GetJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetJobGroupResponseBodyJobGroup> jobGroup{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobGroupResponseBody() {}

  explicit GetJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobGroup) {
      res["JobGroup"] = jobGroup ? boost::any(jobGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobGroup") != m.end() && !m["JobGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroup"].type()) {
        GetJobGroupResponseBodyJobGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroup"]));
        jobGroup = make_shared<GetJobGroupResponseBodyJobGroup>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobGroupResponseBody() = default;
};
class GetJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobGroupResponseBody> body{};

  GetJobGroupResponse() {}

  explicit GetJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobGroupResponse() = default;
};
class GetJobListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> status{};
  shared_ptr<bool> queryAll{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  GetJobListRequest() {}

  explicit GetJobListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (queryAll) {
      res["QueryAll"] = boost::any(*queryAll);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("QueryAll") != m.end() && !m["QueryAll"].empty()) {
      queryAll = make_shared<bool>(boost::any_cast<bool>(m["QueryAll"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetJobListRequest() = default;
};
class GetJobListResponseBodyJobsListSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> conversationDetailId{};

  GetJobListResponseBodyJobsListSummary() {}

  explicit GetJobListResponseBodyJobsListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
  }


  virtual ~GetJobListResponseBodyJobsListSummary() = default;
};
class GetJobListResponseBodyJobsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetJobListResponseBodyJobsListContacts() {}

  explicit GetJobListResponseBodyJobsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetJobListResponseBodyJobsListContacts() = default;
};
class GetJobListResponseBodyJobsListExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetJobListResponseBodyJobsListExtras() {}

  explicit GetJobListResponseBodyJobsListExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetJobListResponseBodyJobsListExtras() = default;
};
class GetJobListResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<GetJobListResponseBodyJobsListSummary>> summary{};
  shared_ptr<vector<GetJobListResponseBodyJobsListContacts>> contacts{};
  shared_ptr<long> priority{};
  shared_ptr<string> failureReason{};
  shared_ptr<long> systemPriority{};
  shared_ptr<vector<GetJobListResponseBodyJobsListExtras>> extras{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};

  GetJobListResponseBodyJobsList() {}

  explicit GetJobListResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetJobListResponseBodyJobsListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobListResponseBodyJobsListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetJobListResponseBodyJobsListSummary>>(expect1);
      }
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<GetJobListResponseBodyJobsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobListResponseBodyJobsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<GetJobListResponseBodyJobsListContacts>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<GetJobListResponseBodyJobsListExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobListResponseBodyJobsListExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<GetJobListResponseBodyJobsListExtras>>(expect1);
      }
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobListResponseBodyJobsList() = default;
};
class GetJobListResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<GetJobListResponseBodyJobsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  GetJobListResponseBodyJobs() {}

  explicit GetJobListResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<GetJobListResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobListResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<GetJobListResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetJobListResponseBodyJobs() = default;
};
class GetJobListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetJobListResponseBodyJobs> jobs{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobListResponseBody() {}

  explicit GetJobListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        GetJobListResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<GetJobListResponseBodyJobs>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobListResponseBody() = default;
};
class GetJobListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobListResponseBody> body{};

  GetJobListResponse() {}

  explicit GetJobListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobListResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobListResponse() = default;
};
class GetJobStatusByCallIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> callId{};

  GetJobStatusByCallIdRequest() {}

  explicit GetJobStatusByCallIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
  }


  virtual ~GetJobStatusByCallIdRequest() = default;
};
class GetJobStatusByCallIdResponseBodyJobContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetJobStatusByCallIdResponseBodyJobContacts() {}

  explicit GetJobStatusByCallIdResponseBodyJobContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobContacts() = default;
};
class GetJobStatusByCallIdResponseBodyJobSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryId{};

  GetJobStatusByCallIdResponseBodyJobSummary() {}

  explicit GetJobStatusByCallIdResponseBodyJobSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobSummary() = default;
};
class GetJobStatusByCallIdResponseBodyJobExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetJobStatusByCallIdResponseBodyJobExtras() {}

  explicit GetJobStatusByCallIdResponseBodyJobExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobExtras() = default;
};
class GetJobStatusByCallIdResponseBodyJobTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetJobStatusByCallIdResponseBodyJobTasksContact() {}

  explicit GetJobStatusByCallIdResponseBodyJobTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobTasksContact() = default;
};
class GetJobStatusByCallIdResponseBodyJobTasksConversationSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryId{};

  GetJobStatusByCallIdResponseBodyJobTasksConversationSummary() {}

  explicit GetJobStatusByCallIdResponseBodyJobTasksConversationSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobTasksConversationSummary() = default;
};
class GetJobStatusByCallIdResponseBodyJobTasksConversation : public Darabonba::Model {
public:
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobTasksConversationSummary>> summary{};
  shared_ptr<string> speaker{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> script{};
  shared_ptr<string> taskId{};
  shared_ptr<string> conversationDetailId{};

  GetJobStatusByCallIdResponseBodyJobTasksConversation() {}

  explicit GetJobStatusByCallIdResponseBodyJobTasksConversation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobTasksConversationSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobTasksConversationSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetJobStatusByCallIdResponseBodyJobTasksConversationSummary>>(expect1);
      }
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobTasksConversation() = default;
};
class GetJobStatusByCallIdResponseBodyJobTasks : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> actualTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<long> endTime{};
  shared_ptr<string> scenarioId{};
  shared_ptr<GetJobStatusByCallIdResponseBodyJobTasksContact> contact{};
  shared_ptr<string> jobId{};
  shared_ptr<string> callId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> brief{};
  shared_ptr<long> duration{};
  shared_ptr<string> taskId{};
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobTasksConversation>> conversation{};

  GetJobStatusByCallIdResponseBodyJobTasks() {}

  explicit GetJobStatusByCallIdResponseBodyJobTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversation) {
      vector<boost::any> temp1;
      for(auto item1:*conversation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        GetJobStatusByCallIdResponseBodyJobTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<GetJobStatusByCallIdResponseBodyJobTasksContact>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Conversation") != m.end() && !m["Conversation"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversation"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobTasksConversation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobTasksConversation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversation = make_shared<vector<GetJobStatusByCallIdResponseBodyJobTasksConversation>>(expect1);
      }
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJobTasks() = default;
};
class GetJobStatusByCallIdResponseBodyJob : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobContacts>> contacts{};
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobSummary>> summary{};
  shared_ptr<long> priority{};
  shared_ptr<string> failureReason{};
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobExtras>> extras{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<vector<GetJobStatusByCallIdResponseBodyJobTasks>> tasks{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};

  GetJobStatusByCallIdResponseBodyJob() {}

  explicit GetJobStatusByCallIdResponseBodyJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<GetJobStatusByCallIdResponseBodyJobContacts>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetJobStatusByCallIdResponseBodyJobSummary>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<GetJobStatusByCallIdResponseBodyJobExtras>>(expect1);
      }
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<GetJobStatusByCallIdResponseBodyJobTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetJobStatusByCallIdResponseBodyJobTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetJobStatusByCallIdResponseBodyJobTasks>>(expect1);
      }
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBodyJob() = default;
};
class GetJobStatusByCallIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetJobStatusByCallIdResponseBodyJob> job{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobStatusByCallIdResponseBody() {}

  explicit GetJobStatusByCallIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (job) {
      res["Job"] = job ? boost::any(job->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Job") != m.end() && !m["Job"].empty()) {
      if (typeid(map<string, boost::any>) == m["Job"].type()) {
        GetJobStatusByCallIdResponseBodyJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Job"]));
        job = make_shared<GetJobStatusByCallIdResponseBodyJob>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobStatusByCallIdResponseBody() = default;
};
class GetJobStatusByCallIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobStatusByCallIdResponseBody> body{};

  GetJobStatusByCallIdResponse() {}

  explicit GetJobStatusByCallIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobStatusByCallIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobStatusByCallIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobStatusByCallIdResponse() = default;
};
class GetJobTemplateDownloadParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};

  GetJobTemplateDownloadParamsRequest() {}

  explicit GetJobTemplateDownloadParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~GetJobTemplateDownloadParamsRequest() = default;
};
class GetJobTemplateDownloadParamsResponseBodyDownloadParams : public Darabonba::Model {
public:
  shared_ptr<string> signatureUrl{};

  GetJobTemplateDownloadParamsResponseBodyDownloadParams() {}

  explicit GetJobTemplateDownloadParamsResponseBodyDownloadParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureUrl) {
      res["SignatureUrl"] = boost::any(*signatureUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureUrl") != m.end() && !m["SignatureUrl"].empty()) {
      signatureUrl = make_shared<string>(boost::any_cast<string>(m["SignatureUrl"]));
    }
  }


  virtual ~GetJobTemplateDownloadParamsResponseBodyDownloadParams() = default;
};
class GetJobTemplateDownloadParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetJobTemplateDownloadParamsResponseBodyDownloadParams> downloadParams{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetJobTemplateDownloadParamsResponseBody() {}

  explicit GetJobTemplateDownloadParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (downloadParams) {
      res["DownloadParams"] = downloadParams ? boost::any(downloadParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DownloadParams") != m.end() && !m["DownloadParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadParams"].type()) {
        GetJobTemplateDownloadParamsResponseBodyDownloadParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadParams"]));
        downloadParams = make_shared<GetJobTemplateDownloadParamsResponseBodyDownloadParams>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetJobTemplateDownloadParamsResponseBody() = default;
};
class GetJobTemplateDownloadParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetJobTemplateDownloadParamsResponseBody> body{};

  GetJobTemplateDownloadParamsResponse() {}

  explicit GetJobTemplateDownloadParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetJobTemplateDownloadParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetJobTemplateDownloadParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetJobTemplateDownloadParamsResponse() = default;
};
class GetNumberRegionInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  GetNumberRegionInfoRequest() {}

  explicit GetNumberRegionInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~GetNumberRegionInfoRequest() = default;
};
class GetNumberRegionInfoResponseBodyPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  GetNumberRegionInfoResponseBodyPhoneNumber() {}

  explicit GetNumberRegionInfoResponseBodyPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~GetNumberRegionInfoResponseBodyPhoneNumber() = default;
};
class GetNumberRegionInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetNumberRegionInfoResponseBodyPhoneNumber> phoneNumber{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetNumberRegionInfoResponseBody() {}

  explicit GetNumberRegionInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = phoneNumber ? boost::any(phoneNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumber"].type()) {
        GetNumberRegionInfoResponseBodyPhoneNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumber"]));
        phoneNumber = make_shared<GetNumberRegionInfoResponseBodyPhoneNumber>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNumberRegionInfoResponseBody() = default;
};
class GetNumberRegionInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNumberRegionInfoResponseBody> body{};

  GetNumberRegionInfoResponse() {}

  explicit GetNumberRegionInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNumberRegionInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNumberRegionInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetNumberRegionInfoResponse() = default;
};
class GetRecordOssUploadParamRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> fileName{};

  GetRecordOssUploadParamRequest() {}

  explicit GetRecordOssUploadParamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GetRecordOssUploadParamRequest() = default;
};
class GetRecordOssUploadParamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policy{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> signature{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> ossFileName{};
  shared_ptr<string> host{};
  shared_ptr<string> expires{};
  shared_ptr<string> dir{};
  shared_ptr<string> code{};
  shared_ptr<string> ossAccessKeyId{};
  shared_ptr<bool> success{};

  GetRecordOssUploadParamResponseBody() {}

  explicit GetRecordOssUploadParamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (ossAccessKeyId) {
      res["OssAccessKeyId"] = boost::any(*ossAccessKeyId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<string>(boost::any_cast<string>(m["Expires"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("OssAccessKeyId") != m.end() && !m["OssAccessKeyId"].empty()) {
      ossAccessKeyId = make_shared<string>(boost::any_cast<string>(m["OssAccessKeyId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRecordOssUploadParamResponseBody() = default;
};
class GetRecordOssUploadParamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetRecordOssUploadParamResponseBody> body{};

  GetRecordOssUploadParamResponse() {}

  explicit GetRecordOssUploadParamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRecordOssUploadParamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRecordOssUploadParamResponseBody>(model1);
      }
    }
  }


  virtual ~GetRecordOssUploadParamResponse() = default;
};
class GetRoutePointRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};

  GetRoutePointRequest() {}

  explicit GetRoutePointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~GetRoutePointRequest() = default;
};
class GetRoutePointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> statusDesc{};
  shared_ptr<string> routePoint{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetRoutePointResponseBody() {}

  explicit GetRoutePointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (routePoint) {
      res["RoutePoint"] = boost::any(*routePoint);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("RoutePoint") != m.end() && !m["RoutePoint"].empty()) {
      routePoint = make_shared<string>(boost::any_cast<string>(m["RoutePoint"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetRoutePointResponseBody() = default;
};
class GetRoutePointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetRoutePointResponseBody> body{};

  GetRoutePointResponse() {}

  explicit GetRoutePointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRoutePointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRoutePointResponseBody>(model1);
      }
    }
  }


  virtual ~GetRoutePointResponse() = default;
};
class GetScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};

  GetScenarioRequest() {}

  explicit GetScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~GetScenarioRequest() = default;
};
class GetScenarioResponseBodyScenarioStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  GetScenarioResponseBodyScenarioStrategyWorkingTime() {}

  explicit GetScenarioResponseBodyScenarioStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenarioStrategyWorkingTime() = default;
};
class GetScenarioResponseBodyScenarioStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<GetScenarioResponseBodyScenarioStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> description{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  GetScenarioResponseBodyScenarioStrategy() {}

  explicit GetScenarioResponseBodyScenarioStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<GetScenarioResponseBodyScenarioStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScenarioResponseBodyScenarioStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<GetScenarioResponseBodyScenarioStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenarioStrategy() = default;
};
class GetScenarioResponseBodyScenarioSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  GetScenarioResponseBodyScenarioSurveysIntents() {}

  explicit GetScenarioResponseBodyScenarioSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenarioSurveysIntents() = default;
};
class GetScenarioResponseBodyScenarioSurveys : public Darabonba::Model {
public:
  shared_ptr<long> round{};
  shared_ptr<string> description{};
  shared_ptr<string> beebotId{};
  shared_ptr<vector<GetScenarioResponseBodyScenarioSurveysIntents>> intents{};
  shared_ptr<string> name{};
  shared_ptr<string> role{};
  shared_ptr<string> id{};

  GetScenarioResponseBodyScenarioSurveys() {}

  explicit GetScenarioResponseBodyScenarioSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<GetScenarioResponseBodyScenarioSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScenarioResponseBodyScenarioSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<GetScenarioResponseBodyScenarioSurveysIntents>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenarioSurveys() = default;
};
class GetScenarioResponseBodyScenarioVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetScenarioResponseBodyScenarioVariables() {}

  explicit GetScenarioResponseBodyScenarioVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenarioVariables() = default;
};
class GetScenarioResponseBodyScenario : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<GetScenarioResponseBodyScenarioStrategy> strategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> description{};
  shared_ptr<vector<GetScenarioResponseBodyScenarioSurveys>> surveys{};
  shared_ptr<vector<GetScenarioResponseBodyScenarioVariables>> variables{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  GetScenarioResponseBodyScenario() {}

  explicit GetScenarioResponseBodyScenario(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        GetScenarioResponseBodyScenarioStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<GetScenarioResponseBodyScenarioStrategy>(model1);
      }
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<GetScenarioResponseBodyScenarioSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScenarioResponseBodyScenarioSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<GetScenarioResponseBodyScenarioSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<GetScenarioResponseBodyScenarioVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetScenarioResponseBodyScenarioVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<GetScenarioResponseBodyScenarioVariables>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetScenarioResponseBodyScenario() = default;
};
class GetScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<GetScenarioResponseBodyScenario> scenario{};

  GetScenarioResponseBody() {}

  explicit GetScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (scenario) {
      res["Scenario"] = scenario ? boost::any(scenario->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenario"].type()) {
        GetScenarioResponseBodyScenario model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenario"]));
        scenario = make_shared<GetScenarioResponseBodyScenario>(model1);
      }
    }
  }


  virtual ~GetScenarioResponseBody() = default;
};
class GetScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetScenarioResponseBody> body{};

  GetScenarioResponse() {}

  explicit GetScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~GetScenarioResponse() = default;
};
class GetServiceExtensionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> serviceType{};

  GetServiceExtensionsRequest() {}

  explicit GetServiceExtensionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~GetServiceExtensionsRequest() = default;
};
class GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> name{};

  GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension() {}

  explicit GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension() = default;
};
class GetServiceExtensionsResponseBodyServiceExtensions : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension>> serviceExtension{};

  GetServiceExtensionsResponseBodyServiceExtensions() {}

  explicit GetServiceExtensionsResponseBodyServiceExtensions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceExtension) {
      vector<boost::any> temp1;
      for(auto item1:*serviceExtension){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceExtension"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceExtension") != m.end() && !m["ServiceExtension"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceExtension"].type()) {
        vector<GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceExtension"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceExtension = make_shared<vector<GetServiceExtensionsResponseBodyServiceExtensionsServiceExtension>>(expect1);
      }
    }
  }


  virtual ~GetServiceExtensionsResponseBodyServiceExtensions() = default;
};
class GetServiceExtensionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetServiceExtensionsResponseBodyServiceExtensions> serviceExtensions{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetServiceExtensionsResponseBody() {}

  explicit GetServiceExtensionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (serviceExtensions) {
      res["ServiceExtensions"] = serviceExtensions ? boost::any(serviceExtensions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ServiceExtensions") != m.end() && !m["ServiceExtensions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceExtensions"].type()) {
        GetServiceExtensionsResponseBodyServiceExtensions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceExtensions"]));
        serviceExtensions = make_shared<GetServiceExtensionsResponseBodyServiceExtensions>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetServiceExtensionsResponseBody() = default;
};
class GetServiceExtensionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetServiceExtensionsResponseBody> body{};

  GetServiceExtensionsResponse() {}

  explicit GetServiceExtensionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceExtensionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceExtensionsResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceExtensionsResponse() = default;
};
class GetSmsConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<int>> scenario{};

  GetSmsConfigRequest() {}

  explicit GetSmsConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["Scenario"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scenario"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      scenario = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~GetSmsConfigRequest() = default;
};
class GetSmsConfigResponseBodySmsConfigsSmsConfig : public Darabonba::Model {
public:
  shared_ptr<string> instance{};
  shared_ptr<string> description{};
  shared_ptr<string> templateCode{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> scenario{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> extra{};
  shared_ptr<string> signName{};
  shared_ptr<long> id{};

  GetSmsConfigResponseBodySmsConfigsSmsConfig() {}

  explicit GetSmsConfigResponseBodySmsConfigsSmsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (templateCode) {
      res["TemplateCode"] = boost::any(*templateCode);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (scenario) {
      res["Scenario"] = boost::any(*scenario);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (signName) {
      res["SignName"] = boost::any(*signName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TemplateCode") != m.end() && !m["TemplateCode"].empty()) {
      templateCode = make_shared<string>(boost::any_cast<string>(m["TemplateCode"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      scenario = make_shared<long>(boost::any_cast<long>(m["Scenario"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("SignName") != m.end() && !m["SignName"].empty()) {
      signName = make_shared<string>(boost::any_cast<string>(m["SignName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetSmsConfigResponseBodySmsConfigsSmsConfig() = default;
};
class GetSmsConfigResponseBodySmsConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<GetSmsConfigResponseBodySmsConfigsSmsConfig>> smsConfig{};

  GetSmsConfigResponseBodySmsConfigs() {}

  explicit GetSmsConfigResponseBodySmsConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smsConfig) {
      vector<boost::any> temp1;
      for(auto item1:*smsConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmsConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmsConfig") != m.end() && !m["SmsConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["SmsConfig"].type()) {
        vector<GetSmsConfigResponseBodySmsConfigsSmsConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmsConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSmsConfigResponseBodySmsConfigsSmsConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smsConfig = make_shared<vector<GetSmsConfigResponseBodySmsConfigsSmsConfig>>(expect1);
      }
    }
  }


  virtual ~GetSmsConfigResponseBodySmsConfigs() = default;
};
class GetSmsConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetSmsConfigResponseBodySmsConfigs> smsConfigs{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetSmsConfigResponseBody() {}

  explicit GetSmsConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (smsConfigs) {
      res["SmsConfigs"] = smsConfigs ? boost::any(smsConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("SmsConfigs") != m.end() && !m["SmsConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmsConfigs"].type()) {
        GetSmsConfigResponseBodySmsConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmsConfigs"]));
        smsConfigs = make_shared<GetSmsConfigResponseBodySmsConfigs>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSmsConfigResponseBody() = default;
};
class GetSmsConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSmsConfigResponseBody> body{};

  GetSmsConfigResponse() {}

  explicit GetSmsConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmsConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmsConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmsConfigResponse() = default;
};
class GetSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> surveyId{};

  GetSurveyRequest() {}

  explicit GetSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~GetSurveyRequest() = default;
};
class GetSurveyResponseBodySurveyAsrCustomModel : public Darabonba::Model {
public:
  shared_ptr<long> customModelStatus{};
  shared_ptr<string> corpora{};

  GetSurveyResponseBodySurveyAsrCustomModel() {}

  explicit GetSurveyResponseBodySurveyAsrCustomModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customModelStatus) {
      res["CustomModelStatus"] = boost::any(*customModelStatus);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomModelStatus") != m.end() && !m["CustomModelStatus"].empty()) {
      customModelStatus = make_shared<long>(boost::any_cast<long>(m["CustomModelStatus"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
  }


  virtual ~GetSurveyResponseBodySurveyAsrCustomModel() = default;
};
class GetSurveyResponseBodySurveyFlow : public Darabonba::Model {
public:
  shared_ptr<bool> isPublished{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> flowId{};

  GetSurveyResponseBodySurveyFlow() {}

  explicit GetSurveyResponseBodySurveyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPublished) {
      res["IsPublished"] = boost::any(*isPublished);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPublished") != m.end() && !m["IsPublished"].empty()) {
      isPublished = make_shared<bool>(boost::any_cast<bool>(m["IsPublished"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~GetSurveyResponseBodySurveyFlow() = default;
};
class GetSurveyResponseBodySurvey : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestions{};
  shared_ptr<long> round{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> description{};
  shared_ptr<string> hotWords{};
  shared_ptr<GetSurveyResponseBodySurveyAsrCustomModel> asrCustomModel{};
  shared_ptr<GetSurveyResponseBodySurveyFlow> flow{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> scenarioUuid{};
  shared_ptr<string> id{};

  GetSurveyResponseBodySurvey() {}

  explicit GetSurveyResponseBodySurvey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotWords) {
      res["HotWords"] = boost::any(*hotWords);
    }
    if (asrCustomModel) {
      res["AsrCustomModel"] = asrCustomModel ? boost::any(asrCustomModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scenarioUuid) {
      res["ScenarioUuid"] = boost::any(*scenarioUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotWords") != m.end() && !m["HotWords"].empty()) {
      hotWords = make_shared<string>(boost::any_cast<string>(m["HotWords"]));
    }
    if (m.find("AsrCustomModel") != m.end() && !m["AsrCustomModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrCustomModel"].type()) {
        GetSurveyResponseBodySurveyAsrCustomModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrCustomModel"]));
        asrCustomModel = make_shared<GetSurveyResponseBodySurveyAsrCustomModel>(model1);
      }
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        GetSurveyResponseBodySurveyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<GetSurveyResponseBodySurveyFlow>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScenarioUuid") != m.end() && !m["ScenarioUuid"].empty()) {
      scenarioUuid = make_shared<string>(boost::any_cast<string>(m["ScenarioUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetSurveyResponseBodySurvey() = default;
};
class GetSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSurveyResponseBodySurvey> survey{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetSurveyResponseBody() {}

  explicit GetSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (survey) {
      res["Survey"] = survey ? boost::any(survey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Survey") != m.end() && !m["Survey"].empty()) {
      if (typeid(map<string, boost::any>) == m["Survey"].type()) {
        GetSurveyResponseBodySurvey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Survey"]));
        survey = make_shared<GetSurveyResponseBodySurvey>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSurveyResponseBody() = default;
};
class GetSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSurveyResponseBody> body{};

  GetSurveyResponse() {}

  explicit GetSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~GetSurveyResponse() = default;
};
class GetTaskListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  GetTaskListRequest() {}

  explicit GetTaskListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~GetTaskListRequest() = default;
};
class GetTaskListResponseBodyTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  GetTaskListResponseBodyTasksContact() {}

  explicit GetTaskListResponseBodyTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~GetTaskListResponseBodyTasksContact() = default;
};
class GetTaskListResponseBodyTasksConversationSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};

  GetTaskListResponseBodyTasksConversationSummary() {}

  explicit GetTaskListResponseBodyTasksConversationSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~GetTaskListResponseBodyTasksConversationSummary() = default;
};
class GetTaskListResponseBodyTasksConversation : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskListResponseBodyTasksConversationSummary>> summary{};
  shared_ptr<string> speaker{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> script{};

  GetTaskListResponseBodyTasksConversation() {}

  explicit GetTaskListResponseBodyTasksConversation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (speaker) {
      res["Speaker"] = boost::any(*speaker);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<GetTaskListResponseBodyTasksConversationSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskListResponseBodyTasksConversationSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<GetTaskListResponseBodyTasksConversationSummary>>(expect1);
      }
    }
    if (m.find("Speaker") != m.end() && !m["Speaker"].empty()) {
      speaker = make_shared<string>(boost::any_cast<string>(m["Speaker"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
  }


  virtual ~GetTaskListResponseBodyTasksConversation() = default;
};
class GetTaskListResponseBodyTasks : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> actualTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> scenarioId{};
  shared_ptr<GetTaskListResponseBodyTasksContact> contact{};
  shared_ptr<string> jobId{};
  shared_ptr<string> callId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> brief{};
  shared_ptr<long> duration{};
  shared_ptr<string> taskId{};
  shared_ptr<vector<GetTaskListResponseBodyTasksConversation>> conversation{};

  GetTaskListResponseBodyTasks() {}

  explicit GetTaskListResponseBodyTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversation) {
      vector<boost::any> temp1;
      for(auto item1:*conversation){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conversation"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        GetTaskListResponseBodyTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<GetTaskListResponseBodyTasksContact>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Conversation") != m.end() && !m["Conversation"].empty()) {
      if (typeid(vector<boost::any>) == m["Conversation"].type()) {
        vector<GetTaskListResponseBodyTasksConversation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conversation"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskListResponseBodyTasksConversation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversation = make_shared<vector<GetTaskListResponseBodyTasksConversation>>(expect1);
      }
    }
  }


  virtual ~GetTaskListResponseBodyTasks() = default;
};
class GetTaskListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetTaskListResponseBodyTasks>> tasks{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetTaskListResponseBody() {}

  explicit GetTaskListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<GetTaskListResponseBodyTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTaskListResponseBodyTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<GetTaskListResponseBodyTasks>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTaskListResponseBody() = default;
};
class GetTaskListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetTaskListResponseBody> body{};

  GetTaskListResponse() {}

  explicit GetTaskListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskListResponse() = default;
};
class GetTURNCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userName{};

  GetTURNCredentialsRequest() {}

  explicit GetTURNCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~GetTURNCredentialsRequest() = default;
};
class GetTURNCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<string> username{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> password{};

  GetTURNCredentialsResponseBody() {}

  explicit GetTURNCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~GetTURNCredentialsResponseBody() = default;
};
class GetTURNCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetTURNCredentialsResponseBody> body{};

  GetTURNCredentialsResponse() {}

  explicit GetTURNCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTURNCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTURNCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTURNCredentialsResponse() = default;
};
class GetTURNServerListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetTURNServerListRequest() {}

  explicit GetTURNServerListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetTURNServerListRequest() = default;
};
class GetTURNServerListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<string> turnServerListConfig{};
  shared_ptr<bool> success{};

  GetTURNServerListResponseBody() {}

  explicit GetTURNServerListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (turnServerListConfig) {
      res["TurnServerListConfig"] = boost::any(*turnServerListConfig);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("TurnServerListConfig") != m.end() && !m["TurnServerListConfig"].empty()) {
      turnServerListConfig = make_shared<string>(boost::any_cast<string>(m["TurnServerListConfig"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTURNServerListResponseBody() = default;
};
class GetTURNServerListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetTURNServerListResponseBody> body{};

  GetTURNServerListResponse() {}

  explicit GetTURNServerListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTURNServerListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTURNServerListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTURNServerListResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyUserSkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  GetUserResponseBodyUserSkillLevelsSkillLevelSkill() {}

  explicit GetUserResponseBodyUserSkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~GetUserResponseBodyUserSkillLevelsSkillLevelSkill() = default;
};
class GetUserResponseBodyUserSkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<GetUserResponseBodyUserSkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  GetUserResponseBodyUserSkillLevelsSkillLevel() {}

  explicit GetUserResponseBodyUserSkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        GetUserResponseBodyUserSkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<GetUserResponseBodyUserSkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~GetUserResponseBodyUserSkillLevelsSkillLevel() = default;
};
class GetUserResponseBodyUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<GetUserResponseBodyUserSkillLevelsSkillLevel>> skillLevel{};

  GetUserResponseBodyUserSkillLevels() {}

  explicit GetUserResponseBodyUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<GetUserResponseBodyUserSkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUserSkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<GetUserResponseBodyUserSkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~GetUserResponseBodyUserSkillLevels() = default;
};
class GetUserResponseBodyUserRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  GetUserResponseBodyUserRolesRole() {}

  explicit GetUserResponseBodyUserRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~GetUserResponseBodyUserRolesRole() = default;
};
class GetUserResponseBodyUserRoles : public Darabonba::Model {
public:
  shared_ptr<vector<GetUserResponseBodyUserRolesRole>> role{};

  GetUserResponseBodyUserRoles() {}

  explicit GetUserResponseBodyUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<GetUserResponseBodyUserRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUserRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<GetUserResponseBodyUserRolesRole>>(expect1);
      }
    }
  }


  virtual ~GetUserResponseBodyUserRoles() = default;
};
class GetUserResponseBodyUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  GetUserResponseBodyUserDetail() {}

  explicit GetUserResponseBodyUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~GetUserResponseBodyUserDetail() = default;
};
class GetUserResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<GetUserResponseBodyUserSkillLevels> skillLevels{};
  shared_ptr<string> userId{};
  shared_ptr<GetUserResponseBodyUserRoles> roles{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<GetUserResponseBodyUserDetail> detail{};

  GetUserResponseBodyUser() {}

  explicit GetUserResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        GetUserResponseBodyUserSkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<GetUserResponseBodyUserSkillLevels>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        GetUserResponseBodyUserRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<GetUserResponseBodyUserRoles>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        GetUserResponseBodyUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<GetUserResponseBodyUserDetail>(model1);
      }
    }
  }


  virtual ~GetUserResponseBodyUser() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetUserResponseBodyUser> user{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserResponseBodyUser>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetUserByExtensionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> extension{};

  GetUserByExtensionRequest() {}

  explicit GetUserByExtensionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
  }


  virtual ~GetUserByExtensionRequest() = default;
};
class GetUserByExtensionResponseBodyUserSkillLevelsSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  GetUserByExtensionResponseBodyUserSkillLevelsSkill() {}

  explicit GetUserByExtensionResponseBodyUserSkillLevelsSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~GetUserByExtensionResponseBodyUserSkillLevelsSkill() = default;
};
class GetUserByExtensionResponseBodyUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<GetUserByExtensionResponseBodyUserSkillLevelsSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  GetUserByExtensionResponseBodyUserSkillLevels() {}

  explicit GetUserByExtensionResponseBodyUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        GetUserByExtensionResponseBodyUserSkillLevelsSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<GetUserByExtensionResponseBodyUserSkillLevelsSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~GetUserByExtensionResponseBodyUserSkillLevels() = default;
};
class GetUserByExtensionResponseBodyUserRoles : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  GetUserByExtensionResponseBodyUserRoles() {}

  explicit GetUserByExtensionResponseBodyUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~GetUserByExtensionResponseBodyUserRoles() = default;
};
class GetUserByExtensionResponseBodyUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> extension{};
  shared_ptr<string> loginName{};
  shared_ptr<string> email{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  GetUserByExtensionResponseBodyUserDetail() {}

  explicit GetUserByExtensionResponseBodyUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~GetUserByExtensionResponseBodyUserDetail() = default;
};
class GetUserByExtensionResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<vector<GetUserByExtensionResponseBodyUserSkillLevels>> skillLevels{};
  shared_ptr<string> userId{};
  shared_ptr<vector<GetUserByExtensionResponseBodyUserRoles>> roles{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<GetUserByExtensionResponseBodyUserDetail> detail{};

  GetUserByExtensionResponseBodyUser() {}

  explicit GetUserByExtensionResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevels"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevels"].type()) {
        vector<GetUserByExtensionResponseBodyUserSkillLevels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserByExtensionResponseBodyUserSkillLevels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevels = make_shared<vector<GetUserByExtensionResponseBodyUserSkillLevels>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<GetUserByExtensionResponseBodyUserRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserByExtensionResponseBodyUserRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<GetUserByExtensionResponseBodyUserRoles>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        GetUserByExtensionResponseBodyUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<GetUserByExtensionResponseBodyUserDetail>(model1);
      }
    }
  }


  virtual ~GetUserByExtensionResponseBodyUser() = default;
};
class GetUserByExtensionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetUserByExtensionResponseBodyUser> user{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  GetUserByExtensionResponseBody() {}

  explicit GetUserByExtensionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserByExtensionResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserByExtensionResponseBodyUser>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetUserByExtensionResponseBody() = default;
};
class GetUserByExtensionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetUserByExtensionResponseBody> body{};

  GetUserByExtensionResponse() {}

  explicit GetUserByExtensionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserByExtensionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserByExtensionResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserByExtensionResponse() = default;
};
class InflightTaskTimeoutRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};
  shared_ptr<long> instanceOwnerId{};

  InflightTaskTimeoutRequest() {}

  explicit InflightTaskTimeoutRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
  }


  virtual ~InflightTaskTimeoutRequest() = default;
};
class InflightTaskTimeoutResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  InflightTaskTimeoutResponseBody() {}

  explicit InflightTaskTimeoutResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InflightTaskTimeoutResponseBody() = default;
};
class InflightTaskTimeoutResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InflightTaskTimeoutResponseBody> body{};

  InflightTaskTimeoutResponse() {}

  explicit InflightTaskTimeoutResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InflightTaskTimeoutResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InflightTaskTimeoutResponseBody>(model1);
      }
    }
  }


  virtual ~InflightTaskTimeoutResponse() = default;
};
class LaunchAppraiseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> acid{};

  LaunchAppraiseRequest() {}

  explicit LaunchAppraiseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
  }


  virtual ~LaunchAppraiseRequest() = default;
};
class LaunchAppraiseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  LaunchAppraiseResponseBody() {}

  explicit LaunchAppraiseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~LaunchAppraiseResponseBody() = default;
};
class LaunchAppraiseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LaunchAppraiseResponseBody> body{};

  LaunchAppraiseResponse() {}

  explicit LaunchAppraiseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchAppraiseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchAppraiseResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchAppraiseResponse() = default;
};
class LaunchShortMessageAppraiseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> acid{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> contactType{};
  shared_ptr<string> phoneNumbers{};

  LaunchShortMessageAppraiseRequest() {}

  explicit LaunchShortMessageAppraiseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<long>(boost::any_cast<long>(m["ContactType"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      phoneNumbers = make_shared<string>(boost::any_cast<string>(m["PhoneNumbers"]));
    }
  }


  virtual ~LaunchShortMessageAppraiseRequest() = default;
};
class LaunchShortMessageAppraiseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  LaunchShortMessageAppraiseResponseBody() {}

  explicit LaunchShortMessageAppraiseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~LaunchShortMessageAppraiseResponseBody() = default;
};
class LaunchShortMessageAppraiseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<LaunchShortMessageAppraiseResponseBody> body{};

  LaunchShortMessageAppraiseResponse() {}

  explicit LaunchShortMessageAppraiseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchShortMessageAppraiseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchShortMessageAppraiseResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchShortMessageAppraiseResponse() = default;
};
class ListAgentDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramIds{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};

  ListAgentDevicesRequest() {}

  explicit ListAgentDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIds) {
      res["RamIds"] = boost::any(*ramIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIds") != m.end() && !m["RamIds"].empty()) {
      ramIds = make_shared<string>(boost::any_cast<string>(m["RamIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
  }


  virtual ~ListAgentDevicesRequest() = default;
};
class ListAgentDevicesResponseBodyAgentDeviceListAgentDevice : public Darabonba::Model {
public:
  shared_ptr<long> loginTime{};
  shared_ptr<string> clientPort{};
  shared_ptr<string> remark{};
  shared_ptr<string> browserVersion{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> isLogin{};
  shared_ptr<long> ramId{};

  ListAgentDevicesResponseBodyAgentDeviceListAgentDevice() {}

  explicit ListAgentDevicesResponseBodyAgentDeviceListAgentDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginTime) {
      res["LoginTime"] = boost::any(*loginTime);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (browserVersion) {
      res["BrowserVersion"] = boost::any(*browserVersion);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isLogin) {
      res["IsLogin"] = boost::any(*isLogin);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginTime") != m.end() && !m["LoginTime"].empty()) {
      loginTime = make_shared<long>(boost::any_cast<long>(m["LoginTime"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<string>(boost::any_cast<string>(m["ClientPort"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("BrowserVersion") != m.end() && !m["BrowserVersion"].empty()) {
      browserVersion = make_shared<string>(boost::any_cast<string>(m["BrowserVersion"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsLogin") != m.end() && !m["IsLogin"].empty()) {
      isLogin = make_shared<long>(boost::any_cast<long>(m["IsLogin"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
  }


  virtual ~ListAgentDevicesResponseBodyAgentDeviceListAgentDevice() = default;
};
class ListAgentDevicesResponseBodyAgentDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentDevicesResponseBodyAgentDeviceListAgentDevice>> agentDevice{};

  ListAgentDevicesResponseBodyAgentDeviceList() {}

  explicit ListAgentDevicesResponseBodyAgentDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentDevice) {
      vector<boost::any> temp1;
      for(auto item1:*agentDevice){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentDevice"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentDevice") != m.end() && !m["AgentDevice"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentDevice"].type()) {
        vector<ListAgentDevicesResponseBodyAgentDeviceListAgentDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentDevice"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentDevicesResponseBodyAgentDeviceListAgentDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentDevice = make_shared<vector<ListAgentDevicesResponseBodyAgentDeviceListAgentDevice>>(expect1);
      }
    }
  }


  virtual ~ListAgentDevicesResponseBodyAgentDeviceList() = default;
};
class ListAgentDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<ListAgentDevicesResponseBodyAgentDeviceList> agentDeviceList{};

  ListAgentDevicesResponseBody() {}

  explicit ListAgentDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (agentDeviceList) {
      res["AgentDeviceList"] = agentDeviceList ? boost::any(agentDeviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("AgentDeviceList") != m.end() && !m["AgentDeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentDeviceList"].type()) {
        ListAgentDevicesResponseBodyAgentDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentDeviceList"]));
        agentDeviceList = make_shared<ListAgentDevicesResponseBodyAgentDeviceList>(model1);
      }
    }
  }


  virtual ~ListAgentDevicesResponseBody() = default;
};
class ListAgentDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentDevicesResponseBody> body{};

  ListAgentDevicesResponse() {}

  explicit ListAgentDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentDevicesResponse() = default;
};
class ListAgentEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};
  shared_ptr<vector<string>> ramId{};
  shared_ptr<vector<string>> event{};

  ListAgentEventsRequest() {}

  explicit ListAgentEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RamId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RamId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ramId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Event"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Event"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      event = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAgentEventsRequest() = default;
};
class ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};

  ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup() {}

  explicit ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup() = default;
};
class ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup>> skillGroup{};

  ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds() {}

  explicit ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroup) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroup"].type()) {
        vector<ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroup = make_shared<vector<ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIdsSkillGroup>>(expect1);
      }
    }
  }


  virtual ~ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds() = default;
};
class ListAgentEventsResponseBodyAgentEventListAgentEvent : public Darabonba::Model {
public:
  shared_ptr<long> eventTime{};
  shared_ptr<string> loginName{};
  shared_ptr<string> event{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ramId{};
  shared_ptr<ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds> skillGroupIds{};

  ListAgentEventsResponseBodyAgentEventListAgentEvent() {}

  explicit ListAgentEventsResponseBodyAgentEventListAgentEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = skillGroupIds ? boost::any(skillGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillGroupIds"].type()) {
        ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillGroupIds"]));
        skillGroupIds = make_shared<ListAgentEventsResponseBodyAgentEventListAgentEventSkillGroupIds>(model1);
      }
    }
  }


  virtual ~ListAgentEventsResponseBodyAgentEventListAgentEvent() = default;
};
class ListAgentEventsResponseBodyAgentEventList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentEventsResponseBodyAgentEventListAgentEvent>> agentEvent{};

  ListAgentEventsResponseBodyAgentEventList() {}

  explicit ListAgentEventsResponseBodyAgentEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentEvent) {
      vector<boost::any> temp1;
      for(auto item1:*agentEvent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentEvent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentEvent") != m.end() && !m["AgentEvent"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentEvent"].type()) {
        vector<ListAgentEventsResponseBodyAgentEventListAgentEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentEvent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentEventsResponseBodyAgentEventListAgentEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentEvent = make_shared<vector<ListAgentEventsResponseBodyAgentEventListAgentEvent>>(expect1);
      }
    }
  }


  virtual ~ListAgentEventsResponseBodyAgentEventList() = default;
};
class ListAgentEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAgentEventsResponseBodyAgentEventList> agentEventList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListAgentEventsResponseBody() {}

  explicit ListAgentEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (agentEventList) {
      res["AgentEventList"] = agentEventList ? boost::any(agentEventList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AgentEventList") != m.end() && !m["AgentEventList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentEventList"].type()) {
        ListAgentEventsResponseBodyAgentEventList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentEventList"]));
        agentEventList = make_shared<ListAgentEventsResponseBodyAgentEventList>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentEventsResponseBody() = default;
};
class ListAgentEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentEventsResponseBody> body{};

  ListAgentEventsResponse() {}

  explicit ListAgentEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentEventsResponse() = default;
};
class ListAgentStateLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> ramId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAgentStateLogsRequest() {}

  explicit ListAgentStateLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAgentStateLogsRequest() = default;
};
class ListAgentStateLogsResponseBodyAgentStateLogPageList : public Darabonba::Model {
public:
  shared_ptr<string> stateCode{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> connectId{};
  shared_ptr<long> stateTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ramId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> counterParty{};

  ListAgentStateLogsResponseBodyAgentStateLogPageList() {}

  explicit ListAgentStateLogsResponseBodyAgentStateLogPageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stateCode) {
      res["StateCode"] = boost::any(*stateCode);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (connectId) {
      res["ConnectId"] = boost::any(*connectId);
    }
    if (stateTime) {
      res["StateTime"] = boost::any(*stateTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (counterParty) {
      res["CounterParty"] = boost::any(*counterParty);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StateCode") != m.end() && !m["StateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["StateCode"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ConnectId") != m.end() && !m["ConnectId"].empty()) {
      connectId = make_shared<string>(boost::any_cast<string>(m["ConnectId"]));
    }
    if (m.find("StateTime") != m.end() && !m["StateTime"].empty()) {
      stateTime = make_shared<long>(boost::any_cast<long>(m["StateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("CounterParty") != m.end() && !m["CounterParty"].empty()) {
      counterParty = make_shared<string>(boost::any_cast<string>(m["CounterParty"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBodyAgentStateLogPageList() = default;
};
class ListAgentStateLogsResponseBodyAgentStateLogPage : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentStateLogsResponseBodyAgentStateLogPageList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentStateLogsResponseBodyAgentStateLogPage() {}

  explicit ListAgentStateLogsResponseBodyAgentStateLogPage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAgentStateLogsResponseBodyAgentStateLogPageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStateLogsResponseBodyAgentStateLogPageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAgentStateLogsResponseBodyAgentStateLogPageList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBodyAgentStateLogPage() = default;
};
class ListAgentStateLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<ListAgentStateLogsResponseBodyAgentStateLogPage> agentStateLogPage{};

  ListAgentStateLogsResponseBody() {}

  explicit ListAgentStateLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (agentStateLogPage) {
      res["AgentStateLogPage"] = agentStateLogPage ? boost::any(agentStateLogPage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("AgentStateLogPage") != m.end() && !m["AgentStateLogPage"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentStateLogPage"].type()) {
        ListAgentStateLogsResponseBodyAgentStateLogPage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentStateLogPage"]));
        agentStateLogPage = make_shared<ListAgentStateLogsResponseBodyAgentStateLogPage>(model1);
      }
    }
  }


  virtual ~ListAgentStateLogsResponseBody() = default;
};
class ListAgentStateLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentStateLogsResponseBody> body{};

  ListAgentStateLogsResponse() {}

  explicit ListAgentStateLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStateLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStateLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStateLogsResponse() = default;
};
class ListAgentStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> state{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAgentStatesRequest() {}

  explicit ListAgentStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAgentStatesRequest() = default;
};
class ListAgentStatesResponseBodyDataListRealTimeAgentState : public Darabonba::Model {
public:
  shared_ptr<string> loginName{};
  shared_ptr<string> dn{};
  shared_ptr<string> stateDuration{};
  shared_ptr<string> state{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> instanceId{};

  ListAgentStatesResponseBodyDataListRealTimeAgentState() {}

  explicit ListAgentStatesResponseBodyDataListRealTimeAgentState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (dn) {
      res["Dn"] = boost::any(*dn);
    }
    if (stateDuration) {
      res["StateDuration"] = boost::any(*stateDuration);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Dn") != m.end() && !m["Dn"].empty()) {
      dn = make_shared<string>(boost::any_cast<string>(m["Dn"]));
    }
    if (m.find("StateDuration") != m.end() && !m["StateDuration"].empty()) {
      stateDuration = make_shared<string>(boost::any_cast<string>(m["StateDuration"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyDataListRealTimeAgentState() = default;
};
class ListAgentStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentStatesResponseBodyDataListRealTimeAgentState>> realTimeAgentState{};

  ListAgentStatesResponseBodyDataList() {}

  explicit ListAgentStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeAgentState) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeAgentState){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeAgentState"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeAgentState") != m.end() && !m["RealTimeAgentState"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeAgentState"].type()) {
        vector<ListAgentStatesResponseBodyDataListRealTimeAgentState> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeAgentState"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStatesResponseBodyDataListRealTimeAgentState model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeAgentState = make_shared<vector<ListAgentStatesResponseBodyDataListRealTimeAgentState>>(expect1);
      }
    }
  }


  virtual ~ListAgentStatesResponseBodyDataList() = default;
};
class ListAgentStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListAgentStatesResponseBodyDataList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentStatesResponseBodyData() {}

  explicit ListAgentStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListAgentStatesResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListAgentStatesResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyData() = default;
};
class ListAgentStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListAgentStatesResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListAgentStatesResponseBody() {}

  explicit ListAgentStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAgentStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAgentStatesResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentStatesResponseBody() = default;
};
class ListAgentStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentStatesResponseBody> body{};

  ListAgentStatesResponse() {}

  explicit ListAgentStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStatesResponse() = default;
};
class ListAgentSummaryReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAgentSummaryReportsRequest() {}

  explicit ListAgentSummaryReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAgentSummaryReportsRequest() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<string> lastLogOutTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<string> firstLogInTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> oneTransferCalls{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (lastLogOutTime) {
      res["LastLogOutTime"] = boost::any(*lastLogOutTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (firstLogInTime) {
      res["FirstLogInTime"] = boost::any(*firstLogInTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (oneTransferCalls) {
      res["OneTransferCalls"] = boost::any(*oneTransferCalls);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("LastLogOutTime") != m.end() && !m["LastLogOutTime"].empty()) {
      lastLogOutTime = make_shared<string>(boost::any_cast<string>(m["LastLogOutTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("FirstLogInTime") != m.end() && !m["FirstLogInTime"].empty()) {
      firstLogInTime = make_shared<string>(boost::any_cast<string>(m["FirstLogInTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("OneTransferCalls") != m.end() && !m["OneTransferCalls"].empty()) {
      oneTransferCalls = make_shared<long>(boost::any_cast<long>(m["OneTransferCalls"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsHandled{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxRingTime{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<string> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<string>(boost::any_cast<string>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall> overall{};
  shared_ptr<string> loginName{};
  shared_ptr<string> agentId{};
  shared_ptr<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound> inbound{};
  shared_ptr<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound> outbound{};
  shared_ptr<string> agentName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> skillGroupIds{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall>(model1);
      }
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound>(model1);
      }
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport>> agentSummaryReport{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*agentSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentSummaryReport") != m.end() && !m["AgentSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentSummaryReport"].type()) {
        vector<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentSummaryReport = make_shared<vector<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportListAgentSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList() = default;
};
class ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport() {}

  explicit ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport() = default;
};
class ListAgentSummaryReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport> pagedAgentSummaryReport{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListAgentSummaryReportsResponseBody() {}

  explicit ListAgentSummaryReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pagedAgentSummaryReport) {
      res["PagedAgentSummaryReport"] = pagedAgentSummaryReport ? boost::any(pagedAgentSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PagedAgentSummaryReport") != m.end() && !m["PagedAgentSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedAgentSummaryReport"].type()) {
        ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedAgentSummaryReport"]));
        pagedAgentSummaryReport = make_shared<ListAgentSummaryReportsResponseBodyPagedAgentSummaryReport>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentSummaryReportsResponseBody() = default;
};
class ListAgentSummaryReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentSummaryReportsResponseBody> body{};

  ListAgentSummaryReportsResponse() {}

  explicit ListAgentSummaryReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentSummaryReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentSummaryReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsResponse() = default;
};
class ListAgentSummaryReportsByIntervalRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAgentSummaryReportsByIntervalRequest() {}

  explicit ListAgentSummaryReportsByIntervalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalRequest() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<string> lastLogOutTime{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<string> firstLogInTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> oneTransferCalls{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (lastLogOutTime) {
      res["LastLogOutTime"] = boost::any(*lastLogOutTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (firstLogInTime) {
      res["FirstLogInTime"] = boost::any(*firstLogInTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (oneTransferCalls) {
      res["OneTransferCalls"] = boost::any(*oneTransferCalls);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("LastLogOutTime") != m.end() && !m["LastLogOutTime"].empty()) {
      lastLogOutTime = make_shared<string>(boost::any_cast<string>(m["LastLogOutTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("FirstLogInTime") != m.end() && !m["FirstLogInTime"].empty()) {
      firstLogInTime = make_shared<string>(boost::any_cast<string>(m["FirstLogInTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("OneTransferCalls") != m.end() && !m["OneTransferCalls"].empty()) {
      oneTransferCalls = make_shared<long>(boost::any_cast<long>(m["OneTransferCalls"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsHandled{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxRingTime{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall> overall{};
  shared_ptr<string> loginName{};
  shared_ptr<string> agentId{};
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound> inbound{};
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound> outbound{};
  shared_ptr<string> agentName{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOverall>(model1);
      }
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReportOutbound>(model1);
      }
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport>> agentSummaryReport{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*agentSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentSummaryReport") != m.end() && !m["AgentSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentSummaryReport"].type()) {
        vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentSummaryReport = make_shared<vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalListAgentSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList> intervalList{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (intervalList) {
      res["IntervalList"] = intervalList ? boost::any(intervalList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("IntervalList") != m.end() && !m["IntervalList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntervalList"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntervalList"]));
        intervalList = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReportIntervalList>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport>> agentTimeIntervalReport{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentTimeIntervalReport) {
      vector<boost::any> temp1;
      for(auto item1:*agentTimeIntervalReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentTimeIntervalReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentTimeIntervalReport") != m.end() && !m["AgentTimeIntervalReport"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentTimeIntervalReport"].type()) {
        vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentTimeIntervalReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentTimeIntervalReport = make_shared<vector<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportListAgentTimeIntervalReport>>(expect1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList() = default;
};
class ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport() {}

  explicit ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport() = default;
};
class ListAgentSummaryReportsByIntervalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport> pagedAgentSummaryReport{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListAgentSummaryReportsByIntervalResponseBody() {}

  explicit ListAgentSummaryReportsByIntervalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pagedAgentSummaryReport) {
      res["PagedAgentSummaryReport"] = pagedAgentSummaryReport ? boost::any(pagedAgentSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PagedAgentSummaryReport") != m.end() && !m["PagedAgentSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedAgentSummaryReport"].type()) {
        ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedAgentSummaryReport"]));
        pagedAgentSummaryReport = make_shared<ListAgentSummaryReportsByIntervalResponseBodyPagedAgentSummaryReport>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponseBody() = default;
};
class ListAgentSummaryReportsByIntervalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentSummaryReportsByIntervalResponseBody> body{};

  ListAgentSummaryReportsByIntervalResponse() {}

  explicit ListAgentSummaryReportsByIntervalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentSummaryReportsByIntervalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentSummaryReportsByIntervalResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsByIntervalResponse() = default;
};
class ListAgentSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> agentIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAgentSummaryReportsSinceMidnightRequest() {}

  explicit ListAgentSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightRequest() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> oneTransferCalls{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (oneTransferCalls) {
      res["OneTransferCalls"] = boost::any(*oneTransferCalls);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("OneTransferCalls") != m.end() && !m["OneTransferCalls"].empty()) {
      oneTransferCalls = make_shared<long>(boost::any_cast<long>(m["OneTransferCalls"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsHandled{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxRingTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<string> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<string>(boost::any_cast<string>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall> overall{};
  shared_ptr<string> loginName{};
  shared_ptr<string> agentId{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound> inbound{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound> outbound{};
  shared_ptr<string> agentName{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOverall>(model1);
      }
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReportOutbound>(model1);
      }
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport>> agentSummaryReport{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*agentSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentSummaryReport") != m.end() && !m["AgentSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentSummaryReport"].type()) {
        vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentSummaryReport = make_shared<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListAgentSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport> pagedAgentSummaryReport{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListAgentSummaryReportsSinceMidnightResponseBody() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pagedAgentSummaryReport) {
      res["PagedAgentSummaryReport"] = pagedAgentSummaryReport ? boost::any(pagedAgentSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PagedAgentSummaryReport") != m.end() && !m["PagedAgentSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedAgentSummaryReport"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedAgentSummaryReport"]));
        pagedAgentSummaryReport = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBody() = default;
};
class ListAgentSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBody> body{};

  ListAgentSummaryReportsSinceMidnightResponse() {}

  explicit ListAgentSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponse() = default;
};
class ListBasicStatisticsReportSubItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> title{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListBasicStatisticsReportSubItemsRequest() {}

  explicit ListBasicStatisticsReportSubItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsRequest() = default;
};
class ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow() {}

  explicit ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow() = default;
};
class ListBasicStatisticsReportSubItemsResponseBodySubItemsList : public Darabonba::Model {
public:
  shared_ptr<string> basicStatisticsReportSubItemName{};
  shared_ptr<string> value{};
  shared_ptr<long> percentage{};
  shared_ptr<long> count{};
  shared_ptr<vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow>> row{};

  ListBasicStatisticsReportSubItemsResponseBodySubItemsList() {}

  explicit ListBasicStatisticsReportSubItemsResponseBodySubItemsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basicStatisticsReportSubItemName) {
      res["BasicStatisticsReportSubItemName"] = boost::any(*basicStatisticsReportSubItemName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (row) {
      vector<boost::any> temp1;
      for(auto item1:*row){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Row"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasicStatisticsReportSubItemName") != m.end() && !m["BasicStatisticsReportSubItemName"].empty()) {
      basicStatisticsReportSubItemName = make_shared<string>(boost::any_cast<string>(m["BasicStatisticsReportSubItemName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Row") != m.end() && !m["Row"].empty()) {
      if (typeid(vector<boost::any>) == m["Row"].type()) {
        vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Row"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        row = make_shared<vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsListRow>>(expect1);
      }
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsResponseBodySubItemsList() = default;
};
class ListBasicStatisticsReportSubItemsResponseBodySubItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListBasicStatisticsReportSubItemsResponseBodySubItems() {}

  explicit ListBasicStatisticsReportSubItemsResponseBodySubItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicStatisticsReportSubItemsResponseBodySubItemsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListBasicStatisticsReportSubItemsResponseBodySubItemsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsResponseBodySubItems() = default;
};
class ListBasicStatisticsReportSubItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListBasicStatisticsReportSubItemsResponseBodySubItems> subItems{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListBasicStatisticsReportSubItemsResponseBody() {}

  explicit ListBasicStatisticsReportSubItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subItems) {
      res["SubItems"] = subItems ? boost::any(subItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubItems") != m.end() && !m["SubItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubItems"].type()) {
        ListBasicStatisticsReportSubItemsResponseBodySubItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubItems"]));
        subItems = make_shared<ListBasicStatisticsReportSubItemsResponseBodySubItems>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsResponseBody() = default;
};
class ListBasicStatisticsReportSubItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListBasicStatisticsReportSubItemsResponseBody> body{};

  ListBasicStatisticsReportSubItemsResponse() {}

  explicit ListBasicStatisticsReportSubItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBasicStatisticsReportSubItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBasicStatisticsReportSubItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBasicStatisticsReportSubItemsResponse() = default;
};
class ListCallDetailRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};
  shared_ptr<string> criteria{};
  shared_ptr<string> contactType{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<bool> withRecording{};
  shared_ptr<string> contactId{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListCallDetailRecordsRequest() {}

  explicit ListCallDetailRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (withRecording) {
      res["WithRecording"] = boost::any(*withRecording);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("WithRecording") != m.end() && !m["WithRecording"].empty()) {
      withRecording = make_shared<bool>(boost::any_cast<bool>(m["WithRecording"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCallDetailRecordsRequest() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording : public Darabonba::Model {
public:
  shared_ptr<long> startTime{};
  shared_ptr<string> contactId{};
  shared_ptr<string> qualityCheckTaskId{};
  shared_ptr<string> agentId{};
  shared_ptr<string> fileDescription{};
  shared_ptr<long> duration{};
  shared_ptr<string> agentName{};
  shared_ptr<string> fileName{};
  shared_ptr<string> qualityCheckTid{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (qualityCheckTaskId) {
      res["QualityCheckTaskId"] = boost::any(*qualityCheckTaskId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (qualityCheckTid) {
      res["QualityCheckTid"] = boost::any(*qualityCheckTid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("QualityCheckTaskId") != m.end() && !m["QualityCheckTaskId"].empty()) {
      qualityCheckTaskId = make_shared<string>(boost::any_cast<string>(m["QualityCheckTaskId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("QualityCheckTid") != m.end() && !m["QualityCheckTid"].empty()) {
      qualityCheckTid = make_shared<string>(boost::any_cast<string>(m["QualityCheckTid"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording>> recording{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recording) {
      vector<boost::any> temp1;
      for(auto item1:*recording){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recording"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      if (typeid(vector<boost::any>) == m["Recording"].type()) {
        vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recording"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recording = make_shared<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording>>(expect1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent : public Darabonba::Model {
public:
  shared_ptr<string> satisfaction{};
  shared_ptr<string> agentId{};
  shared_ptr<string> feedback{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<string>(boost::any_cast<string>(m["Satisfaction"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent>> callDetailAgent{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDetailAgent) {
      vector<boost::any> temp1;
      for(auto item1:*callDetailAgent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallDetailAgent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDetailAgent") != m.end() && !m["CallDetailAgent"].empty()) {
      if (typeid(vector<boost::any>) == m["CallDetailAgent"].type()) {
        vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallDetailAgent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callDetailAgent = make_shared<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent>>(expect1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord : public Darabonba::Model {
public:
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings> recordings{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> agentNames{};
  shared_ptr<long> satisfaction{};
  shared_ptr<long> startTime{};
  shared_ptr<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents> agents{};
  shared_ptr<string> satisfactionDesc{};
  shared_ptr<string> contactId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<long> duration{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> feedback{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (recordings) {
      res["Recordings"] = recordings ? boost::any(recordings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (agents) {
      res["Agents"] = agents ? boost::any(agents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (satisfactionDesc) {
      res["SatisfactionDesc"] = boost::any(*satisfactionDesc);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recordings"].type()) {
        ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recordings"]));
        recordings = make_shared<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings>(model1);
      }
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<long>(boost::any_cast<long>(m["Satisfaction"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Agents") != m.end() && !m["Agents"].empty()) {
      if (typeid(map<string, boost::any>) == m["Agents"].type()) {
        ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Agents"]));
        agents = make_shared<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents>(model1);
      }
    }
    if (m.find("SatisfactionDesc") != m.end() && !m["SatisfactionDesc"].empty()) {
      satisfactionDesc = make_shared<string>(boost::any_cast<string>(m["SatisfactionDesc"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecordsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord>> callDetailRecord{};

  ListCallDetailRecordsResponseBodyCallDetailRecordsList() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecordsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDetailRecord) {
      vector<boost::any> temp1;
      for(auto item1:*callDetailRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallDetailRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDetailRecord") != m.end() && !m["CallDetailRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["CallDetailRecord"].type()) {
        vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallDetailRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callDetailRecord = make_shared<vector<ListCallDetailRecordsResponseBodyCallDetailRecordsListCallDetailRecord>>(expect1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecordsList() = default;
};
class ListCallDetailRecordsResponseBodyCallDetailRecords : public Darabonba::Model {
public:
  shared_ptr<ListCallDetailRecordsResponseBodyCallDetailRecordsList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallDetailRecordsResponseBodyCallDetailRecords() {}

  explicit ListCallDetailRecordsResponseBodyCallDetailRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListCallDetailRecordsResponseBodyCallDetailRecordsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListCallDetailRecordsResponseBodyCallDetailRecordsList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyCallDetailRecords() = default;
};
class ListCallDetailRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListCallDetailRecordsResponseBodyCallDetailRecords> callDetailRecords{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListCallDetailRecordsResponseBody() {}

  explicit ListCallDetailRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (callDetailRecords) {
      res["CallDetailRecords"] = callDetailRecords ? boost::any(callDetailRecords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CallDetailRecords") != m.end() && !m["CallDetailRecords"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallDetailRecords"].type()) {
        ListCallDetailRecordsResponseBodyCallDetailRecords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallDetailRecords"]));
        callDetailRecords = make_shared<ListCallDetailRecordsResponseBodyCallDetailRecords>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBody() = default;
};
class ListCallDetailRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCallDetailRecordsResponseBody> body{};

  ListCallDetailRecordsResponse() {}

  explicit ListCallDetailRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallDetailRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallDetailRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponse() = default;
};
class ListCallEventDetailByContactIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactId{};

  ListCallEventDetailByContactIdRequest() {}

  explicit ListCallEventDetailByContactIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
  }


  virtual ~ListCallEventDetailByContactIdRequest() = default;
};
class ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData : public Darabonba::Model {
public:
  shared_ptr<string> hangUper{};
  shared_ptr<string> eventType{};
  shared_ptr<string> helper{};
  shared_ptr<string> skillGroup{};
  shared_ptr<string> satisfactionalResearch{};

  ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData() {}

  explicit ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hangUper) {
      res["HangUper"] = boost::any(*hangUper);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (helper) {
      res["Helper"] = boost::any(*helper);
    }
    if (skillGroup) {
      res["SkillGroup"] = boost::any(*skillGroup);
    }
    if (satisfactionalResearch) {
      res["SatisfactionalResearch"] = boost::any(*satisfactionalResearch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HangUper") != m.end() && !m["HangUper"].empty()) {
      hangUper = make_shared<string>(boost::any_cast<string>(m["HangUper"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Helper") != m.end() && !m["Helper"].empty()) {
      helper = make_shared<string>(boost::any_cast<string>(m["Helper"]));
    }
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      skillGroup = make_shared<string>(boost::any_cast<string>(m["SkillGroup"]));
    }
    if (m.find("SatisfactionalResearch") != m.end() && !m["SatisfactionalResearch"].empty()) {
      satisfactionalResearch = make_shared<string>(boost::any_cast<string>(m["SatisfactionalResearch"]));
    }
  }


  virtual ~ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData() = default;
};
class ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> callMode{};
  shared_ptr<ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData> detailData{};
  shared_ptr<string> event{};
  shared_ptr<string> timeStamp{};
  shared_ptr<string> agentName{};
  shared_ptr<long> duration{};

  ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail() {}

  explicit ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callMode) {
      res["CallMode"] = boost::any(*callMode);
    }
    if (detailData) {
      res["DetailData"] = detailData ? boost::any(detailData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallMode") != m.end() && !m["CallMode"].empty()) {
      callMode = make_shared<string>(boost::any_cast<string>(m["CallMode"]));
    }
    if (m.find("DetailData") != m.end() && !m["DetailData"].empty()) {
      if (typeid(map<string, boost::any>) == m["DetailData"].type()) {
        ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DetailData"]));
        detailData = make_shared<ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetailDetailData>(model1);
      }
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail() = default;
};
class ListCallEventDetailByContactIdResponseBodyDataEvents : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail>> callEventDetail{};

  ListCallEventDetailByContactIdResponseBodyDataEvents() {}

  explicit ListCallEventDetailByContactIdResponseBodyDataEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callEventDetail) {
      vector<boost::any> temp1;
      for(auto item1:*callEventDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallEventDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallEventDetail") != m.end() && !m["CallEventDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["CallEventDetail"].type()) {
        vector<ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallEventDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callEventDetail = make_shared<vector<ListCallEventDetailByContactIdResponseBodyDataEventsCallEventDetail>>(expect1);
      }
    }
  }


  virtual ~ListCallEventDetailByContactIdResponseBodyDataEvents() = default;
};
class ListCallEventDetailByContactIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> startTime{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> callType{};
  shared_ptr<string> releaseAgent{};
  shared_ptr<string> caller{};
  shared_ptr<string> callee{};
  shared_ptr<ListCallEventDetailByContactIdResponseBodyDataEvents> events{};
  shared_ptr<string> privacyNumber{};

  ListCallEventDetailByContactIdResponseBodyData() {}

  explicit ListCallEventDetailByContactIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (releaseAgent) {
      res["ReleaseAgent"] = boost::any(*releaseAgent);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (events) {
      res["Events"] = events ? boost::any(events->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privacyNumber) {
      res["PrivacyNumber"] = boost::any(*privacyNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ReleaseAgent") != m.end() && !m["ReleaseAgent"].empty()) {
      releaseAgent = make_shared<string>(boost::any_cast<string>(m["ReleaseAgent"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Events") != m.end() && !m["Events"].empty()) {
      if (typeid(map<string, boost::any>) == m["Events"].type()) {
        ListCallEventDetailByContactIdResponseBodyDataEvents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Events"]));
        events = make_shared<ListCallEventDetailByContactIdResponseBodyDataEvents>(model1);
      }
    }
    if (m.find("PrivacyNumber") != m.end() && !m["PrivacyNumber"].empty()) {
      privacyNumber = make_shared<string>(boost::any_cast<string>(m["PrivacyNumber"]));
    }
  }


  virtual ~ListCallEventDetailByContactIdResponseBodyData() = default;
};
class ListCallEventDetailByContactIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListCallEventDetailByContactIdResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListCallEventDetailByContactIdResponseBody() {}

  explicit ListCallEventDetailByContactIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallEventDetailByContactIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallEventDetailByContactIdResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCallEventDetailByContactIdResponseBody() = default;
};
class ListCallEventDetailByContactIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCallEventDetailByContactIdResponseBody> body{};

  ListCallEventDetailByContactIdResponse() {}

  explicit ListCallEventDetailByContactIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallEventDetailByContactIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallEventDetailByContactIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallEventDetailByContactIdResponse() = default;
};
class ListCallMeasureSummaryReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> intervalType{};

  ListCallMeasureSummaryReportsRequest() {}

  explicit ListCallMeasureSummaryReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (intervalType) {
      res["IntervalType"] = boost::any(*intervalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IntervalType") != m.end() && !m["IntervalType"].empty()) {
      intervalType = make_shared<string>(boost::any_cast<string>(m["IntervalType"]));
    }
  }


  virtual ~ListCallMeasureSummaryReportsRequest() = default;
};
class ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport : public Darabonba::Model {
public:
  shared_ptr<string> day{};
  shared_ptr<string> year{};
  shared_ptr<long> inboundDurationByMinute{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> outboundDurationByMinute{};
  shared_ptr<long> inboundCount{};
  shared_ptr<string> month{};

  ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport() {}

  explicit ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (day) {
      res["Day"] = boost::any(*day);
    }
    if (year) {
      res["Year"] = boost::any(*year);
    }
    if (inboundDurationByMinute) {
      res["InboundDurationByMinute"] = boost::any(*inboundDurationByMinute);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (outboundDurationByMinute) {
      res["OutboundDurationByMinute"] = boost::any(*outboundDurationByMinute);
    }
    if (inboundCount) {
      res["InboundCount"] = boost::any(*inboundCount);
    }
    if (month) {
      res["Month"] = boost::any(*month);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Day") != m.end() && !m["Day"].empty()) {
      day = make_shared<string>(boost::any_cast<string>(m["Day"]));
    }
    if (m.find("Year") != m.end() && !m["Year"].empty()) {
      year = make_shared<string>(boost::any_cast<string>(m["Year"]));
    }
    if (m.find("InboundDurationByMinute") != m.end() && !m["InboundDurationByMinute"].empty()) {
      inboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["InboundDurationByMinute"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("OutboundDurationByMinute") != m.end() && !m["OutboundDurationByMinute"].empty()) {
      outboundDurationByMinute = make_shared<long>(boost::any_cast<long>(m["OutboundDurationByMinute"]));
    }
    if (m.find("InboundCount") != m.end() && !m["InboundCount"].empty()) {
      inboundCount = make_shared<long>(boost::any_cast<long>(m["InboundCount"]));
    }
    if (m.find("Month") != m.end() && !m["Month"].empty()) {
      month = make_shared<string>(boost::any_cast<string>(m["Month"]));
    }
  }


  virtual ~ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport() = default;
};
class ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport>> callMeasureSummaryReport{};

  ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList() {}

  explicit ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callMeasureSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*callMeasureSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallMeasureSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallMeasureSummaryReport") != m.end() && !m["CallMeasureSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["CallMeasureSummaryReport"].type()) {
        vector<ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallMeasureSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callMeasureSummaryReport = make_shared<vector<ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportListCallMeasureSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList() = default;
};
class ListCallMeasureSummaryReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList> callMeasureSummaryReportList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListCallMeasureSummaryReportsResponseBody() {}

  explicit ListCallMeasureSummaryReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callMeasureSummaryReportList) {
      res["CallMeasureSummaryReportList"] = callMeasureSummaryReportList ? boost::any(callMeasureSummaryReportList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallMeasureSummaryReportList") != m.end() && !m["CallMeasureSummaryReportList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallMeasureSummaryReportList"].type()) {
        ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallMeasureSummaryReportList"]));
        callMeasureSummaryReportList = make_shared<ListCallMeasureSummaryReportsResponseBodyCallMeasureSummaryReportList>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCallMeasureSummaryReportsResponseBody() = default;
};
class ListCallMeasureSummaryReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCallMeasureSummaryReportsResponseBody> body{};

  ListCallMeasureSummaryReportsResponse() {}

  explicit ListCallMeasureSummaryReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallMeasureSummaryReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallMeasureSummaryReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallMeasureSummaryReportsResponse() = default;
};
class ListConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> configItem{};

  ListConfigRequest() {}

  explicit ListConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (configItem) {
      res["ConfigItem"] = boost::any(*configItem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ConfigItem") != m.end() && !m["ConfigItem"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConfigItem"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConfigItem"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      configItem = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConfigRequest() = default;
};
class ListConfigResponseBodyConfigItemsConfigItem : public Darabonba::Model {
public:
  shared_ptr<string> value{};
  shared_ptr<string> name{};

  ListConfigResponseBodyConfigItemsConfigItem() {}

  explicit ListConfigResponseBodyConfigItemsConfigItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListConfigResponseBodyConfigItemsConfigItem() = default;
};
class ListConfigResponseBodyConfigItems : public Darabonba::Model {
public:
  shared_ptr<vector<ListConfigResponseBodyConfigItemsConfigItem>> configItem{};

  ListConfigResponseBodyConfigItems() {}

  explicit ListConfigResponseBodyConfigItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItem) {
      vector<boost::any> temp1;
      for(auto item1:*configItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItem") != m.end() && !m["ConfigItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItem"].type()) {
        vector<ListConfigResponseBodyConfigItemsConfigItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigResponseBodyConfigItemsConfigItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItem = make_shared<vector<ListConfigResponseBodyConfigItemsConfigItem>>(expect1);
      }
    }
  }


  virtual ~ListConfigResponseBodyConfigItems() = default;
};
class ListConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListConfigResponseBodyConfigItems> configItems{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListConfigResponseBody() {}

  explicit ListConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItems) {
      res["ConfigItems"] = configItems ? boost::any(configItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItems") != m.end() && !m["ConfigItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConfigItems"].type()) {
        ListConfigResponseBodyConfigItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConfigItems"]));
        configItems = make_shared<ListConfigResponseBodyConfigItems>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListConfigResponseBody() = default;
};
class ListConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConfigResponseBody> body{};

  ListConfigResponse() {}

  explicit ListConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigResponse() = default;
};
class ListContactFlowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListContactFlowsRequest() {}

  explicit ListContactFlowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListContactFlowsRequest() = default;
};
class ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber() {}

  explicit ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber() = default;
};
class ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber>> phoneNumber{};

  ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers() {}

  explicit ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers() = default;
};
class ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> lockedBy{};
  shared_ptr<string> version{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> contactFlowVersionDescription{};
  shared_ptr<string> lastModifiedBy{};

  ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion() {}

  explicit ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (lockedBy) {
      res["LockedBy"] = boost::any(*lockedBy);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (contactFlowVersionDescription) {
      res["ContactFlowVersionDescription"] = boost::any(*contactFlowVersionDescription);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = boost::any(*lastModifiedBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("LockedBy") != m.end() && !m["LockedBy"].empty()) {
      lockedBy = make_shared<string>(boost::any_cast<string>(m["LockedBy"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("ContactFlowVersionDescription") != m.end() && !m["ContactFlowVersionDescription"].empty()) {
      contactFlowVersionDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionDescription"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      lastModifiedBy = make_shared<string>(boost::any_cast<string>(m["LastModifiedBy"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion() = default;
};
class ListContactFlowsResponseBodyContactFlowsContactFlowVersions : public Darabonba::Model {
public:
  shared_ptr<vector<ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion>> contactFlowVersion{};

  ListContactFlowsResponseBodyContactFlowsContactFlowVersions() {}

  explicit ListContactFlowsResponseBodyContactFlowsContactFlowVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowVersion) {
      vector<boost::any> temp1;
      for(auto item1:*contactFlowVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactFlowVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowVersion") != m.end() && !m["ContactFlowVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactFlowVersion"].type()) {
        vector<ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactFlowVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactFlowVersion = make_shared<vector<ListContactFlowsResponseBodyContactFlowsContactFlowVersionsContactFlowVersion>>(expect1);
      }
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlowsContactFlowVersions() = default;
};
class ListContactFlowsResponseBodyContactFlowsContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> type{};
  shared_ptr<ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers> phoneNumbers{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<ListContactFlowsResponseBodyContactFlowsContactFlowVersions> versions{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> appliedVersion{};

  ListContactFlowsResponseBodyContactFlowsContactFlow() {}

  explicit ListContactFlowsResponseBodyContactFlowsContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (versions) {
      res["Versions"] = versions ? boost::any(versions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (appliedVersion) {
      res["AppliedVersion"] = boost::any(*appliedVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<ListContactFlowsResponseBodyContactFlowsContactFlowPhoneNumbers>(model1);
      }
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Versions"].type()) {
        ListContactFlowsResponseBodyContactFlowsContactFlowVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Versions"]));
        versions = make_shared<ListContactFlowsResponseBodyContactFlowsContactFlowVersions>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      appliedVersion = make_shared<string>(boost::any_cast<string>(m["AppliedVersion"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlowsContactFlow() = default;
};
class ListContactFlowsResponseBodyContactFlows : public Darabonba::Model {
public:
  shared_ptr<vector<ListContactFlowsResponseBodyContactFlowsContactFlow>> contactFlow{};

  ListContactFlowsResponseBodyContactFlows() {}

  explicit ListContactFlowsResponseBodyContactFlows(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlow) {
      vector<boost::any> temp1;
      for(auto item1:*contactFlow){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactFlow"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactFlow"].type()) {
        vector<ListContactFlowsResponseBodyContactFlowsContactFlow> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactFlow"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListContactFlowsResponseBodyContactFlowsContactFlow model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactFlow = make_shared<vector<ListContactFlowsResponseBodyContactFlowsContactFlow>>(expect1);
      }
    }
  }


  virtual ~ListContactFlowsResponseBodyContactFlows() = default;
};
class ListContactFlowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListContactFlowsResponseBodyContactFlows> contactFlows{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListContactFlowsResponseBody() {}

  explicit ListContactFlowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (contactFlows) {
      res["ContactFlows"] = contactFlows ? boost::any(contactFlows->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ContactFlows") != m.end() && !m["ContactFlows"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlows"].type()) {
        ListContactFlowsResponseBodyContactFlows model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlows"]));
        contactFlows = make_shared<ListContactFlowsResponseBodyContactFlows>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListContactFlowsResponseBody() = default;
};
class ListContactFlowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListContactFlowsResponseBody> body{};

  ListContactFlowsResponse() {}

  explicit ListContactFlowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListContactFlowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListContactFlowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListContactFlowsResponse() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber>> phoneNumber{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser : public Darabonba::Model {
public:
  shared_ptr<string> userId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail> detail{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUserDetail>(model1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser>> user{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdminUser>>(expect1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin() = default;
};
class ListInstancesOfUserResponseBodyInstancesCallCenterInstance : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> owner{};
  shared_ptr<long> storageMaxSize{};
  shared_ptr<long> storageMaxDays{};
  shared_ptr<long> maxOnlineAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers> phoneNumbers{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> storageBucket{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> createdTime{};
  shared_ptr<string> directoryId{};
  shared_ptr<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin> admin{};
  shared_ptr<string> tenantId{};

  ListInstancesOfUserResponseBodyInstancesCallCenterInstance() {}

  explicit ListInstancesOfUserResponseBodyInstancesCallCenterInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (storageMaxSize) {
      res["StorageMaxSize"] = boost::any(*storageMaxSize);
    }
    if (storageMaxDays) {
      res["StorageMaxDays"] = boost::any(*storageMaxDays);
    }
    if (maxOnlineAgents) {
      res["MaxOnlineAgents"] = boost::any(*maxOnlineAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (storageBucket) {
      res["StorageBucket"] = boost::any(*storageBucket);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (directoryId) {
      res["DirectoryId"] = boost::any(*directoryId);
    }
    if (admin) {
      res["Admin"] = admin ? boost::any(admin->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("StorageMaxSize") != m.end() && !m["StorageMaxSize"].empty()) {
      storageMaxSize = make_shared<long>(boost::any_cast<long>(m["StorageMaxSize"]));
    }
    if (m.find("StorageMaxDays") != m.end() && !m["StorageMaxDays"].empty()) {
      storageMaxDays = make_shared<long>(boost::any_cast<long>(m["StorageMaxDays"]));
    }
    if (m.find("MaxOnlineAgents") != m.end() && !m["MaxOnlineAgents"].empty()) {
      maxOnlineAgents = make_shared<long>(boost::any_cast<long>(m["MaxOnlineAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<ListInstancesOfUserResponseBodyInstancesCallCenterInstancePhoneNumbers>(model1);
      }
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("StorageBucket") != m.end() && !m["StorageBucket"].empty()) {
      storageBucket = make_shared<string>(boost::any_cast<string>(m["StorageBucket"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<long>(boost::any_cast<long>(m["CreatedTime"]));
    }
    if (m.find("DirectoryId") != m.end() && !m["DirectoryId"].empty()) {
      directoryId = make_shared<string>(boost::any_cast<string>(m["DirectoryId"]));
    }
    if (m.find("Admin") != m.end() && !m["Admin"].empty()) {
      if (typeid(map<string, boost::any>) == m["Admin"].type()) {
        ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Admin"]));
        admin = make_shared<ListInstancesOfUserResponseBodyInstancesCallCenterInstanceAdmin>(model1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstancesCallCenterInstance() = default;
};
class ListInstancesOfUserResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstance>> callCenterInstance{};

  ListInstancesOfUserResponseBodyInstances() {}

  explicit ListInstancesOfUserResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callCenterInstance) {
      vector<boost::any> temp1;
      for(auto item1:*callCenterInstance){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallCenterInstance"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallCenterInstance") != m.end() && !m["CallCenterInstance"].empty()) {
      if (typeid(vector<boost::any>) == m["CallCenterInstance"].type()) {
        vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstance> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallCenterInstance"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyInstancesCallCenterInstance model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callCenterInstance = make_shared<vector<ListInstancesOfUserResponseBodyInstancesCallCenterInstance>>(expect1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponseBodyInstances() = default;
};
class ListInstancesOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListInstancesOfUserResponseBodyInstances> instances{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListInstancesOfUserResponseBody() {}

  explicit ListInstancesOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        ListInstancesOfUserResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<ListInstancesOfUserResponseBodyInstances>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBody() = default;
};
class ListInstancesOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListInstancesOfUserResponseBody> body{};

  ListInstancesOfUserResponse() {}

  explicit ListInstancesOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponse() = default;
};
class ListIvrTrackingDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> calledNumber{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIvrTrackingDetailRequest() {}

  explicit ListIvrTrackingDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListIvrTrackingDetailRequest() = default;
};
class ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> deviceID{};
  shared_ptr<string> inputData{};
  shared_ptr<string> flowName{};
  shared_ptr<long> stopTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<long> startTime{};
  shared_ptr<string> description{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> contactId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> outputData{};
  shared_ptr<string> tenantId{};

  ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail() {}

  explicit ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceID) {
      res["DeviceID"] = boost::any(*deviceID);
    }
    if (inputData) {
      res["InputData"] = boost::any(*inputData);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (outputData) {
      res["OutputData"] = boost::any(*outputData);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceID") != m.end() && !m["DeviceID"].empty()) {
      deviceID = make_shared<string>(boost::any_cast<string>(m["DeviceID"]));
    }
    if (m.find("InputData") != m.end() && !m["InputData"].empty()) {
      inputData = make_shared<string>(boost::any_cast<string>(m["InputData"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("OutputData") != m.end() && !m["OutputData"].empty()) {
      outputData = make_shared<string>(boost::any_cast<string>(m["OutputData"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail() = default;
};
class ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail>> ivrTrackingDetail{};

  ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList() {}

  explicit ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ivrTrackingDetail) {
      vector<boost::any> temp1;
      for(auto item1:*ivrTrackingDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IvrTrackingDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IvrTrackingDetail") != m.end() && !m["IvrTrackingDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["IvrTrackingDetail"].type()) {
        vector<ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IvrTrackingDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ivrTrackingDetail = make_shared<vector<ListIvrTrackingDetailResponseBodyIvrTrackingDetailsListIvrTrackingDetail>>(expect1);
      }
    }
  }


  virtual ~ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList() = default;
};
class ListIvrTrackingDetailResponseBodyIvrTrackingDetails : public Darabonba::Model {
public:
  shared_ptr<ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListIvrTrackingDetailResponseBodyIvrTrackingDetails() {}

  explicit ListIvrTrackingDetailResponseBodyIvrTrackingDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListIvrTrackingDetailResponseBodyIvrTrackingDetailsList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIvrTrackingDetailResponseBodyIvrTrackingDetails() = default;
};
class ListIvrTrackingDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListIvrTrackingDetailResponseBodyIvrTrackingDetails> ivrTrackingDetails{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListIvrTrackingDetailResponseBody() {}

  explicit ListIvrTrackingDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (ivrTrackingDetails) {
      res["IvrTrackingDetails"] = ivrTrackingDetails ? boost::any(ivrTrackingDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("IvrTrackingDetails") != m.end() && !m["IvrTrackingDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["IvrTrackingDetails"].type()) {
        ListIvrTrackingDetailResponseBodyIvrTrackingDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IvrTrackingDetails"]));
        ivrTrackingDetails = make_shared<ListIvrTrackingDetailResponseBodyIvrTrackingDetails>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIvrTrackingDetailResponseBody() = default;
};
class ListIvrTrackingDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListIvrTrackingDetailResponseBody> body{};

  ListIvrTrackingDetailResponse() {}

  explicit ListIvrTrackingDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIvrTrackingDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIvrTrackingDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ListIvrTrackingDetailResponse() = default;
};
class ListJobGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListJobGroupsRequest() {}

  explicit ListJobGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListJobGroupsRequest() = default;
};
class ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime() {}

  explicit ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime() = default;
};
class ListJobGroupsResponseBodyJobGroupsListStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> description{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListJobGroupsResponseBodyJobGroupsListStrategy() {}

  explicit ListJobGroupsResponseBodyJobGroupsListStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<ListJobGroupsResponseBodyJobGroupsListStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListStrategy() = default;
};
class ListJobGroupsResponseBodyJobGroupsListProgressCategories : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobGroupsResponseBodyJobGroupsListProgressCategories() {}

  explicit ListJobGroupsResponseBodyJobGroupsListProgressCategories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListProgressCategories() = default;
};
class ListJobGroupsResponseBodyJobGroupsListProgress : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> totalNotAnswered{};
  shared_ptr<long> startTime{};
  shared_ptr<vector<ListJobGroupsResponseBodyJobGroupsListProgressCategories>> categories{};
  shared_ptr<long> totalJobs{};
  shared_ptr<long> totalCompleted{};
  shared_ptr<long> duration{};

  ListJobGroupsResponseBodyJobGroupsListProgress() {}

  explicit ListJobGroupsResponseBodyJobGroupsListProgress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalNotAnswered) {
      res["TotalNotAnswered"] = boost::any(*totalNotAnswered);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (categories) {
      vector<boost::any> temp1;
      for(auto item1:*categories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Categories"] = boost::any(temp1);
    }
    if (totalJobs) {
      res["TotalJobs"] = boost::any(*totalJobs);
    }
    if (totalCompleted) {
      res["TotalCompleted"] = boost::any(*totalCompleted);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalNotAnswered") != m.end() && !m["TotalNotAnswered"].empty()) {
      totalNotAnswered = make_shared<long>(boost::any_cast<long>(m["TotalNotAnswered"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<ListJobGroupsResponseBodyJobGroupsListProgressCategories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Categories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobGroupsResponseBodyJobGroupsListProgressCategories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        categories = make_shared<vector<ListJobGroupsResponseBodyJobGroupsListProgressCategories>>(expect1);
      }
    }
    if (m.find("TotalJobs") != m.end() && !m["TotalJobs"].empty()) {
      totalJobs = make_shared<long>(boost::any_cast<long>(m["TotalJobs"]));
    }
    if (m.find("TotalCompleted") != m.end() && !m["TotalCompleted"].empty()) {
      totalCompleted = make_shared<long>(boost::any_cast<long>(m["TotalCompleted"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsListProgress() = default;
};
class ListJobGroupsResponseBodyJobGroupsList : public Darabonba::Model {
public:
  shared_ptr<string> scenarioId{};
  shared_ptr<long> creationTime{};
  shared_ptr<ListJobGroupsResponseBodyJobGroupsListStrategy> strategy{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<ListJobGroupsResponseBodyJobGroupsListProgress> progress{};
  shared_ptr<string> description{};
  shared_ptr<string> jobFilePath{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListJobGroupsResponseBodyJobGroupsList() {}

  explicit ListJobGroupsResponseBodyJobGroupsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (progress) {
      res["Progress"] = progress ? boost::any(progress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (jobFilePath) {
      res["JobFilePath"] = boost::any(*jobFilePath);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListJobGroupsResponseBodyJobGroupsListStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListJobGroupsResponseBodyJobGroupsListStrategy>(model1);
      }
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      if (typeid(map<string, boost::any>) == m["Progress"].type()) {
        ListJobGroupsResponseBodyJobGroupsListProgress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Progress"]));
        progress = make_shared<ListJobGroupsResponseBodyJobGroupsListProgress>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JobFilePath") != m.end() && !m["JobFilePath"].empty()) {
      jobFilePath = make_shared<string>(boost::any_cast<string>(m["JobFilePath"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroupsList() = default;
};
class ListJobGroupsResponseBodyJobGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobGroupsResponseBodyJobGroupsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListJobGroupsResponseBodyJobGroups() {}

  explicit ListJobGroupsResponseBodyJobGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListJobGroupsResponseBodyJobGroupsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobGroupsResponseBodyJobGroupsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListJobGroupsResponseBodyJobGroupsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListJobGroupsResponseBodyJobGroups() = default;
};
class ListJobGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<ListJobGroupsResponseBodyJobGroups> jobGroups{};

  ListJobGroupsResponseBody() {}

  explicit ListJobGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (jobGroups) {
      res["JobGroups"] = jobGroups ? boost::any(jobGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("JobGroups") != m.end() && !m["JobGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["JobGroups"].type()) {
        ListJobGroupsResponseBodyJobGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["JobGroups"]));
        jobGroups = make_shared<ListJobGroupsResponseBodyJobGroups>(model1);
      }
    }
  }


  virtual ~ListJobGroupsResponseBody() = default;
};
class ListJobGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListJobGroupsResponseBody> body{};

  ListJobGroupsResponse() {}

  explicit ListJobGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobGroupsResponse() = default;
};
class ListJobsByGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> jobStatus{};
  shared_ptr<string> jobFailureReason{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListJobsByGroupRequest() {}

  explicit ListJobsByGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobStatus) {
      res["JobStatus"] = boost::any(*jobStatus);
    }
    if (jobFailureReason) {
      res["JobFailureReason"] = boost::any(*jobFailureReason);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobStatus") != m.end() && !m["JobStatus"].empty()) {
      jobStatus = make_shared<string>(boost::any_cast<string>(m["JobStatus"]));
    }
    if (m.find("JobFailureReason") != m.end() && !m["JobFailureReason"].empty()) {
      jobFailureReason = make_shared<string>(boost::any_cast<string>(m["JobFailureReason"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListJobsByGroupRequest() = default;
};
class ListJobsByGroupResponseBodyJobsListSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> conversationDetailId{};

  ListJobsByGroupResponseBodyJobsListSummary() {}

  explicit ListJobsByGroupResponseBodyJobsListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListSummary() = default;
};
class ListJobsByGroupResponseBodyJobsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  ListJobsByGroupResponseBodyJobsListContacts() {}

  explicit ListJobsByGroupResponseBodyJobsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListContacts() = default;
};
class ListJobsByGroupResponseBodyJobsListExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobsByGroupResponseBodyJobsListExtras() {}

  explicit ListJobsByGroupResponseBodyJobsListExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsListExtras() = default;
};
class ListJobsByGroupResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListSummary>> summary{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListContacts>> contacts{};
  shared_ptr<long> priority{};
  shared_ptr<string> failureReason{};
  shared_ptr<long> systemPriority{};
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsListExtras>> extras{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};

  ListJobsByGroupResponseBodyJobsList() {}

  explicit ListJobsByGroupResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (systemPriority) {
      res["SystemPriority"] = boost::any(*systemPriority);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<ListJobsByGroupResponseBodyJobsListSummary>>(expect1);
      }
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<ListJobsByGroupResponseBodyJobsListContacts>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("SystemPriority") != m.end() && !m["SystemPriority"].empty()) {
      systemPriority = make_shared<long>(boost::any_cast<long>(m["SystemPriority"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<ListJobsByGroupResponseBodyJobsListExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsListExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<ListJobsByGroupResponseBodyJobsListExtras>>(expect1);
      }
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobsList() = default;
};
class ListJobsByGroupResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobsByGroupResponseBodyJobsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListJobsByGroupResponseBodyJobs() {}

  explicit ListJobsByGroupResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListJobsByGroupResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobsByGroupResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListJobsByGroupResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListJobsByGroupResponseBodyJobs() = default;
};
class ListJobsByGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListJobsByGroupResponseBodyJobs> jobs{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListJobsByGroupResponseBody() {}

  explicit ListJobsByGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        ListJobsByGroupResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<ListJobsByGroupResponseBodyJobs>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobsByGroupResponseBody() = default;
};
class ListJobsByGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListJobsByGroupResponseBody> body{};

  ListJobsByGroupResponse() {}

  explicit ListJobsByGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobsByGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobsByGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobsByGroupResponse() = default;
};
class ListJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> timeAlignment{};
  shared_ptr<string> contactName{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListJobStatusRequest() {}

  explicit ListJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (timeAlignment) {
      res["TimeAlignment"] = boost::any(*timeAlignment);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("TimeAlignment") != m.end() && !m["TimeAlignment"].empty()) {
      timeAlignment = make_shared<string>(boost::any_cast<string>(m["TimeAlignment"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListJobStatusRequest() = default;
};
class ListJobStatusResponseBodyJobsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  ListJobStatusResponseBodyJobsListContacts() {}

  explicit ListJobStatusResponseBodyJobsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsListContacts() = default;
};
class ListJobStatusResponseBodyJobsListSummary : public Darabonba::Model {
public:
  shared_ptr<string> summaryName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> summaryId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> conversationDetailId{};

  ListJobStatusResponseBodyJobsListSummary() {}

  explicit ListJobStatusResponseBodyJobsListSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryName) {
      res["SummaryName"] = boost::any(*summaryName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (summaryId) {
      res["SummaryId"] = boost::any(*summaryId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (conversationDetailId) {
      res["ConversationDetailId"] = boost::any(*conversationDetailId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryName") != m.end() && !m["SummaryName"].empty()) {
      summaryName = make_shared<string>(boost::any_cast<string>(m["SummaryName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("SummaryId") != m.end() && !m["SummaryId"].empty()) {
      summaryId = make_shared<string>(boost::any_cast<string>(m["SummaryId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ConversationDetailId") != m.end() && !m["ConversationDetailId"].empty()) {
      conversationDetailId = make_shared<string>(boost::any_cast<string>(m["ConversationDetailId"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsListSummary() = default;
};
class ListJobStatusResponseBodyJobsListExtras : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListJobStatusResponseBodyJobsListExtras() {}

  explicit ListJobStatusResponseBodyJobsListExtras(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsListExtras() = default;
};
class ListJobStatusResponseBodyJobsListTasksContact : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> jobId{};
  shared_ptr<string> honorific{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  ListJobStatusResponseBodyJobsListTasksContact() {}

  explicit ListJobStatusResponseBodyJobsListTasksContact(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (honorific) {
      res["Honorific"] = boost::any(*honorific);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Honorific") != m.end() && !m["Honorific"].empty()) {
      honorific = make_shared<string>(boost::any_cast<string>(m["Honorific"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsListTasksContact() = default;
};
class ListJobStatusResponseBodyJobsListTasks : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> planedTime{};
  shared_ptr<string> chatbotId{};
  shared_ptr<long> actualTime{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> scenarioId{};
  shared_ptr<ListJobStatusResponseBodyJobsListTasksContact> contact{};
  shared_ptr<string> jobId{};
  shared_ptr<string> callId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> brief{};
  shared_ptr<long> duration{};
  shared_ptr<string> taskId{};

  ListJobStatusResponseBodyJobsListTasks() {}

  explicit ListJobStatusResponseBodyJobsListTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (planedTime) {
      res["PlanedTime"] = boost::any(*planedTime);
    }
    if (chatbotId) {
      res["ChatbotId"] = boost::any(*chatbotId);
    }
    if (actualTime) {
      res["ActualTime"] = boost::any(*actualTime);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (contact) {
      res["Contact"] = contact ? boost::any(contact->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (brief) {
      res["Brief"] = boost::any(*brief);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PlanedTime") != m.end() && !m["PlanedTime"].empty()) {
      planedTime = make_shared<long>(boost::any_cast<long>(m["PlanedTime"]));
    }
    if (m.find("ChatbotId") != m.end() && !m["ChatbotId"].empty()) {
      chatbotId = make_shared<string>(boost::any_cast<string>(m["ChatbotId"]));
    }
    if (m.find("ActualTime") != m.end() && !m["ActualTime"].empty()) {
      actualTime = make_shared<long>(boost::any_cast<long>(m["ActualTime"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      if (typeid(map<string, boost::any>) == m["Contact"].type()) {
        ListJobStatusResponseBodyJobsListTasksContact model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Contact"]));
        contact = make_shared<ListJobStatusResponseBodyJobsListTasksContact>(model1);
      }
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Brief") != m.end() && !m["Brief"].empty()) {
      brief = make_shared<string>(boost::any_cast<string>(m["Brief"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsListTasks() = default;
};
class ListJobStatusResponseBodyJobsList : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<string>> callingNumbers{};
  shared_ptr<vector<ListJobStatusResponseBodyJobsListContacts>> contacts{};
  shared_ptr<vector<ListJobStatusResponseBodyJobsListSummary>> summary{};
  shared_ptr<long> priority{};
  shared_ptr<string> failureReason{};
  shared_ptr<vector<ListJobStatusResponseBodyJobsListExtras>> extras{};
  shared_ptr<string> referenceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<vector<ListJobStatusResponseBodyJobsListTasks>> tasks{};
  shared_ptr<string> strategyId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> jobId{};

  ListJobStatusResponseBodyJobsList() {}

  explicit ListJobStatusResponseBodyJobsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (callingNumbers) {
      res["CallingNumbers"] = boost::any(*callingNumbers);
    }
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (summary) {
      vector<boost::any> temp1;
      for(auto item1:*summary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summary"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (extras) {
      vector<boost::any> temp1;
      for(auto item1:*extras){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Extras"] = boost::any(temp1);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("CallingNumbers") != m.end() && !m["CallingNumbers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumbers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumbers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumbers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<ListJobStatusResponseBodyJobsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobStatusResponseBodyJobsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<ListJobStatusResponseBodyJobsListContacts>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(vector<boost::any>) == m["Summary"].type()) {
        vector<ListJobStatusResponseBodyJobsListSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobStatusResponseBodyJobsListSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summary = make_shared<vector<ListJobStatusResponseBodyJobsListSummary>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("Extras") != m.end() && !m["Extras"].empty()) {
      if (typeid(vector<boost::any>) == m["Extras"].type()) {
        vector<ListJobStatusResponseBodyJobsListExtras> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Extras"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobStatusResponseBodyJobsListExtras model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extras = make_shared<vector<ListJobStatusResponseBodyJobsListExtras>>(expect1);
      }
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<ListJobStatusResponseBodyJobsListTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobStatusResponseBodyJobsListTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<ListJobStatusResponseBodyJobsListTasks>>(expect1);
      }
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobsList() = default;
};
class ListJobStatusResponseBodyJobs : public Darabonba::Model {
public:
  shared_ptr<vector<ListJobStatusResponseBodyJobsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListJobStatusResponseBodyJobs() {}

  explicit ListJobStatusResponseBodyJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListJobStatusResponseBodyJobsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListJobStatusResponseBodyJobsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListJobStatusResponseBodyJobsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListJobStatusResponseBodyJobs() = default;
};
class ListJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListJobStatusResponseBodyJobs> jobs{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListJobStatusResponseBody() {}

  explicit ListJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jobs) {
      res["Jobs"] = jobs ? boost::any(jobs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jobs") != m.end() && !m["Jobs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Jobs"].type()) {
        ListJobStatusResponseBodyJobs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Jobs"]));
        jobs = make_shared<ListJobStatusResponseBodyJobs>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListJobStatusResponseBody() = default;
};
class ListJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListJobStatusResponseBody> body{};

  ListJobStatusResponse() {}

  explicit ListJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ListJobStatusResponse() = default;
};
class ListMediasRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> namePrefix{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListMediasRequest() {}

  explicit ListMediasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (namePrefix) {
      res["NamePrefix"] = boost::any(*namePrefix);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NamePrefix") != m.end() && !m["NamePrefix"].empty()) {
      namePrefix = make_shared<string>(boost::any_cast<string>(m["NamePrefix"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListMediasRequest() = default;
};
class ListMediasResponseBodyMediasListMedia : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> filePath{};
  shared_ptr<string> instance{};
  shared_ptr<string> description{};
  shared_ptr<string> fileName{};
  shared_ptr<string> name{};
  shared_ptr<string> content{};
  shared_ptr<string> ossFileName{};

  ListMediasResponseBodyMediasListMedia() {}

  explicit ListMediasResponseBodyMediasListMedia(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (ossFileName) {
      res["OssFileName"] = boost::any(*ossFileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("OssFileName") != m.end() && !m["OssFileName"].empty()) {
      ossFileName = make_shared<string>(boost::any_cast<string>(m["OssFileName"]));
    }
  }


  virtual ~ListMediasResponseBodyMediasListMedia() = default;
};
class ListMediasResponseBodyMediasList : public Darabonba::Model {
public:
  shared_ptr<vector<ListMediasResponseBodyMediasListMedia>> media{};

  ListMediasResponseBodyMediasList() {}

  explicit ListMediasResponseBodyMediasList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (media) {
      vector<boost::any> temp1;
      for(auto item1:*media){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Media"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Media") != m.end() && !m["Media"].empty()) {
      if (typeid(vector<boost::any>) == m["Media"].type()) {
        vector<ListMediasResponseBodyMediasListMedia> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Media"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMediasResponseBodyMediasListMedia model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        media = make_shared<vector<ListMediasResponseBodyMediasListMedia>>(expect1);
      }
    }
  }


  virtual ~ListMediasResponseBodyMediasList() = default;
};
class ListMediasResponseBodyMedias : public Darabonba::Model {
public:
  shared_ptr<ListMediasResponseBodyMediasList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMediasResponseBodyMedias() {}

  explicit ListMediasResponseBodyMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListMediasResponseBodyMediasList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListMediasResponseBodyMediasList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMediasResponseBodyMedias() = default;
};
class ListMediasResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListMediasResponseBodyMedias> medias{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListMediasResponseBody() {}

  explicit ListMediasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (medias) {
      res["Medias"] = medias ? boost::any(medias->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Medias") != m.end() && !m["Medias"].empty()) {
      if (typeid(map<string, boost::any>) == m["Medias"].type()) {
        ListMediasResponseBodyMedias model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Medias"]));
        medias = make_shared<ListMediasResponseBodyMedias>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListMediasResponseBody() = default;
};
class ListMediasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMediasResponseBody> body{};

  ListMediasResponse() {}

  explicit ListMediasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMediasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMediasResponseBody>(model1);
      }
    }
  }


  virtual ~ListMediasResponse() = default;
};
class ListOutboundPhoneNumberOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListOutboundPhoneNumberOfUserRequest() {}

  explicit ListOutboundPhoneNumberOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserRequest() = default;
};
class ListOutboundPhoneNumberOfUserResponseBodyNumberList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> number{};

  ListOutboundPhoneNumberOfUserResponseBodyNumberList() {}

  explicit ListOutboundPhoneNumberOfUserResponseBodyNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Number"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Number"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      number = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponseBodyNumberList() = default;
};
class ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> poolId{};
  shared_ptr<string> subId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> poolName{};
  shared_ptr<string> bizId{};
  shared_ptr<string> regionNameCity{};
  shared_ptr<string> extra{};
  shared_ptr<string> telX{};

  ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber() {}

  explicit ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (poolId) {
      res["PoolId"] = boost::any(*poolId);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (poolName) {
      res["PoolName"] = boost::any(*poolName);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (regionNameCity) {
      res["RegionNameCity"] = boost::any(*regionNameCity);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (telX) {
      res["TelX"] = boost::any(*telX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PoolId") != m.end() && !m["PoolId"].empty()) {
      poolId = make_shared<string>(boost::any_cast<string>(m["PoolId"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PoolName") != m.end() && !m["PoolName"].empty()) {
      poolName = make_shared<string>(boost::any_cast<string>(m["PoolName"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("RegionNameCity") != m.end() && !m["RegionNameCity"].empty()) {
      regionNameCity = make_shared<string>(boost::any_cast<string>(m["RegionNameCity"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("TelX") != m.end() && !m["TelX"].empty()) {
      telX = make_shared<string>(boost::any_cast<string>(m["TelX"]));
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber() = default;
};
class ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> privateFlag{};
  shared_ptr<bool> testOnly{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> sipTelX{};
  shared_ptr<string> city{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberId{};
  shared_ptr<long> trunks{};
  shared_ptr<string> number{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber> privacyNumber{};
  shared_ptr<string> province{};

  ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber() {}

  explicit ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateFlag) {
      res["PrivateFlag"] = boost::any(*privateFlag);
    }
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (sipTelX) {
      res["SipTelX"] = boost::any(*sipTelX);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (privacyNumber) {
      res["PrivacyNumber"] = privacyNumber ? boost::any(privacyNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateFlag") != m.end() && !m["PrivateFlag"].empty()) {
      privateFlag = make_shared<bool>(boost::any_cast<bool>(m["PrivateFlag"]));
    }
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("SipTelX") != m.end() && !m["SipTelX"].empty()) {
      sipTelX = make_shared<string>(boost::any_cast<string>(m["SipTelX"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PrivacyNumber") != m.end() && !m["PrivacyNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivacyNumber"].type()) {
        ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivacyNumber"]));
        privacyNumber = make_shared<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumberPrivacyNumber>(model1);
      }
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber() = default;
};
class ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber>> phoneNumber{};

  ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers() {}

  explicit ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers() = default;
};
class ListOutboundPhoneNumberOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListOutboundPhoneNumberOfUserResponseBodyNumberList> numberList{};
  shared_ptr<string> code{};
  shared_ptr<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers> outboundPhoneNumbers{};
  shared_ptr<bool> success{};

  ListOutboundPhoneNumberOfUserResponseBody() {}

  explicit ListOutboundPhoneNumberOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (numberList) {
      res["NumberList"] = numberList ? boost::any(numberList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (outboundPhoneNumbers) {
      res["OutboundPhoneNumbers"] = outboundPhoneNumbers ? boost::any(outboundPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(map<string, boost::any>) == m["NumberList"].type()) {
        ListOutboundPhoneNumberOfUserResponseBodyNumberList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NumberList"]));
        numberList = make_shared<ListOutboundPhoneNumberOfUserResponseBodyNumberList>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("OutboundPhoneNumbers") != m.end() && !m["OutboundPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutboundPhoneNumbers"].type()) {
        ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutboundPhoneNumbers"]));
        outboundPhoneNumbers = make_shared<ListOutboundPhoneNumberOfUserResponseBodyOutboundPhoneNumbers>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponseBody() = default;
};
class ListOutboundPhoneNumberOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOutboundPhoneNumberOfUserResponseBody> body{};

  ListOutboundPhoneNumberOfUserResponse() {}

  explicit ListOutboundPhoneNumberOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOutboundPhoneNumberOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOutboundPhoneNumberOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListOutboundPhoneNumberOfUserResponse() = default;
};
class ListPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> outboundOnly{};

  ListPhoneNumbersRequest() {}

  explicit ListPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundOnly) {
      res["OutboundOnly"] = boost::any(*outboundOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundOnly") != m.end() && !m["OutboundOnly"].empty()) {
      outboundOnly = make_shared<bool>(boost::any_cast<bool>(m["OutboundOnly"]));
    }
  }


  virtual ~ListPhoneNumbersRequest() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};

  ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup>> skillGroup{};

  ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroup) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroup"].type()) {
        vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroup = make_shared<vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroupsSkillGroup>>(expect1);
      }
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};

  ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> poolId{};
  shared_ptr<string> subId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> poolName{};
  shared_ptr<string> bizId{};
  shared_ptr<string> regionNameCity{};
  shared_ptr<string> extra{};
  shared_ptr<string> telX{};

  ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (poolId) {
      res["PoolId"] = boost::any(*poolId);
    }
    if (subId) {
      res["SubId"] = boost::any(*subId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (poolName) {
      res["PoolName"] = boost::any(*poolName);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (regionNameCity) {
      res["RegionNameCity"] = boost::any(*regionNameCity);
    }
    if (extra) {
      res["Extra"] = boost::any(*extra);
    }
    if (telX) {
      res["TelX"] = boost::any(*telX);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PoolId") != m.end() && !m["PoolId"].empty()) {
      poolId = make_shared<string>(boost::any_cast<string>(m["PoolId"]));
    }
    if (m.find("SubId") != m.end() && !m["SubId"].empty()) {
      subId = make_shared<string>(boost::any_cast<string>(m["SubId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PoolName") != m.end() && !m["PoolName"].empty()) {
      poolName = make_shared<string>(boost::any_cast<string>(m["PoolName"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("RegionNameCity") != m.end() && !m["RegionNameCity"].empty()) {
      regionNameCity = make_shared<string>(boost::any_cast<string>(m["RegionNameCity"]));
    }
    if (m.find("Extra") != m.end() && !m["Extra"].empty()) {
      extra = make_shared<string>(boost::any_cast<string>(m["Extra"]));
    }
    if (m.find("TelX") != m.end() && !m["TelX"].empty()) {
      telX = make_shared<string>(boost::any_cast<string>(m["TelX"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> sipTelX{};
  shared_ptr<string> city{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> assignee{};
  shared_ptr<string> phoneNumberId{};
  shared_ptr<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups> skillGroups{};
  shared_ptr<long> trunks{};
  shared_ptr<string> number{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow> contactFlow{};
  shared_ptr<long> numberCommodityStatus{};
  shared_ptr<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber> privacyNumber{};
  shared_ptr<string> province{};

  ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (sipTelX) {
      res["SipTelX"] = boost::any(*sipTelX);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    if (skillGroups) {
      res["SkillGroups"] = skillGroups ? boost::any(skillGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numberCommodityStatus) {
      res["NumberCommodityStatus"] = boost::any(*numberCommodityStatus);
    }
    if (privacyNumber) {
      res["PrivacyNumber"] = privacyNumber ? boost::any(privacyNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("SipTelX") != m.end() && !m["SipTelX"].empty()) {
      sipTelX = make_shared<string>(boost::any_cast<string>(m["SipTelX"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillGroups"].type()) {
        ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillGroups"]));
        skillGroups = make_shared<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberSkillGroups>(model1);
      }
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberContactFlow>(model1);
      }
    }
    if (m.find("NumberCommodityStatus") != m.end() && !m["NumberCommodityStatus"].empty()) {
      numberCommodityStatus = make_shared<long>(boost::any_cast<long>(m["NumberCommodityStatus"]));
    }
    if (m.find("PrivacyNumber") != m.end() && !m["PrivacyNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivacyNumber"].type()) {
        ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivacyNumber"]));
        privacyNumber = make_shared<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumberPrivacyNumber>(model1);
      }
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber() = default;
};
class ListPhoneNumbersResponseBodyPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber>> phoneNumber{};

  ListPhoneNumbersResponseBodyPhoneNumbers() {}

  explicit ListPhoneNumbersResponseBodyPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListPhoneNumbersResponseBodyPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListPhoneNumbersResponseBodyPhoneNumbers() = default;
};
class ListPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPhoneNumbersResponseBodyPhoneNumbers> phoneNumbers{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListPhoneNumbersResponseBody() {}

  explicit ListPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        ListPhoneNumbersResponseBodyPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<ListPhoneNumbersResponseBodyPhoneNumbers>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBody() = default;
};
class ListPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPhoneNumbersResponseBody> body{};

  ListPhoneNumbersResponse() {}

  explicit ListPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneNumbersResponse() = default;
};
class ListPhoneTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> outboundOnly{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> currentPage{};
  shared_ptr<string> number{};
  shared_ptr<vector<string>> numberGroupIds{};

  ListPhoneTagsRequest() {}

  explicit ListPhoneTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundOnly) {
      res["OutboundOnly"] = boost::any(*outboundOnly);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (currentPage) {
      res["CurrentPage"] = boost::any(*currentPage);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (numberGroupIds) {
      res["NumberGroupIds"] = boost::any(*numberGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundOnly") != m.end() && !m["OutboundOnly"].empty()) {
      outboundOnly = make_shared<bool>(boost::any_cast<bool>(m["OutboundOnly"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("CurrentPage") != m.end() && !m["CurrentPage"].empty()) {
      currentPage = make_shared<long>(boost::any_cast<long>(m["CurrentPage"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("NumberGroupIds") != m.end() && !m["NumberGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NumberGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NumberGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      numberGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPhoneTagsRequest() = default;
};
class ListPhoneTagsResponseBodyPhoneNumbersList : public Darabonba::Model {
public:
  shared_ptr<long> type{};
  shared_ptr<string> serviceTag{};
  shared_ptr<long> createTime{};
  shared_ptr<string> city{};
  shared_ptr<vector<string>> skillGroupIdList{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<string> phoneNumberId{};
  shared_ptr<string> provider{};
  shared_ptr<string> number{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> province{};
  shared_ptr<long> concurrency{};

  ListPhoneTagsResponseBodyPhoneNumbersList() {}

  explicit ListPhoneTagsResponseBodyPhoneNumbersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (serviceTag) {
      res["ServiceTag"] = boost::any(*serviceTag);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (concurrency) {
      res["Concurrency"] = boost::any(*concurrency);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("ServiceTag") != m.end() && !m["ServiceTag"].empty()) {
      serviceTag = make_shared<string>(boost::any_cast<string>(m["ServiceTag"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Concurrency") != m.end() && !m["Concurrency"].empty()) {
      concurrency = make_shared<long>(boost::any_cast<long>(m["Concurrency"]));
    }
  }


  virtual ~ListPhoneTagsResponseBodyPhoneNumbersList() = default;
};
class ListPhoneTagsResponseBodyPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneTagsResponseBodyPhoneNumbersList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPhoneTagsResponseBodyPhoneNumbers() {}

  explicit ListPhoneTagsResponseBodyPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPhoneTagsResponseBodyPhoneNumbersList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneTagsResponseBodyPhoneNumbersList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPhoneTagsResponseBodyPhoneNumbersList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhoneTagsResponseBodyPhoneNumbers() = default;
};
class ListPhoneTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPhoneTagsResponseBodyPhoneNumbers> phoneNumbers{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListPhoneTagsResponseBody() {}

  explicit ListPhoneTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        ListPhoneTagsResponseBodyPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<ListPhoneTagsResponseBodyPhoneNumbers>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPhoneTagsResponseBody() = default;
};
class ListPhoneTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPhoneTagsResponseBody> body{};

  ListPhoneTagsResponse() {}

  explicit ListPhoneTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneTagsResponse() = default;
};
class ListRealTimeAgentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListRealTimeAgentRequest() {}

  explicit ListRealTimeAgentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListRealTimeAgentRequest() = default;
};
class ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill() {}

  explicit ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill() = default;
};
class ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel() {}

  explicit ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel() = default;
};
class ListRealTimeAgentResponseBodyDataUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel>> skillLevel{};

  ListRealTimeAgentResponseBodyDataUserSkillLevels() {}

  explicit ListRealTimeAgentResponseBodyDataUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<ListRealTimeAgentResponseBodyDataUserSkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~ListRealTimeAgentResponseBodyDataUserSkillLevels() = default;
};
class ListRealTimeAgentResponseBodyDataUser : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> stateDesc{};
  shared_ptr<ListRealTimeAgentResponseBodyDataUserSkillLevels> skillLevels{};
  shared_ptr<string> dn{};
  shared_ptr<string> state{};
  shared_ptr<string> ramId{};
  shared_ptr<string> phone{};

  ListRealTimeAgentResponseBodyDataUser() {}

  explicit ListRealTimeAgentResponseBodyDataUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (stateDesc) {
      res["StateDesc"] = boost::any(*stateDesc);
    }
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dn) {
      res["Dn"] = boost::any(*dn);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("StateDesc") != m.end() && !m["StateDesc"].empty()) {
      stateDesc = make_shared<string>(boost::any_cast<string>(m["StateDesc"]));
    }
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        ListRealTimeAgentResponseBodyDataUserSkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<ListRealTimeAgentResponseBodyDataUserSkillLevels>(model1);
      }
    }
    if (m.find("Dn") != m.end() && !m["Dn"].empty()) {
      dn = make_shared<string>(boost::any_cast<string>(m["Dn"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListRealTimeAgentResponseBodyDataUser() = default;
};
class ListRealTimeAgentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealTimeAgentResponseBodyDataUser>> user{};

  ListRealTimeAgentResponseBodyData() {}

  explicit ListRealTimeAgentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListRealTimeAgentResponseBodyDataUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealTimeAgentResponseBodyDataUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListRealTimeAgentResponseBodyDataUser>>(expect1);
      }
    }
  }


  virtual ~ListRealTimeAgentResponseBodyData() = default;
};
class ListRealTimeAgentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRealTimeAgentResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListRealTimeAgentResponseBody() {}

  explicit ListRealTimeAgentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRealTimeAgentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRealTimeAgentResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRealTimeAgentResponseBody() = default;
};
class ListRealTimeAgentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRealTimeAgentResponseBody> body{};

  ListRealTimeAgentResponse() {}

  explicit ListRealTimeAgentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealTimeAgentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealTimeAgentResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealTimeAgentResponse() = default;
};
class ListRecentCallRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> criteria{};

  ListRecentCallRecordsRequest() {}

  explicit ListRecentCallRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
  }


  virtual ~ListRecentCallRecordsRequest() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> queueTime{};
  shared_ptr<long> ringTime{};
  shared_ptr<long> startTime{};
  shared_ptr<long> talkTime{};
  shared_ptr<long> holdTime{};
  shared_ptr<long> workTime{};
  shared_ptr<string> satisfaction{};
  shared_ptr<string> feedback{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (ringTime) {
      res["RingTime"] = boost::any(*ringTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (talkTime) {
      res["TalkTime"] = boost::any(*talkTime);
    }
    if (holdTime) {
      res["HoldTime"] = boost::any(*holdTime);
    }
    if (workTime) {
      res["WorkTime"] = boost::any(*workTime);
    }
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("RingTime") != m.end() && !m["RingTime"].empty()) {
      ringTime = make_shared<long>(boost::any_cast<long>(m["RingTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("TalkTime") != m.end() && !m["TalkTime"].empty()) {
      talkTime = make_shared<long>(boost::any_cast<long>(m["TalkTime"]));
    }
    if (m.find("HoldTime") != m.end() && !m["HoldTime"].empty()) {
      holdTime = make_shared<long>(boost::any_cast<long>(m["HoldTime"]));
    }
    if (m.find("WorkTime") != m.end() && !m["WorkTime"].empty()) {
      workTime = make_shared<long>(boost::any_cast<long>(m["WorkTime"]));
    }
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<string>(boost::any_cast<string>(m["Satisfaction"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent>> callDetailAgent{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDetailAgent) {
      vector<boost::any> temp1;
      for(auto item1:*callDetailAgent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallDetailAgent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDetailAgent") != m.end() && !m["CallDetailAgent"].empty()) {
      if (typeid(vector<boost::any>) == m["CallDetailAgent"].type()) {
        vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallDetailAgent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callDetailAgent = make_shared<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgentsCallDetailAgent>>(expect1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> calledNumber{};
  shared_ptr<long> startTime{};
  shared_ptr<long> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> filePath{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> channel{};
  shared_ptr<string> instanceId{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording>> recording{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recording) {
      vector<boost::any> temp1;
      for(auto item1:*recording){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recording"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      if (typeid(vector<boost::any>) == m["Recording"].type()) {
        vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recording"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recording = make_shared<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordingsRecording>>(expect1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> duration{};
  shared_ptr<long> satisfaction{};
  shared_ptr<string> contactType{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> agentNames{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> extraAttr{};
  shared_ptr<string> satisfactionDesc{};
  shared_ptr<string> feedback{};
  shared_ptr<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents> agents{};
  shared_ptr<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings> recordings{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (extraAttr) {
      res["ExtraAttr"] = boost::any(*extraAttr);
    }
    if (satisfactionDesc) {
      res["SatisfactionDesc"] = boost::any(*satisfactionDesc);
    }
    if (feedback) {
      res["Feedback"] = boost::any(*feedback);
    }
    if (agents) {
      res["Agents"] = agents ? boost::any(agents->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (recordings) {
      res["Recordings"] = recordings ? boost::any(recordings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<long>(boost::any_cast<long>(m["Satisfaction"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ExtraAttr") != m.end() && !m["ExtraAttr"].empty()) {
      extraAttr = make_shared<string>(boost::any_cast<string>(m["ExtraAttr"]));
    }
    if (m.find("SatisfactionDesc") != m.end() && !m["SatisfactionDesc"].empty()) {
      satisfactionDesc = make_shared<string>(boost::any_cast<string>(m["SatisfactionDesc"]));
    }
    if (m.find("Feedback") != m.end() && !m["Feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["Feedback"]));
    }
    if (m.find("Agents") != m.end() && !m["Agents"].empty()) {
      if (typeid(map<string, boost::any>) == m["Agents"].type()) {
        ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Agents"]));
        agents = make_shared<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordAgents>(model1);
      }
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recordings"].type()) {
        ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recordings"]));
        recordings = make_shared<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecordRecordings>(model1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecordsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord>> callDetailRecord{};

  ListRecentCallRecordsResponseBodyCallDetailRecordsList() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecordsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDetailRecord) {
      vector<boost::any> temp1;
      for(auto item1:*callDetailRecord){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallDetailRecord"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDetailRecord") != m.end() && !m["CallDetailRecord"].empty()) {
      if (typeid(vector<boost::any>) == m["CallDetailRecord"].type()) {
        vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallDetailRecord"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callDetailRecord = make_shared<vector<ListRecentCallRecordsResponseBodyCallDetailRecordsListCallDetailRecord>>(expect1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecordsList() = default;
};
class ListRecentCallRecordsResponseBodyCallDetailRecords : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<ListRecentCallRecordsResponseBodyCallDetailRecordsList> list{};

  ListRecentCallRecordsResponseBodyCallDetailRecords() {}

  explicit ListRecentCallRecordsResponseBodyCallDetailRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListRecentCallRecordsResponseBodyCallDetailRecordsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListRecentCallRecordsResponseBodyCallDetailRecordsList>(model1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBodyCallDetailRecords() = default;
};
class ListRecentCallRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRecentCallRecordsResponseBodyCallDetailRecords> callDetailRecords{};

  ListRecentCallRecordsResponseBody() {}

  explicit ListRecentCallRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (callDetailRecords) {
      res["CallDetailRecords"] = callDetailRecords ? boost::any(callDetailRecords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("CallDetailRecords") != m.end() && !m["CallDetailRecords"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallDetailRecords"].type()) {
        ListRecentCallRecordsResponseBodyCallDetailRecords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallDetailRecords"]));
        callDetailRecords = make_shared<ListRecentCallRecordsResponseBodyCallDetailRecords>(model1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponseBody() = default;
};
class ListRecentCallRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRecentCallRecordsResponseBody> body{};

  ListRecentCallRecordsResponse() {}

  explicit ListRecentCallRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecentCallRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecentCallRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecentCallRecordsResponse() = default;
};
class ListRecordingOfDualTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> connectId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> agentId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListRecordingOfDualTrackRequest() {}

  explicit ListRecordingOfDualTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (connectId) {
      res["ConnectId"] = boost::any(*connectId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ConnectId") != m.end() && !m["ConnectId"].empty()) {
      connectId = make_shared<string>(boost::any_cast<string>(m["ConnectId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRecordingOfDualTrackRequest() = default;
};
class ListRecordingOfDualTrackResponseBodyRecordingsListRecording : public Darabonba::Model {
public:
  shared_ptr<string> contactType{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> filePath{};
  shared_ptr<long> startTime{};
  shared_ptr<string> contactId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<long> duration{};
  shared_ptr<string> channel{};
  shared_ptr<string> fileDescription{};

  ListRecordingOfDualTrackResponseBodyRecordingsListRecording() {}

  explicit ListRecordingOfDualTrackResponseBodyRecordingsListRecording(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
  }


  virtual ~ListRecordingOfDualTrackResponseBodyRecordingsListRecording() = default;
};
class ListRecordingOfDualTrackResponseBodyRecordingsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecordingOfDualTrackResponseBodyRecordingsListRecording>> recording{};

  ListRecordingOfDualTrackResponseBodyRecordingsList() {}

  explicit ListRecordingOfDualTrackResponseBodyRecordingsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recording) {
      vector<boost::any> temp1;
      for(auto item1:*recording){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recording"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      if (typeid(vector<boost::any>) == m["Recording"].type()) {
        vector<ListRecordingOfDualTrackResponseBodyRecordingsListRecording> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recording"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecordingOfDualTrackResponseBodyRecordingsListRecording model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recording = make_shared<vector<ListRecordingOfDualTrackResponseBodyRecordingsListRecording>>(expect1);
      }
    }
  }


  virtual ~ListRecordingOfDualTrackResponseBodyRecordingsList() = default;
};
class ListRecordingOfDualTrackResponseBodyRecordings : public Darabonba::Model {
public:
  shared_ptr<ListRecordingOfDualTrackResponseBodyRecordingsList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRecordingOfDualTrackResponseBodyRecordings() {}

  explicit ListRecordingOfDualTrackResponseBodyRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListRecordingOfDualTrackResponseBodyRecordingsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListRecordingOfDualTrackResponseBodyRecordingsList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecordingOfDualTrackResponseBodyRecordings() = default;
};
class ListRecordingOfDualTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRecordingOfDualTrackResponseBodyRecordings> recordings{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListRecordingOfDualTrackResponseBody() {}

  explicit ListRecordingOfDualTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (recordings) {
      res["Recordings"] = recordings ? boost::any(recordings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recordings"].type()) {
        ListRecordingOfDualTrackResponseBodyRecordings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recordings"]));
        recordings = make_shared<ListRecordingOfDualTrackResponseBodyRecordings>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRecordingOfDualTrackResponseBody() = default;
};
class ListRecordingOfDualTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRecordingOfDualTrackResponseBody> body{};

  ListRecordingOfDualTrackResponse() {}

  explicit ListRecordingOfDualTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecordingOfDualTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecordingOfDualTrackResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecordingOfDualTrackResponse() = default;
};
class ListRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<long> stopTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> agentId{};
  shared_ptr<string> criteria{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListRecordingsRequest() {}

  explicit ListRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRecordingsRequest() = default;
};
class ListRecordingsResponseBodyRecordingsListRecording : public Darabonba::Model {
public:
  shared_ptr<string> contactType{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> filePath{};
  shared_ptr<long> startTime{};
  shared_ptr<string> contactId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<long> duration{};
  shared_ptr<string> channel{};
  shared_ptr<string> fileDescription{};

  ListRecordingsResponseBodyRecordingsListRecording() {}

  explicit ListRecordingsResponseBodyRecordingsListRecording(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
  }


  virtual ~ListRecordingsResponseBodyRecordingsListRecording() = default;
};
class ListRecordingsResponseBodyRecordingsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecordingsResponseBodyRecordingsListRecording>> recording{};

  ListRecordingsResponseBodyRecordingsList() {}

  explicit ListRecordingsResponseBodyRecordingsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recording) {
      vector<boost::any> temp1;
      for(auto item1:*recording){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recording"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      if (typeid(vector<boost::any>) == m["Recording"].type()) {
        vector<ListRecordingsResponseBodyRecordingsListRecording> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recording"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecordingsResponseBodyRecordingsListRecording model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recording = make_shared<vector<ListRecordingsResponseBodyRecordingsListRecording>>(expect1);
      }
    }
  }


  virtual ~ListRecordingsResponseBodyRecordingsList() = default;
};
class ListRecordingsResponseBodyRecordings : public Darabonba::Model {
public:
  shared_ptr<ListRecordingsResponseBodyRecordingsList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRecordingsResponseBodyRecordings() {}

  explicit ListRecordingsResponseBodyRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListRecordingsResponseBodyRecordingsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListRecordingsResponseBodyRecordingsList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecordingsResponseBodyRecordings() = default;
};
class ListRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRecordingsResponseBodyRecordings> recordings{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListRecordingsResponseBody() {}

  explicit ListRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (recordings) {
      res["Recordings"] = recordings ? boost::any(recordings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recordings"].type()) {
        ListRecordingsResponseBodyRecordings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recordings"]));
        recordings = make_shared<ListRecordingsResponseBodyRecordings>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRecordingsResponseBody() = default;
};
class ListRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRecordingsResponseBody> body{};

  ListRecordingsResponse() {}

  explicit ListRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecordingsResponse() = default;
};
class ListRecordingsByContactIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactId{};

  ListRecordingsByContactIdRequest() {}

  explicit ListRecordingsByContactIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
  }


  virtual ~ListRecordingsByContactIdRequest() = default;
};
class ListRecordingsByContactIdResponseBodyRecordingsRecording : public Darabonba::Model {
public:
  shared_ptr<string> contactType{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> qualityCheckTid{};
  shared_ptr<string> filePath{};
  shared_ptr<long> startTime{};
  shared_ptr<string> contactId{};
  shared_ptr<string> qualityCheckTaskId{};
  shared_ptr<string> callingNumber{};
  shared_ptr<long> duration{};
  shared_ptr<string> fileDescription{};
  shared_ptr<string> channel{};

  ListRecordingsByContactIdResponseBodyRecordingsRecording() {}

  explicit ListRecordingsByContactIdResponseBodyRecordingsRecording(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (qualityCheckTid) {
      res["QualityCheckTid"] = boost::any(*qualityCheckTid);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (qualityCheckTaskId) {
      res["QualityCheckTaskId"] = boost::any(*qualityCheckTaskId);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileDescription) {
      res["FileDescription"] = boost::any(*fileDescription);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("QualityCheckTid") != m.end() && !m["QualityCheckTid"].empty()) {
      qualityCheckTid = make_shared<string>(boost::any_cast<string>(m["QualityCheckTid"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("QualityCheckTaskId") != m.end() && !m["QualityCheckTaskId"].empty()) {
      qualityCheckTaskId = make_shared<string>(boost::any_cast<string>(m["QualityCheckTaskId"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("FileDescription") != m.end() && !m["FileDescription"].empty()) {
      fileDescription = make_shared<string>(boost::any_cast<string>(m["FileDescription"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
  }


  virtual ~ListRecordingsByContactIdResponseBodyRecordingsRecording() = default;
};
class ListRecordingsByContactIdResponseBodyRecordings : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecordingsByContactIdResponseBodyRecordingsRecording>> recording{};

  ListRecordingsByContactIdResponseBodyRecordings() {}

  explicit ListRecordingsByContactIdResponseBodyRecordings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recording) {
      vector<boost::any> temp1;
      for(auto item1:*recording){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recording"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Recording") != m.end() && !m["Recording"].empty()) {
      if (typeid(vector<boost::any>) == m["Recording"].type()) {
        vector<ListRecordingsByContactIdResponseBodyRecordingsRecording> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recording"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecordingsByContactIdResponseBodyRecordingsRecording model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recording = make_shared<vector<ListRecordingsByContactIdResponseBodyRecordingsRecording>>(expect1);
      }
    }
  }


  virtual ~ListRecordingsByContactIdResponseBodyRecordings() = default;
};
class ListRecordingsByContactIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRecordingsByContactIdResponseBodyRecordings> recordings{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListRecordingsByContactIdResponseBody() {}

  explicit ListRecordingsByContactIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (recordings) {
      res["Recordings"] = recordings ? boost::any(recordings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Recordings") != m.end() && !m["Recordings"].empty()) {
      if (typeid(map<string, boost::any>) == m["Recordings"].type()) {
        ListRecordingsByContactIdResponseBodyRecordings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Recordings"]));
        recordings = make_shared<ListRecordingsByContactIdResponseBodyRecordings>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRecordingsByContactIdResponseBody() = default;
};
class ListRecordingsByContactIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRecordingsByContactIdResponseBody> body{};

  ListRecordingsByContactIdResponse() {}

  explicit ListRecordingsByContactIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecordingsByContactIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecordingsByContactIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecordingsByContactIdResponse() = default;
};
class ListRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListRolesRequest() {}

  explicit ListRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListRolesRequest() = default;
};
class ListRolesResponseBodyRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  ListRolesResponseBodyRolesRole() {}

  explicit ListRolesResponseBodyRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~ListRolesResponseBodyRolesRole() = default;
};
class ListRolesResponseBodyRoles : public Darabonba::Model {
public:
  shared_ptr<vector<ListRolesResponseBodyRolesRole>> role{};

  ListRolesResponseBodyRoles() {}

  explicit ListRolesResponseBodyRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<ListRolesResponseBodyRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRolesResponseBodyRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<ListRolesResponseBodyRolesRole>>(expect1);
      }
    }
  }


  virtual ~ListRolesResponseBodyRoles() = default;
};
class ListRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListRolesResponseBodyRoles> roles{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListRolesResponseBody() {}

  explicit ListRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        ListRolesResponseBodyRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<ListRolesResponseBodyRoles>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRolesResponseBody() = default;
};
class ListRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRolesResponseBody> body{};

  ListRolesResponse() {}

  explicit ListRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRolesResponse() = default;
};
class ListScenariosRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListScenariosRequest() {}

  explicit ListScenariosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListScenariosRequest() = default;
};
class ListScenariosResponseBodyScenariosStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  ListScenariosResponseBodyScenariosStrategyWorkingTime() {}

  explicit ListScenariosResponseBodyScenariosStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenariosStrategyWorkingTime() = default;
};
class ListScenariosResponseBodyScenariosStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<ListScenariosResponseBodyScenariosStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> description{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListScenariosResponseBodyScenariosStrategy() {}

  explicit ListScenariosResponseBodyScenariosStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<ListScenariosResponseBodyScenariosStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenariosStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<ListScenariosResponseBodyScenariosStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenariosStrategy() = default;
};
class ListScenariosResponseBodyScenariosSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  ListScenariosResponseBodyScenariosSurveysIntents() {}

  explicit ListScenariosResponseBodyScenariosSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenariosSurveysIntents() = default;
};
class ListScenariosResponseBodyScenariosSurveys : public Darabonba::Model {
public:
  shared_ptr<long> round{};
  shared_ptr<string> description{};
  shared_ptr<string> beebotId{};
  shared_ptr<vector<ListScenariosResponseBodyScenariosSurveysIntents>> intents{};
  shared_ptr<string> name{};
  shared_ptr<string> role{};
  shared_ptr<string> id{};

  ListScenariosResponseBodyScenariosSurveys() {}

  explicit ListScenariosResponseBodyScenariosSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<ListScenariosResponseBodyScenariosSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenariosSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<ListScenariosResponseBodyScenariosSurveysIntents>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenariosSurveys() = default;
};
class ListScenariosResponseBodyScenariosVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListScenariosResponseBodyScenariosVariables() {}

  explicit ListScenariosResponseBodyScenariosVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenariosVariables() = default;
};
class ListScenariosResponseBodyScenarios : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<ListScenariosResponseBodyScenariosStrategy> strategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListScenariosResponseBodyScenariosSurveys>> surveys{};
  shared_ptr<vector<ListScenariosResponseBodyScenariosVariables>> variables{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListScenariosResponseBodyScenarios() {}

  explicit ListScenariosResponseBodyScenarios(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ListScenariosResponseBodyScenariosStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ListScenariosResponseBodyScenariosStrategy>(model1);
      }
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<ListScenariosResponseBodyScenariosSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenariosSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<ListScenariosResponseBodyScenariosSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListScenariosResponseBodyScenariosVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenariosVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListScenariosResponseBodyScenariosVariables>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScenariosResponseBodyScenarios() = default;
};
class ListScenariosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListScenariosResponseBodyScenarios>> scenarios{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListScenariosResponseBody() {}

  explicit ListScenariosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (scenarios) {
      vector<boost::any> temp1;
      for(auto item1:*scenarios){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Scenarios"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Scenarios") != m.end() && !m["Scenarios"].empty()) {
      if (typeid(vector<boost::any>) == m["Scenarios"].type()) {
        vector<ListScenariosResponseBodyScenarios> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Scenarios"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenariosResponseBodyScenarios model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarios = make_shared<vector<ListScenariosResponseBodyScenarios>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScenariosResponseBody() = default;
};
class ListScenariosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScenariosResponseBody> body{};

  ListScenariosResponse() {}

  explicit ListScenariosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScenariosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScenariosResponseBody>(model1);
      }
    }
  }


  virtual ~ListScenariosResponse() = default;
};
class ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow : public Darabonba::Model {
public:
  shared_ptr<bool> isPublished{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> flowId{};

  ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow() {}

  explicit ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPublished) {
      res["IsPublished"] = boost::any(*isPublished);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPublished") != m.end() && !m["IsPublished"].empty()) {
      isPublished = make_shared<bool>(boost::any_cast<bool>(m["IsPublished"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow() = default;
};
class ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents() {}

  explicit ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents() = default;
};
class ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestions{};
  shared_ptr<long> round{};
  shared_ptr<string> description{};
  shared_ptr<string> beebotId{};
  shared_ptr<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow> flow{};
  shared_ptr<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents>> intents{};
  shared_ptr<string> name{};
  shared_ptr<string> role{};
  shared_ptr<string> id{};

  ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys() {}

  explicit ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysFlow>(model1);
      }
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveysIntents>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys() = default;
};
class ListScenarioTemplatesResponseBodyScenarioTemplatesVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListScenarioTemplatesResponseBodyScenarioTemplatesVariables() {}

  explicit ListScenarioTemplatesResponseBodyScenarioTemplatesVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBodyScenarioTemplatesVariables() = default;
};
class ListScenarioTemplatesResponseBodyScenarioTemplates : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys>> surveys{};
  shared_ptr<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesVariables>> variables{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListScenarioTemplatesResponseBodyScenarioTemplates() {}

  explicit ListScenarioTemplatesResponseBodyScenarioTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ListScenarioTemplatesResponseBodyScenarioTemplatesVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioTemplatesResponseBodyScenarioTemplatesVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ListScenarioTemplatesResponseBodyScenarioTemplatesVariables>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBodyScenarioTemplates() = default;
};
class ListScenarioTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListScenarioTemplatesResponseBodyScenarioTemplates>> scenarioTemplates{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListScenarioTemplatesResponseBody() {}

  explicit ListScenarioTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (scenarioTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*scenarioTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScenarioTemplates"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ScenarioTemplates") != m.end() && !m["ScenarioTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["ScenarioTemplates"].type()) {
        vector<ListScenarioTemplatesResponseBodyScenarioTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScenarioTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListScenarioTemplatesResponseBodyScenarioTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scenarioTemplates = make_shared<vector<ListScenarioTemplatesResponseBodyScenarioTemplates>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListScenarioTemplatesResponseBody() = default;
};
class ListScenarioTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListScenarioTemplatesResponseBody> body{};

  ListScenarioTemplatesResponse() {}

  explicit ListScenarioTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListScenarioTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListScenarioTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListScenarioTemplatesResponse() = default;
};
class ListSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListSkillGroupsRequest() {}

  explicit ListSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSkillGroupsRequest() = default;
};
class ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber() {}

  explicit ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber() = default;
};
class ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber>> phoneNumber{};

  ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers() {}

  explicit ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers() = default;
};
class ListSkillGroupsResponseBodySkillGroupsSkillGroup : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers> outboundPhoneNumbers{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> userCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> accQueueName{};
  shared_ptr<string> accSkillGroupName{};
  shared_ptr<string> skillGroupDescription{};

  ListSkillGroupsResponseBodySkillGroupsSkillGroup() {}

  explicit ListSkillGroupsResponseBodySkillGroupsSkillGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outboundPhoneNumbers) {
      res["OutboundPhoneNumbers"] = outboundPhoneNumbers ? boost::any(outboundPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (accQueueName) {
      res["AccQueueName"] = boost::any(*accQueueName);
    }
    if (accSkillGroupName) {
      res["AccSkillGroupName"] = boost::any(*accSkillGroupName);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutboundPhoneNumbers") != m.end() && !m["OutboundPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutboundPhoneNumbers"].type()) {
        ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutboundPhoneNumbers"]));
        outboundPhoneNumbers = make_shared<ListSkillGroupsResponseBodySkillGroupsSkillGroupOutboundPhoneNumbers>(model1);
      }
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("AccQueueName") != m.end() && !m["AccQueueName"].empty()) {
      accQueueName = make_shared<string>(boost::any_cast<string>(m["AccQueueName"]));
    }
    if (m.find("AccSkillGroupName") != m.end() && !m["AccSkillGroupName"].empty()) {
      accSkillGroupName = make_shared<string>(boost::any_cast<string>(m["AccSkillGroupName"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodySkillGroupsSkillGroup() = default;
};
class ListSkillGroupsResponseBodySkillGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsResponseBodySkillGroupsSkillGroup>> skillGroup{};

  ListSkillGroupsResponseBodySkillGroups() {}

  explicit ListSkillGroupsResponseBodySkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroup) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroup"].type()) {
        vector<ListSkillGroupsResponseBodySkillGroupsSkillGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsResponseBodySkillGroupsSkillGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroup = make_shared<vector<ListSkillGroupsResponseBodySkillGroupsSkillGroup>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupsResponseBodySkillGroups() = default;
};
class ListSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListSkillGroupsResponseBodySkillGroups> skillGroups{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupsResponseBody() {}

  explicit ListSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (skillGroups) {
      res["SkillGroups"] = skillGroups ? boost::any(skillGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillGroups"].type()) {
        ListSkillGroupsResponseBodySkillGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillGroups"]));
        skillGroups = make_shared<ListSkillGroupsResponseBodySkillGroups>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupsResponseBody() = default;
};
class ListSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupsResponseBody> body{};

  ListSkillGroupsResponse() {}

  explicit ListSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupsResponse() = default;
};
class ListSkillGroupsOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ListSkillGroupsOfUserRequest() {}

  explicit ListSkillGroupsOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListSkillGroupsOfUserRequest() = default;
};
class ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> province{};
  shared_ptr<string> phoneNumberId{};

  ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber() {}

  explicit ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber() = default;
};
class ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber>> phoneNumber{};

  ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers() {}

  explicit ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers() = default;
};
class ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers> outboundPhoneNumbers{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill() {}

  explicit ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outboundPhoneNumbers) {
      res["OutboundPhoneNumbers"] = outboundPhoneNumbers ? boost::any(outboundPhoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutboundPhoneNumbers") != m.end() && !m["OutboundPhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutboundPhoneNumbers"].type()) {
        ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutboundPhoneNumbers"]));
        outboundPhoneNumbers = make_shared<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkillOutboundPhoneNumbers>(model1);
      }
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill() = default;
};
class ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel() {}

  explicit ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel() = default;
};
class ListSkillGroupsOfUserResponseBodySkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel>> skillLevel{};

  ListSkillGroupsOfUserResponseBodySkillLevels() {}

  explicit ListSkillGroupsOfUserResponseBodySkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<ListSkillGroupsOfUserResponseBodySkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBodySkillLevels() = default;
};
class ListSkillGroupsOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupsOfUserResponseBodySkillLevels> skillLevels{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupsOfUserResponseBody() {}

  explicit ListSkillGroupsOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        ListSkillGroupsOfUserResponseBodySkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<ListSkillGroupsOfUserResponseBodySkillLevels>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupsOfUserResponseBody() = default;
};
class ListSkillGroupsOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupsOfUserResponseBody> body{};

  ListSkillGroupsOfUserResponse() {}

  explicit ListSkillGroupsOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupsOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupsOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupsOfUserResponse() = default;
};
class ListSkillGroupStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListSkillGroupStatesRequest() {}

  explicit ListSkillGroupStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSkillGroupStatesRequest() = default;
};
class ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState : public Darabonba::Model {
public:
  shared_ptr<long> workingAgents{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> longestCall{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> readyAgents{};
  shared_ptr<string> instanceId{};

  ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState() {}

  explicit ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (longestCall) {
      res["LongestCall"] = boost::any(*longestCall);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("LongestCall") != m.end() && !m["LongestCall"].empty()) {
      longestCall = make_shared<long>(boost::any_cast<long>(m["LongestCall"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState() = default;
};
class ListSkillGroupStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState>> realTimeSkillGroupState{};

  ListSkillGroupStatesResponseBodyDataList() {}

  explicit ListSkillGroupStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (realTimeSkillGroupState) {
      vector<boost::any> temp1;
      for(auto item1:*realTimeSkillGroupState){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RealTimeSkillGroupState"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RealTimeSkillGroupState") != m.end() && !m["RealTimeSkillGroupState"].empty()) {
      if (typeid(vector<boost::any>) == m["RealTimeSkillGroupState"].type()) {
        vector<ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RealTimeSkillGroupState"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        realTimeSkillGroupState = make_shared<vector<ListSkillGroupStatesResponseBodyDataListRealTimeSkillGroupState>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyDataList() = default;
};
class ListSkillGroupStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupStatesResponseBodyDataList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupStatesResponseBodyData() {}

  explicit ListSkillGroupStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListSkillGroupStatesResponseBodyDataList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListSkillGroupStatesResponseBodyDataList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyData() = default;
};
class ListSkillGroupStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListSkillGroupStatesResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupStatesResponseBody() {}

  explicit ListSkillGroupStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillGroupStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillGroupStatesResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBody() = default;
};
class ListSkillGroupStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupStatesResponseBody> body{};

  ListSkillGroupStatesResponse() {}

  explicit ListSkillGroupStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupStatesResponse() = default;
};
class ListSkillGroupSummaryReportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListSkillGroupSummaryReportsRequest() {}

  explicit ListSkillGroupSummaryReportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsRequest() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> queueMaxWaitTimeDuration{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> answeredByAgentOfQueueWaitTimeDuration{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> inComingQueueOfQueueCount{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> abandonedInQueueOfQueueCount{};
  shared_ptr<long> overFlowInQueueOfQueueCount{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> answeredByAgentOfQueueMaxWaitTimeDuration{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> answeredByAgentOfQueueCount{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> giveUpByAgentOfQueueCount{};
  shared_ptr<long> queueWaitTimeDuration{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (queueMaxWaitTimeDuration) {
      res["QueueMaxWaitTimeDuration"] = boost::any(*queueMaxWaitTimeDuration);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (answeredByAgentOfQueueWaitTimeDuration) {
      res["AnsweredByAgentOfQueueWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueWaitTimeDuration);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (inComingQueueOfQueueCount) {
      res["InComingQueueOfQueueCount"] = boost::any(*inComingQueueOfQueueCount);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (abandonedInQueueOfQueueCount) {
      res["AbandonedInQueueOfQueueCount"] = boost::any(*abandonedInQueueOfQueueCount);
    }
    if (overFlowInQueueOfQueueCount) {
      res["OverFlowInQueueOfQueueCount"] = boost::any(*overFlowInQueueOfQueueCount);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (answeredByAgentOfQueueMaxWaitTimeDuration) {
      res["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueMaxWaitTimeDuration);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (answeredByAgentOfQueueCount) {
      res["AnsweredByAgentOfQueueCount"] = boost::any(*answeredByAgentOfQueueCount);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (giveUpByAgentOfQueueCount) {
      res["GiveUpByAgentOfQueueCount"] = boost::any(*giveUpByAgentOfQueueCount);
    }
    if (queueWaitTimeDuration) {
      res["QueueWaitTimeDuration"] = boost::any(*queueWaitTimeDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("QueueMaxWaitTimeDuration") != m.end() && !m["QueueMaxWaitTimeDuration"].empty()) {
      queueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("AnsweredByAgentOfQueueWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueWaitTimeDuration"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("InComingQueueOfQueueCount") != m.end() && !m["InComingQueueOfQueueCount"].empty()) {
      inComingQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["InComingQueueOfQueueCount"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("AbandonedInQueueOfQueueCount") != m.end() && !m["AbandonedInQueueOfQueueCount"].empty()) {
      abandonedInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AbandonedInQueueOfQueueCount"]));
    }
    if (m.find("OverFlowInQueueOfQueueCount") != m.end() && !m["OverFlowInQueueOfQueueCount"].empty()) {
      overFlowInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["OverFlowInQueueOfQueueCount"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AnsweredByAgentOfQueueMaxWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueMaxWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AnsweredByAgentOfQueueCount") != m.end() && !m["AnsweredByAgentOfQueueCount"].empty()) {
      answeredByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueCount"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("GiveUpByAgentOfQueueCount") != m.end() && !m["GiveUpByAgentOfQueueCount"].empty()) {
      giveUpByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["GiveUpByAgentOfQueueCount"]));
    }
    if (m.find("QueueWaitTimeDuration") != m.end() && !m["QueueWaitTimeDuration"].empty()) {
      queueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueWaitTimeDuration"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound> inbound{};
  shared_ptr<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound> outbound{};
  shared_ptr<string> instanceId{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport>> skillGroupSummaryReport{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroupSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroupSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupSummaryReport") != m.end() && !m["SkillGroupSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroupSummaryReport"].type()) {
        vector<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroupSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroupSummaryReport = make_shared<vector<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList() = default;
};
class ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport> pagedSkillGroupSummaryReport{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupSummaryReportsResponseBody() {}

  explicit ListSkillGroupSummaryReportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagedSkillGroupSummaryReport) {
      res["PagedSkillGroupSummaryReport"] = pagedSkillGroupSummaryReport ? boost::any(pagedSkillGroupSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagedSkillGroupSummaryReport") != m.end() && !m["PagedSkillGroupSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedSkillGroupSummaryReport"].type()) {
        ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedSkillGroupSummaryReport"]));
        pagedSkillGroupSummaryReport = make_shared<ListSkillGroupSummaryReportsResponseBodyPagedSkillGroupSummaryReport>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponseBody() = default;
};
class ListSkillGroupSummaryReportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupSummaryReportsResponseBody> body{};

  ListSkillGroupSummaryReportsResponse() {}

  explicit ListSkillGroupSummaryReportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupSummaryReportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupSummaryReportsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsResponse() = default;
};
class ListSkillGroupSummaryReportsByIntervalRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> interval{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListSkillGroupSummaryReportsByIntervalRequest() {}

  explicit ListSkillGroupSummaryReportsByIntervalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalRequest() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> queueMaxWaitTimeDuration{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> answeredByAgentOfQueueWaitTimeDuration{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> inComingQueueOfQueueCount{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> abandonedInQueueOfQueueCount{};
  shared_ptr<long> overFlowInQueueOfQueueCount{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> answeredByAgentOfQueueMaxWaitTimeDuration{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> answeredByAgentOfQueueCount{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> giveUpByAgentOfQueueCount{};
  shared_ptr<long> queueWaitTimeDuration{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (queueMaxWaitTimeDuration) {
      res["QueueMaxWaitTimeDuration"] = boost::any(*queueMaxWaitTimeDuration);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (answeredByAgentOfQueueWaitTimeDuration) {
      res["AnsweredByAgentOfQueueWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueWaitTimeDuration);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (inComingQueueOfQueueCount) {
      res["InComingQueueOfQueueCount"] = boost::any(*inComingQueueOfQueueCount);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (abandonedInQueueOfQueueCount) {
      res["AbandonedInQueueOfQueueCount"] = boost::any(*abandonedInQueueOfQueueCount);
    }
    if (overFlowInQueueOfQueueCount) {
      res["OverFlowInQueueOfQueueCount"] = boost::any(*overFlowInQueueOfQueueCount);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (answeredByAgentOfQueueMaxWaitTimeDuration) {
      res["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueMaxWaitTimeDuration);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (answeredByAgentOfQueueCount) {
      res["AnsweredByAgentOfQueueCount"] = boost::any(*answeredByAgentOfQueueCount);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (giveUpByAgentOfQueueCount) {
      res["GiveUpByAgentOfQueueCount"] = boost::any(*giveUpByAgentOfQueueCount);
    }
    if (queueWaitTimeDuration) {
      res["QueueWaitTimeDuration"] = boost::any(*queueWaitTimeDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("QueueMaxWaitTimeDuration") != m.end() && !m["QueueMaxWaitTimeDuration"].empty()) {
      queueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("AnsweredByAgentOfQueueWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueWaitTimeDuration"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("InComingQueueOfQueueCount") != m.end() && !m["InComingQueueOfQueueCount"].empty()) {
      inComingQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["InComingQueueOfQueueCount"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("AbandonedInQueueOfQueueCount") != m.end() && !m["AbandonedInQueueOfQueueCount"].empty()) {
      abandonedInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AbandonedInQueueOfQueueCount"]));
    }
    if (m.find("OverFlowInQueueOfQueueCount") != m.end() && !m["OverFlowInQueueOfQueueCount"].empty()) {
      overFlowInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["OverFlowInQueueOfQueueCount"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AnsweredByAgentOfQueueMaxWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueMaxWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AnsweredByAgentOfQueueCount") != m.end() && !m["AnsweredByAgentOfQueueCount"].empty()) {
      answeredByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueCount"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("GiveUpByAgentOfQueueCount") != m.end() && !m["GiveUpByAgentOfQueueCount"].empty()) {
      giveUpByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["GiveUpByAgentOfQueueCount"]));
    }
    if (m.find("QueueWaitTimeDuration") != m.end() && !m["QueueWaitTimeDuration"].empty()) {
      queueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueWaitTimeDuration"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall> overall{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound> inbound{};
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound> outbound{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> instanceId{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOverall>(model1);
      }
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReportOutbound>(model1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport>> skillGroupSummaryReport{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroupSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroupSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupSummaryReport") != m.end() && !m["SkillGroupSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroupSummaryReport"].type()) {
        vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroupSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroupSummaryReport = make_shared<vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalListSkillGroupSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList> intervalList{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (intervalList) {
      res["IntervalList"] = intervalList ? boost::any(intervalList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("IntervalList") != m.end() && !m["IntervalList"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntervalList"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntervalList"]));
        intervalList = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReportIntervalList>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport>> skillGroupTimeIntervalReport{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupTimeIntervalReport) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroupTimeIntervalReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroupTimeIntervalReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupTimeIntervalReport") != m.end() && !m["SkillGroupTimeIntervalReport"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroupTimeIntervalReport"].type()) {
        vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroupTimeIntervalReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroupTimeIntervalReport = make_shared<vector<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportListSkillGroupTimeIntervalReport>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport> pagedSkillGroupSummaryReport{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupSummaryReportsByIntervalResponseBody() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagedSkillGroupSummaryReport) {
      res["PagedSkillGroupSummaryReport"] = pagedSkillGroupSummaryReport ? boost::any(pagedSkillGroupSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagedSkillGroupSummaryReport") != m.end() && !m["PagedSkillGroupSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedSkillGroupSummaryReport"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedSkillGroupSummaryReport"]));
        pagedSkillGroupSummaryReport = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBodyPagedSkillGroupSummaryReport>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponseBody() = default;
};
class ListSkillGroupSummaryReportsByIntervalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupSummaryReportsByIntervalResponseBody> body{};

  ListSkillGroupSummaryReportsByIntervalResponse() {}

  explicit ListSkillGroupSummaryReportsByIntervalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupSummaryReportsByIntervalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupSummaryReportsByIntervalResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsByIntervalResponse() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListSkillGroupSummaryReportsSinceMidnightRequest() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroups) {
      res["SkillGroups"] = boost::any(*skillGroups);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      skillGroups = make_shared<string>(boost::any_cast<string>(m["SkillGroups"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightRequest() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> totalCalls{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound : public Darabonba::Model {
public:
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> queueMaxWaitTimeDuration{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> answeredByAgentOfQueueWaitTimeDuration{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> inComingQueueOfQueueCount{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> abandonedInQueueOfQueueCount{};
  shared_ptr<long> overFlowInQueueOfQueueCount{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> answeredByAgentOfQueueMaxWaitTimeDuration{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> answeredByAgentOfQueueCount{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> giveUpByAgentOfQueueCount{};
  shared_ptr<long> queueWaitTimeDuration{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (queueMaxWaitTimeDuration) {
      res["QueueMaxWaitTimeDuration"] = boost::any(*queueMaxWaitTimeDuration);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (answeredByAgentOfQueueWaitTimeDuration) {
      res["AnsweredByAgentOfQueueWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueWaitTimeDuration);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (inComingQueueOfQueueCount) {
      res["InComingQueueOfQueueCount"] = boost::any(*inComingQueueOfQueueCount);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (abandonedInQueueOfQueueCount) {
      res["AbandonedInQueueOfQueueCount"] = boost::any(*abandonedInQueueOfQueueCount);
    }
    if (overFlowInQueueOfQueueCount) {
      res["OverFlowInQueueOfQueueCount"] = boost::any(*overFlowInQueueOfQueueCount);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (answeredByAgentOfQueueMaxWaitTimeDuration) {
      res["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueMaxWaitTimeDuration);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (answeredByAgentOfQueueCount) {
      res["AnsweredByAgentOfQueueCount"] = boost::any(*answeredByAgentOfQueueCount);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (giveUpByAgentOfQueueCount) {
      res["GiveUpByAgentOfQueueCount"] = boost::any(*giveUpByAgentOfQueueCount);
    }
    if (queueWaitTimeDuration) {
      res["QueueWaitTimeDuration"] = boost::any(*queueWaitTimeDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("QueueMaxWaitTimeDuration") != m.end() && !m["QueueMaxWaitTimeDuration"].empty()) {
      queueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("AnsweredByAgentOfQueueWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueWaitTimeDuration"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("InComingQueueOfQueueCount") != m.end() && !m["InComingQueueOfQueueCount"].empty()) {
      inComingQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["InComingQueueOfQueueCount"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("AbandonedInQueueOfQueueCount") != m.end() && !m["AbandonedInQueueOfQueueCount"].empty()) {
      abandonedInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AbandonedInQueueOfQueueCount"]));
    }
    if (m.find("OverFlowInQueueOfQueueCount") != m.end() && !m["OverFlowInQueueOfQueueCount"].empty()) {
      overFlowInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["OverFlowInQueueOfQueueCount"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("AnsweredByAgentOfQueueMaxWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueMaxWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueMaxWaitTimeDuration"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AnsweredByAgentOfQueueCount") != m.end() && !m["AnsweredByAgentOfQueueCount"].empty()) {
      answeredByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueCount"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("GiveUpByAgentOfQueueCount") != m.end() && !m["GiveUpByAgentOfQueueCount"].empty()) {
      giveUpByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["GiveUpByAgentOfQueueCount"]));
    }
    if (m.find("QueueWaitTimeDuration") != m.end() && !m["QueueWaitTimeDuration"].empty()) {
      queueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueWaitTimeDuration"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound : public Darabonba::Model {
public:
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> totalWorkTime{};
  shared_ptr<double> answerRate{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> averageDialingTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall> overall{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound> inbound{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound> outbound{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> instanceId{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOverall>(model1);
      }
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReportOutbound>(model1);
      }
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport>> skillGroupSummaryReport{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupSummaryReport) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroupSummaryReport){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroupSummaryReport"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupSummaryReport") != m.end() && !m["SkillGroupSummaryReport"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroupSummaryReport"].type()) {
        vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroupSummaryReport"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroupSummaryReport = make_shared<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListSkillGroupSummaryReport>>(expect1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport> pagedSkillGroupSummaryReport{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBody() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagedSkillGroupSummaryReport) {
      res["PagedSkillGroupSummaryReport"] = pagedSkillGroupSummaryReport ? boost::any(pagedSkillGroupSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PagedSkillGroupSummaryReport") != m.end() && !m["PagedSkillGroupSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedSkillGroupSummaryReport"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedSkillGroupSummaryReport"]));
        pagedSkillGroupSummaryReport = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBody() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBody> body{};

  ListSkillGroupSummaryReportsSinceMidnightResponse() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponse() = default;
};
class ListSurveysRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};

  ListSurveysRequest() {}

  explicit ListSurveysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
  }


  virtual ~ListSurveysRequest() = default;
};
class ListSurveysResponseBodySurveysAsrCustomModel : public Darabonba::Model {
public:
  shared_ptr<long> customModelStatus{};
  shared_ptr<string> corpora{};

  ListSurveysResponseBodySurveysAsrCustomModel() {}

  explicit ListSurveysResponseBodySurveysAsrCustomModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customModelStatus) {
      res["CustomModelStatus"] = boost::any(*customModelStatus);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomModelStatus") != m.end() && !m["CustomModelStatus"].empty()) {
      customModelStatus = make_shared<long>(boost::any_cast<long>(m["CustomModelStatus"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
  }


  virtual ~ListSurveysResponseBodySurveysAsrCustomModel() = default;
};
class ListSurveysResponseBodySurveysFlow : public Darabonba::Model {
public:
  shared_ptr<bool> isPublished{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> flowId{};

  ListSurveysResponseBodySurveysFlow() {}

  explicit ListSurveysResponseBodySurveysFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPublished) {
      res["IsPublished"] = boost::any(*isPublished);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPublished") != m.end() && !m["IsPublished"].empty()) {
      isPublished = make_shared<bool>(boost::any_cast<bool>(m["IsPublished"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~ListSurveysResponseBodySurveysFlow() = default;
};
class ListSurveysResponseBodySurveys : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestions{};
  shared_ptr<long> round{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> description{};
  shared_ptr<string> hotWords{};
  shared_ptr<ListSurveysResponseBodySurveysAsrCustomModel> asrCustomModel{};
  shared_ptr<ListSurveysResponseBodySurveysFlow> flow{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> scenarioUuid{};
  shared_ptr<string> id{};

  ListSurveysResponseBodySurveys() {}

  explicit ListSurveysResponseBodySurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotWords) {
      res["HotWords"] = boost::any(*hotWords);
    }
    if (asrCustomModel) {
      res["AsrCustomModel"] = asrCustomModel ? boost::any(asrCustomModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scenarioUuid) {
      res["ScenarioUuid"] = boost::any(*scenarioUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotWords") != m.end() && !m["HotWords"].empty()) {
      hotWords = make_shared<string>(boost::any_cast<string>(m["HotWords"]));
    }
    if (m.find("AsrCustomModel") != m.end() && !m["AsrCustomModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrCustomModel"].type()) {
        ListSurveysResponseBodySurveysAsrCustomModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrCustomModel"]));
        asrCustomModel = make_shared<ListSurveysResponseBodySurveysAsrCustomModel>(model1);
      }
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ListSurveysResponseBodySurveysFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ListSurveysResponseBodySurveysFlow>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScenarioUuid") != m.end() && !m["ScenarioUuid"].empty()) {
      scenarioUuid = make_shared<string>(boost::any_cast<string>(m["ScenarioUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListSurveysResponseBodySurveys() = default;
};
class ListSurveysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSurveysResponseBodySurveys>> surveys{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListSurveysResponseBody() {}

  explicit ListSurveysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<ListSurveysResponseBodySurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSurveysResponseBodySurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<ListSurveysResponseBodySurveys>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSurveysResponseBody() = default;
};
class ListSurveysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSurveysResponseBody> body{};

  ListSurveysResponse() {}

  explicit ListSurveysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSurveysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSurveysResponseBody>(model1);
      }
    }
  }


  virtual ~ListSurveysResponse() = default;
};
class ListTransferableSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListTransferableSkillGroupsRequest() {}

  explicit ListTransferableSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListTransferableSkillGroupsRequest() = default;
};
class ListTransferableSkillGroupsResponseBodySkillGroups : public Darabonba::Model {
public:
  shared_ptr<bool> allowPrivateOutboundNumber{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> userCount{};
  shared_ptr<string> accQueueName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};
  shared_ptr<string> accSkillGroupName{};

  ListTransferableSkillGroupsResponseBodySkillGroups() {}

  explicit ListTransferableSkillGroupsResponseBodySkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowPrivateOutboundNumber) {
      res["AllowPrivateOutboundNumber"] = boost::any(*allowPrivateOutboundNumber);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (accQueueName) {
      res["AccQueueName"] = boost::any(*accQueueName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    if (accSkillGroupName) {
      res["AccSkillGroupName"] = boost::any(*accSkillGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowPrivateOutboundNumber") != m.end() && !m["AllowPrivateOutboundNumber"].empty()) {
      allowPrivateOutboundNumber = make_shared<bool>(boost::any_cast<bool>(m["AllowPrivateOutboundNumber"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("AccQueueName") != m.end() && !m["AccQueueName"].empty()) {
      accQueueName = make_shared<string>(boost::any_cast<string>(m["AccQueueName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
    if (m.find("AccSkillGroupName") != m.end() && !m["AccSkillGroupName"].empty()) {
      accSkillGroupName = make_shared<string>(boost::any_cast<string>(m["AccSkillGroupName"]));
    }
  }


  virtual ~ListTransferableSkillGroupsResponseBodySkillGroups() = default;
};
class ListTransferableSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListTransferableSkillGroupsResponseBodySkillGroups>> skillGroups{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListTransferableSkillGroupsResponseBody() {}

  explicit ListTransferableSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<ListTransferableSkillGroupsResponseBodySkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTransferableSkillGroupsResponseBodySkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<ListTransferableSkillGroupsResponseBodySkillGroups>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTransferableSkillGroupsResponseBody() = default;
};
class ListTransferableSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTransferableSkillGroupsResponseBody> body{};

  ListTransferableSkillGroupsResponse() {}

  explicit ListTransferableSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTransferableSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTransferableSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTransferableSkillGroupsResponse() = default;
};
class ListTrunkProvidersResponseBodyTrunkProviders : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> providerName{};

  ListTrunkProvidersResponseBodyTrunkProviders() {}

  explicit ListTrunkProvidersResponseBodyTrunkProviders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
  }


  virtual ~ListTrunkProvidersResponseBodyTrunkProviders() = default;
};
class ListTrunkProvidersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListTrunkProvidersResponseBodyTrunkProviders>> trunkProviders{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListTrunkProvidersResponseBody() {}

  explicit ListTrunkProvidersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (trunkProviders) {
      vector<boost::any> temp1;
      for(auto item1:*trunkProviders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrunkProviders"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("TrunkProviders") != m.end() && !m["TrunkProviders"].empty()) {
      if (typeid(vector<boost::any>) == m["TrunkProviders"].type()) {
        vector<ListTrunkProvidersResponseBodyTrunkProviders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrunkProviders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrunkProvidersResponseBodyTrunkProviders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trunkProviders = make_shared<vector<ListTrunkProvidersResponseBodyTrunkProviders>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTrunkProvidersResponseBody() = default;
};
class ListTrunkProvidersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTrunkProvidersResponseBody> body{};

  ListTrunkProvidersResponse() {}

  explicit ListTrunkProvidersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrunkProvidersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrunkProvidersResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrunkProvidersResponse() = default;
};
class ListTrunksOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  ListTrunksOfSkillGroupRequest() {}

  explicit ListTrunksOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListTrunksOfSkillGroupRequest() = default;
};
class ListTrunksOfSkillGroupResponseBodyTrunkConfigs : public Darabonba::Model {
public:
  shared_ptr<string> providerName{};
  shared_ptr<bool> primary{};

  ListTrunksOfSkillGroupResponseBodyTrunkConfigs() {}

  explicit ListTrunksOfSkillGroupResponseBodyTrunkConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
  }


  virtual ~ListTrunksOfSkillGroupResponseBodyTrunkConfigs() = default;
};
class ListTrunksOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListTrunksOfSkillGroupResponseBodyTrunkConfigs>> trunkConfigs{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListTrunksOfSkillGroupResponseBody() {}

  explicit ListTrunksOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (trunkConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*trunkConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrunkConfigs"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("TrunkConfigs") != m.end() && !m["TrunkConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TrunkConfigs"].type()) {
        vector<ListTrunksOfSkillGroupResponseBodyTrunkConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrunkConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrunksOfSkillGroupResponseBodyTrunkConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trunkConfigs = make_shared<vector<ListTrunksOfSkillGroupResponseBodyTrunkConfigs>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTrunksOfSkillGroupResponseBody() = default;
};
class ListTrunksOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTrunksOfSkillGroupResponseBody> body{};

  ListTrunksOfSkillGroupResponse() {}

  explicit ListTrunksOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrunksOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrunksOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrunksOfSkillGroupResponse() = default;
};
class ListUnreachableContactsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUnreachableContactsRequest() {}

  explicit ListUnreachableContactsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUnreachableContactsRequest() = default;
};
class ListUnreachableContactsResponseBodyUnreachableContactsListContacts : public Darabonba::Model {
public:
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> contactId{};
  shared_ptr<string> state{};
  shared_ptr<string> contactName{};
  shared_ptr<string> role{};
  shared_ptr<string> referenceId{};

  ListUnreachableContactsResponseBodyUnreachableContactsListContacts() {}

  explicit ListUnreachableContactsResponseBodyUnreachableContactsListContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (contactName) {
      res["ContactName"] = boost::any(*contactName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ContactName") != m.end() && !m["ContactName"].empty()) {
      contactName = make_shared<string>(boost::any_cast<string>(m["ContactName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~ListUnreachableContactsResponseBodyUnreachableContactsListContacts() = default;
};
class ListUnreachableContactsResponseBodyUnreachableContactsList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUnreachableContactsResponseBodyUnreachableContactsListContacts>> contacts{};
  shared_ptr<long> totalAttempts{};

  ListUnreachableContactsResponseBodyUnreachableContactsList() {}

  explicit ListUnreachableContactsResponseBodyUnreachableContactsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contacts) {
      vector<boost::any> temp1;
      for(auto item1:*contacts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contacts"] = boost::any(temp1);
    }
    if (totalAttempts) {
      res["TotalAttempts"] = boost::any(*totalAttempts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contacts") != m.end() && !m["Contacts"].empty()) {
      if (typeid(vector<boost::any>) == m["Contacts"].type()) {
        vector<ListUnreachableContactsResponseBodyUnreachableContactsListContacts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contacts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUnreachableContactsResponseBodyUnreachableContactsListContacts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contacts = make_shared<vector<ListUnreachableContactsResponseBodyUnreachableContactsListContacts>>(expect1);
      }
    }
    if (m.find("TotalAttempts") != m.end() && !m["TotalAttempts"].empty()) {
      totalAttempts = make_shared<long>(boost::any_cast<long>(m["TotalAttempts"]));
    }
  }


  virtual ~ListUnreachableContactsResponseBodyUnreachableContactsList() = default;
};
class ListUnreachableContactsResponseBodyUnreachableContacts : public Darabonba::Model {
public:
  shared_ptr<vector<ListUnreachableContactsResponseBodyUnreachableContactsList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUnreachableContactsResponseBodyUnreachableContacts() {}

  explicit ListUnreachableContactsResponseBodyUnreachableContacts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUnreachableContactsResponseBodyUnreachableContactsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUnreachableContactsResponseBodyUnreachableContactsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUnreachableContactsResponseBodyUnreachableContactsList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUnreachableContactsResponseBodyUnreachableContacts() = default;
};
class ListUnreachableContactsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUnreachableContactsResponseBodyUnreachableContacts> unreachableContacts{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListUnreachableContactsResponseBody() {}

  explicit ListUnreachableContactsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unreachableContacts) {
      res["UnreachableContacts"] = unreachableContacts ? boost::any(unreachableContacts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UnreachableContacts") != m.end() && !m["UnreachableContacts"].empty()) {
      if (typeid(map<string, boost::any>) == m["UnreachableContacts"].type()) {
        ListUnreachableContactsResponseBodyUnreachableContacts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UnreachableContacts"]));
        unreachableContacts = make_shared<ListUnreachableContactsResponseBodyUnreachableContacts>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListUnreachableContactsResponseBody() = default;
};
class ListUnreachableContactsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUnreachableContactsResponseBody> body{};

  ListUnreachableContactsResponse() {}

  explicit ListUnreachableContactsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUnreachableContactsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUnreachableContactsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUnreachableContactsResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill() {}

  explicit ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill() = default;
};
class ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel() {}

  explicit ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<ListUsersResponseBodyUsersListUserSkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel() = default;
};
class ListUsersResponseBodyUsersListUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel>> skillLevel{};

  ListUsersResponseBodyUsersListUserSkillLevels() {}

  explicit ListUsersResponseBodyUsersListUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<ListUsersResponseBodyUsersListUserSkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserSkillLevels() = default;
};
class ListUsersResponseBodyUsersListUserRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  ListUsersResponseBodyUsersListUserRolesRole() {}

  explicit ListUsersResponseBodyUsersListUserRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserRolesRole() = default;
};
class ListUsersResponseBodyUsersListUserRoles : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyUsersListUserRolesRole>> role{};

  ListUsersResponseBodyUsersListUserRoles() {}

  explicit ListUsersResponseBodyUsersListUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<ListUsersResponseBodyUsersListUserRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUsersListUserRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<ListUsersResponseBodyUsersListUserRolesRole>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserRoles() = default;
};
class ListUsersResponseBodyUsersListUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  ListUsersResponseBodyUsersListUserDetail() {}

  explicit ListUsersResponseBodyUsersListUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListUsersResponseBodyUsersListUserDetail() = default;
};
class ListUsersResponseBodyUsersListUser : public Darabonba::Model {
public:
  shared_ptr<ListUsersResponseBodyUsersListUserSkillLevels> skillLevels{};
  shared_ptr<string> privateOutboundNumberId{};
  shared_ptr<string> userId{};
  shared_ptr<ListUsersResponseBodyUsersListUserRoles> roles{};
  shared_ptr<bool> primary{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<ListUsersResponseBodyUsersListUserDetail> detail{};

  ListUsersResponseBodyUsersListUser() {}

  explicit ListUsersResponseBodyUsersListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateOutboundNumberId) {
      res["PrivateOutboundNumberId"] = boost::any(*privateOutboundNumberId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        ListUsersResponseBodyUsersListUserSkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<ListUsersResponseBodyUsersListUserSkillLevels>(model1);
      }
    }
    if (m.find("PrivateOutboundNumberId") != m.end() && !m["PrivateOutboundNumberId"].empty()) {
      privateOutboundNumberId = make_shared<string>(boost::any_cast<string>(m["PrivateOutboundNumberId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        ListUsersResponseBodyUsersListUserRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<ListUsersResponseBodyUsersListUserRoles>(model1);
      }
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        ListUsersResponseBodyUsersListUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<ListUsersResponseBodyUsersListUserDetail>(model1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUsersListUser() = default;
};
class ListUsersResponseBodyUsersList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyUsersListUser>> user{};

  ListUsersResponseBodyUsersList() {}

  explicit ListUsersResponseBodyUsersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListUsersResponseBodyUsersListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUsersListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListUsersResponseBodyUsersListUser>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBodyUsersList() = default;
};
class ListUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<ListUsersResponseBodyUsersList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUsersResponseBodyUsers() {}

  explicit ListUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListUsersResponseBodyUsersList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListUsersResponseBodyUsersList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUsersResponseBodyUsers() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListUsersResponseBodyUsers> users{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListUsersResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListUsersResponseBodyUsers>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class ListUsersOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListUsersOfSkillGroupRequest() {}

  explicit ListUsersOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUsersOfSkillGroupRequest() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupDescription{};

  ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupDescription) {
      res["SkillGroupDescription"] = boost::any(*skillGroupDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupDescription") != m.end() && !m["SkillGroupDescription"].empty()) {
      skillGroupDescription = make_shared<string>(boost::any_cast<string>(m["SkillGroupDescription"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel : public Darabonba::Model {
public:
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill> skill{};
  shared_ptr<string> skillLevelId{};
  shared_ptr<long> level{};

  ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skill) {
      res["Skill"] = skill ? boost::any(skill->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillLevelId) {
      res["SkillLevelId"] = boost::any(*skillLevelId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Skill") != m.end() && !m["Skill"].empty()) {
      if (typeid(map<string, boost::any>) == m["Skill"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Skill"]));
        skill = make_shared<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevelSkill>(model1);
      }
    }
    if (m.find("SkillLevelId") != m.end() && !m["SkillLevelId"].empty()) {
      skillLevelId = make_shared<string>(boost::any_cast<string>(m["SkillLevelId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel>> skillLevel{};

  ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevel) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevel = make_shared<vector<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevelsSkillLevel>>(expect1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege : public Darabonba::Model {
public:
  shared_ptr<string> privilegeName{};
  shared_ptr<string> privilegeId{};
  shared_ptr<string> privilegeDescription{};

  ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privilegeName) {
      res["PrivilegeName"] = boost::any(*privilegeName);
    }
    if (privilegeId) {
      res["PrivilegeId"] = boost::any(*privilegeId);
    }
    if (privilegeDescription) {
      res["PrivilegeDescription"] = boost::any(*privilegeDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivilegeName") != m.end() && !m["PrivilegeName"].empty()) {
      privilegeName = make_shared<string>(boost::any_cast<string>(m["PrivilegeName"]));
    }
    if (m.find("PrivilegeId") != m.end() && !m["PrivilegeId"].empty()) {
      privilegeId = make_shared<string>(boost::any_cast<string>(m["PrivilegeId"]));
    }
    if (m.find("PrivilegeDescription") != m.end() && !m["PrivilegeDescription"].empty()) {
      privilegeDescription = make_shared<string>(boost::any_cast<string>(m["PrivilegeDescription"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege>> privilege{};

  ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privilege) {
      vector<boost::any> temp1;
      for(auto item1:*privilege){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Privilege"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Privilege") != m.end() && !m["Privilege"].empty()) {
      if (typeid(vector<boost::any>) == m["Privilege"].type()) {
        vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Privilege"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        privilege = make_shared<vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivilegesPrivilege>>(expect1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges> privileges{};
  shared_ptr<long> userCount{};
  shared_ptr<string> roleName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleId{};

  ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (privileges) {
      res["Privileges"] = privileges ? boost::any(privileges->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("Privileges") != m.end() && !m["Privileges"].empty()) {
      if (typeid(map<string, boost::any>) == m["Privileges"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Privileges"]));
        privileges = make_shared<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRolePrivileges>(model1);
      }
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserRoles : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole>> role{};

  ListUsersOfSkillGroupResponseBodyUsersListUserRoles() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<ListUsersOfSkillGroupResponseBodyUsersListUserRolesRole>>(expect1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserRoles() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUserDetail : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> department{};
  shared_ptr<string> phone{};

  ListUsersOfSkillGroupResponseBodyUsersListUserDetail() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUserDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (department) {
      res["Department"] = boost::any(*department);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Department") != m.end() && !m["Department"].empty()) {
      department = make_shared<string>(boost::any_cast<string>(m["Department"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUserDetail() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersListUser : public Darabonba::Model {
public:
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels> skillLevels{};
  shared_ptr<string> userId{};
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersListUserRoles> roles{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersListUserDetail> detail{};

  ListUsersOfSkillGroupResponseBodyUsersListUser() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersListUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillLevels) {
      res["SkillLevels"] = skillLevels ? boost::any(skillLevels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (detail) {
      res["Detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillLevels") != m.end() && !m["SkillLevels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillLevels"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillLevels"]));
        skillLevels = make_shared<ListUsersOfSkillGroupResponseBodyUsersListUserSkillLevels>(model1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersListUserRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<ListUsersOfSkillGroupResponseBodyUsersListUserRoles>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["Detail"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersListUserDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Detail"]));
        detail = make_shared<ListUsersOfSkillGroupResponseBodyUsersListUserDetail>(model1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersListUser() = default;
};
class ListUsersOfSkillGroupResponseBodyUsersList : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersOfSkillGroupResponseBodyUsersListUser>> user{};

  ListUsersOfSkillGroupResponseBodyUsersList() {}

  explicit ListUsersOfSkillGroupResponseBodyUsersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<ListUsersOfSkillGroupResponseBodyUsersListUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersOfSkillGroupResponseBodyUsersListUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<ListUsersOfSkillGroupResponseBodyUsersListUser>>(expect1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsersList() = default;
};
class ListUsersOfSkillGroupResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsersList> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUsersOfSkillGroupResponseBodyUsers() {}

  explicit ListUsersOfSkillGroupResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      res["List"] = list ? boost::any(list->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(map<string, boost::any>) == m["List"].type()) {
        ListUsersOfSkillGroupResponseBodyUsersList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["List"]));
        list = make_shared<ListUsersOfSkillGroupResponseBodyUsersList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBodyUsers() = default;
};
class ListUsersOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListUsersOfSkillGroupResponseBodyUsers> users{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ListUsersOfSkillGroupResponseBody() {}

  explicit ListUsersOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListUsersOfSkillGroupResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListUsersOfSkillGroupResponseBodyUsers>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListUsersOfSkillGroupResponseBody() = default;
};
class ListUsersOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUsersOfSkillGroupResponseBody> body{};

  ListUsersOfSkillGroupResponse() {}

  explicit ListUsersOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersOfSkillGroupResponse() = default;
};
class ListVoiceAppraiseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListVoiceAppraiseRequest() {}

  explicit ListVoiceAppraiseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListVoiceAppraiseRequest() = default;
};
class ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<long> trunks{};
  shared_ptr<string> number{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<string> phoneNumberId{};

  ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber() {}

  explicit ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber() = default;
};
class ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers : public Darabonba::Model {
public:
  shared_ptr<vector<ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber>> phoneNumber{};

  ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers() {}

  explicit ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phoneNumber) {
      vector<boost::any> temp1;
      for(auto item1:*phoneNumber){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PhoneNumber"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(vector<boost::any>) == m["PhoneNumber"].type()) {
        vector<ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PhoneNumber"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phoneNumber = make_shared<vector<ListVoiceAppraiseResponseBodyContactFlowPhoneNumbersPhoneNumber>>(expect1);
      }
    }
  }


  virtual ~ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers() = default;
};
class ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> lastModified{};
  shared_ptr<string> version{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<string> contactFlowVersionDescription{};
  shared_ptr<string> lastModifiedBy{};
  shared_ptr<string> content{};

  ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion() {}

  explicit ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (lastModified) {
      res["LastModified"] = boost::any(*lastModified);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (contactFlowVersionDescription) {
      res["ContactFlowVersionDescription"] = boost::any(*contactFlowVersionDescription);
    }
    if (lastModifiedBy) {
      res["LastModifiedBy"] = boost::any(*lastModifiedBy);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("LastModified") != m.end() && !m["LastModified"].empty()) {
      lastModified = make_shared<string>(boost::any_cast<string>(m["LastModified"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("ContactFlowVersionDescription") != m.end() && !m["ContactFlowVersionDescription"].empty()) {
      contactFlowVersionDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionDescription"]));
    }
    if (m.find("LastModifiedBy") != m.end() && !m["LastModifiedBy"].empty()) {
      lastModifiedBy = make_shared<string>(boost::any_cast<string>(m["LastModifiedBy"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion() = default;
};
class ListVoiceAppraiseResponseBodyContactFlowVersions : public Darabonba::Model {
public:
  shared_ptr<vector<ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion>> contactFlowVersion{};

  ListVoiceAppraiseResponseBodyContactFlowVersions() {}

  explicit ListVoiceAppraiseResponseBodyContactFlowVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowVersion) {
      vector<boost::any> temp1;
      for(auto item1:*contactFlowVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContactFlowVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowVersion") != m.end() && !m["ContactFlowVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["ContactFlowVersion"].type()) {
        vector<ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContactFlowVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contactFlowVersion = make_shared<vector<ListVoiceAppraiseResponseBodyContactFlowVersionsContactFlowVersion>>(expect1);
      }
    }
  }


  virtual ~ListVoiceAppraiseResponseBodyContactFlowVersions() = default;
};
class ListVoiceAppraiseResponseBodyContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> type{};
  shared_ptr<ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers> phoneNumbers{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<ListVoiceAppraiseResponseBodyContactFlowVersions> versions{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> appliedVersion{};

  ListVoiceAppraiseResponseBodyContactFlow() {}

  explicit ListVoiceAppraiseResponseBodyContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = phoneNumbers ? boost::any(phoneNumbers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (versions) {
      res["Versions"] = versions ? boost::any(versions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (appliedVersion) {
      res["AppliedVersion"] = boost::any(*appliedVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumbers"].type()) {
        ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumbers"]));
        phoneNumbers = make_shared<ListVoiceAppraiseResponseBodyContactFlowPhoneNumbers>(model1);
      }
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("Versions") != m.end() && !m["Versions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Versions"].type()) {
        ListVoiceAppraiseResponseBodyContactFlowVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Versions"]));
        versions = make_shared<ListVoiceAppraiseResponseBodyContactFlowVersions>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("AppliedVersion") != m.end() && !m["AppliedVersion"].empty()) {
      appliedVersion = make_shared<string>(boost::any_cast<string>(m["AppliedVersion"]));
    }
  }


  virtual ~ListVoiceAppraiseResponseBodyContactFlow() = default;
};
class ListVoiceAppraiseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> notice{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<ListVoiceAppraiseResponseBodyContactFlow> contactFlow{};
  shared_ptr<bool> success{};

  ListVoiceAppraiseResponseBody() {}

  explicit ListVoiceAppraiseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (notice) {
      res["Notice"] = boost::any(*notice);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Notice") != m.end() && !m["Notice"].empty()) {
      notice = make_shared<string>(boost::any_cast<string>(m["Notice"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        ListVoiceAppraiseResponseBodyContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<ListVoiceAppraiseResponseBodyContactFlow>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListVoiceAppraiseResponseBody() = default;
};
class ListVoiceAppraiseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListVoiceAppraiseResponseBody> body{};

  ListVoiceAppraiseResponse() {}

  explicit ListVoiceAppraiseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVoiceAppraiseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVoiceAppraiseResponseBody>(model1);
      }
    }
  }


  virtual ~ListVoiceAppraiseResponse() = default;
};
class ModifyAgentDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<long> isLogin{};
  shared_ptr<long> agentDeviceId{};
  shared_ptr<string> instanceId{};

  ModifyAgentDeviceRequest() {}

  explicit ModifyAgentDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isLogin) {
      res["IsLogin"] = boost::any(*isLogin);
    }
    if (agentDeviceId) {
      res["AgentDeviceId"] = boost::any(*agentDeviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsLogin") != m.end() && !m["IsLogin"].empty()) {
      isLogin = make_shared<long>(boost::any_cast<long>(m["IsLogin"]));
    }
    if (m.find("AgentDeviceId") != m.end() && !m["AgentDeviceId"].empty()) {
      agentDeviceId = make_shared<long>(boost::any_cast<long>(m["AgentDeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyAgentDeviceRequest() = default;
};
class ModifyAgentDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyAgentDeviceResponseBody() {}

  explicit ModifyAgentDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyAgentDeviceResponseBody() = default;
};
class ModifyAgentDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAgentDeviceResponseBody> body{};

  ModifyAgentDeviceResponse() {}

  explicit ModifyAgentDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAgentDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAgentDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAgentDeviceResponse() = default;
};
class ModifyCabInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceDescription{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> callCenterInstanceId{};

  ModifyCabInstanceRequest() {}

  explicit ModifyCabInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (callCenterInstanceId) {
      res["CallCenterInstanceId"] = boost::any(*callCenterInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("CallCenterInstanceId") != m.end() && !m["CallCenterInstanceId"].empty()) {
      callCenterInstanceId = make_shared<string>(boost::any_cast<string>(m["CallCenterInstanceId"]));
    }
  }


  virtual ~ModifyCabInstanceRequest() = default;
};
class ModifyCabInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> creationTime{};
  shared_ptr<string> callCenterInstanceId{};
  shared_ptr<string> owner{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> maxConcurrentConversation{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceDescription{};

  ModifyCabInstanceResponseBodyInstance() {}

  explicit ModifyCabInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creationTime) {
      res["CreationTime"] = boost::any(*creationTime);
    }
    if (callCenterInstanceId) {
      res["CallCenterInstanceId"] = boost::any(*callCenterInstanceId);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (maxConcurrentConversation) {
      res["MaxConcurrentConversation"] = boost::any(*maxConcurrentConversation);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceDescription) {
      res["InstanceDescription"] = boost::any(*instanceDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreationTime") != m.end() && !m["CreationTime"].empty()) {
      creationTime = make_shared<long>(boost::any_cast<long>(m["CreationTime"]));
    }
    if (m.find("CallCenterInstanceId") != m.end() && !m["CallCenterInstanceId"].empty()) {
      callCenterInstanceId = make_shared<string>(boost::any_cast<string>(m["CallCenterInstanceId"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("MaxConcurrentConversation") != m.end() && !m["MaxConcurrentConversation"].empty()) {
      maxConcurrentConversation = make_shared<long>(boost::any_cast<long>(m["MaxConcurrentConversation"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceDescription") != m.end() && !m["InstanceDescription"].empty()) {
      instanceDescription = make_shared<string>(boost::any_cast<string>(m["InstanceDescription"]));
    }
  }


  virtual ~ModifyCabInstanceResponseBodyInstance() = default;
};
class ModifyCabInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyCabInstanceResponseBodyInstance> instance{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyCabInstanceResponseBody() {}

  explicit ModifyCabInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        ModifyCabInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<ModifyCabInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyCabInstanceResponseBody() = default;
};
class ModifyCabInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCabInstanceResponseBody> body{};

  ModifyCabInstanceResponse() {}

  explicit ModifyCabInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCabInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCabInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCabInstanceResponse() = default;
};
class ModifyPhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumberId{};
  shared_ptr<string> usage{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<vector<string>> skillGroupId{};

  ModifyPhoneNumberRequest() {}

  explicit ModifyPhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyPhoneNumberRequest() = default;
};
class ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillGroupId{};

  ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup() {}

  explicit ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup() = default;
};
class ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup>> skillGroup{};

  ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups() {}

  explicit ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroup) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroup") != m.end() && !m["SkillGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroup"].type()) {
        vector<ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroup = make_shared<vector<ModifyPhoneNumberResponseBodyPhoneNumberSkillGroupsSkillGroup>>(expect1);
      }
    }
  }


  virtual ~ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups() = default;
};
class ModifyPhoneNumberResponseBodyPhoneNumberContactFlow : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> contactFlowDescription{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowId{};

  ModifyPhoneNumberResponseBodyPhoneNumberContactFlow() {}

  explicit ModifyPhoneNumberResponseBodyPhoneNumberContactFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (contactFlowDescription) {
      res["ContactFlowDescription"] = boost::any(*contactFlowDescription);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ContactFlowDescription") != m.end() && !m["ContactFlowDescription"].empty()) {
      contactFlowDescription = make_shared<string>(boost::any_cast<string>(m["ContactFlowDescription"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBodyPhoneNumberContactFlow() = default;
};
class ModifyPhoneNumberResponseBodyPhoneNumber : public Darabonba::Model {
public:
  shared_ptr<ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups> skillGroups{};
  shared_ptr<bool> testOnly{};
  shared_ptr<long> trunks{};
  shared_ptr<long> remainingTime{};
  shared_ptr<string> number{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> usage{};
  shared_ptr<bool> allowOutbound{};
  shared_ptr<string> phoneNumberDescription{};
  shared_ptr<ModifyPhoneNumberResponseBodyPhoneNumberContactFlow> contactFlow{};
  shared_ptr<string> phoneNumberId{};

  ModifyPhoneNumberResponseBodyPhoneNumber() {}

  explicit ModifyPhoneNumberResponseBodyPhoneNumber(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroups) {
      res["SkillGroups"] = skillGroups ? boost::any(skillGroups->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (testOnly) {
      res["TestOnly"] = boost::any(*testOnly);
    }
    if (trunks) {
      res["Trunks"] = boost::any(*trunks);
    }
    if (remainingTime) {
      res["RemainingTime"] = boost::any(*remainingTime);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (allowOutbound) {
      res["AllowOutbound"] = boost::any(*allowOutbound);
    }
    if (phoneNumberDescription) {
      res["PhoneNumberDescription"] = boost::any(*phoneNumberDescription);
    }
    if (contactFlow) {
      res["ContactFlow"] = contactFlow ? boost::any(contactFlow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(map<string, boost::any>) == m["SkillGroups"].type()) {
        ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SkillGroups"]));
        skillGroups = make_shared<ModifyPhoneNumberResponseBodyPhoneNumberSkillGroups>(model1);
      }
    }
    if (m.find("TestOnly") != m.end() && !m["TestOnly"].empty()) {
      testOnly = make_shared<bool>(boost::any_cast<bool>(m["TestOnly"]));
    }
    if (m.find("Trunks") != m.end() && !m["Trunks"].empty()) {
      trunks = make_shared<long>(boost::any_cast<long>(m["Trunks"]));
    }
    if (m.find("RemainingTime") != m.end() && !m["RemainingTime"].empty()) {
      remainingTime = make_shared<long>(boost::any_cast<long>(m["RemainingTime"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("AllowOutbound") != m.end() && !m["AllowOutbound"].empty()) {
      allowOutbound = make_shared<bool>(boost::any_cast<bool>(m["AllowOutbound"]));
    }
    if (m.find("PhoneNumberDescription") != m.end() && !m["PhoneNumberDescription"].empty()) {
      phoneNumberDescription = make_shared<string>(boost::any_cast<string>(m["PhoneNumberDescription"]));
    }
    if (m.find("ContactFlow") != m.end() && !m["ContactFlow"].empty()) {
      if (typeid(map<string, boost::any>) == m["ContactFlow"].type()) {
        ModifyPhoneNumberResponseBodyPhoneNumberContactFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ContactFlow"]));
        contactFlow = make_shared<ModifyPhoneNumberResponseBodyPhoneNumberContactFlow>(model1);
      }
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBodyPhoneNumber() = default;
};
class ModifyPhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ModifyPhoneNumberResponseBodyPhoneNumber> phoneNumber{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyPhoneNumberResponseBody() {}

  explicit ModifyPhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = phoneNumber ? boost::any(phoneNumber->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      if (typeid(map<string, boost::any>) == m["PhoneNumber"].type()) {
        ModifyPhoneNumberResponseBodyPhoneNumber model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PhoneNumber"]));
        phoneNumber = make_shared<ModifyPhoneNumberResponseBodyPhoneNumber>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBody() = default;
};
class ModifyPhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPhoneNumberResponseBody> body{};

  ModifyPhoneNumberResponse() {}

  explicit ModifyPhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhoneNumberResponse() = default;
};
class ModifyPhoneTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> serviceTag{};
  shared_ptr<vector<string>> skillGroupIdList{};

  ModifyPhoneTagsRequest() {}

  explicit ModifyPhoneTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (serviceTag) {
      res["ServiceTag"] = boost::any(*serviceTag);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ServiceTag") != m.end() && !m["ServiceTag"].empty()) {
      serviceTag = make_shared<string>(boost::any_cast<string>(m["ServiceTag"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyPhoneTagsRequest() = default;
};
class ModifyPhoneTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyPhoneTagsResponseBody() {}

  explicit ModifyPhoneTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyPhoneTagsResponseBody() = default;
};
class ModifyPhoneTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPhoneTagsResponseBody> body{};

  ModifyPhoneTagsResponse() {}

  explicit ModifyPhoneTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhoneTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhoneTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhoneTagsResponse() = default;
};
class ModifyPrimaryTrunksOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<vector<string>> primaryProviderName{};

  ModifyPrimaryTrunksOfSkillGroupRequest() {}

  explicit ModifyPrimaryTrunksOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (primaryProviderName) {
      res["PrimaryProviderName"] = boost::any(*primaryProviderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("PrimaryProviderName") != m.end() && !m["PrimaryProviderName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryProviderName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryProviderName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryProviderName = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyPrimaryTrunksOfSkillGroupRequest() = default;
};
class ModifyPrimaryTrunksOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyPrimaryTrunksOfSkillGroupResponseBody() {}

  explicit ModifyPrimaryTrunksOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyPrimaryTrunksOfSkillGroupResponseBody() = default;
};
class ModifyPrimaryTrunksOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPrimaryTrunksOfSkillGroupResponseBody> body{};

  ModifyPrimaryTrunksOfSkillGroupResponse() {}

  explicit ModifyPrimaryTrunksOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrimaryTrunksOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrimaryTrunksOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrimaryTrunksOfSkillGroupResponse() = default;
};
class ModifyPrivacyNumberCallDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> callId{};
  shared_ptr<string> contactId{};

  ModifyPrivacyNumberCallDetailRequest() {}

  explicit ModifyPrivacyNumberCallDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
  }


  virtual ~ModifyPrivacyNumberCallDetailRequest() = default;
};
class ModifyPrivacyNumberCallDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyPrivacyNumberCallDetailResponseBody() {}

  explicit ModifyPrivacyNumberCallDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyPrivacyNumberCallDetailResponseBody() = default;
};
class ModifyPrivacyNumberCallDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPrivacyNumberCallDetailResponseBody> body{};

  ModifyPrivacyNumberCallDetailResponse() {}

  explicit ModifyPrivacyNumberCallDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPrivacyNumberCallDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPrivacyNumberCallDetailResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPrivacyNumberCallDetailResponse() = default;
};
class ModifyScenarioRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> variables{};

  ModifyScenarioRequest() {}

  explicit ModifyScenarioRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (variables) {
      res["Variables"] = boost::any(*variables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      variables = make_shared<string>(boost::any_cast<string>(m["Variables"]));
    }
  }


  virtual ~ModifyScenarioRequest() = default;
};
class ModifyScenarioResponseBodyScenarioStrategyWorkingTime : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> beginTime{};

  ModifyScenarioResponseBodyScenarioStrategyWorkingTime() {}

  explicit ModifyScenarioResponseBodyScenarioStrategyWorkingTime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<string>(boost::any_cast<string>(m["BeginTime"]));
    }
  }


  virtual ~ModifyScenarioResponseBodyScenarioStrategyWorkingTime() = default;
};
class ModifyScenarioResponseBodyScenarioStrategy : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> strategyName{};
  shared_ptr<long> maxAttemptsPerDay{};
  shared_ptr<vector<ModifyScenarioResponseBodyScenarioStrategyWorkingTime>> workingTime{};
  shared_ptr<string> followUpStrategy{};
  shared_ptr<long> endTime{};
  shared_ptr<string> customized{};
  shared_ptr<long> startTime{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> strategyId{};
  shared_ptr<vector<string>> repeatDays{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> strategyDescription{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> repeatBy{};

  ModifyScenarioResponseBodyScenarioStrategy() {}

  explicit ModifyScenarioResponseBodyScenarioStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (strategyName) {
      res["StrategyName"] = boost::any(*strategyName);
    }
    if (maxAttemptsPerDay) {
      res["MaxAttemptsPerDay"] = boost::any(*maxAttemptsPerDay);
    }
    if (workingTime) {
      vector<boost::any> temp1;
      for(auto item1:*workingTime){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WorkingTime"] = boost::any(temp1);
    }
    if (followUpStrategy) {
      res["FollowUpStrategy"] = boost::any(*followUpStrategy);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (strategyId) {
      res["StrategyId"] = boost::any(*strategyId);
    }
    if (repeatDays) {
      res["RepeatDays"] = boost::any(*repeatDays);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (strategyDescription) {
      res["StrategyDescription"] = boost::any(*strategyDescription);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (repeatBy) {
      res["RepeatBy"] = boost::any(*repeatBy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("StrategyName") != m.end() && !m["StrategyName"].empty()) {
      strategyName = make_shared<string>(boost::any_cast<string>(m["StrategyName"]));
    }
    if (m.find("MaxAttemptsPerDay") != m.end() && !m["MaxAttemptsPerDay"].empty()) {
      maxAttemptsPerDay = make_shared<long>(boost::any_cast<long>(m["MaxAttemptsPerDay"]));
    }
    if (m.find("WorkingTime") != m.end() && !m["WorkingTime"].empty()) {
      if (typeid(vector<boost::any>) == m["WorkingTime"].type()) {
        vector<ModifyScenarioResponseBodyScenarioStrategyWorkingTime> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WorkingTime"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScenarioResponseBodyScenarioStrategyWorkingTime model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        workingTime = make_shared<vector<ModifyScenarioResponseBodyScenarioStrategyWorkingTime>>(expect1);
      }
    }
    if (m.find("FollowUpStrategy") != m.end() && !m["FollowUpStrategy"].empty()) {
      followUpStrategy = make_shared<string>(boost::any_cast<string>(m["FollowUpStrategy"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<string>(boost::any_cast<string>(m["Customized"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("StrategyId") != m.end() && !m["StrategyId"].empty()) {
      strategyId = make_shared<string>(boost::any_cast<string>(m["StrategyId"]));
    }
    if (m.find("RepeatDays") != m.end() && !m["RepeatDays"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RepeatDays"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RepeatDays"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      repeatDays = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("StrategyDescription") != m.end() && !m["StrategyDescription"].empty()) {
      strategyDescription = make_shared<string>(boost::any_cast<string>(m["StrategyDescription"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("RepeatBy") != m.end() && !m["RepeatBy"].empty()) {
      repeatBy = make_shared<string>(boost::any_cast<string>(m["RepeatBy"]));
    }
  }


  virtual ~ModifyScenarioResponseBodyScenarioStrategy() = default;
};
class ModifyScenarioResponseBodyScenarioSurveysIntents : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> intentId{};

  ModifyScenarioResponseBodyScenarioSurveysIntents() {}

  explicit ModifyScenarioResponseBodyScenarioSurveysIntents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (intentId) {
      res["IntentId"] = boost::any(*intentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("IntentId") != m.end() && !m["IntentId"].empty()) {
      intentId = make_shared<string>(boost::any_cast<string>(m["IntentId"]));
    }
  }


  virtual ~ModifyScenarioResponseBodyScenarioSurveysIntents() = default;
};
class ModifyScenarioResponseBodyScenarioSurveys : public Darabonba::Model {
public:
  shared_ptr<long> round{};
  shared_ptr<string> surveyDescription{};
  shared_ptr<string> beebotId{};
  shared_ptr<vector<ModifyScenarioResponseBodyScenarioSurveysIntents>> intents{};
  shared_ptr<string> surveyName{};
  shared_ptr<string> role{};
  shared_ptr<string> surveyId{};

  ModifyScenarioResponseBodyScenarioSurveys() {}

  explicit ModifyScenarioResponseBodyScenarioSurveys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (surveyDescription) {
      res["SurveyDescription"] = boost::any(*surveyDescription);
    }
    if (beebotId) {
      res["BeebotId"] = boost::any(*beebotId);
    }
    if (intents) {
      vector<boost::any> temp1;
      for(auto item1:*intents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Intents"] = boost::any(temp1);
    }
    if (surveyName) {
      res["SurveyName"] = boost::any(*surveyName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SurveyDescription") != m.end() && !m["SurveyDescription"].empty()) {
      surveyDescription = make_shared<string>(boost::any_cast<string>(m["SurveyDescription"]));
    }
    if (m.find("BeebotId") != m.end() && !m["BeebotId"].empty()) {
      beebotId = make_shared<string>(boost::any_cast<string>(m["BeebotId"]));
    }
    if (m.find("Intents") != m.end() && !m["Intents"].empty()) {
      if (typeid(vector<boost::any>) == m["Intents"].type()) {
        vector<ModifyScenarioResponseBodyScenarioSurveysIntents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Intents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScenarioResponseBodyScenarioSurveysIntents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        intents = make_shared<vector<ModifyScenarioResponseBodyScenarioSurveysIntents>>(expect1);
      }
    }
    if (m.find("SurveyName") != m.end() && !m["SurveyName"].empty()) {
      surveyName = make_shared<string>(boost::any_cast<string>(m["SurveyName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~ModifyScenarioResponseBodyScenarioSurveys() = default;
};
class ModifyScenarioResponseBodyScenarioVariables : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyScenarioResponseBodyScenarioVariables() {}

  explicit ModifyScenarioResponseBodyScenarioVariables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyScenarioResponseBodyScenarioVariables() = default;
};
class ModifyScenarioResponseBodyScenario : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> scenarioId{};
  shared_ptr<ModifyScenarioResponseBodyScenarioStrategy> strategy{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> scenarioDescription{};
  shared_ptr<string> scenarioName{};
  shared_ptr<vector<ModifyScenarioResponseBodyScenarioSurveys>> surveys{};
  shared_ptr<vector<ModifyScenarioResponseBodyScenarioVariables>> variables{};

  ModifyScenarioResponseBodyScenario() {}

  explicit ModifyScenarioResponseBodyScenario(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (strategy) {
      res["Strategy"] = strategy ? boost::any(strategy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (scenarioDescription) {
      res["ScenarioDescription"] = boost::any(*scenarioDescription);
    }
    if (scenarioName) {
      res["ScenarioName"] = boost::any(*scenarioName);
    }
    if (surveys) {
      vector<boost::any> temp1;
      for(auto item1:*surveys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Surveys"] = boost::any(temp1);
    }
    if (variables) {
      vector<boost::any> temp1;
      for(auto item1:*variables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Variables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategy"].type()) {
        ModifyScenarioResponseBodyScenarioStrategy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategy"]));
        strategy = make_shared<ModifyScenarioResponseBodyScenarioStrategy>(model1);
      }
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("ScenarioDescription") != m.end() && !m["ScenarioDescription"].empty()) {
      scenarioDescription = make_shared<string>(boost::any_cast<string>(m["ScenarioDescription"]));
    }
    if (m.find("ScenarioName") != m.end() && !m["ScenarioName"].empty()) {
      scenarioName = make_shared<string>(boost::any_cast<string>(m["ScenarioName"]));
    }
    if (m.find("Surveys") != m.end() && !m["Surveys"].empty()) {
      if (typeid(vector<boost::any>) == m["Surveys"].type()) {
        vector<ModifyScenarioResponseBodyScenarioSurveys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Surveys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScenarioResponseBodyScenarioSurveys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        surveys = make_shared<vector<ModifyScenarioResponseBodyScenarioSurveys>>(expect1);
      }
    }
    if (m.find("Variables") != m.end() && !m["Variables"].empty()) {
      if (typeid(vector<boost::any>) == m["Variables"].type()) {
        vector<ModifyScenarioResponseBodyScenarioVariables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Variables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyScenarioResponseBodyScenarioVariables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        variables = make_shared<vector<ModifyScenarioResponseBodyScenarioVariables>>(expect1);
      }
    }
  }


  virtual ~ModifyScenarioResponseBodyScenario() = default;
};
class ModifyScenarioResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<ModifyScenarioResponseBodyScenario> scenario{};

  ModifyScenarioResponseBody() {}

  explicit ModifyScenarioResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (scenario) {
      res["Scenario"] = scenario ? boost::any(scenario->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Scenario") != m.end() && !m["Scenario"].empty()) {
      if (typeid(map<string, boost::any>) == m["Scenario"].type()) {
        ModifyScenarioResponseBodyScenario model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Scenario"]));
        scenario = make_shared<ModifyScenarioResponseBodyScenario>(model1);
      }
    }
  }


  virtual ~ModifyScenarioResponseBody() = default;
};
class ModifyScenarioResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyScenarioResponseBody> body{};

  ModifyScenarioResponse() {}

  explicit ModifyScenarioResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyScenarioResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyScenarioResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyScenarioResponse() = default;
};
class ModifySkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<bool> allowPrivateOutboundNumber{};
  shared_ptr<vector<string>> outboundPhoneNumberId{};
  shared_ptr<vector<string>> userId{};
  shared_ptr<vector<int>> skillLevel{};

  ModifySkillGroupRequest() {}

  explicit ModifySkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (allowPrivateOutboundNumber) {
      res["AllowPrivateOutboundNumber"] = boost::any(*allowPrivateOutboundNumber);
    }
    if (outboundPhoneNumberId) {
      res["OutboundPhoneNumberId"] = boost::any(*outboundPhoneNumberId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("AllowPrivateOutboundNumber") != m.end() && !m["AllowPrivateOutboundNumber"].empty()) {
      allowPrivateOutboundNumber = make_shared<bool>(boost::any_cast<bool>(m["AllowPrivateOutboundNumber"]));
    }
    if (m.find("OutboundPhoneNumberId") != m.end() && !m["OutboundPhoneNumberId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutboundPhoneNumberId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutboundPhoneNumberId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outboundPhoneNumberId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ModifySkillGroupRequest() = default;
};
class ModifySkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifySkillGroupResponseBody() {}

  explicit ModifySkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySkillGroupResponseBody() = default;
};
class ModifySkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySkillGroupResponseBody> body{};

  ModifySkillGroupResponse() {}

  explicit ModifySkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillGroupResponse() = default;
};
class ModifySkillGroupOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};
  shared_ptr<vector<string>> roleId{};
  shared_ptr<vector<string>> skillGroupId{};
  shared_ptr<vector<int>> skillLevel{};

  ModifySkillGroupOfUserRequest() {}

  explicit ModifySkillGroupOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ModifySkillGroupOfUserRequest() = default;
};
class ModifySkillGroupOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifySkillGroupOfUserResponseBody() {}

  explicit ModifySkillGroupOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySkillGroupOfUserResponseBody() = default;
};
class ModifySkillGroupOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySkillGroupOfUserResponseBody> body{};

  ModifySkillGroupOfUserResponse() {}

  explicit ModifySkillGroupOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillGroupOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillGroupOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillGroupOfUserResponse() = default;
};
class ModifySkillGroupOutboundNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> operationType{};
  shared_ptr<vector<string>> outboundPhoneNumberId{};

  ModifySkillGroupOutboundNumbersRequest() {}

  explicit ModifySkillGroupOutboundNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (outboundPhoneNumberId) {
      res["OutboundPhoneNumberId"] = boost::any(*outboundPhoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<long>(boost::any_cast<long>(m["OperationType"]));
    }
    if (m.find("OutboundPhoneNumberId") != m.end() && !m["OutboundPhoneNumberId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutboundPhoneNumberId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutboundPhoneNumberId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outboundPhoneNumberId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifySkillGroupOutboundNumbersRequest() = default;
};
class ModifySkillGroupOutboundNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifySkillGroupOutboundNumbersResponseBody() {}

  explicit ModifySkillGroupOutboundNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySkillGroupOutboundNumbersResponseBody() = default;
};
class ModifySkillGroupOutboundNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySkillGroupOutboundNumbersResponseBody> body{};

  ModifySkillGroupOutboundNumbersResponse() {}

  explicit ModifySkillGroupOutboundNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillGroupOutboundNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillGroupOutboundNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillGroupOutboundNumbersResponse() = default;
};
class ModifySurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> surveyId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> corpora{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> globalQuestions{};
  shared_ptr<string> role{};
  shared_ptr<long> round{};

  ModifySurveyRequest() {}

  explicit ModifySurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
  }


  virtual ~ModifySurveyRequest() = default;
};
class ModifySurveyResponseBodySurveyAsrCustomModel : public Darabonba::Model {
public:
  shared_ptr<long> customModelStatus{};
  shared_ptr<string> corpora{};

  ModifySurveyResponseBodySurveyAsrCustomModel() {}

  explicit ModifySurveyResponseBodySurveyAsrCustomModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customModelStatus) {
      res["CustomModelStatus"] = boost::any(*customModelStatus);
    }
    if (corpora) {
      res["Corpora"] = boost::any(*corpora);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomModelStatus") != m.end() && !m["CustomModelStatus"].empty()) {
      customModelStatus = make_shared<long>(boost::any_cast<long>(m["CustomModelStatus"]));
    }
    if (m.find("Corpora") != m.end() && !m["Corpora"].empty()) {
      corpora = make_shared<string>(boost::any_cast<string>(m["Corpora"]));
    }
  }


  virtual ~ModifySurveyResponseBodySurveyAsrCustomModel() = default;
};
class ModifySurveyResponseBodySurveyFlow : public Darabonba::Model {
public:
  shared_ptr<bool> isPublished{};
  shared_ptr<string> flowJson{};
  shared_ptr<string> flowId{};

  ModifySurveyResponseBodySurveyFlow() {}

  explicit ModifySurveyResponseBodySurveyFlow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPublished) {
      res["IsPublished"] = boost::any(*isPublished);
    }
    if (flowJson) {
      res["FlowJson"] = boost::any(*flowJson);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPublished") != m.end() && !m["IsPublished"].empty()) {
      isPublished = make_shared<bool>(boost::any_cast<bool>(m["IsPublished"]));
    }
    if (m.find("FlowJson") != m.end() && !m["FlowJson"].empty()) {
      flowJson = make_shared<string>(boost::any_cast<string>(m["FlowJson"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
  }


  virtual ~ModifySurveyResponseBodySurveyFlow() = default;
};
class ModifySurveyResponseBodySurvey : public Darabonba::Model {
public:
  shared_ptr<string> globalQuestions{};
  shared_ptr<long> round{};
  shared_ptr<string> speechOptimizationParam{};
  shared_ptr<string> description{};
  shared_ptr<string> hotWords{};
  shared_ptr<ModifySurveyResponseBodySurveyAsrCustomModel> asrCustomModel{};
  shared_ptr<ModifySurveyResponseBodySurveyFlow> flow{};
  shared_ptr<string> role{};
  shared_ptr<string> name{};
  shared_ptr<string> scenarioUuid{};
  shared_ptr<string> id{};

  ModifySurveyResponseBodySurvey() {}

  explicit ModifySurveyResponseBodySurvey(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (globalQuestions) {
      res["GlobalQuestions"] = boost::any(*globalQuestions);
    }
    if (round) {
      res["Round"] = boost::any(*round);
    }
    if (speechOptimizationParam) {
      res["SpeechOptimizationParam"] = boost::any(*speechOptimizationParam);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hotWords) {
      res["HotWords"] = boost::any(*hotWords);
    }
    if (asrCustomModel) {
      res["AsrCustomModel"] = asrCustomModel ? boost::any(asrCustomModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (flow) {
      res["Flow"] = flow ? boost::any(flow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scenarioUuid) {
      res["ScenarioUuid"] = boost::any(*scenarioUuid);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GlobalQuestions") != m.end() && !m["GlobalQuestions"].empty()) {
      globalQuestions = make_shared<string>(boost::any_cast<string>(m["GlobalQuestions"]));
    }
    if (m.find("Round") != m.end() && !m["Round"].empty()) {
      round = make_shared<long>(boost::any_cast<long>(m["Round"]));
    }
    if (m.find("SpeechOptimizationParam") != m.end() && !m["SpeechOptimizationParam"].empty()) {
      speechOptimizationParam = make_shared<string>(boost::any_cast<string>(m["SpeechOptimizationParam"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HotWords") != m.end() && !m["HotWords"].empty()) {
      hotWords = make_shared<string>(boost::any_cast<string>(m["HotWords"]));
    }
    if (m.find("AsrCustomModel") != m.end() && !m["AsrCustomModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrCustomModel"].type()) {
        ModifySurveyResponseBodySurveyAsrCustomModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrCustomModel"]));
        asrCustomModel = make_shared<ModifySurveyResponseBodySurveyAsrCustomModel>(model1);
      }
    }
    if (m.find("Flow") != m.end() && !m["Flow"].empty()) {
      if (typeid(map<string, boost::any>) == m["Flow"].type()) {
        ModifySurveyResponseBodySurveyFlow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Flow"]));
        flow = make_shared<ModifySurveyResponseBodySurveyFlow>(model1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ScenarioUuid") != m.end() && !m["ScenarioUuid"].empty()) {
      scenarioUuid = make_shared<string>(boost::any_cast<string>(m["ScenarioUuid"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ModifySurveyResponseBodySurvey() = default;
};
class ModifySurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifySurveyResponseBodySurvey> survey{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifySurveyResponseBody() {}

  explicit ModifySurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (survey) {
      res["Survey"] = survey ? boost::any(survey->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Survey") != m.end() && !m["Survey"].empty()) {
      if (typeid(map<string, boost::any>) == m["Survey"].type()) {
        ModifySurveyResponseBodySurvey model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Survey"]));
        survey = make_shared<ModifySurveyResponseBodySurvey>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySurveyResponseBody() = default;
};
class ModifySurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySurveyResponseBody> body{};

  ModifySurveyResponse() {}

  explicit ModifySurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySurveyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySurveyResponse() = default;
};
class ModifyUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};
  shared_ptr<string> phone{};
  shared_ptr<string> email{};
  shared_ptr<string> privateOutboundNumberId{};
  shared_ptr<vector<string>> roleId{};
  shared_ptr<vector<string>> skillGroupId{};
  shared_ptr<vector<int>> skillLevel{};

  ModifyUserRequest() {}

  explicit ModifyUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (privateOutboundNumberId) {
      res["PrivateOutboundNumberId"] = boost::any(*privateOutboundNumberId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("PrivateOutboundNumberId") != m.end() && !m["PrivateOutboundNumberId"].empty()) {
      privateOutboundNumberId = make_shared<string>(boost::any_cast<string>(m["PrivateOutboundNumberId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["SkillLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      skillLevel = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ModifyUserRequest() = default;
};
class ModifyUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifyUserResponseBody() {}

  explicit ModifyUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyUserResponseBody() = default;
};
class ModifyUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyUserResponseBody> body{};

  ModifyUserResponse() {}

  explicit ModifyUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserResponse() = default;
};
class PickGlobalOutboundNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> calleeNumber{};
  shared_ptr<long> count{};
  shared_ptr<bool> isVirtual{};
  shared_ptr<vector<string>> skillGroupId{};

  PickGlobalOutboundNumbersRequest() {}

  explicit PickGlobalOutboundNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calleeNumber) {
      res["CalleeNumber"] = boost::any(*calleeNumber);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (isVirtual) {
      res["IsVirtual"] = boost::any(*isVirtual);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalleeNumber") != m.end() && !m["CalleeNumber"].empty()) {
      calleeNumber = make_shared<string>(boost::any_cast<string>(m["CalleeNumber"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("IsVirtual") != m.end() && !m["IsVirtual"].empty()) {
      isVirtual = make_shared<bool>(boost::any_cast<bool>(m["IsVirtual"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PickGlobalOutboundNumbersRequest() = default;
};
class PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller() {}

  explicit PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller() = default;
};
class PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee() {}

  explicit PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee() = default;
};
class PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair : public Darabonba::Model {
public:
  shared_ptr<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller> caller{};
  shared_ptr<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee> callee{};

  PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair() {}

  explicit PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caller) {
      res["Caller"] = caller ? boost::any(caller->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callee) {
      res["Callee"] = callee ? boost::any(callee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      if (typeid(map<string, boost::any>) == m["Caller"].type()) {
        PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Caller"]));
        caller = make_shared<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller>(model1);
      }
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      if (typeid(map<string, boost::any>) == m["Callee"].type()) {
        PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Callee"]));
        callee = make_shared<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee>(model1);
      }
    }
  }


  virtual ~PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair() = default;
};
class PickGlobalOutboundNumbersResponseBodyDialNumberPairs : public Darabonba::Model {
public:
  shared_ptr<vector<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair>> dialNumberPair{};

  PickGlobalOutboundNumbersResponseBodyDialNumberPairs() {}

  explicit PickGlobalOutboundNumbersResponseBodyDialNumberPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialNumberPair) {
      vector<boost::any> temp1;
      for(auto item1:*dialNumberPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DialNumberPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialNumberPair") != m.end() && !m["DialNumberPair"].empty()) {
      if (typeid(vector<boost::any>) == m["DialNumberPair"].type()) {
        vector<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DialNumberPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialNumberPair = make_shared<vector<PickGlobalOutboundNumbersResponseBodyDialNumberPairsDialNumberPair>>(expect1);
      }
    }
  }


  virtual ~PickGlobalOutboundNumbersResponseBodyDialNumberPairs() = default;
};
class PickGlobalOutboundNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<PickGlobalOutboundNumbersResponseBodyDialNumberPairs> dialNumberPairs{};

  PickGlobalOutboundNumbersResponseBody() {}

  explicit PickGlobalOutboundNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (dialNumberPairs) {
      res["DialNumberPairs"] = dialNumberPairs ? boost::any(dialNumberPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("DialNumberPairs") != m.end() && !m["DialNumberPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DialNumberPairs"].type()) {
        PickGlobalOutboundNumbersResponseBodyDialNumberPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DialNumberPairs"]));
        dialNumberPairs = make_shared<PickGlobalOutboundNumbersResponseBodyDialNumberPairs>(model1);
      }
    }
  }


  virtual ~PickGlobalOutboundNumbersResponseBody() = default;
};
class PickGlobalOutboundNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PickGlobalOutboundNumbersResponseBody> body{};

  PickGlobalOutboundNumbersResponse() {}

  explicit PickGlobalOutboundNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PickGlobalOutboundNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PickGlobalOutboundNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~PickGlobalOutboundNumbersResponse() = default;
};
class PickLocalNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> calleeNumber{};
  shared_ptr<vector<string>> candidateNumber{};

  PickLocalNumberRequest() {}

  explicit PickLocalNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calleeNumber) {
      res["CalleeNumber"] = boost::any(*calleeNumber);
    }
    if (candidateNumber) {
      res["CandidateNumber"] = boost::any(*candidateNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalleeNumber") != m.end() && !m["CalleeNumber"].empty()) {
      calleeNumber = make_shared<string>(boost::any_cast<string>(m["CalleeNumber"]));
    }
    if (m.find("CandidateNumber") != m.end() && !m["CandidateNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CandidateNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CandidateNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      candidateNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PickLocalNumberRequest() = default;
};
class PickLocalNumberResponseBodyDataCaller : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickLocalNumberResponseBodyDataCaller() {}

  explicit PickLocalNumberResponseBodyDataCaller(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickLocalNumberResponseBodyDataCaller() = default;
};
class PickLocalNumberResponseBodyDataCallee : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickLocalNumberResponseBodyDataCallee() {}

  explicit PickLocalNumberResponseBodyDataCallee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickLocalNumberResponseBodyDataCallee() = default;
};
class PickLocalNumberResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<PickLocalNumberResponseBodyDataCaller> caller{};
  shared_ptr<PickLocalNumberResponseBodyDataCallee> callee{};

  PickLocalNumberResponseBodyData() {}

  explicit PickLocalNumberResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caller) {
      res["Caller"] = caller ? boost::any(caller->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callee) {
      res["Callee"] = callee ? boost::any(callee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      if (typeid(map<string, boost::any>) == m["Caller"].type()) {
        PickLocalNumberResponseBodyDataCaller model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Caller"]));
        caller = make_shared<PickLocalNumberResponseBodyDataCaller>(model1);
      }
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      if (typeid(map<string, boost::any>) == m["Callee"].type()) {
        PickLocalNumberResponseBodyDataCallee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Callee"]));
        callee = make_shared<PickLocalNumberResponseBodyDataCallee>(model1);
      }
    }
  }


  virtual ~PickLocalNumberResponseBodyData() = default;
};
class PickLocalNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<PickLocalNumberResponseBodyData> data{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  PickLocalNumberResponseBody() {}

  explicit PickLocalNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PickLocalNumberResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PickLocalNumberResponseBodyData>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PickLocalNumberResponseBody() = default;
};
class PickLocalNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PickLocalNumberResponseBody> body{};

  PickLocalNumberResponse() {}

  explicit PickLocalNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PickLocalNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PickLocalNumberResponseBody>(model1);
      }
    }
  }


  virtual ~PickLocalNumberResponse() = default;
};
class PickOutboundNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> calleeNumber{};
  shared_ptr<long> count{};
  shared_ptr<vector<string>> candidateNumber{};

  PickOutboundNumbersRequest() {}

  explicit PickOutboundNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (calleeNumber) {
      res["CalleeNumber"] = boost::any(*calleeNumber);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (candidateNumber) {
      res["CandidateNumber"] = boost::any(*candidateNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CalleeNumber") != m.end() && !m["CalleeNumber"].empty()) {
      calleeNumber = make_shared<string>(boost::any_cast<string>(m["CalleeNumber"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("CandidateNumber") != m.end() && !m["CandidateNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CandidateNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CandidateNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      candidateNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~PickOutboundNumbersRequest() = default;
};
class PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller() {}

  explicit PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller() = default;
};
class PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee : public Darabonba::Model {
public:
  shared_ptr<string> number{};
  shared_ptr<string> city{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee() {}

  explicit PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee() = default;
};
class PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair : public Darabonba::Model {
public:
  shared_ptr<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller> caller{};
  shared_ptr<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee> callee{};

  PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair() {}

  explicit PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caller) {
      res["Caller"] = caller ? boost::any(caller->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callee) {
      res["Callee"] = callee ? boost::any(callee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      if (typeid(map<string, boost::any>) == m["Caller"].type()) {
        PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Caller"]));
        caller = make_shared<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCaller>(model1);
      }
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      if (typeid(map<string, boost::any>) == m["Callee"].type()) {
        PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Callee"]));
        callee = make_shared<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPairCallee>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair() = default;
};
class PickOutboundNumbersResponseBodyDialNumberPairs : public Darabonba::Model {
public:
  shared_ptr<vector<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair>> dialNumberPair{};

  PickOutboundNumbersResponseBodyDialNumberPairs() {}

  explicit PickOutboundNumbersResponseBodyDialNumberPairs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialNumberPair) {
      vector<boost::any> temp1;
      for(auto item1:*dialNumberPair){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DialNumberPair"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialNumberPair") != m.end() && !m["DialNumberPair"].empty()) {
      if (typeid(vector<boost::any>) == m["DialNumberPair"].type()) {
        vector<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DialNumberPair"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dialNumberPair = make_shared<vector<PickOutboundNumbersResponseBodyDialNumberPairsDialNumberPair>>(expect1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDialNumberPairs() = default;
};
class PickOutboundNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<PickOutboundNumbersResponseBodyDialNumberPairs> dialNumberPairs{};

  PickOutboundNumbersResponseBody() {}

  explicit PickOutboundNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (dialNumberPairs) {
      res["DialNumberPairs"] = dialNumberPairs ? boost::any(dialNumberPairs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("DialNumberPairs") != m.end() && !m["DialNumberPairs"].empty()) {
      if (typeid(map<string, boost::any>) == m["DialNumberPairs"].type()) {
        PickOutboundNumbersResponseBodyDialNumberPairs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DialNumberPairs"]));
        dialNumberPairs = make_shared<PickOutboundNumbersResponseBodyDialNumberPairs>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponseBody() = default;
};
class PickOutboundNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PickOutboundNumbersResponseBody> body{};

  PickOutboundNumbersResponse() {}

  explicit PickOutboundNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PickOutboundNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PickOutboundNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponse() = default;
};
class PublishContactFlowVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> contactFlowVersionId{};
  shared_ptr<bool> useTianGong{};

  PublishContactFlowVersionRequest() {}

  explicit PublishContactFlowVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (contactFlowVersionId) {
      res["ContactFlowVersionId"] = boost::any(*contactFlowVersionId);
    }
    if (useTianGong) {
      res["UseTianGong"] = boost::any(*useTianGong);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ContactFlowVersionId") != m.end() && !m["ContactFlowVersionId"].empty()) {
      contactFlowVersionId = make_shared<string>(boost::any_cast<string>(m["ContactFlowVersionId"]));
    }
    if (m.find("UseTianGong") != m.end() && !m["UseTianGong"].empty()) {
      useTianGong = make_shared<bool>(boost::any_cast<bool>(m["UseTianGong"]));
    }
  }


  virtual ~PublishContactFlowVersionRequest() = default;
};
class PublishContactFlowVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  PublishContactFlowVersionResponseBody() {}

  explicit PublishContactFlowVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishContactFlowVersionResponseBody() = default;
};
class PublishContactFlowVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishContactFlowVersionResponseBody> body{};

  PublishContactFlowVersionResponse() {}

  explicit PublishContactFlowVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishContactFlowVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishContactFlowVersionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishContactFlowVersionResponse() = default;
};
class PublishPredictiveJobGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<string> skillGroupId{};

  PublishPredictiveJobGroupRequest() {}

  explicit PublishPredictiveJobGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~PublishPredictiveJobGroupRequest() = default;
};
class PublishPredictiveJobGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  PublishPredictiveJobGroupResponseBody() {}

  explicit PublishPredictiveJobGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishPredictiveJobGroupResponseBody() = default;
};
class PublishPredictiveJobGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishPredictiveJobGroupResponseBody> body{};

  PublishPredictiveJobGroupResponse() {}

  explicit PublishPredictiveJobGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishPredictiveJobGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishPredictiveJobGroupResponseBody>(model1);
      }
    }
  }


  virtual ~PublishPredictiveJobGroupResponse() = default;
};
class PublishSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> surveyId{};

  PublishSurveyRequest() {}

  explicit PublishSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (surveyId) {
      res["SurveyId"] = boost::any(*surveyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("SurveyId") != m.end() && !m["SurveyId"].empty()) {
      surveyId = make_shared<string>(boost::any_cast<string>(m["SurveyId"]));
    }
  }


  virtual ~PublishSurveyRequest() = default;
};
class PublishSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  PublishSurveyResponseBody() {}

  explicit PublishSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishSurveyResponseBody() = default;
};
class PublishSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishSurveyResponseBody> body{};

  PublishSurveyResponse() {}

  explicit PublishSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~PublishSurveyResponse() = default;
};
class RefreshTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  RefreshTokenRequest() {}

  explicit RefreshTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RefreshTokenRequest() = default;
};
class RefreshTokenResponseBodyToken : public Darabonba::Model {
public:
  shared_ptr<string> signature{};
  shared_ptr<string> signData{};

  RefreshTokenResponseBodyToken() {}

  explicit RefreshTokenResponseBodyToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (signData) {
      res["SignData"] = boost::any(*signData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("SignData") != m.end() && !m["SignData"].empty()) {
      signData = make_shared<string>(boost::any_cast<string>(m["SignData"]));
    }
  }


  virtual ~RefreshTokenResponseBodyToken() = default;
};
class RefreshTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<RefreshTokenResponseBodyToken> token{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RefreshTokenResponseBody() {}

  explicit RefreshTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (token) {
      res["Token"] = token ? boost::any(token->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      if (typeid(map<string, boost::any>) == m["Token"].type()) {
        RefreshTokenResponseBodyToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Token"]));
        token = make_shared<RefreshTokenResponseBodyToken>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RefreshTokenResponseBody() = default;
};
class RefreshTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RefreshTokenResponseBody> body{};

  RefreshTokenResponse() {}

  explicit RefreshTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshTokenResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshTokenResponse() = default;
};
class RemovePhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumberId{};

  RemovePhoneNumberRequest() {}

  explicit RemovePhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberId) {
      res["PhoneNumberId"] = boost::any(*phoneNumberId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberId") != m.end() && !m["PhoneNumberId"].empty()) {
      phoneNumberId = make_shared<string>(boost::any_cast<string>(m["PhoneNumberId"]));
    }
  }


  virtual ~RemovePhoneNumberRequest() = default;
};
class RemovePhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RemovePhoneNumberResponseBody() {}

  explicit RemovePhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemovePhoneNumberResponseBody() = default;
};
class RemovePhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemovePhoneNumberResponseBody> body{};

  RemovePhoneNumberResponse() {}

  explicit RemovePhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumberResponse() = default;
};
class RemoveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userId{};

  RemoveUsersRequest() {}

  explicit RemoveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveUsersRequest() = default;
};
class RemoveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RemoveUsersResponseBody() {}

  explicit RemoveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveUsersResponseBody() = default;
};
class RemoveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveUsersResponseBody> body{};

  RemoveUsersResponse() {}

  explicit RemoveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersResponse() = default;
};
class RemoveUsersFromSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<vector<string>> userId{};

  RemoveUsersFromSkillGroupRequest() {}

  explicit RemoveUsersFromSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveUsersFromSkillGroupRequest() = default;
};
class RemoveUsersFromSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RemoveUsersFromSkillGroupResponseBody() {}

  explicit RemoveUsersFromSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponseBody() = default;
};
class RemoveUsersFromSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveUsersFromSkillGroupResponseBody> body{};

  RemoveUsersFromSkillGroupResponse() {}

  explicit RemoveUsersFromSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersFromSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersFromSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponse() = default;
};
class RequestLoginInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  RequestLoginInfoRequest() {}

  explicit RequestLoginInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RequestLoginInfoRequest() = default;
};
class RequestLoginInfoResponseBodyLoginInfoRolesRole : public Darabonba::Model {
public:
  shared_ptr<string> roleDescription{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> roleId{};

  RequestLoginInfoResponseBodyLoginInfoRolesRole() {}

  explicit RequestLoginInfoResponseBodyLoginInfoRolesRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roleDescription) {
      res["RoleDescription"] = boost::any(*roleDescription);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoleDescription") != m.end() && !m["RoleDescription"].empty()) {
      roleDescription = make_shared<string>(boost::any_cast<string>(m["RoleDescription"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~RequestLoginInfoResponseBodyLoginInfoRolesRole() = default;
};
class RequestLoginInfoResponseBodyLoginInfoRoles : public Darabonba::Model {
public:
  shared_ptr<vector<RequestLoginInfoResponseBodyLoginInfoRolesRole>> role{};

  RequestLoginInfoResponseBodyLoginInfoRoles() {}

  explicit RequestLoginInfoResponseBodyLoginInfoRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      vector<boost::any> temp1;
      for(auto item1:*role){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Role"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<RequestLoginInfoResponseBodyLoginInfoRolesRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Role"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RequestLoginInfoResponseBodyLoginInfoRolesRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        role = make_shared<vector<RequestLoginInfoResponseBodyLoginInfoRolesRole>>(expect1);
      }
    }
  }


  virtual ~RequestLoginInfoResponseBodyLoginInfoRoles() = default;
};
class RequestLoginInfoResponseBodyLoginInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> signature{};
  shared_ptr<string> extension{};
  shared_ptr<string> signData{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> region{};
  shared_ptr<string> agentServerUrl{};
  shared_ptr<RequestLoginInfoResponseBodyLoginInfoRoles> roles{};
  shared_ptr<string> userName{};
  shared_ptr<string> webRtcUrl{};
  shared_ptr<string> tenantId{};

  RequestLoginInfoResponseBodyLoginInfo() {}

  explicit RequestLoginInfoResponseBodyLoginInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (signData) {
      res["SignData"] = boost::any(*signData);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (agentServerUrl) {
      res["AgentServerUrl"] = boost::any(*agentServerUrl);
    }
    if (roles) {
      res["Roles"] = roles ? boost::any(roles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (webRtcUrl) {
      res["WebRtcUrl"] = boost::any(*webRtcUrl);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("SignData") != m.end() && !m["SignData"].empty()) {
      signData = make_shared<string>(boost::any_cast<string>(m["SignData"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("AgentServerUrl") != m.end() && !m["AgentServerUrl"].empty()) {
      agentServerUrl = make_shared<string>(boost::any_cast<string>(m["AgentServerUrl"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Roles"].type()) {
        RequestLoginInfoResponseBodyLoginInfoRoles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Roles"]));
        roles = make_shared<RequestLoginInfoResponseBodyLoginInfoRoles>(model1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WebRtcUrl") != m.end() && !m["WebRtcUrl"].empty()) {
      webRtcUrl = make_shared<string>(boost::any_cast<string>(m["WebRtcUrl"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~RequestLoginInfoResponseBodyLoginInfo() = default;
};
class RequestLoginInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<RequestLoginInfoResponseBodyLoginInfo> loginInfo{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  RequestLoginInfoResponseBody() {}

  explicit RequestLoginInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (loginInfo) {
      res["LoginInfo"] = loginInfo ? boost::any(loginInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("LoginInfo") != m.end() && !m["LoginInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LoginInfo"].type()) {
        RequestLoginInfoResponseBodyLoginInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LoginInfo"]));
        loginInfo = make_shared<RequestLoginInfoResponseBodyLoginInfo>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RequestLoginInfoResponseBody() = default;
};
class RequestLoginInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RequestLoginInfoResponseBody> body{};

  RequestLoginInfoResponse() {}

  explicit RequestLoginInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RequestLoginInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RequestLoginInfoResponseBody>(model1);
      }
    }
  }


  virtual ~RequestLoginInfoResponse() = default;
};
class ResetUserStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<int>> ramIdList{};

  ResetUserStatusRequest() {}

  explicit ResetUserStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIdList) {
      res["RamIdList"] = boost::any(*ramIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIdList") != m.end() && !m["RamIdList"].empty()) {
      vector<int> toVec1;
      if (typeid(vector<boost::any>) == m["RamIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RamIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<int>(item));
        }
      }
      ramIdList = make_shared<vector<int>>(toVec1);
    }
  }


  virtual ~ResetUserStatusRequest() = default;
};
class ResetUserStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ResetUserStatusResponseBody() {}

  explicit ResetUserStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetUserStatusResponseBody() = default;
};
class ResetUserStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetUserStatusResponseBody> body{};

  ResetUserStatusResponse() {}

  explicit ResetUserStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetUserStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetUserStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ResetUserStatusResponse() = default;
};
class ResumeJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> all{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};

  ResumeJobsRequest() {}

  explicit ResumeJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ResumeJobsRequest() = default;
};
class ResumeJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ResumeJobsResponseBody() {}

  explicit ResumeJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumeJobsResponseBody() = default;
};
class ResumeJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResumeJobsResponseBody> body{};

  ResumeJobsResponse() {}

  explicit ResumeJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeJobsResponse() = default;
};
class ResumePredictiveJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<bool> all{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobId{};

  ResumePredictiveJobsRequest() {}

  explicit ResumePredictiveJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ResumePredictiveJobsRequest() = default;
};
class ResumePredictiveJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ResumePredictiveJobsResponseBody() {}

  explicit ResumePredictiveJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumePredictiveJobsResponseBody() = default;
};
class ResumePredictiveJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResumePredictiveJobsResponseBody> body{};

  ResumePredictiveJobsResponse() {}

  explicit ResumePredictiveJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumePredictiveJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumePredictiveJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ResumePredictiveJobsResponse() = default;
};
class SaveStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> recordTime{};
  shared_ptr<string> callId{};
  shared_ptr<string> callerNumber{};
  shared_ptr<string> calleeNumber{};
  shared_ptr<long> callStartTime{};
  shared_ptr<string> stats{};
  shared_ptr<string> uid{};
  shared_ptr<string> tenantId{};

  SaveStatsRequest() {}

  explicit SaveStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordTime) {
      res["RecordTime"] = boost::any(*recordTime);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callerNumber) {
      res["CallerNumber"] = boost::any(*callerNumber);
    }
    if (calleeNumber) {
      res["CalleeNumber"] = boost::any(*calleeNumber);
    }
    if (callStartTime) {
      res["CallStartTime"] = boost::any(*callStartTime);
    }
    if (stats) {
      res["Stats"] = boost::any(*stats);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordTime") != m.end() && !m["RecordTime"].empty()) {
      recordTime = make_shared<long>(boost::any_cast<long>(m["RecordTime"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallerNumber") != m.end() && !m["CallerNumber"].empty()) {
      callerNumber = make_shared<string>(boost::any_cast<string>(m["CallerNumber"]));
    }
    if (m.find("CalleeNumber") != m.end() && !m["CalleeNumber"].empty()) {
      calleeNumber = make_shared<string>(boost::any_cast<string>(m["CalleeNumber"]));
    }
    if (m.find("CallStartTime") != m.end() && !m["CallStartTime"].empty()) {
      callStartTime = make_shared<long>(boost::any_cast<long>(m["CallStartTime"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      stats = make_shared<string>(boost::any_cast<string>(m["Stats"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~SaveStatsRequest() = default;
};
class SaveStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SaveStatsResponseBody() {}

  explicit SaveStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveStatsResponseBody() = default;
};
class SaveStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SaveStatsResponseBody> body{};

  SaveStatsResponse() {}

  explicit SaveStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveStatsResponseBody>(model1);
      }
    }
  }


  virtual ~SaveStatsResponse() = default;
};
class SaveWebRTCStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> recordTime{};
  shared_ptr<string> callId{};
  shared_ptr<string> callerNumber{};
  shared_ptr<string> calleeNumber{};
  shared_ptr<long> callStartTime{};
  shared_ptr<string> stats{};
  shared_ptr<string> uid{};
  shared_ptr<string> tenantId{};

  SaveWebRTCStatsRequest() {}

  explicit SaveWebRTCStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (recordTime) {
      res["RecordTime"] = boost::any(*recordTime);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callerNumber) {
      res["CallerNumber"] = boost::any(*callerNumber);
    }
    if (calleeNumber) {
      res["CalleeNumber"] = boost::any(*calleeNumber);
    }
    if (callStartTime) {
      res["CallStartTime"] = boost::any(*callStartTime);
    }
    if (stats) {
      res["Stats"] = boost::any(*stats);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RecordTime") != m.end() && !m["RecordTime"].empty()) {
      recordTime = make_shared<long>(boost::any_cast<long>(m["RecordTime"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallerNumber") != m.end() && !m["CallerNumber"].empty()) {
      callerNumber = make_shared<string>(boost::any_cast<string>(m["CallerNumber"]));
    }
    if (m.find("CalleeNumber") != m.end() && !m["CalleeNumber"].empty()) {
      calleeNumber = make_shared<string>(boost::any_cast<string>(m["CalleeNumber"]));
    }
    if (m.find("CallStartTime") != m.end() && !m["CallStartTime"].empty()) {
      callStartTime = make_shared<long>(boost::any_cast<long>(m["CallStartTime"]));
    }
    if (m.find("Stats") != m.end() && !m["Stats"].empty()) {
      stats = make_shared<string>(boost::any_cast<string>(m["Stats"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~SaveWebRTCStatsRequest() = default;
};
class SaveWebRTCStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> rowCount{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SaveWebRTCStatsResponseBody() {}

  explicit SaveWebRTCStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveWebRTCStatsResponseBody() = default;
};
class SaveWebRTCStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SaveWebRTCStatsResponseBody> body{};

  SaveWebRTCStatsResponse() {}

  explicit SaveWebRTCStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveWebRTCStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveWebRTCStatsResponseBody>(model1);
      }
    }
  }


  virtual ~SaveWebRTCStatsResponse() = default;
};
class SendPredefinedShortMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumbers{};
  shared_ptr<long> configId{};
  shared_ptr<string> templateParam{};

  SendPredefinedShortMessageRequest() {}

  explicit SendPredefinedShortMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumbers) {
      res["PhoneNumbers"] = boost::any(*phoneNumbers);
    }
    if (configId) {
      res["ConfigId"] = boost::any(*configId);
    }
    if (templateParam) {
      res["TemplateParam"] = boost::any(*templateParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumbers") != m.end() && !m["PhoneNumbers"].empty()) {
      phoneNumbers = make_shared<string>(boost::any_cast<string>(m["PhoneNumbers"]));
    }
    if (m.find("ConfigId") != m.end() && !m["ConfigId"].empty()) {
      configId = make_shared<long>(boost::any_cast<long>(m["ConfigId"]));
    }
    if (m.find("TemplateParam") != m.end() && !m["TemplateParam"].empty()) {
      templateParam = make_shared<string>(boost::any_cast<string>(m["TemplateParam"]));
    }
  }


  virtual ~SendPredefinedShortMessageRequest() = default;
};
class SendPredefinedShortMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<string> bizId{};
  shared_ptr<bool> success{};

  SendPredefinedShortMessageResponseBody() {}

  explicit SendPredefinedShortMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (bizId) {
      res["BizId"] = boost::any(*bizId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("BizId") != m.end() && !m["BizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["BizId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SendPredefinedShortMessageResponseBody() = default;
};
class SendPredefinedShortMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SendPredefinedShortMessageResponseBody> body{};

  SendPredefinedShortMessageResponse() {}

  explicit SendPredefinedShortMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendPredefinedShortMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendPredefinedShortMessageResponseBody>(model1);
      }
    }
  }


  virtual ~SendPredefinedShortMessageResponse() = default;
};
class StartBack2BackCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> workflowId{};
  shared_ptr<string> callCenterNumber{};
  shared_ptr<string> caller{};
  shared_ptr<string> callee{};

  StartBack2BackCallRequest() {}

  explicit StartBack2BackCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    if (callCenterNumber) {
      res["CallCenterNumber"] = boost::any(*callCenterNumber);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
    if (m.find("CallCenterNumber") != m.end() && !m["CallCenterNumber"].empty()) {
      callCenterNumber = make_shared<string>(boost::any_cast<string>(m["CallCenterNumber"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
  }


  virtual ~StartBack2BackCallRequest() = default;
};
class StartBack2BackCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> statusDesc{};
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};
  shared_ptr<string> timeStamp{};

  StartBack2BackCallResponseBody() {}

  explicit StartBack2BackCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<string>(boost::any_cast<string>(m["TimeStamp"]));
    }
  }


  virtual ~StartBack2BackCallResponseBody() = default;
};
class StartBack2BackCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartBack2BackCallResponseBody> body{};

  StartBack2BackCallResponse() {}

  explicit StartBack2BackCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartBack2BackCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartBack2BackCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartBack2BackCallResponse() = default;
};
class StartJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> jobJson{};
  shared_ptr<bool> selfHostedCallCenter{};
  shared_ptr<vector<string>> callingNumber{};

  StartJobRequest() {}

  explicit StartJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (jobJson) {
      res["JobJson"] = boost::any(*jobJson);
    }
    if (selfHostedCallCenter) {
      res["SelfHostedCallCenter"] = boost::any(*selfHostedCallCenter);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("JobJson") != m.end() && !m["JobJson"].empty()) {
      jobJson = make_shared<string>(boost::any_cast<string>(m["JobJson"]));
    }
    if (m.find("SelfHostedCallCenter") != m.end() && !m["SelfHostedCallCenter"].empty()) {
      selfHostedCallCenter = make_shared<bool>(boost::any_cast<bool>(m["SelfHostedCallCenter"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CallingNumber"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CallingNumber"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      callingNumber = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~StartJobRequest() = default;
};
class StartJobResponseBodyTaskIds : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  StartJobResponseBodyTaskIds() {}

  explicit StartJobResponseBodyTaskIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~StartJobResponseBodyTaskIds() = default;
};
class StartJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<StartJobResponseBodyTaskIds>> taskIds{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  StartJobResponseBody() {}

  explicit StartJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskIds) {
      vector<boost::any> temp1;
      for(auto item1:*taskIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskIds"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskIds") != m.end() && !m["TaskIds"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskIds"].type()) {
        vector<StartJobResponseBodyTaskIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartJobResponseBodyTaskIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskIds = make_shared<vector<StartJobResponseBodyTaskIds>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartJobResponseBody() = default;
};
class StartJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<StartJobResponseBody> body{};

  StartJobResponse() {}

  explicit StartJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartJobResponse() = default;
};
class SubmitBatchJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobGroupId{};

  SubmitBatchJobsRequest() {}

  explicit SubmitBatchJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
  }


  virtual ~SubmitBatchJobsRequest() = default;
};
class SubmitBatchJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SubmitBatchJobsResponseBody() {}

  explicit SubmitBatchJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitBatchJobsResponseBody() = default;
};
class SubmitBatchJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitBatchJobsResponseBody> body{};

  SubmitBatchJobsResponse() {}

  explicit SubmitBatchJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitBatchJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitBatchJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitBatchJobsResponse() = default;
};
class SubmitCabRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceOwnerId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> resourceRecording{};
  shared_ptr<string> mergedRecording{};

  SubmitCabRecordingRequest() {}

  explicit SubmitCabRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (resourceRecording) {
      res["ResourceRecording"] = boost::any(*resourceRecording);
    }
    if (mergedRecording) {
      res["MergedRecording"] = boost::any(*mergedRecording);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("ResourceRecording") != m.end() && !m["ResourceRecording"].empty()) {
      resourceRecording = make_shared<string>(boost::any_cast<string>(m["ResourceRecording"]));
    }
    if (m.find("MergedRecording") != m.end() && !m["MergedRecording"].empty()) {
      mergedRecording = make_shared<string>(boost::any_cast<string>(m["MergedRecording"]));
    }
  }


  virtual ~SubmitCabRecordingRequest() = default;
};
class SubmitCabRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SubmitCabRecordingResponseBody() {}

  explicit SubmitCabRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitCabRecordingResponseBody() = default;
};
class SubmitCabRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitCabRecordingResponseBody> body{};

  SubmitCabRecordingResponse() {}

  explicit SubmitCabRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCabRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCabRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCabRecordingResponse() = default;
};
class SuspendJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> all{};
  shared_ptr<string> scenarioId{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> jobId{};
  shared_ptr<vector<string>> jobReferenceId{};

  SuspendJobsRequest() {}

  explicit SuspendJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (scenarioId) {
      res["ScenarioId"] = boost::any(*scenarioId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobReferenceId) {
      res["JobReferenceId"] = boost::any(*jobReferenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ScenarioId") != m.end() && !m["ScenarioId"].empty()) {
      scenarioId = make_shared<string>(boost::any_cast<string>(m["ScenarioId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("JobReferenceId") != m.end() && !m["JobReferenceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobReferenceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobReferenceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobReferenceId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SuspendJobsRequest() = default;
};
class SuspendJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SuspendJobsResponseBody() {}

  explicit SuspendJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendJobsResponseBody() = default;
};
class SuspendJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SuspendJobsResponseBody> body{};

  SuspendJobsResponse() {}

  explicit SuspendJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendJobsResponse() = default;
};
class SuspendPredictiveJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<bool> all{};
  shared_ptr<string> jobGroupId{};
  shared_ptr<vector<string>> jobId{};

  SuspendPredictiveJobsRequest() {}

  explicit SuspendPredictiveJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (jobGroupId) {
      res["JobGroupId"] = boost::any(*jobGroupId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("JobGroupId") != m.end() && !m["JobGroupId"].empty()) {
      jobGroupId = make_shared<string>(boost::any_cast<string>(m["JobGroupId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["JobId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["JobId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      jobId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SuspendPredictiveJobsRequest() = default;
};
class SuspendPredictiveJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  SuspendPredictiveJobsResponseBody() {}

  explicit SuspendPredictiveJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SuspendPredictiveJobsResponseBody() = default;
};
class SuspendPredictiveJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SuspendPredictiveJobsResponseBody> body{};

  SuspendPredictiveJobsResponse() {}

  explicit SuspendPredictiveJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendPredictiveJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendPredictiveJobsResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendPredictiveJobsResponse() = default;
};
class TaskPreparingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> instanceOwnerId{};

  TaskPreparingRequest() {}

  explicit TaskPreparingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (instanceOwnerId) {
      res["InstanceOwnerId"] = boost::any(*instanceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("InstanceOwnerId") != m.end() && !m["InstanceOwnerId"].empty()) {
      instanceOwnerId = make_shared<long>(boost::any_cast<long>(m["InstanceOwnerId"]));
    }
  }


  virtual ~TaskPreparingRequest() = default;
};
class TaskPreparingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  TaskPreparingResponseBody() {}

  explicit TaskPreparingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TaskPreparingResponseBody() = default;
};
class TaskPreparingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TaskPreparingResponseBody> body{};

  TaskPreparingResponse() {}

  explicit TaskPreparingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TaskPreparingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TaskPreparingResponseBody>(model1);
      }
    }
  }


  virtual ~TaskPreparingResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddAgentDeviceResponse addAgentDeviceWithOptions(shared_ptr<AddAgentDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAgentDeviceResponse addAgentDevice(shared_ptr<AddAgentDeviceRequest> request);
  AddBulkPhoneNumbersResponse addBulkPhoneNumbersWithOptions(shared_ptr<AddBulkPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddBulkPhoneNumbersResponse addBulkPhoneNumbers(shared_ptr<AddBulkPhoneNumbersRequest> request);
  AddPhoneNumberResponse addPhoneNumberWithOptions(shared_ptr<AddPhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneNumberResponse addPhoneNumber(shared_ptr<AddPhoneNumberRequest> request);
  AddPhoneTagsResponse addPhoneTagsWithOptions(shared_ptr<AddPhoneTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneTagsResponse addPhoneTags(shared_ptr<AddPhoneTagsRequest> request);
  AssignJobsResponse assignJobsWithOptions(shared_ptr<AssignJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignJobsResponse assignJobs(shared_ptr<AssignJobsRequest> request);
  AssignUsersResponse assignUsersWithOptions(shared_ptr<AssignUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignUsersResponse assignUsers(shared_ptr<AssignUsersRequest> request);
  CallOnlinePrivacyNumberResponse callOnlinePrivacyNumberWithOptions(shared_ptr<CallOnlinePrivacyNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CallOnlinePrivacyNumberResponse callOnlinePrivacyNumber(shared_ptr<CallOnlinePrivacyNumberRequest> request);
  CancelJobsResponse cancelJobsWithOptions(shared_ptr<CancelJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelJobsResponse cancelJobs(shared_ptr<CancelJobsRequest> request);
  CheckNumberAvaliableResponse checkNumberAvaliableWithOptions(shared_ptr<CheckNumberAvaliableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckNumberAvaliableResponse checkNumberAvaliable(shared_ptr<CheckNumberAvaliableRequest> request);
  CommitContactFlowVersionModificationResponse commitContactFlowVersionModificationWithOptions(shared_ptr<CommitContactFlowVersionModificationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CommitContactFlowVersionModificationResponse commitContactFlowVersionModification(shared_ptr<CommitContactFlowVersionModificationRequest> request);
  CreateBatchJobsResponse createBatchJobsWithOptions(shared_ptr<CreateBatchJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBatchJobsResponse createBatchJobs(shared_ptr<CreateBatchJobsRequest> request);
  CreateCabInstanceResponse createCabInstanceWithOptions(shared_ptr<CreateCabInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCabInstanceResponse createCabInstance(shared_ptr<CreateCabInstanceRequest> request);
  CreateContactFlowResponse createContactFlowWithOptions(shared_ptr<CreateContactFlowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateContactFlowResponse createContactFlow(shared_ptr<CreateContactFlowRequest> request);
  CreateFaultResponse createFaultWithOptions(shared_ptr<CreateFaultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFaultResponse createFault(shared_ptr<CreateFaultRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateJobGroupResponse createJobGroupWithOptions(shared_ptr<CreateJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateJobGroupResponse createJobGroup(shared_ptr<CreateJobGroupRequest> request);
  CreateMediaResponse createMediaWithOptions(shared_ptr<CreateMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaResponse createMedia(shared_ptr<CreateMediaRequest> request);
  CreatePredictiveJobGroupResponse createPredictiveJobGroupWithOptions(shared_ptr<CreatePredictiveJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePredictiveJobGroupResponse createPredictiveJobGroup(shared_ptr<CreatePredictiveJobGroupRequest> request);
  CreateScenarioResponse createScenarioWithOptions(shared_ptr<CreateScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScenarioResponse createScenario(shared_ptr<CreateScenarioRequest> request);
  CreateScenarioFromTemplateResponse createScenarioFromTemplateWithOptions(shared_ptr<CreateScenarioFromTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateScenarioFromTemplateResponse createScenarioFromTemplate(shared_ptr<CreateScenarioFromTemplateRequest> request);
  CreateSkillGroupResponse createSkillGroupWithOptions(shared_ptr<CreateSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSkillGroupResponse createSkillGroup(shared_ptr<CreateSkillGroupRequest> request);
  CreateSurveyResponse createSurveyWithOptions(shared_ptr<CreateSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSurveyResponse createSurvey(shared_ptr<CreateSurveyRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  CreateVoiceAppraiseResponse createVoiceAppraiseWithOptions(shared_ptr<CreateVoiceAppraiseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVoiceAppraiseResponse createVoiceAppraise(shared_ptr<CreateVoiceAppraiseRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteJobGroupResponse deleteJobGroupWithOptions(shared_ptr<DeleteJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteJobGroupResponse deleteJobGroup(shared_ptr<DeleteJobGroupRequest> request);
  DeleteMediaResponse deleteMediaWithOptions(shared_ptr<DeleteMediaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMediaResponse deleteMedia(shared_ptr<DeleteMediaRequest> request);
  DeletePhoneTagsResponse deletePhoneTagsWithOptions(shared_ptr<DeletePhoneTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePhoneTagsResponse deletePhoneTags(shared_ptr<DeletePhoneTagsRequest> request);
  DeleteSkillGroupResponse deleteSkillGroupWithOptions(shared_ptr<DeleteSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSkillGroupResponse deleteSkillGroup(shared_ptr<DeleteSkillGroupRequest> request);
  DeleteSurveyResponse deleteSurveyWithOptions(shared_ptr<DeleteSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSurveyResponse deleteSurvey(shared_ptr<DeleteSurveyRequest> request);
  DialExResponse dialExWithOptions(shared_ptr<DialExRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DialExResponse dialEx(shared_ptr<DialExRequest> request);
  DialogueResponse dialogueWithOptions(shared_ptr<DialogueRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DialogueResponse dialogue(shared_ptr<DialogueRequest> request);
  DisableTrunkProvidersResponse disableTrunkProvidersWithOptions(shared_ptr<DisableTrunkProvidersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableTrunkProvidersResponse disableTrunkProviders(shared_ptr<DisableTrunkProvidersRequest> request);
  DownloadAllTypeRecordingResponse downloadAllTypeRecordingWithOptions(shared_ptr<DownloadAllTypeRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadAllTypeRecordingResponse downloadAllTypeRecording(shared_ptr<DownloadAllTypeRecordingRequest> request);
  DownloadCabRecordingResponse downloadCabRecordingWithOptions(shared_ptr<DownloadCabRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadCabRecordingResponse downloadCabRecording(shared_ptr<DownloadCabRecordingRequest> request);
  DownloadOriginalStatisticsReportResponse downloadOriginalStatisticsReportWithOptions(shared_ptr<DownloadOriginalStatisticsReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadOriginalStatisticsReportResponse downloadOriginalStatisticsReport(shared_ptr<DownloadOriginalStatisticsReportRequest> request);
  DownloadRecordingResponse downloadRecordingWithOptions(shared_ptr<DownloadRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadRecordingResponse downloadRecording(shared_ptr<DownloadRecordingRequest> request);
  DownloadUnreachableContactsResponse downloadUnreachableContactsWithOptions(shared_ptr<DownloadUnreachableContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadUnreachableContactsResponse downloadUnreachableContacts(shared_ptr<DownloadUnreachableContactsRequest> request);
  FindUsersResponse findUsersWithOptions(shared_ptr<FindUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindUsersResponse findUsers(shared_ptr<FindUsersRequest> request);
  GenerateAgentStatisticReportResponse generateAgentStatisticReportWithOptions(shared_ptr<GenerateAgentStatisticReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAgentStatisticReportResponse generateAgentStatisticReport(shared_ptr<GenerateAgentStatisticReportRequest> request);
  GetAgentDataResponse getAgentDataWithOptions(shared_ptr<GetAgentDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAgentDataResponse getAgentData(shared_ptr<GetAgentDataRequest> request);
  GetCallMeasureSummaryReportResponse getCallMeasureSummaryReportWithOptions(shared_ptr<GetCallMeasureSummaryReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCallMeasureSummaryReportResponse getCallMeasureSummaryReport(shared_ptr<GetCallMeasureSummaryReportRequest> request);
  GetConfigResponse getConfigWithOptions(shared_ptr<GetConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConfigResponse getConfig(shared_ptr<GetConfigRequest> request);
  GetConversationDetailByContactIdResponse getConversationDetailByContactIdWithOptions(shared_ptr<GetConversationDetailByContactIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConversationDetailByContactIdResponse getConversationDetailByContactId(shared_ptr<GetConversationDetailByContactIdRequest> request);
  GetConversationListResponse getConversationListWithOptions(shared_ptr<GetConversationListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConversationListResponse getConversationList(shared_ptr<GetConversationListRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetInstanceStateResponse getInstanceStateWithOptions(shared_ptr<GetInstanceStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceStateResponse getInstanceState(shared_ptr<GetInstanceStateRequest> request);
  GetInstanceSummaryReportResponse getInstanceSummaryReportWithOptions(shared_ptr<GetInstanceSummaryReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceSummaryReportResponse getInstanceSummaryReport(shared_ptr<GetInstanceSummaryReportRequest> request);
  GetInstanceSummaryReportByIntervalResponse getInstanceSummaryReportByIntervalWithOptions(shared_ptr<GetInstanceSummaryReportByIntervalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceSummaryReportByIntervalResponse getInstanceSummaryReportByInterval(shared_ptr<GetInstanceSummaryReportByIntervalRequest> request);
  GetInstanceSummaryReportSinceMidnightResponse getInstanceSummaryReportSinceMidnightWithOptions(shared_ptr<GetInstanceSummaryReportSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceSummaryReportSinceMidnightResponse getInstanceSummaryReportSinceMidnight(shared_ptr<GetInstanceSummaryReportSinceMidnightRequest> request);
  GetJobResponse getJobWithOptions(shared_ptr<GetJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobResponse getJob(shared_ptr<GetJobRequest> request);
  GetJobDataUploadParamsResponse getJobDataUploadParamsWithOptions(shared_ptr<GetJobDataUploadParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobDataUploadParamsResponse getJobDataUploadParams(shared_ptr<GetJobDataUploadParamsRequest> request);
  GetJobFileUploadUrlResponse getJobFileUploadUrlWithOptions(shared_ptr<GetJobFileUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobFileUploadUrlResponse getJobFileUploadUrl(shared_ptr<GetJobFileUploadUrlRequest> request);
  GetJobGroupResponse getJobGroupWithOptions(shared_ptr<GetJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobGroupResponse getJobGroup(shared_ptr<GetJobGroupRequest> request);
  GetJobListResponse getJobListWithOptions(shared_ptr<GetJobListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobListResponse getJobList(shared_ptr<GetJobListRequest> request);
  GetJobStatusByCallIdResponse getJobStatusByCallIdWithOptions(shared_ptr<GetJobStatusByCallIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobStatusByCallIdResponse getJobStatusByCallId(shared_ptr<GetJobStatusByCallIdRequest> request);
  GetJobTemplateDownloadParamsResponse getJobTemplateDownloadParamsWithOptions(shared_ptr<GetJobTemplateDownloadParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetJobTemplateDownloadParamsResponse getJobTemplateDownloadParams(shared_ptr<GetJobTemplateDownloadParamsRequest> request);
  GetNumberRegionInfoResponse getNumberRegionInfoWithOptions(shared_ptr<GetNumberRegionInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNumberRegionInfoResponse getNumberRegionInfo(shared_ptr<GetNumberRegionInfoRequest> request);
  GetRecordOssUploadParamResponse getRecordOssUploadParamWithOptions(shared_ptr<GetRecordOssUploadParamRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRecordOssUploadParamResponse getRecordOssUploadParam(shared_ptr<GetRecordOssUploadParamRequest> request);
  GetRoutePointResponse getRoutePointWithOptions(shared_ptr<GetRoutePointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRoutePointResponse getRoutePoint(shared_ptr<GetRoutePointRequest> request);
  GetScenarioResponse getScenarioWithOptions(shared_ptr<GetScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetScenarioResponse getScenario(shared_ptr<GetScenarioRequest> request);
  GetServiceExtensionsResponse getServiceExtensionsWithOptions(shared_ptr<GetServiceExtensionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceExtensionsResponse getServiceExtensions(shared_ptr<GetServiceExtensionsRequest> request);
  GetSmsConfigResponse getSmsConfigWithOptions(shared_ptr<GetSmsConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmsConfigResponse getSmsConfig(shared_ptr<GetSmsConfigRequest> request);
  GetSurveyResponse getSurveyWithOptions(shared_ptr<GetSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSurveyResponse getSurvey(shared_ptr<GetSurveyRequest> request);
  GetTaskListResponse getTaskListWithOptions(shared_ptr<GetTaskListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskListResponse getTaskList(shared_ptr<GetTaskListRequest> request);
  GetTURNCredentialsResponse getTURNCredentialsWithOptions(shared_ptr<GetTURNCredentialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTURNCredentialsResponse getTURNCredentials(shared_ptr<GetTURNCredentialsRequest> request);
  GetTURNServerListResponse getTURNServerListWithOptions(shared_ptr<GetTURNServerListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTURNServerListResponse getTURNServerList(shared_ptr<GetTURNServerListRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetUserByExtensionResponse getUserByExtensionWithOptions(shared_ptr<GetUserByExtensionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserByExtensionResponse getUserByExtension(shared_ptr<GetUserByExtensionRequest> request);
  InflightTaskTimeoutResponse inflightTaskTimeoutWithOptions(shared_ptr<InflightTaskTimeoutRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InflightTaskTimeoutResponse inflightTaskTimeout(shared_ptr<InflightTaskTimeoutRequest> request);
  LaunchAppraiseResponse launchAppraiseWithOptions(shared_ptr<LaunchAppraiseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchAppraiseResponse launchAppraise(shared_ptr<LaunchAppraiseRequest> request);
  LaunchShortMessageAppraiseResponse launchShortMessageAppraiseWithOptions(shared_ptr<LaunchShortMessageAppraiseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchShortMessageAppraiseResponse launchShortMessageAppraise(shared_ptr<LaunchShortMessageAppraiseRequest> request);
  ListAgentDevicesResponse listAgentDevicesWithOptions(shared_ptr<ListAgentDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentDevicesResponse listAgentDevices(shared_ptr<ListAgentDevicesRequest> request);
  ListAgentEventsResponse listAgentEventsWithOptions(shared_ptr<ListAgentEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentEventsResponse listAgentEvents(shared_ptr<ListAgentEventsRequest> request);
  ListAgentStateLogsResponse listAgentStateLogsWithOptions(shared_ptr<ListAgentStateLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStateLogsResponse listAgentStateLogs(shared_ptr<ListAgentStateLogsRequest> request);
  ListAgentStatesResponse listAgentStatesWithOptions(shared_ptr<ListAgentStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStatesResponse listAgentStates(shared_ptr<ListAgentStatesRequest> request);
  ListAgentSummaryReportsResponse listAgentSummaryReportsWithOptions(shared_ptr<ListAgentSummaryReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentSummaryReportsResponse listAgentSummaryReports(shared_ptr<ListAgentSummaryReportsRequest> request);
  ListAgentSummaryReportsByIntervalResponse listAgentSummaryReportsByIntervalWithOptions(shared_ptr<ListAgentSummaryReportsByIntervalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentSummaryReportsByIntervalResponse listAgentSummaryReportsByInterval(shared_ptr<ListAgentSummaryReportsByIntervalRequest> request);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnightWithOptions(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnight(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request);
  ListBasicStatisticsReportSubItemsResponse listBasicStatisticsReportSubItemsWithOptions(shared_ptr<ListBasicStatisticsReportSubItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBasicStatisticsReportSubItemsResponse listBasicStatisticsReportSubItems(shared_ptr<ListBasicStatisticsReportSubItemsRequest> request);
  ListCallDetailRecordsResponse listCallDetailRecordsWithOptions(shared_ptr<ListCallDetailRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallDetailRecordsResponse listCallDetailRecords(shared_ptr<ListCallDetailRecordsRequest> request);
  ListCallEventDetailByContactIdResponse listCallEventDetailByContactIdWithOptions(shared_ptr<ListCallEventDetailByContactIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallEventDetailByContactIdResponse listCallEventDetailByContactId(shared_ptr<ListCallEventDetailByContactIdRequest> request);
  ListCallMeasureSummaryReportsResponse listCallMeasureSummaryReportsWithOptions(shared_ptr<ListCallMeasureSummaryReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallMeasureSummaryReportsResponse listCallMeasureSummaryReports(shared_ptr<ListCallMeasureSummaryReportsRequest> request);
  ListConfigResponse listConfigWithOptions(shared_ptr<ListConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigResponse listConfig(shared_ptr<ListConfigRequest> request);
  ListContactFlowsResponse listContactFlowsWithOptions(shared_ptr<ListContactFlowsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListContactFlowsResponse listContactFlows(shared_ptr<ListContactFlowsRequest> request);
  ListInstancesOfUserResponse listInstancesOfUserWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesOfUserResponse listInstancesOfUser();
  ListIvrTrackingDetailResponse listIvrTrackingDetailWithOptions(shared_ptr<ListIvrTrackingDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIvrTrackingDetailResponse listIvrTrackingDetail(shared_ptr<ListIvrTrackingDetailRequest> request);
  ListJobGroupsResponse listJobGroupsWithOptions(shared_ptr<ListJobGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobGroupsResponse listJobGroups(shared_ptr<ListJobGroupsRequest> request);
  ListJobsByGroupResponse listJobsByGroupWithOptions(shared_ptr<ListJobsByGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobsByGroupResponse listJobsByGroup(shared_ptr<ListJobsByGroupRequest> request);
  ListJobStatusResponse listJobStatusWithOptions(shared_ptr<ListJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListJobStatusResponse listJobStatus(shared_ptr<ListJobStatusRequest> request);
  ListMediasResponse listMediasWithOptions(shared_ptr<ListMediasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMediasResponse listMedias(shared_ptr<ListMediasRequest> request);
  ListOutboundPhoneNumberOfUserResponse listOutboundPhoneNumberOfUserWithOptions(shared_ptr<ListOutboundPhoneNumberOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOutboundPhoneNumberOfUserResponse listOutboundPhoneNumberOfUser(shared_ptr<ListOutboundPhoneNumberOfUserRequest> request);
  ListPhoneNumbersResponse listPhoneNumbersWithOptions(shared_ptr<ListPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneNumbersResponse listPhoneNumbers(shared_ptr<ListPhoneNumbersRequest> request);
  ListPhoneTagsResponse listPhoneTagsWithOptions(shared_ptr<ListPhoneTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneTagsResponse listPhoneTags(shared_ptr<ListPhoneTagsRequest> request);
  ListRealTimeAgentResponse listRealTimeAgentWithOptions(shared_ptr<ListRealTimeAgentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealTimeAgentResponse listRealTimeAgent(shared_ptr<ListRealTimeAgentRequest> request);
  ListRecentCallRecordsResponse listRecentCallRecordsWithOptions(shared_ptr<ListRecentCallRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecentCallRecordsResponse listRecentCallRecords(shared_ptr<ListRecentCallRecordsRequest> request);
  ListRecordingOfDualTrackResponse listRecordingOfDualTrackWithOptions(shared_ptr<ListRecordingOfDualTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecordingOfDualTrackResponse listRecordingOfDualTrack(shared_ptr<ListRecordingOfDualTrackRequest> request);
  ListRecordingsResponse listRecordingsWithOptions(shared_ptr<ListRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecordingsResponse listRecordings(shared_ptr<ListRecordingsRequest> request);
  ListRecordingsByContactIdResponse listRecordingsByContactIdWithOptions(shared_ptr<ListRecordingsByContactIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecordingsByContactIdResponse listRecordingsByContactId(shared_ptr<ListRecordingsByContactIdRequest> request);
  ListRolesResponse listRolesWithOptions(shared_ptr<ListRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRolesResponse listRoles(shared_ptr<ListRolesRequest> request);
  ListScenariosResponse listScenariosWithOptions(shared_ptr<ListScenariosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScenariosResponse listScenarios(shared_ptr<ListScenariosRequest> request);
  ListScenarioTemplatesResponse listScenarioTemplatesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListScenarioTemplatesResponse listScenarioTemplates();
  ListSkillGroupsResponse listSkillGroupsWithOptions(shared_ptr<ListSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupsResponse listSkillGroups(shared_ptr<ListSkillGroupsRequest> request);
  ListSkillGroupsOfUserResponse listSkillGroupsOfUserWithOptions(shared_ptr<ListSkillGroupsOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupsOfUserResponse listSkillGroupsOfUser(shared_ptr<ListSkillGroupsOfUserRequest> request);
  ListSkillGroupStatesResponse listSkillGroupStatesWithOptions(shared_ptr<ListSkillGroupStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupStatesResponse listSkillGroupStates(shared_ptr<ListSkillGroupStatesRequest> request);
  ListSkillGroupSummaryReportsResponse listSkillGroupSummaryReportsWithOptions(shared_ptr<ListSkillGroupSummaryReportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupSummaryReportsResponse listSkillGroupSummaryReports(shared_ptr<ListSkillGroupSummaryReportsRequest> request);
  ListSkillGroupSummaryReportsByIntervalResponse listSkillGroupSummaryReportsByIntervalWithOptions(shared_ptr<ListSkillGroupSummaryReportsByIntervalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupSummaryReportsByIntervalResponse listSkillGroupSummaryReportsByInterval(shared_ptr<ListSkillGroupSummaryReportsByIntervalRequest> request);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnightWithOptions(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnight(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request);
  ListSurveysResponse listSurveysWithOptions(shared_ptr<ListSurveysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSurveysResponse listSurveys(shared_ptr<ListSurveysRequest> request);
  ListTransferableSkillGroupsResponse listTransferableSkillGroupsWithOptions(shared_ptr<ListTransferableSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTransferableSkillGroupsResponse listTransferableSkillGroups(shared_ptr<ListTransferableSkillGroupsRequest> request);
  ListTrunkProvidersResponse listTrunkProvidersWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrunkProvidersResponse listTrunkProviders();
  ListTrunksOfSkillGroupResponse listTrunksOfSkillGroupWithOptions(shared_ptr<ListTrunksOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrunksOfSkillGroupResponse listTrunksOfSkillGroup(shared_ptr<ListTrunksOfSkillGroupRequest> request);
  ListUnreachableContactsResponse listUnreachableContactsWithOptions(shared_ptr<ListUnreachableContactsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUnreachableContactsResponse listUnreachableContacts(shared_ptr<ListUnreachableContactsRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  ListUsersOfSkillGroupResponse listUsersOfSkillGroupWithOptions(shared_ptr<ListUsersOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersOfSkillGroupResponse listUsersOfSkillGroup(shared_ptr<ListUsersOfSkillGroupRequest> request);
  ListVoiceAppraiseResponse listVoiceAppraiseWithOptions(shared_ptr<ListVoiceAppraiseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVoiceAppraiseResponse listVoiceAppraise(shared_ptr<ListVoiceAppraiseRequest> request);
  ModifyAgentDeviceResponse modifyAgentDeviceWithOptions(shared_ptr<ModifyAgentDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAgentDeviceResponse modifyAgentDevice(shared_ptr<ModifyAgentDeviceRequest> request);
  ModifyCabInstanceResponse modifyCabInstanceWithOptions(shared_ptr<ModifyCabInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCabInstanceResponse modifyCabInstance(shared_ptr<ModifyCabInstanceRequest> request);
  ModifyPhoneNumberResponse modifyPhoneNumberWithOptions(shared_ptr<ModifyPhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhoneNumberResponse modifyPhoneNumber(shared_ptr<ModifyPhoneNumberRequest> request);
  ModifyPhoneTagsResponse modifyPhoneTagsWithOptions(shared_ptr<ModifyPhoneTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhoneTagsResponse modifyPhoneTags(shared_ptr<ModifyPhoneTagsRequest> request);
  ModifyPrimaryTrunksOfSkillGroupResponse modifyPrimaryTrunksOfSkillGroupWithOptions(shared_ptr<ModifyPrimaryTrunksOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrimaryTrunksOfSkillGroupResponse modifyPrimaryTrunksOfSkillGroup(shared_ptr<ModifyPrimaryTrunksOfSkillGroupRequest> request);
  ModifyPrivacyNumberCallDetailResponse modifyPrivacyNumberCallDetailWithOptions(shared_ptr<ModifyPrivacyNumberCallDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPrivacyNumberCallDetailResponse modifyPrivacyNumberCallDetail(shared_ptr<ModifyPrivacyNumberCallDetailRequest> request);
  ModifyScenarioResponse modifyScenarioWithOptions(shared_ptr<ModifyScenarioRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyScenarioResponse modifyScenario(shared_ptr<ModifyScenarioRequest> request);
  ModifySkillGroupResponse modifySkillGroupWithOptions(shared_ptr<ModifySkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillGroupResponse modifySkillGroup(shared_ptr<ModifySkillGroupRequest> request);
  ModifySkillGroupOfUserResponse modifySkillGroupOfUserWithOptions(shared_ptr<ModifySkillGroupOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillGroupOfUserResponse modifySkillGroupOfUser(shared_ptr<ModifySkillGroupOfUserRequest> request);
  ModifySkillGroupOutboundNumbersResponse modifySkillGroupOutboundNumbersWithOptions(shared_ptr<ModifySkillGroupOutboundNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillGroupOutboundNumbersResponse modifySkillGroupOutboundNumbers(shared_ptr<ModifySkillGroupOutboundNumbersRequest> request);
  ModifySurveyResponse modifySurveyWithOptions(shared_ptr<ModifySurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySurveyResponse modifySurvey(shared_ptr<ModifySurveyRequest> request);
  ModifyUserResponse modifyUserWithOptions(shared_ptr<ModifyUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserResponse modifyUser(shared_ptr<ModifyUserRequest> request);
  PickGlobalOutboundNumbersResponse pickGlobalOutboundNumbersWithOptions(shared_ptr<PickGlobalOutboundNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PickGlobalOutboundNumbersResponse pickGlobalOutboundNumbers(shared_ptr<PickGlobalOutboundNumbersRequest> request);
  PickLocalNumberResponse pickLocalNumberWithOptions(shared_ptr<PickLocalNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PickLocalNumberResponse pickLocalNumber(shared_ptr<PickLocalNumberRequest> request);
  PickOutboundNumbersResponse pickOutboundNumbersWithOptions(shared_ptr<PickOutboundNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PickOutboundNumbersResponse pickOutboundNumbers(shared_ptr<PickOutboundNumbersRequest> request);
  PublishContactFlowVersionResponse publishContactFlowVersionWithOptions(shared_ptr<PublishContactFlowVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishContactFlowVersionResponse publishContactFlowVersion(shared_ptr<PublishContactFlowVersionRequest> request);
  PublishPredictiveJobGroupResponse publishPredictiveJobGroupWithOptions(shared_ptr<PublishPredictiveJobGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishPredictiveJobGroupResponse publishPredictiveJobGroup(shared_ptr<PublishPredictiveJobGroupRequest> request);
  PublishSurveyResponse publishSurveyWithOptions(shared_ptr<PublishSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishSurveyResponse publishSurvey(shared_ptr<PublishSurveyRequest> request);
  RefreshTokenResponse refreshTokenWithOptions(shared_ptr<RefreshTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshTokenResponse refreshToken(shared_ptr<RefreshTokenRequest> request);
  RemovePhoneNumberResponse removePhoneNumberWithOptions(shared_ptr<RemovePhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumberResponse removePhoneNumber(shared_ptr<RemovePhoneNumberRequest> request);
  RemoveUsersResponse removeUsersWithOptions(shared_ptr<RemoveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersResponse removeUsers(shared_ptr<RemoveUsersRequest> request);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroupWithOptions(shared_ptr<RemoveUsersFromSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroup(shared_ptr<RemoveUsersFromSkillGroupRequest> request);
  RequestLoginInfoResponse requestLoginInfoWithOptions(shared_ptr<RequestLoginInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RequestLoginInfoResponse requestLoginInfo(shared_ptr<RequestLoginInfoRequest> request);
  ResetUserStatusResponse resetUserStatusWithOptions(shared_ptr<ResetUserStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetUserStatusResponse resetUserStatus(shared_ptr<ResetUserStatusRequest> request);
  ResumeJobsResponse resumeJobsWithOptions(shared_ptr<ResumeJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeJobsResponse resumeJobs(shared_ptr<ResumeJobsRequest> request);
  ResumePredictiveJobsResponse resumePredictiveJobsWithOptions(shared_ptr<ResumePredictiveJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumePredictiveJobsResponse resumePredictiveJobs(shared_ptr<ResumePredictiveJobsRequest> request);
  SaveStatsResponse saveStatsWithOptions(shared_ptr<SaveStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveStatsResponse saveStats(shared_ptr<SaveStatsRequest> request);
  SaveWebRTCStatsResponse saveWebRTCStatsWithOptions(shared_ptr<SaveWebRTCStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveWebRTCStatsResponse saveWebRTCStats(shared_ptr<SaveWebRTCStatsRequest> request);
  SendPredefinedShortMessageResponse sendPredefinedShortMessageWithOptions(shared_ptr<SendPredefinedShortMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendPredefinedShortMessageResponse sendPredefinedShortMessage(shared_ptr<SendPredefinedShortMessageRequest> request);
  StartBack2BackCallResponse startBack2BackCallWithOptions(shared_ptr<StartBack2BackCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartBack2BackCallResponse startBack2BackCall(shared_ptr<StartBack2BackCallRequest> request);
  StartJobResponse startJobWithOptions(shared_ptr<StartJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartJobResponse startJob(shared_ptr<StartJobRequest> request);
  SubmitBatchJobsResponse submitBatchJobsWithOptions(shared_ptr<SubmitBatchJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitBatchJobsResponse submitBatchJobs(shared_ptr<SubmitBatchJobsRequest> request);
  SubmitCabRecordingResponse submitCabRecordingWithOptions(shared_ptr<SubmitCabRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCabRecordingResponse submitCabRecording(shared_ptr<SubmitCabRecordingRequest> request);
  SuspendJobsResponse suspendJobsWithOptions(shared_ptr<SuspendJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendJobsResponse suspendJobs(shared_ptr<SuspendJobsRequest> request);
  SuspendPredictiveJobsResponse suspendPredictiveJobsWithOptions(shared_ptr<SuspendPredictiveJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendPredictiveJobsResponse suspendPredictiveJobs(shared_ptr<SuspendPredictiveJobsRequest> request);
  TaskPreparingResponse taskPreparingWithOptions(shared_ptr<TaskPreparingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TaskPreparingResponse taskPreparing(shared_ptr<TaskPreparingRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CCC20170705

#endif
