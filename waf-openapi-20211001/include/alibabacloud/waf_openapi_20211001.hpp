// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_WAF-OPENAPI20211001_H_
#define ALIBABACLOUD_WAF-OPENAPI20211001_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Waf-openapi20211001 {
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class ClearMajorProtectionBlackIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  ClearMajorProtectionBlackIpRequest() {}

  explicit ClearMajorProtectionBlackIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ClearMajorProtectionBlackIpRequest() = default;
};
class ClearMajorProtectionBlackIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ClearMajorProtectionBlackIpResponseBody() {}

  explicit ClearMajorProtectionBlackIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClearMajorProtectionBlackIpResponseBody() = default;
};
class ClearMajorProtectionBlackIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearMajorProtectionBlackIpResponseBody> body{};

  ClearMajorProtectionBlackIpResponse() {}

  explicit ClearMajorProtectionBlackIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearMajorProtectionBlackIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearMajorProtectionBlackIpResponseBody>(model1);
      }
    }
  }


  virtual ~ClearMajorProtectionBlackIpResponse() = default;
};
class CopyDefenseTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};

  CopyDefenseTemplateRequest() {}

  explicit CopyDefenseTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CopyDefenseTemplateRequest() = default;
};
class CopyDefenseTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> templateId{};

  CopyDefenseTemplateResponseBody() {}

  explicit CopyDefenseTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CopyDefenseTemplateResponseBody() = default;
};
class CopyDefenseTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyDefenseTemplateResponseBody> body{};

  CopyDefenseTemplateResponse() {}

  explicit CopyDefenseTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyDefenseTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyDefenseTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CopyDefenseTemplateResponse() = default;
};
class CreateApiExportRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> param{};
  shared_ptr<string> region{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> type{};
  shared_ptr<string> zoneId{};

  CreateApiExportRequest() {}

  explicit CreateApiExportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (param) {
      res["Param"] = boost::any(*param);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Param") != m.end() && !m["Param"].empty()) {
      param = make_shared<string>(boost::any_cast<string>(m["Param"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateApiExportRequest() = default;
};
class CreateApiExportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateApiExportResponseBody() {}

  explicit CreateApiExportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiExportResponseBody() = default;
};
class CreateApiExportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiExportResponseBody> body{};

  CreateApiExportResponse() {}

  explicit CreateApiExportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiExportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiExportResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiExportResponse() = default;
};
class CreateCloudResourceRequestListenCertificates : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certificateId{};

  CreateCloudResourceRequestListenCertificates() {}

  explicit CreateCloudResourceRequestListenCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
  }


  virtual ~CreateCloudResourceRequestListenCertificates() = default;
};
class CreateCloudResourceRequestListen : public Darabonba::Model {
public:
  shared_ptr<vector<CreateCloudResourceRequestListenCertificates>> certificates{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> TLSVersion{};

  CreateCloudResourceRequestListen() {}

  explicit CreateCloudResourceRequestListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<CreateCloudResourceRequestListenCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudResourceRequestListenCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<CreateCloudResourceRequestListenCertificates>>(expect1);
      }
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
  }


  virtual ~CreateCloudResourceRequestListen() = default;
};
class CreateCloudResourceRequestRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCloudResourceRequestRedirectRequestHeaders() {}

  explicit CreateCloudResourceRequestRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCloudResourceRequestRedirectRequestHeaders() = default;
};
class CreateCloudResourceRequestRedirect : public Darabonba::Model {
public:
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<CreateCloudResourceRequestRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};
  shared_ptr<bool> xffProto{};

  CreateCloudResourceRequestRedirect() {}

  explicit CreateCloudResourceRequestRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<CreateCloudResourceRequestRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudResourceRequestRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<CreateCloudResourceRequestRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~CreateCloudResourceRequestRedirect() = default;
};
class CreateCloudResourceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCloudResourceRequestTag() {}

  explicit CreateCloudResourceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCloudResourceRequestTag() = default;
};
class CreateCloudResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<CreateCloudResourceRequestListen> listen{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<CreateCloudResourceRequestRedirect> redirect{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<CreateCloudResourceRequestTag>> tag{};

  CreateCloudResourceRequest() {}

  explicit CreateCloudResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        CreateCloudResourceRequestListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<CreateCloudResourceRequestListen>(model1);
      }
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        CreateCloudResourceRequestRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<CreateCloudResourceRequestRedirect>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateCloudResourceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudResourceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateCloudResourceRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateCloudResourceRequest() = default;
};
class CreateCloudResourceShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateCloudResourceShrinkRequestTag() {}

  explicit CreateCloudResourceShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateCloudResourceShrinkRequestTag() = default;
};
class CreateCloudResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> listenShrink{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> redirectShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<CreateCloudResourceShrinkRequestTag>> tag{};

  CreateCloudResourceShrinkRequest() {}

  explicit CreateCloudResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listenShrink) {
      res["Listen"] = boost::any(*listenShrink);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (redirectShrink) {
      res["Redirect"] = boost::any(*redirectShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      listenShrink = make_shared<string>(boost::any_cast<string>(m["Listen"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      redirectShrink = make_shared<string>(boost::any_cast<string>(m["Redirect"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateCloudResourceShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCloudResourceShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateCloudResourceShrinkRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateCloudResourceShrinkRequest() = default;
};
class CreateCloudResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cloudResourceId{};
  shared_ptr<string> requestId{};

  CreateCloudResourceResponseBody() {}

  explicit CreateCloudResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResourceId) {
      res["CloudResourceId"] = boost::any(*cloudResourceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResourceId") != m.end() && !m["CloudResourceId"].empty()) {
      cloudResourceId = make_shared<string>(boost::any_cast<string>(m["CloudResourceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCloudResourceResponseBody() = default;
};
class CreateCloudResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudResourceResponseBody> body{};

  CreateCloudResourceResponse() {}

  explicit CreateCloudResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudResourceResponse() = default;
};
class CreateDefenseResourceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDefenseResourceRequestTag() {}

  explicit CreateDefenseResourceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDefenseResourceRequestTag() = default;
};
class CreateDefenseResourceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> customHeaders{};
  shared_ptr<string> description{};
  shared_ptr<string> detail{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> pattern{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceOrigin{};
  shared_ptr<vector<CreateDefenseResourceRequestTag>> tag{};
  shared_ptr<long> xffStatus{};

  CreateDefenseResourceRequest() {}

  explicit CreateDefenseResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHeaders) {
      res["CustomHeaders"] = boost::any(*customHeaders);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceOrigin) {
      res["ResourceOrigin"] = boost::any(*resourceOrigin);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (xffStatus) {
      res["XffStatus"] = boost::any(*xffStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHeaders") != m.end() && !m["CustomHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceOrigin") != m.end() && !m["ResourceOrigin"].empty()) {
      resourceOrigin = make_shared<string>(boost::any_cast<string>(m["ResourceOrigin"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDefenseResourceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDefenseResourceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDefenseResourceRequestTag>>(expect1);
      }
    }
    if (m.find("XffStatus") != m.end() && !m["XffStatus"].empty()) {
      xffStatus = make_shared<long>(boost::any_cast<long>(m["XffStatus"]));
    }
  }


  virtual ~CreateDefenseResourceRequest() = default;
};
class CreateDefenseResourceShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDefenseResourceShrinkRequestTag() {}

  explicit CreateDefenseResourceShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDefenseResourceShrinkRequestTag() = default;
};
class CreateDefenseResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> customHeadersShrink{};
  shared_ptr<string> description{};
  shared_ptr<string> detail{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> pattern{};
  shared_ptr<string> product{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceOrigin{};
  shared_ptr<vector<CreateDefenseResourceShrinkRequestTag>> tag{};
  shared_ptr<long> xffStatus{};

  CreateDefenseResourceShrinkRequest() {}

  explicit CreateDefenseResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customHeadersShrink) {
      res["CustomHeaders"] = boost::any(*customHeadersShrink);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceOrigin) {
      res["ResourceOrigin"] = boost::any(*resourceOrigin);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (xffStatus) {
      res["XffStatus"] = boost::any(*xffStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomHeaders") != m.end() && !m["CustomHeaders"].empty()) {
      customHeadersShrink = make_shared<string>(boost::any_cast<string>(m["CustomHeaders"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceOrigin") != m.end() && !m["ResourceOrigin"].empty()) {
      resourceOrigin = make_shared<string>(boost::any_cast<string>(m["ResourceOrigin"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDefenseResourceShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDefenseResourceShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDefenseResourceShrinkRequestTag>>(expect1);
      }
    }
    if (m.find("XffStatus") != m.end() && !m["XffStatus"].empty()) {
      xffStatus = make_shared<long>(boost::any_cast<long>(m["XffStatus"]));
    }
  }


  virtual ~CreateDefenseResourceShrinkRequest() = default;
};
class CreateDefenseResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> resource{};

  CreateDefenseResourceResponseBody() {}

  explicit CreateDefenseResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~CreateDefenseResourceResponseBody() = default;
};
class CreateDefenseResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefenseResourceResponseBody> body{};

  CreateDefenseResourceResponse() {}

  explicit CreateDefenseResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefenseResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefenseResourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefenseResourceResponse() = default;
};
class CreateDefenseResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> addList{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  CreateDefenseResourceGroupRequest() {}

  explicit CreateDefenseResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addList) {
      res["AddList"] = boost::any(*addList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddList") != m.end() && !m["AddList"].empty()) {
      addList = make_shared<string>(boost::any_cast<string>(m["AddList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~CreateDefenseResourceGroupRequest() = default;
};
class CreateDefenseResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDefenseResourceGroupResponseBody() {}

  explicit CreateDefenseResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDefenseResourceGroupResponseBody() = default;
};
class CreateDefenseResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefenseResourceGroupResponseBody> body{};

  CreateDefenseResourceGroupResponse() {}

  explicit CreateDefenseResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefenseResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefenseResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefenseResourceGroupResponse() = default;
};
class CreateDefenseRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> rules{};
  shared_ptr<long> templateId{};

  CreateDefenseRuleRequest() {}

  explicit CreateDefenseRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseType) {
      res["DefenseType"] = boost::any(*defenseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseType") != m.end() && !m["DefenseType"].empty()) {
      defenseType = make_shared<string>(boost::any_cast<string>(m["DefenseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CreateDefenseRuleRequest() = default;
};
class CreateDefenseRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> ruleIds{};

  CreateDefenseRuleResponseBody() {}

  explicit CreateDefenseRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
  }


  virtual ~CreateDefenseRuleResponseBody() = default;
};
class CreateDefenseRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefenseRuleResponseBody> body{};

  CreateDefenseRuleResponse() {}

  explicit CreateDefenseRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefenseRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefenseRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefenseRuleResponse() = default;
};
class CreateDefenseTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateOrigin{};
  shared_ptr<long> templateStatus{};
  shared_ptr<string> templateType{};

  CreateDefenseTemplateRequest() {}

  explicit CreateDefenseTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateOrigin) {
      res["TemplateOrigin"] = boost::any(*templateOrigin);
    }
    if (templateStatus) {
      res["TemplateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateOrigin") != m.end() && !m["TemplateOrigin"].empty()) {
      templateOrigin = make_shared<string>(boost::any_cast<string>(m["TemplateOrigin"]));
    }
    if (m.find("TemplateStatus") != m.end() && !m["TemplateStatus"].empty()) {
      templateStatus = make_shared<long>(boost::any_cast<long>(m["TemplateStatus"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~CreateDefenseTemplateRequest() = default;
};
class CreateDefenseTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> templateId{};

  CreateDefenseTemplateResponseBody() {}

  explicit CreateDefenseTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CreateDefenseTemplateResponseBody() = default;
};
class CreateDefenseTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDefenseTemplateResponseBody> body{};

  CreateDefenseTemplateResponse() {}

  explicit CreateDefenseTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDefenseTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDefenseTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDefenseTemplateResponse() = default;
};
class CreateDomainRequestListen : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> exclusiveIp{};
  shared_ptr<bool> focusHttps{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<vector<long>> httpPorts{};
  shared_ptr<vector<long>> httpsPorts{};
  shared_ptr<bool> IPv6Enabled{};
  shared_ptr<string> protectionResource{};
  shared_ptr<bool> SM2AccessOnly{};
  shared_ptr<string> SM2CertId{};
  shared_ptr<bool> SM2Enabled{};
  shared_ptr<string> TLSVersion{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};

  CreateDomainRequestListen() {}

  explicit CreateDomainRequestListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (exclusiveIp) {
      res["ExclusiveIp"] = boost::any(*exclusiveIp);
    }
    if (focusHttps) {
      res["FocusHttps"] = boost::any(*focusHttps);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (IPv6Enabled) {
      res["IPv6Enabled"] = boost::any(*IPv6Enabled);
    }
    if (protectionResource) {
      res["ProtectionResource"] = boost::any(*protectionResource);
    }
    if (SM2AccessOnly) {
      res["SM2AccessOnly"] = boost::any(*SM2AccessOnly);
    }
    if (SM2CertId) {
      res["SM2CertId"] = boost::any(*SM2CertId);
    }
    if (SM2Enabled) {
      res["SM2Enabled"] = boost::any(*SM2Enabled);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("ExclusiveIp") != m.end() && !m["ExclusiveIp"].empty()) {
      exclusiveIp = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveIp"]));
    }
    if (m.find("FocusHttps") != m.end() && !m["FocusHttps"].empty()) {
      focusHttps = make_shared<bool>(boost::any_cast<bool>(m["FocusHttps"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpsPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpsPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpsPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IPv6Enabled") != m.end() && !m["IPv6Enabled"].empty()) {
      IPv6Enabled = make_shared<bool>(boost::any_cast<bool>(m["IPv6Enabled"]));
    }
    if (m.find("ProtectionResource") != m.end() && !m["ProtectionResource"].empty()) {
      protectionResource = make_shared<string>(boost::any_cast<string>(m["ProtectionResource"]));
    }
    if (m.find("SM2AccessOnly") != m.end() && !m["SM2AccessOnly"].empty()) {
      SM2AccessOnly = make_shared<bool>(boost::any_cast<bool>(m["SM2AccessOnly"]));
    }
    if (m.find("SM2CertId") != m.end() && !m["SM2CertId"].empty()) {
      SM2CertId = make_shared<string>(boost::any_cast<string>(m["SM2CertId"]));
    }
    if (m.find("SM2Enabled") != m.end() && !m["SM2Enabled"].empty()) {
      SM2Enabled = make_shared<bool>(boost::any_cast<bool>(m["SM2Enabled"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateDomainRequestListen() = default;
};
class CreateDomainRequestRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDomainRequestRedirectRequestHeaders() {}

  explicit CreateDomainRequestRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDomainRequestRedirectRequestHeaders() = default;
};
class CreateDomainRequestRedirect : public Darabonba::Model {
public:
  shared_ptr<vector<string>> backends{};
  shared_ptr<vector<string>> backupBackends{};
  shared_ptr<bool> cnameEnabled{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<bool> focusHttpBackend{};
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<string> loadbalance{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<CreateDomainRequestRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<bool> retry{};
  shared_ptr<string> routingRules{};
  shared_ptr<bool> sniEnabled{};
  shared_ptr<string> sniHost{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<bool> xffProto{};

  CreateDomainRequestRedirect() {}

  explicit CreateDomainRequestRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backends) {
      res["Backends"] = boost::any(*backends);
    }
    if (backupBackends) {
      res["BackupBackends"] = boost::any(*backupBackends);
    }
    if (cnameEnabled) {
      res["CnameEnabled"] = boost::any(*cnameEnabled);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (focusHttpBackend) {
      res["FocusHttpBackend"] = boost::any(*focusHttpBackend);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (loadbalance) {
      res["Loadbalance"] = boost::any(*loadbalance);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (routingRules) {
      res["RoutingRules"] = boost::any(*routingRules);
    }
    if (sniEnabled) {
      res["SniEnabled"] = boost::any(*sniEnabled);
    }
    if (sniHost) {
      res["SniHost"] = boost::any(*sniHost);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backends") != m.end() && !m["Backends"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Backends"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Backends"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backends = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BackupBackends") != m.end() && !m["BackupBackends"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BackupBackends"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BackupBackends"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backupBackends = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CnameEnabled") != m.end() && !m["CnameEnabled"].empty()) {
      cnameEnabled = make_shared<bool>(boost::any_cast<bool>(m["CnameEnabled"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("FocusHttpBackend") != m.end() && !m["FocusHttpBackend"].empty()) {
      focusHttpBackend = make_shared<bool>(boost::any_cast<bool>(m["FocusHttpBackend"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("Loadbalance") != m.end() && !m["Loadbalance"].empty()) {
      loadbalance = make_shared<string>(boost::any_cast<string>(m["Loadbalance"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<CreateDomainRequestRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDomainRequestRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<CreateDomainRequestRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["Retry"]));
    }
    if (m.find("RoutingRules") != m.end() && !m["RoutingRules"].empty()) {
      routingRules = make_shared<string>(boost::any_cast<string>(m["RoutingRules"]));
    }
    if (m.find("SniEnabled") != m.end() && !m["SniEnabled"].empty()) {
      sniEnabled = make_shared<bool>(boost::any_cast<bool>(m["SniEnabled"]));
    }
    if (m.find("SniHost") != m.end() && !m["SniHost"].empty()) {
      sniHost = make_shared<string>(boost::any_cast<string>(m["SniHost"]));
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~CreateDomainRequestRedirect() = default;
};
class CreateDomainRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDomainRequestTag() {}

  explicit CreateDomainRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDomainRequestTag() = default;
};
class CreateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<CreateDomainRequestListen> listen{};
  shared_ptr<CreateDomainRequestRedirect> redirect{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<CreateDomainRequestTag>> tag{};

  CreateDomainRequest() {}

  explicit CreateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        CreateDomainRequestListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<CreateDomainRequestListen>(model1);
      }
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        CreateDomainRequestRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<CreateDomainRequestRedirect>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDomainRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDomainRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDomainRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDomainRequest() = default;
};
class CreateDomainShrinkRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDomainShrinkRequestTag() {}

  explicit CreateDomainShrinkRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDomainShrinkRequestTag() = default;
};
class CreateDomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> listenShrink{};
  shared_ptr<string> redirectShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<CreateDomainShrinkRequestTag>> tag{};

  CreateDomainShrinkRequest() {}

  explicit CreateDomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listenShrink) {
      res["Listen"] = boost::any(*listenShrink);
    }
    if (redirectShrink) {
      res["Redirect"] = boost::any(*redirectShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      listenShrink = make_shared<string>(boost::any_cast<string>(m["Listen"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      redirectShrink = make_shared<string>(boost::any_cast<string>(m["Redirect"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDomainShrinkRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDomainShrinkRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDomainShrinkRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDomainShrinkRequest() = default;
};
class CreateDomainResponseBodyDomainInfo : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainId{};

  CreateDomainResponseBodyDomainInfo() {}

  explicit CreateDomainResponseBodyDomainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
  }


  virtual ~CreateDomainResponseBodyDomainInfo() = default;
};
class CreateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateDomainResponseBodyDomainInfo> domainInfo{};
  shared_ptr<string> requestId{};

  CreateDomainResponseBody() {}

  explicit CreateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainInfo) {
      res["DomainInfo"] = domainInfo ? boost::any(domainInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainInfo") != m.end() && !m["DomainInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainInfo"].type()) {
        CreateDomainResponseBodyDomainInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainInfo"]));
        domainInfo = make_shared<CreateDomainResponseBodyDomainInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDomainResponseBody() = default;
};
class CreateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDomainResponseBody> body{};

  CreateDomainResponse() {}

  explicit CreateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDomainResponse() = default;
};
class CreateHybridCloudGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> backSourceMark{};
  shared_ptr<long> clusterId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loadBalanceIp{};
  shared_ptr<string> locationCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  CreateHybridCloudGroupRequest() {}

  explicit CreateHybridCloudGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backSourceMark) {
      res["BackSourceMark"] = boost::any(*backSourceMark);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loadBalanceIp) {
      res["LoadBalanceIp"] = boost::any(*loadBalanceIp);
    }
    if (locationCode) {
      res["LocationCode"] = boost::any(*locationCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackSourceMark") != m.end() && !m["BackSourceMark"].empty()) {
      backSourceMark = make_shared<string>(boost::any_cast<string>(m["BackSourceMark"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoadBalanceIp") != m.end() && !m["LoadBalanceIp"].empty()) {
      loadBalanceIp = make_shared<string>(boost::any_cast<string>(m["LoadBalanceIp"]));
    }
    if (m.find("LocationCode") != m.end() && !m["LocationCode"].empty()) {
      locationCode = make_shared<string>(boost::any_cast<string>(m["LocationCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~CreateHybridCloudGroupRequest() = default;
};
class CreateHybridCloudGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  CreateHybridCloudGroupResponseBody() {}

  explicit CreateHybridCloudGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateHybridCloudGroupResponseBody() = default;
};
class CreateHybridCloudGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateHybridCloudGroupResponseBody> body{};

  CreateHybridCloudGroupResponse() {}

  explicit CreateHybridCloudGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHybridCloudGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHybridCloudGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHybridCloudGroupResponse() = default;
};
class CreateMajorProtectionBlackIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  CreateMajorProtectionBlackIpRequest() {}

  explicit CreateMajorProtectionBlackIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~CreateMajorProtectionBlackIpRequest() = default;
};
class CreateMajorProtectionBlackIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateMajorProtectionBlackIpResponseBody() {}

  explicit CreateMajorProtectionBlackIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMajorProtectionBlackIpResponseBody() = default;
};
class CreateMajorProtectionBlackIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMajorProtectionBlackIpResponseBody> body{};

  CreateMajorProtectionBlackIpResponse() {}

  explicit CreateMajorProtectionBlackIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMajorProtectionBlackIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMajorProtectionBlackIpResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMajorProtectionBlackIpResponse() = default;
};
class CreateMemberAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> memberAccountIds{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sourceIp{};

  CreateMemberAccountsRequest() {}

  explicit CreateMemberAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memberAccountIds) {
      res["MemberAccountIds"] = boost::any(*memberAccountIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MemberAccountIds") != m.end() && !m["MemberAccountIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemberAccountIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemberAccountIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memberAccountIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~CreateMemberAccountsRequest() = default;
};
class CreateMemberAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateMemberAccountsResponseBody() {}

  explicit CreateMemberAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMemberAccountsResponseBody() = default;
};
class CreateMemberAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMemberAccountsResponseBody> body{};

  CreateMemberAccountsResponse() {}

  explicit CreateMemberAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMemberAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMemberAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMemberAccountsResponse() = default;
};
class CreatePostpaidInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  CreatePostpaidInstanceRequest() {}

  explicit CreatePostpaidInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~CreatePostpaidInstanceRequest() = default;
};
class CreatePostpaidInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  CreatePostpaidInstanceResponseBody() {}

  explicit CreatePostpaidInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreatePostpaidInstanceResponseBody() = default;
};
class CreatePostpaidInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePostpaidInstanceResponseBody> body{};

  CreatePostpaidInstanceResponse() {}

  explicit CreatePostpaidInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePostpaidInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePostpaidInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePostpaidInstanceResponse() = default;
};
class CreateSM2CertRequest : public Darabonba::Model {
public:
  shared_ptr<string> certName{};
  shared_ptr<string> encryptCertificate{};
  shared_ptr<string> encryptPrivateKey{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> signCertificate{};
  shared_ptr<string> signPrivateKey{};

  CreateSM2CertRequest() {}

  explicit CreateSM2CertRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (encryptCertificate) {
      res["EncryptCertificate"] = boost::any(*encryptCertificate);
    }
    if (encryptPrivateKey) {
      res["EncryptPrivateKey"] = boost::any(*encryptPrivateKey);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (signCertificate) {
      res["SignCertificate"] = boost::any(*signCertificate);
    }
    if (signPrivateKey) {
      res["SignPrivateKey"] = boost::any(*signPrivateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("EncryptCertificate") != m.end() && !m["EncryptCertificate"].empty()) {
      encryptCertificate = make_shared<string>(boost::any_cast<string>(m["EncryptCertificate"]));
    }
    if (m.find("EncryptPrivateKey") != m.end() && !m["EncryptPrivateKey"].empty()) {
      encryptPrivateKey = make_shared<string>(boost::any_cast<string>(m["EncryptPrivateKey"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SignCertificate") != m.end() && !m["SignCertificate"].empty()) {
      signCertificate = make_shared<string>(boost::any_cast<string>(m["SignCertificate"]));
    }
    if (m.find("SignPrivateKey") != m.end() && !m["SignPrivateKey"].empty()) {
      signPrivateKey = make_shared<string>(boost::any_cast<string>(m["SignPrivateKey"]));
    }
  }


  virtual ~CreateSM2CertRequest() = default;
};
class CreateSM2CertResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> requestId{};

  CreateSM2CertResponseBody() {}

  explicit CreateSM2CertResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSM2CertResponseBody() = default;
};
class CreateSM2CertResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSM2CertResponseBody> body{};

  CreateSM2CertResponse() {}

  explicit CreateSM2CertResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSM2CertResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSM2CertResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSM2CertResponse() = default;
};
class DeleteApisecAbnormalsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> abnormalIds{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DeleteApisecAbnormalsRequest() {}

  explicit DeleteApisecAbnormalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalIds) {
      res["AbnormalIds"] = boost::any(*abnormalIds);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalIds") != m.end() && !m["AbnormalIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AbnormalIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AbnormalIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      abnormalIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DeleteApisecAbnormalsRequest() = default;
};
class DeleteApisecAbnormalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApisecAbnormalsResponseBody() {}

  explicit DeleteApisecAbnormalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApisecAbnormalsResponseBody() = default;
};
class DeleteApisecAbnormalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApisecAbnormalsResponseBody> body{};

  DeleteApisecAbnormalsResponse() {}

  explicit DeleteApisecAbnormalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApisecAbnormalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApisecAbnormalsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApisecAbnormalsResponse() = default;
};
class DeleteApisecEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> eventIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DeleteApisecEventsRequest() {}

  explicit DeleteApisecEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (eventIds) {
      res["EventIds"] = boost::any(*eventIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EventIds") != m.end() && !m["EventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DeleteApisecEventsRequest() = default;
};
class DeleteApisecEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApisecEventsResponseBody() {}

  explicit DeleteApisecEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApisecEventsResponseBody() = default;
};
class DeleteApisecEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApisecEventsResponseBody> body{};

  DeleteApisecEventsResponse() {}

  explicit DeleteApisecEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApisecEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApisecEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApisecEventsResponse() = default;
};
class DeleteCloudResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceProduct{};

  DeleteCloudResourceRequest() {}

  explicit DeleteCloudResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
  }


  virtual ~DeleteCloudResourceRequest() = default;
};
class DeleteCloudResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCloudResourceResponseBody() {}

  explicit DeleteCloudResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCloudResourceResponseBody() = default;
};
class DeleteCloudResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCloudResourceResponseBody> body{};

  DeleteCloudResourceResponse() {}

  explicit DeleteCloudResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudResourceResponse() = default;
};
class DeleteDefenseResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DeleteDefenseResourceRequest() {}

  explicit DeleteDefenseResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DeleteDefenseResourceRequest() = default;
};
class DeleteDefenseResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDefenseResourceResponseBody() {}

  explicit DeleteDefenseResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDefenseResourceResponseBody() = default;
};
class DeleteDefenseResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDefenseResourceResponseBody> body{};

  DeleteDefenseResourceResponse() {}

  explicit DeleteDefenseResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDefenseResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDefenseResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDefenseResourceResponse() = default;
};
class DeleteDefenseResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DeleteDefenseResourceGroupRequest() {}

  explicit DeleteDefenseResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DeleteDefenseResourceGroupRequest() = default;
};
class DeleteDefenseResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDefenseResourceGroupResponseBody() {}

  explicit DeleteDefenseResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDefenseResourceGroupResponseBody() = default;
};
class DeleteDefenseResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDefenseResourceGroupResponseBody> body{};

  DeleteDefenseResourceGroupResponse() {}

  explicit DeleteDefenseResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDefenseResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDefenseResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDefenseResourceGroupResponse() = default;
};
class DeleteDefenseRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleIds{};
  shared_ptr<long> templateId{};

  DeleteDefenseRuleRequest() {}

  explicit DeleteDefenseRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseType) {
      res["DefenseType"] = boost::any(*defenseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseType") != m.end() && !m["DefenseType"].empty()) {
      defenseType = make_shared<string>(boost::any_cast<string>(m["DefenseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      ruleIds = make_shared<string>(boost::any_cast<string>(m["RuleIds"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DeleteDefenseRuleRequest() = default;
};
class DeleteDefenseRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDefenseRuleResponseBody() {}

  explicit DeleteDefenseRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDefenseRuleResponseBody() = default;
};
class DeleteDefenseRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDefenseRuleResponseBody> body{};

  DeleteDefenseRuleResponse() {}

  explicit DeleteDefenseRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDefenseRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDefenseRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDefenseRuleResponse() = default;
};
class DeleteDefenseTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};

  DeleteDefenseTemplateRequest() {}

  explicit DeleteDefenseTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DeleteDefenseTemplateRequest() = default;
};
class DeleteDefenseTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDefenseTemplateResponseBody() {}

  explicit DeleteDefenseTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDefenseTemplateResponseBody() = default;
};
class DeleteDefenseTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDefenseTemplateResponseBody> body{};

  DeleteDefenseTemplateResponse() {}

  explicit DeleteDefenseTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDefenseTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDefenseTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDefenseTemplateResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteMajorProtectionBlackIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  DeleteMajorProtectionBlackIpRequest() {}

  explicit DeleteMajorProtectionBlackIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DeleteMajorProtectionBlackIpRequest() = default;
};
class DeleteMajorProtectionBlackIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMajorProtectionBlackIpResponseBody() {}

  explicit DeleteMajorProtectionBlackIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMajorProtectionBlackIpResponseBody() = default;
};
class DeleteMajorProtectionBlackIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMajorProtectionBlackIpResponseBody> body{};

  DeleteMajorProtectionBlackIpResponse() {}

  explicit DeleteMajorProtectionBlackIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMajorProtectionBlackIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMajorProtectionBlackIpResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMajorProtectionBlackIpResponse() = default;
};
class DeleteMemberAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> memberAccountId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sourceIp{};

  DeleteMemberAccountRequest() {}

  explicit DeleteMemberAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memberAccountId) {
      res["MemberAccountId"] = boost::any(*memberAccountId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MemberAccountId") != m.end() && !m["MemberAccountId"].empty()) {
      memberAccountId = make_shared<string>(boost::any_cast<string>(m["MemberAccountId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DeleteMemberAccountRequest() = default;
};
class DeleteMemberAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMemberAccountResponseBody() {}

  explicit DeleteMemberAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMemberAccountResponseBody() = default;
};
class DeleteMemberAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMemberAccountResponseBody> body{};

  DeleteMemberAccountResponse() {}

  explicit DeleteMemberAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMemberAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMemberAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMemberAccountResponse() = default;
};
class DescribeAbnormalCloudResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeAbnormalCloudResourcesRequest() {}

  explicit DescribeAbnormalCloudResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeAbnormalCloudResourcesRequest() = default;
};
class DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certName{};
  shared_ptr<string> code{};
  shared_ptr<string> commonName{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> productCertId{};
  shared_ptr<string> productCertName{};
  shared_ptr<string> productDomainExtension{};

  DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails() {}

  explicit DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (productCertId) {
      res["ProductCertId"] = boost::any(*productCertId);
    }
    if (productCertName) {
      res["ProductCertName"] = boost::any(*productCertName);
    }
    if (productDomainExtension) {
      res["ProductDomainExtension"] = boost::any(*productDomainExtension);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ProductCertId") != m.end() && !m["ProductCertId"].empty()) {
      productCertId = make_shared<string>(boost::any_cast<string>(m["ProductCertId"]));
    }
    if (m.find("ProductCertName") != m.end() && !m["ProductCertName"].empty()) {
      productCertName = make_shared<string>(boost::any_cast<string>(m["ProductCertName"]));
    }
    if (m.find("ProductDomainExtension") != m.end() && !m["ProductDomainExtension"].empty()) {
      productDomainExtension = make_shared<string>(boost::any_cast<string>(m["ProductDomainExtension"]));
    }
  }


  virtual ~DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails() = default;
};
class DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails>> details{};
  shared_ptr<string> reason{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceInstanceName{};
  shared_ptr<long> resourceInstancePort{};
  shared_ptr<string> resourceProduct{};

  DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources() {}

  explicit DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceInstanceName) {
      res["ResourceInstanceName"] = boost::any(*resourceInstanceName);
    }
    if (resourceInstancePort) {
      res["ResourceInstancePort"] = boost::any(*resourceInstancePort);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResourcesDetails>>(expect1);
      }
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceInstanceName") != m.end() && !m["ResourceInstanceName"].empty()) {
      resourceInstanceName = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceName"]));
    }
    if (m.find("ResourceInstancePort") != m.end() && !m["ResourceInstancePort"].empty()) {
      resourceInstancePort = make_shared<long>(boost::any_cast<long>(m["ResourceInstancePort"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
  }


  virtual ~DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources() = default;
};
class DescribeAbnormalCloudResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources>> abnormalCloudResources{};
  shared_ptr<string> requestId{};

  DescribeAbnormalCloudResourcesResponseBody() {}

  explicit DescribeAbnormalCloudResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalCloudResources) {
      vector<boost::any> temp1;
      for(auto item1:*abnormalCloudResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbnormalCloudResources"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalCloudResources") != m.end() && !m["AbnormalCloudResources"].empty()) {
      if (typeid(vector<boost::any>) == m["AbnormalCloudResources"].type()) {
        vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbnormalCloudResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abnormalCloudResources = make_shared<vector<DescribeAbnormalCloudResourcesResponseBodyAbnormalCloudResources>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAbnormalCloudResourcesResponseBody() = default;
};
class DescribeAbnormalCloudResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAbnormalCloudResourcesResponseBody> body{};

  DescribeAbnormalCloudResourcesResponse() {}

  explicit DescribeAbnormalCloudResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAbnormalCloudResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAbnormalCloudResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAbnormalCloudResourcesResponse() = default;
};
class DescribeAccountDelegatedStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeAccountDelegatedStatusRequest() {}

  explicit DescribeAccountDelegatedStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeAccountDelegatedStatusRequest() = default;
};
class DescribeAccountDelegatedStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<bool> delegatedStatus{};
  shared_ptr<string> requestId{};

  DescribeAccountDelegatedStatusResponseBody() {}

  explicit DescribeAccountDelegatedStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (delegatedStatus) {
      res["DelegatedStatus"] = boost::any(*delegatedStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DelegatedStatus") != m.end() && !m["DelegatedStatus"].empty()) {
      delegatedStatus = make_shared<bool>(boost::any_cast<bool>(m["DelegatedStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAccountDelegatedStatusResponseBody() = default;
};
class DescribeAccountDelegatedStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccountDelegatedStatusResponseBody> body{};

  DescribeAccountDelegatedStatusResponse() {}

  explicit DescribeAccountDelegatedStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccountDelegatedStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccountDelegatedStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccountDelegatedStatusResponse() = default;
};
class DescribeApiExportsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> lang{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApiExportsRequest() {}

  explicit DescribeApiExportsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lang) {
      res["Lang"] = boost::any(*lang);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Lang") != m.end() && !m["Lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["Lang"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApiExportsRequest() = default;
};
class DescribeApiExportsResponseBodyApiExports : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> format{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  DescribeApiExportsResponseBodyApiExports() {}

  explicit DescribeApiExportsResponseBodyApiExports(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiExportsResponseBodyApiExports() = default;
};
class DescribeApiExportsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiExportsResponseBodyApiExports>> apiExports{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};

  DescribeApiExportsResponseBody() {}

  explicit DescribeApiExportsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiExports) {
      vector<boost::any> temp1;
      for(auto item1:*apiExports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiExports"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiExports") != m.end() && !m["ApiExports"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiExports"].type()) {
        vector<DescribeApiExportsResponseBodyApiExports> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiExports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiExportsResponseBodyApiExports model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiExports = make_shared<vector<DescribeApiExportsResponseBodyApiExports>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeApiExportsResponseBody() = default;
};
class DescribeApiExportsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiExportsResponseBody> body{};

  DescribeApiExportsResponse() {}

  explicit DescribeApiExportsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiExportsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiExportsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiExportsResponse() = default;
};
class DescribeApisecAbnormalDomainStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderWay{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeApisecAbnormalDomainStatisticRequest() {}

  explicit DescribeApisecAbnormalDomainStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeApisecAbnormalDomainStatisticRequest() = default;
};
class DescribeApisecAbnormalDomainStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> apiCount{};
  shared_ptr<string> domain{};
  shared_ptr<long> high{};
  shared_ptr<long> low{};
  shared_ptr<long> medium{};

  DescribeApisecAbnormalDomainStatisticResponseBodyData() {}

  explicit DescribeApisecAbnormalDomainStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiCount) {
      res["ApiCount"] = boost::any(*apiCount);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (high) {
      res["High"] = boost::any(*high);
    }
    if (low) {
      res["Low"] = boost::any(*low);
    }
    if (medium) {
      res["Medium"] = boost::any(*medium);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiCount") != m.end() && !m["ApiCount"].empty()) {
      apiCount = make_shared<long>(boost::any_cast<long>(m["ApiCount"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("High") != m.end() && !m["High"].empty()) {
      high = make_shared<long>(boost::any_cast<long>(m["High"]));
    }
    if (m.find("Low") != m.end() && !m["Low"].empty()) {
      low = make_shared<long>(boost::any_cast<long>(m["Low"]));
    }
    if (m.find("Medium") != m.end() && !m["Medium"].empty()) {
      medium = make_shared<long>(boost::any_cast<long>(m["Medium"]));
    }
  }


  virtual ~DescribeApisecAbnormalDomainStatisticResponseBodyData() = default;
};
class DescribeApisecAbnormalDomainStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecAbnormalDomainStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecAbnormalDomainStatisticResponseBody() {}

  explicit DescribeApisecAbnormalDomainStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecAbnormalDomainStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecAbnormalDomainStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecAbnormalDomainStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecAbnormalDomainStatisticResponseBody() = default;
};
class DescribeApisecAbnormalDomainStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecAbnormalDomainStatisticResponseBody> body{};

  DescribeApisecAbnormalDomainStatisticResponse() {}

  explicit DescribeApisecAbnormalDomainStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecAbnormalDomainStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecAbnormalDomainStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecAbnormalDomainStatisticResponse() = default;
};
class DescribeApisecAbnormalsRequest : public Darabonba::Model {
public:
  shared_ptr<string> abnormalId{};
  shared_ptr<string> abnormalLevel{};
  shared_ptr<string> abnormalTag{};
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiTag{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderWay{};
  shared_ptr<string> origin{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> userStatus{};

  DescribeApisecAbnormalsRequest() {}

  explicit DescribeApisecAbnormalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalId) {
      res["AbnormalId"] = boost::any(*abnormalId);
    }
    if (abnormalLevel) {
      res["AbnormalLevel"] = boost::any(*abnormalLevel);
    }
    if (abnormalTag) {
      res["AbnormalTag"] = boost::any(*abnormalTag);
    }
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalId") != m.end() && !m["AbnormalId"].empty()) {
      abnormalId = make_shared<string>(boost::any_cast<string>(m["AbnormalId"]));
    }
    if (m.find("AbnormalLevel") != m.end() && !m["AbnormalLevel"].empty()) {
      abnormalLevel = make_shared<string>(boost::any_cast<string>(m["AbnormalLevel"]));
    }
    if (m.find("AbnormalTag") != m.end() && !m["AbnormalTag"].empty()) {
      abnormalTag = make_shared<string>(boost::any_cast<string>(m["AbnormalTag"]));
    }
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~DescribeApisecAbnormalsRequest() = default;
};
class DescribeApisecAbnormalsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> abnormalEventNumber{};
  shared_ptr<string> abnormalId{};
  shared_ptr<string> abnormalInfo{};
  shared_ptr<string> abnormalLevel{};
  shared_ptr<string> abnormalTag{};
  shared_ptr<string> abnromalStatus{};
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiTag{};
  shared_ptr<long> discoverTime{};
  shared_ptr<vector<string>> examples{};
  shared_ptr<long> firstTime{};
  shared_ptr<long> follow{};
  shared_ptr<long> ignoreTime{};
  shared_ptr<long> lastestTime{};
  shared_ptr<long> latestDiscoverTime{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> note{};
  shared_ptr<string> origin{};
  shared_ptr<string> userStatus{};

  DescribeApisecAbnormalsResponseBodyData() {}

  explicit DescribeApisecAbnormalsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalEventNumber) {
      res["AbnormalEventNumber"] = boost::any(*abnormalEventNumber);
    }
    if (abnormalId) {
      res["AbnormalId"] = boost::any(*abnormalId);
    }
    if (abnormalInfo) {
      res["AbnormalInfo"] = boost::any(*abnormalInfo);
    }
    if (abnormalLevel) {
      res["AbnormalLevel"] = boost::any(*abnormalLevel);
    }
    if (abnormalTag) {
      res["AbnormalTag"] = boost::any(*abnormalTag);
    }
    if (abnromalStatus) {
      res["AbnromalStatus"] = boost::any(*abnromalStatus);
    }
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (discoverTime) {
      res["DiscoverTime"] = boost::any(*discoverTime);
    }
    if (examples) {
      res["Examples"] = boost::any(*examples);
    }
    if (firstTime) {
      res["FirstTime"] = boost::any(*firstTime);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (ignoreTime) {
      res["IgnoreTime"] = boost::any(*ignoreTime);
    }
    if (lastestTime) {
      res["LastestTime"] = boost::any(*lastestTime);
    }
    if (latestDiscoverTime) {
      res["LatestDiscoverTime"] = boost::any(*latestDiscoverTime);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalEventNumber") != m.end() && !m["AbnormalEventNumber"].empty()) {
      abnormalEventNumber = make_shared<long>(boost::any_cast<long>(m["AbnormalEventNumber"]));
    }
    if (m.find("AbnormalId") != m.end() && !m["AbnormalId"].empty()) {
      abnormalId = make_shared<string>(boost::any_cast<string>(m["AbnormalId"]));
    }
    if (m.find("AbnormalInfo") != m.end() && !m["AbnormalInfo"].empty()) {
      abnormalInfo = make_shared<string>(boost::any_cast<string>(m["AbnormalInfo"]));
    }
    if (m.find("AbnormalLevel") != m.end() && !m["AbnormalLevel"].empty()) {
      abnormalLevel = make_shared<string>(boost::any_cast<string>(m["AbnormalLevel"]));
    }
    if (m.find("AbnormalTag") != m.end() && !m["AbnormalTag"].empty()) {
      abnormalTag = make_shared<string>(boost::any_cast<string>(m["AbnormalTag"]));
    }
    if (m.find("AbnromalStatus") != m.end() && !m["AbnromalStatus"].empty()) {
      abnromalStatus = make_shared<string>(boost::any_cast<string>(m["AbnromalStatus"]));
    }
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("DiscoverTime") != m.end() && !m["DiscoverTime"].empty()) {
      discoverTime = make_shared<long>(boost::any_cast<long>(m["DiscoverTime"]));
    }
    if (m.find("Examples") != m.end() && !m["Examples"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Examples"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Examples"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      examples = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FirstTime") != m.end() && !m["FirstTime"].empty()) {
      firstTime = make_shared<long>(boost::any_cast<long>(m["FirstTime"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<long>(boost::any_cast<long>(m["Follow"]));
    }
    if (m.find("IgnoreTime") != m.end() && !m["IgnoreTime"].empty()) {
      ignoreTime = make_shared<long>(boost::any_cast<long>(m["IgnoreTime"]));
    }
    if (m.find("LastestTime") != m.end() && !m["LastestTime"].empty()) {
      lastestTime = make_shared<long>(boost::any_cast<long>(m["LastestTime"]));
    }
    if (m.find("LatestDiscoverTime") != m.end() && !m["LatestDiscoverTime"].empty()) {
      latestDiscoverTime = make_shared<long>(boost::any_cast<long>(m["LatestDiscoverTime"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~DescribeApisecAbnormalsResponseBodyData() = default;
};
class DescribeApisecAbnormalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecAbnormalsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecAbnormalsResponseBody() {}

  explicit DescribeApisecAbnormalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecAbnormalsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecAbnormalsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecAbnormalsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecAbnormalsResponseBody() = default;
};
class DescribeApisecAbnormalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecAbnormalsResponseBody> body{};

  DescribeApisecAbnormalsResponse() {}

  explicit DescribeApisecAbnormalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecAbnormalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecAbnormalsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecAbnormalsResponse() = default;
};
class DescribeApisecApiResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiTag{};
  shared_ptr<string> apiType{};
  shared_ptr<string> authFlag{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> endTime{};
  shared_ptr<long> follow{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> note{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderWay{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestSensitiveType{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sensitiveLevel{};
  shared_ptr<string> sensitiveType{};
  shared_ptr<string> startTime{};

  DescribeApisecApiResourcesRequest() {}

  explicit DescribeApisecApiResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (authFlag) {
      res["AuthFlag"] = boost::any(*authFlag);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestSensitiveType) {
      res["RequestSensitiveType"] = boost::any(*requestSensitiveType);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sensitiveLevel) {
      res["SensitiveLevel"] = boost::any(*sensitiveLevel);
    }
    if (sensitiveType) {
      res["SensitiveType"] = boost::any(*sensitiveType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AuthFlag") != m.end() && !m["AuthFlag"].empty()) {
      authFlag = make_shared<string>(boost::any_cast<string>(m["AuthFlag"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<long>(boost::any_cast<long>(m["Follow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestSensitiveType") != m.end() && !m["RequestSensitiveType"].empty()) {
      requestSensitiveType = make_shared<string>(boost::any_cast<string>(m["RequestSensitiveType"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SensitiveLevel") != m.end() && !m["SensitiveLevel"].empty()) {
      sensitiveLevel = make_shared<string>(boost::any_cast<string>(m["SensitiveLevel"]));
    }
    if (m.find("SensitiveType") != m.end() && !m["SensitiveType"].empty()) {
      sensitiveType = make_shared<string>(boost::any_cast<string>(m["SensitiveType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApisecApiResourcesRequest() = default;
};
class DescribeApisecApiResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNum{};
  shared_ptr<long> allCnt{};
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiInfo{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiSensitive{};
  shared_ptr<string> apiSensitiveRequest{};
  shared_ptr<string> apiSensitiveResponse{};
  shared_ptr<string> apiStatus{};
  shared_ptr<string> apiTag{};
  shared_ptr<string> apiType{};
  shared_ptr<string> authFlag{};
  shared_ptr<long> botCnt{};
  shared_ptr<long> crossBorderCnt{};
  shared_ptr<long> eventNum{};
  shared_ptr<vector<string>> examples{};
  shared_ptr<long> farthestTs{};
  shared_ptr<long> follow{};
  shared_ptr<long> lastestTs{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> note{};
  shared_ptr<vector<string>> resources{};

  DescribeApisecApiResourcesResponseBodyData() {}

  explicit DescribeApisecApiResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNum) {
      res["AbnormalNum"] = boost::any(*abnormalNum);
    }
    if (allCnt) {
      res["AllCnt"] = boost::any(*allCnt);
    }
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiInfo) {
      res["ApiInfo"] = boost::any(*apiInfo);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiSensitive) {
      res["ApiSensitive"] = boost::any(*apiSensitive);
    }
    if (apiSensitiveRequest) {
      res["ApiSensitiveRequest"] = boost::any(*apiSensitiveRequest);
    }
    if (apiSensitiveResponse) {
      res["ApiSensitiveResponse"] = boost::any(*apiSensitiveResponse);
    }
    if (apiStatus) {
      res["ApiStatus"] = boost::any(*apiStatus);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (authFlag) {
      res["AuthFlag"] = boost::any(*authFlag);
    }
    if (botCnt) {
      res["BotCnt"] = boost::any(*botCnt);
    }
    if (crossBorderCnt) {
      res["CrossBorderCnt"] = boost::any(*crossBorderCnt);
    }
    if (eventNum) {
      res["EventNum"] = boost::any(*eventNum);
    }
    if (examples) {
      res["Examples"] = boost::any(*examples);
    }
    if (farthestTs) {
      res["FarthestTs"] = boost::any(*farthestTs);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (lastestTs) {
      res["LastestTs"] = boost::any(*lastestTs);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNum") != m.end() && !m["AbnormalNum"].empty()) {
      abnormalNum = make_shared<long>(boost::any_cast<long>(m["AbnormalNum"]));
    }
    if (m.find("AllCnt") != m.end() && !m["AllCnt"].empty()) {
      allCnt = make_shared<long>(boost::any_cast<long>(m["AllCnt"]));
    }
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      apiInfo = make_shared<string>(boost::any_cast<string>(m["ApiInfo"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiSensitive") != m.end() && !m["ApiSensitive"].empty()) {
      apiSensitive = make_shared<string>(boost::any_cast<string>(m["ApiSensitive"]));
    }
    if (m.find("ApiSensitiveRequest") != m.end() && !m["ApiSensitiveRequest"].empty()) {
      apiSensitiveRequest = make_shared<string>(boost::any_cast<string>(m["ApiSensitiveRequest"]));
    }
    if (m.find("ApiSensitiveResponse") != m.end() && !m["ApiSensitiveResponse"].empty()) {
      apiSensitiveResponse = make_shared<string>(boost::any_cast<string>(m["ApiSensitiveResponse"]));
    }
    if (m.find("ApiStatus") != m.end() && !m["ApiStatus"].empty()) {
      apiStatus = make_shared<string>(boost::any_cast<string>(m["ApiStatus"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<string>(boost::any_cast<string>(m["ApiType"]));
    }
    if (m.find("AuthFlag") != m.end() && !m["AuthFlag"].empty()) {
      authFlag = make_shared<string>(boost::any_cast<string>(m["AuthFlag"]));
    }
    if (m.find("BotCnt") != m.end() && !m["BotCnt"].empty()) {
      botCnt = make_shared<long>(boost::any_cast<long>(m["BotCnt"]));
    }
    if (m.find("CrossBorderCnt") != m.end() && !m["CrossBorderCnt"].empty()) {
      crossBorderCnt = make_shared<long>(boost::any_cast<long>(m["CrossBorderCnt"]));
    }
    if (m.find("EventNum") != m.end() && !m["EventNum"].empty()) {
      eventNum = make_shared<long>(boost::any_cast<long>(m["EventNum"]));
    }
    if (m.find("Examples") != m.end() && !m["Examples"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Examples"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Examples"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      examples = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FarthestTs") != m.end() && !m["FarthestTs"].empty()) {
      farthestTs = make_shared<long>(boost::any_cast<long>(m["FarthestTs"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<long>(boost::any_cast<long>(m["Follow"]));
    }
    if (m.find("LastestTs") != m.end() && !m["LastestTs"].empty()) {
      lastestTs = make_shared<long>(boost::any_cast<long>(m["LastestTs"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeApisecApiResourcesResponseBodyData() = default;
};
class DescribeApisecApiResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecApiResourcesResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecApiResourcesResponseBody() {}

  explicit DescribeApisecApiResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecApiResourcesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecApiResourcesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecApiResourcesResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecApiResourcesResponseBody() = default;
};
class DescribeApisecApiResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecApiResourcesResponseBody> body{};

  DescribeApisecApiResourcesResponse() {}

  explicit DescribeApisecApiResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecApiResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecApiResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecApiResourcesResponse() = default;
};
class DescribeApisecAssetTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeApisecAssetTrendRequest() {}

  explicit DescribeApisecAssetTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeApisecAssetTrendRequest() = default;
};
class DescribeApisecAssetTrendResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assetActive{};
  shared_ptr<long> assetCount{};
  shared_ptr<long> assetOffline{};
  shared_ptr<long> timestamp{};

  DescribeApisecAssetTrendResponseBodyData() {}

  explicit DescribeApisecAssetTrendResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetActive) {
      res["AssetActive"] = boost::any(*assetActive);
    }
    if (assetCount) {
      res["AssetCount"] = boost::any(*assetCount);
    }
    if (assetOffline) {
      res["AssetOffline"] = boost::any(*assetOffline);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetActive") != m.end() && !m["AssetActive"].empty()) {
      assetActive = make_shared<long>(boost::any_cast<long>(m["AssetActive"]));
    }
    if (m.find("AssetCount") != m.end() && !m["AssetCount"].empty()) {
      assetCount = make_shared<long>(boost::any_cast<long>(m["AssetCount"]));
    }
    if (m.find("AssetOffline") != m.end() && !m["AssetOffline"].empty()) {
      assetOffline = make_shared<long>(boost::any_cast<long>(m["AssetOffline"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeApisecAssetTrendResponseBodyData() = default;
};
class DescribeApisecAssetTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecAssetTrendResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeApisecAssetTrendResponseBody() {}

  explicit DescribeApisecAssetTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecAssetTrendResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecAssetTrendResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecAssetTrendResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecAssetTrendResponseBody() = default;
};
class DescribeApisecAssetTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecAssetTrendResponseBody> body{};

  DescribeApisecAssetTrendResponse() {}

  explicit DescribeApisecAssetTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecAssetTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecAssetTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecAssetTrendResponse() = default;
};
class DescribeApisecEventDomainStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderWay{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeApisecEventDomainStatisticRequest() {}

  explicit DescribeApisecEventDomainStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeApisecEventDomainStatisticRequest() = default;
};
class DescribeApisecEventDomainStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> apiCount{};
  shared_ptr<string> domain{};
  shared_ptr<long> high{};
  shared_ptr<long> low{};
  shared_ptr<long> medium{};

  DescribeApisecEventDomainStatisticResponseBodyData() {}

  explicit DescribeApisecEventDomainStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiCount) {
      res["ApiCount"] = boost::any(*apiCount);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (high) {
      res["High"] = boost::any(*high);
    }
    if (low) {
      res["Low"] = boost::any(*low);
    }
    if (medium) {
      res["Medium"] = boost::any(*medium);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiCount") != m.end() && !m["ApiCount"].empty()) {
      apiCount = make_shared<long>(boost::any_cast<long>(m["ApiCount"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("High") != m.end() && !m["High"].empty()) {
      high = make_shared<long>(boost::any_cast<long>(m["High"]));
    }
    if (m.find("Low") != m.end() && !m["Low"].empty()) {
      low = make_shared<long>(boost::any_cast<long>(m["Low"]));
    }
    if (m.find("Medium") != m.end() && !m["Medium"].empty()) {
      medium = make_shared<long>(boost::any_cast<long>(m["Medium"]));
    }
  }


  virtual ~DescribeApisecEventDomainStatisticResponseBodyData() = default;
};
class DescribeApisecEventDomainStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecEventDomainStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecEventDomainStatisticResponseBody() {}

  explicit DescribeApisecEventDomainStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecEventDomainStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecEventDomainStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecEventDomainStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecEventDomainStatisticResponseBody() = default;
};
class DescribeApisecEventDomainStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecEventDomainStatisticResponseBody> body{};

  DescribeApisecEventDomainStatisticResponse() {}

  explicit DescribeApisecEventDomainStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecEventDomainStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecEventDomainStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecEventDomainStatisticResponse() = default;
};
class DescribeApisecEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiTag{};
  shared_ptr<string> attackIp{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTs{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventLevel{};
  shared_ptr<string> eventTag{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderWay{};
  shared_ptr<string> origin{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTs{};
  shared_ptr<string> userStatus{};

  DescribeApisecEventsRequest() {}

  explicit DescribeApisecEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (attackIp) {
      res["AttackIp"] = boost::any(*attackIp);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventLevel) {
      res["EventLevel"] = boost::any(*eventLevel);
    }
    if (eventTag) {
      res["EventTag"] = boost::any(*eventTag);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("AttackIp") != m.end() && !m["AttackIp"].empty()) {
      attackIp = make_shared<string>(boost::any_cast<string>(m["AttackIp"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventLevel") != m.end() && !m["EventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["EventLevel"]));
    }
    if (m.find("EventTag") != m.end() && !m["EventTag"].empty()) {
      eventTag = make_shared<string>(boost::any_cast<string>(m["EventTag"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~DescribeApisecEventsRequest() = default;
};
class DescribeApisecEventsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> allCnt{};
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiTag{};
  shared_ptr<string> attackClient{};
  shared_ptr<string> attackCntInfo{};
  shared_ptr<string> attackIp{};
  shared_ptr<string> attackIpInfo{};
  shared_ptr<vector<string>> attackIps{};
  shared_ptr<long> endTs{};
  shared_ptr<string> eventId{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> eventLevel{};
  shared_ptr<string> eventTag{};
  shared_ptr<long> follow{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> note{};
  shared_ptr<string> origin{};
  shared_ptr<string> remoteCountry{};
  shared_ptr<string> remoteRegion{};
  shared_ptr<string> requestData{};
  shared_ptr<string> responseData{};
  shared_ptr<long> startTs{};
  shared_ptr<string> userStatus{};

  DescribeApisecEventsResponseBodyData() {}

  explicit DescribeApisecEventsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allCnt) {
      res["AllCnt"] = boost::any(*allCnt);
    }
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiTag) {
      res["ApiTag"] = boost::any(*apiTag);
    }
    if (attackClient) {
      res["AttackClient"] = boost::any(*attackClient);
    }
    if (attackCntInfo) {
      res["AttackCntInfo"] = boost::any(*attackCntInfo);
    }
    if (attackIp) {
      res["AttackIp"] = boost::any(*attackIp);
    }
    if (attackIpInfo) {
      res["AttackIpInfo"] = boost::any(*attackIpInfo);
    }
    if (attackIps) {
      res["AttackIps"] = boost::any(*attackIps);
    }
    if (endTs) {
      res["EndTs"] = boost::any(*endTs);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (eventLevel) {
      res["EventLevel"] = boost::any(*eventLevel);
    }
    if (eventTag) {
      res["EventTag"] = boost::any(*eventTag);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (remoteCountry) {
      res["RemoteCountry"] = boost::any(*remoteCountry);
    }
    if (remoteRegion) {
      res["RemoteRegion"] = boost::any(*remoteRegion);
    }
    if (requestData) {
      res["RequestData"] = boost::any(*requestData);
    }
    if (responseData) {
      res["ResponseData"] = boost::any(*responseData);
    }
    if (startTs) {
      res["StartTs"] = boost::any(*startTs);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllCnt") != m.end() && !m["AllCnt"].empty()) {
      allCnt = make_shared<long>(boost::any_cast<long>(m["AllCnt"]));
    }
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiTag") != m.end() && !m["ApiTag"].empty()) {
      apiTag = make_shared<string>(boost::any_cast<string>(m["ApiTag"]));
    }
    if (m.find("AttackClient") != m.end() && !m["AttackClient"].empty()) {
      attackClient = make_shared<string>(boost::any_cast<string>(m["AttackClient"]));
    }
    if (m.find("AttackCntInfo") != m.end() && !m["AttackCntInfo"].empty()) {
      attackCntInfo = make_shared<string>(boost::any_cast<string>(m["AttackCntInfo"]));
    }
    if (m.find("AttackIp") != m.end() && !m["AttackIp"].empty()) {
      attackIp = make_shared<string>(boost::any_cast<string>(m["AttackIp"]));
    }
    if (m.find("AttackIpInfo") != m.end() && !m["AttackIpInfo"].empty()) {
      attackIpInfo = make_shared<string>(boost::any_cast<string>(m["AttackIpInfo"]));
    }
    if (m.find("AttackIps") != m.end() && !m["AttackIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AttackIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AttackIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attackIps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTs") != m.end() && !m["EndTs"].empty()) {
      endTs = make_shared<long>(boost::any_cast<long>(m["EndTs"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("EventLevel") != m.end() && !m["EventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["EventLevel"]));
    }
    if (m.find("EventTag") != m.end() && !m["EventTag"].empty()) {
      eventTag = make_shared<string>(boost::any_cast<string>(m["EventTag"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<long>(boost::any_cast<long>(m["Follow"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("RemoteCountry") != m.end() && !m["RemoteCountry"].empty()) {
      remoteCountry = make_shared<string>(boost::any_cast<string>(m["RemoteCountry"]));
    }
    if (m.find("RemoteRegion") != m.end() && !m["RemoteRegion"].empty()) {
      remoteRegion = make_shared<string>(boost::any_cast<string>(m["RemoteRegion"]));
    }
    if (m.find("RequestData") != m.end() && !m["RequestData"].empty()) {
      requestData = make_shared<string>(boost::any_cast<string>(m["RequestData"]));
    }
    if (m.find("ResponseData") != m.end() && !m["ResponseData"].empty()) {
      responseData = make_shared<string>(boost::any_cast<string>(m["ResponseData"]));
    }
    if (m.find("StartTs") != m.end() && !m["StartTs"].empty()) {
      startTs = make_shared<long>(boost::any_cast<long>(m["StartTs"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~DescribeApisecEventsResponseBodyData() = default;
};
class DescribeApisecEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecEventsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecEventsResponseBody() {}

  explicit DescribeApisecEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecEventsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecEventsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecEventsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecEventsResponseBody() = default;
};
class DescribeApisecEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecEventsResponseBody> body{};

  DescribeApisecEventsResponse() {}

  explicit DescribeApisecEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecEventsResponse() = default;
};
class DescribeApisecLogDeliveriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecLogDeliveriesRequest() {}

  explicit DescribeApisecLogDeliveriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecLogDeliveriesRequest() = default;
};
class DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs : public Darabonba::Model {
public:
  shared_ptr<string> assertKey{};
  shared_ptr<string> logRegionId{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> status{};

  DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs() {}

  explicit DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertKey) {
      res["AssertKey"] = boost::any(*assertKey);
    }
    if (logRegionId) {
      res["LogRegionId"] = boost::any(*logRegionId);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssertKey") != m.end() && !m["AssertKey"].empty()) {
      assertKey = make_shared<string>(boost::any_cast<string>(m["AssertKey"]));
    }
    if (m.find("LogRegionId") != m.end() && !m["LogRegionId"].empty()) {
      logRegionId = make_shared<string>(boost::any_cast<string>(m["LogRegionId"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs() = default;
};
class DescribeApisecLogDeliveriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs>> deliveryConfigs{};
  shared_ptr<string> requestId{};

  DescribeApisecLogDeliveriesResponseBody() {}

  explicit DescribeApisecLogDeliveriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deliveryConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*deliveryConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeliveryConfigs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeliveryConfigs") != m.end() && !m["DeliveryConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["DeliveryConfigs"].type()) {
        vector<DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeliveryConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deliveryConfigs = make_shared<vector<DescribeApisecLogDeliveriesResponseBodyDeliveryConfigs>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecLogDeliveriesResponseBody() = default;
};
class DescribeApisecLogDeliveriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecLogDeliveriesResponseBody> body{};

  DescribeApisecLogDeliveriesResponse() {}

  explicit DescribeApisecLogDeliveriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecLogDeliveriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecLogDeliveriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecLogDeliveriesResponse() = default;
};
class DescribeApisecMatchedHostsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> type{};

  DescribeApisecMatchedHostsRequest() {}

  explicit DescribeApisecMatchedHostsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApisecMatchedHostsRequest() = default;
};
class DescribeApisecMatchedHostsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> matchedHost{};

  DescribeApisecMatchedHostsResponseBodyData() {}

  explicit DescribeApisecMatchedHostsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
  }


  virtual ~DescribeApisecMatchedHostsResponseBodyData() = default;
};
class DescribeApisecMatchedHostsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecMatchedHostsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  DescribeApisecMatchedHostsResponseBody() {}

  explicit DescribeApisecMatchedHostsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecMatchedHostsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecMatchedHostsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecMatchedHostsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecMatchedHostsResponseBody() = default;
};
class DescribeApisecMatchedHostsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecMatchedHostsResponseBody> body{};

  DescribeApisecMatchedHostsResponse() {}

  explicit DescribeApisecMatchedHostsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecMatchedHostsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecMatchedHostsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecMatchedHostsResponse() = default;
};
class DescribeApisecProtectionGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> apisecStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecProtectionGroupsRequest() {}

  explicit DescribeApisecProtectionGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apisecStatus) {
      res["ApisecStatus"] = boost::any(*apisecStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApisecStatus") != m.end() && !m["ApisecStatus"].empty()) {
      apisecStatus = make_shared<long>(boost::any_cast<long>(m["ApisecStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecProtectionGroupsRequest() = default;
};
class DescribeApisecProtectionGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> apisecStatus{};
  shared_ptr<long> reportStatus{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<long> traceStatus{};

  DescribeApisecProtectionGroupsResponseBodyData() {}

  explicit DescribeApisecProtectionGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apisecStatus) {
      res["ApisecStatus"] = boost::any(*apisecStatus);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (traceStatus) {
      res["TraceStatus"] = boost::any(*traceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApisecStatus") != m.end() && !m["ApisecStatus"].empty()) {
      apisecStatus = make_shared<long>(boost::any_cast<long>(m["ApisecStatus"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<long>(boost::any_cast<long>(m["ReportStatus"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("TraceStatus") != m.end() && !m["TraceStatus"].empty()) {
      traceStatus = make_shared<long>(boost::any_cast<long>(m["TraceStatus"]));
    }
  }


  virtual ~DescribeApisecProtectionGroupsResponseBodyData() = default;
};
class DescribeApisecProtectionGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecProtectionGroupsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecProtectionGroupsResponseBody() {}

  explicit DescribeApisecProtectionGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecProtectionGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecProtectionGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecProtectionGroupsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecProtectionGroupsResponseBody() = default;
};
class DescribeApisecProtectionGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecProtectionGroupsResponseBody> body{};

  DescribeApisecProtectionGroupsResponse() {}

  explicit DescribeApisecProtectionGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecProtectionGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecProtectionGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecProtectionGroupsResponse() = default;
};
class DescribeApisecProtectionResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<long> apisecStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecProtectionResourcesRequest() {}

  explicit DescribeApisecProtectionResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apisecStatus) {
      res["ApisecStatus"] = boost::any(*apisecStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApisecStatus") != m.end() && !m["ApisecStatus"].empty()) {
      apisecStatus = make_shared<long>(boost::any_cast<long>(m["ApisecStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecProtectionResourcesRequest() = default;
};
class DescribeApisecProtectionResourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> apisecStatus{};
  shared_ptr<long> reportStatus{};
  shared_ptr<string> resource{};
  shared_ptr<long> traceStatus{};

  DescribeApisecProtectionResourcesResponseBodyData() {}

  explicit DescribeApisecProtectionResourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apisecStatus) {
      res["ApisecStatus"] = boost::any(*apisecStatus);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (traceStatus) {
      res["TraceStatus"] = boost::any(*traceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApisecStatus") != m.end() && !m["ApisecStatus"].empty()) {
      apisecStatus = make_shared<long>(boost::any_cast<long>(m["ApisecStatus"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<long>(boost::any_cast<long>(m["ReportStatus"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("TraceStatus") != m.end() && !m["TraceStatus"].empty()) {
      traceStatus = make_shared<long>(boost::any_cast<long>(m["TraceStatus"]));
    }
  }


  virtual ~DescribeApisecProtectionResourcesResponseBodyData() = default;
};
class DescribeApisecProtectionResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecProtectionResourcesResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecProtectionResourcesResponseBody() {}

  explicit DescribeApisecProtectionResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecProtectionResourcesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecProtectionResourcesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecProtectionResourcesResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecProtectionResourcesResponseBody() = default;
};
class DescribeApisecProtectionResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecProtectionResourcesResponseBody> body{};

  DescribeApisecProtectionResourcesResponse() {}

  explicit DescribeApisecProtectionResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecProtectionResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecProtectionResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecProtectionResourcesResponse() = default;
};
class DescribeApisecRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<string> name{};
  shared_ptr<string> origin{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribeApisecRulesRequest() {}

  explicit DescribeApisecRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (origin) {
      res["Origin"] = boost::any(*origin);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Origin") != m.end() && !m["Origin"].empty()) {
      origin = make_shared<string>(boost::any_cast<string>(m["Origin"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApisecRulesRequest() = default;
};
class DescribeApisecRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> rule{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};
  shared_ptr<long> updateTime{};

  DescribeApisecRulesResponseBodyData() {}

  explicit DescribeApisecRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rule) {
      res["Rule"] = boost::any(*rule);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      rule = make_shared<string>(boost::any_cast<string>(m["Rule"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeApisecRulesResponseBodyData() = default;
};
class DescribeApisecRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecRulesResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecRulesResponseBody() {}

  explicit DescribeApisecRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecRulesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecRulesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecRulesResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecRulesResponseBody() = default;
};
class DescribeApisecRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecRulesResponseBody> body{};

  DescribeApisecRulesResponse() {}

  explicit DescribeApisecRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecRulesResponse() = default;
};
class DescribeApisecSensitiveDomainStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderWay{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> type{};

  DescribeApisecSensitiveDomainStatisticRequest() {}

  explicit DescribeApisecSensitiveDomainStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApisecSensitiveDomainStatisticRequest() = default;
};
class DescribeApisecSensitiveDomainStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> apiCount{};
  shared_ptr<long> domainCount{};
  shared_ptr<string> sensitiveCode{};
  shared_ptr<string> sensitiveLevel{};
  shared_ptr<string> sensitiveName{};

  DescribeApisecSensitiveDomainStatisticResponseBodyData() {}

  explicit DescribeApisecSensitiveDomainStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiCount) {
      res["ApiCount"] = boost::any(*apiCount);
    }
    if (domainCount) {
      res["DomainCount"] = boost::any(*domainCount);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveLevel) {
      res["SensitiveLevel"] = boost::any(*sensitiveLevel);
    }
    if (sensitiveName) {
      res["SensitiveName"] = boost::any(*sensitiveName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiCount") != m.end() && !m["ApiCount"].empty()) {
      apiCount = make_shared<long>(boost::any_cast<long>(m["ApiCount"]));
    }
    if (m.find("DomainCount") != m.end() && !m["DomainCount"].empty()) {
      domainCount = make_shared<long>(boost::any_cast<long>(m["DomainCount"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<string>(boost::any_cast<string>(m["SensitiveCode"]));
    }
    if (m.find("SensitiveLevel") != m.end() && !m["SensitiveLevel"].empty()) {
      sensitiveLevel = make_shared<string>(boost::any_cast<string>(m["SensitiveLevel"]));
    }
    if (m.find("SensitiveName") != m.end() && !m["SensitiveName"].empty()) {
      sensitiveName = make_shared<string>(boost::any_cast<string>(m["SensitiveName"]));
    }
  }


  virtual ~DescribeApisecSensitiveDomainStatisticResponseBodyData() = default;
};
class DescribeApisecSensitiveDomainStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecSensitiveDomainStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisecSensitiveDomainStatisticResponseBody() {}

  explicit DescribeApisecSensitiveDomainStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecSensitiveDomainStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecSensitiveDomainStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecSensitiveDomainStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisecSensitiveDomainStatisticResponseBody() = default;
};
class DescribeApisecSensitiveDomainStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecSensitiveDomainStatisticResponseBody> body{};

  DescribeApisecSensitiveDomainStatisticResponse() {}

  explicit DescribeApisecSensitiveDomainStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecSensitiveDomainStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecSensitiveDomainStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecSensitiveDomainStatisticResponse() = default;
};
class DescribeApisecSlsLogStoresRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> logRegionId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecSlsLogStoresRequest() {}

  explicit DescribeApisecSlsLogStoresRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logRegionId) {
      res["LogRegionId"] = boost::any(*logRegionId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogRegionId") != m.end() && !m["LogRegionId"].empty()) {
      logRegionId = make_shared<string>(boost::any_cast<string>(m["LogRegionId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecSlsLogStoresRequest() = default;
};
class DescribeApisecSlsLogStoresResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> logStores{};
  shared_ptr<string> requestId{};

  DescribeApisecSlsLogStoresResponseBody() {}

  explicit DescribeApisecSlsLogStoresResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logStores) {
      res["LogStores"] = boost::any(*logStores);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogStores") != m.end() && !m["LogStores"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LogStores"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LogStores"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logStores = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecSlsLogStoresResponseBody() = default;
};
class DescribeApisecSlsLogStoresResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecSlsLogStoresResponseBody> body{};

  DescribeApisecSlsLogStoresResponse() {}

  explicit DescribeApisecSlsLogStoresResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecSlsLogStoresResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecSlsLogStoresResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecSlsLogStoresResponse() = default;
};
class DescribeApisecSlsProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> logRegionId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecSlsProjectsRequest() {}

  explicit DescribeApisecSlsProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logRegionId) {
      res["LogRegionId"] = boost::any(*logRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogRegionId") != m.end() && !m["LogRegionId"].empty()) {
      logRegionId = make_shared<string>(boost::any_cast<string>(m["LogRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecSlsProjectsRequest() = default;
};
class DescribeApisecSlsProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> projects{};
  shared_ptr<string> requestId{};

  DescribeApisecSlsProjectsResponseBody() {}

  explicit DescribeApisecSlsProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projects) {
      res["Projects"] = boost::any(*projects);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Projects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projects = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecSlsProjectsResponseBody() = default;
};
class DescribeApisecSlsProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecSlsProjectsResponseBody> body{};

  DescribeApisecSlsProjectsResponse() {}

  explicit DescribeApisecSlsProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecSlsProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecSlsProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecSlsProjectsResponse() = default;
};
class DescribeApisecStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> type{};

  DescribeApisecStatisticsRequest() {}

  explicit DescribeApisecStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApisecStatisticsRequest() = default;
};
class DescribeApisecStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> actioned{};
  shared_ptr<long> api{};
  shared_ptr<long> confirmed{};
  shared_ptr<long> domain{};
  shared_ptr<long> fixed{};
  shared_ptr<long> high{};
  shared_ptr<long> ignore{};
  shared_ptr<long> low{};
  shared_ptr<long> medium{};
  shared_ptr<long> toBeConfirmed{};
  shared_ptr<long> toBeFixed{};
  shared_ptr<string> todayHigh{};
  shared_ptr<long> todayLow{};
  shared_ptr<string> todayMedium{};
  shared_ptr<string> todayTotal{};
  shared_ptr<long> total{};

  DescribeApisecStatisticsResponseBodyData() {}

  explicit DescribeApisecStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actioned) {
      res["Actioned"] = boost::any(*actioned);
    }
    if (api) {
      res["Api"] = boost::any(*api);
    }
    if (confirmed) {
      res["Confirmed"] = boost::any(*confirmed);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (fixed) {
      res["Fixed"] = boost::any(*fixed);
    }
    if (high) {
      res["High"] = boost::any(*high);
    }
    if (ignore) {
      res["Ignore"] = boost::any(*ignore);
    }
    if (low) {
      res["Low"] = boost::any(*low);
    }
    if (medium) {
      res["Medium"] = boost::any(*medium);
    }
    if (toBeConfirmed) {
      res["ToBeConfirmed"] = boost::any(*toBeConfirmed);
    }
    if (toBeFixed) {
      res["ToBeFixed"] = boost::any(*toBeFixed);
    }
    if (todayHigh) {
      res["TodayHigh"] = boost::any(*todayHigh);
    }
    if (todayLow) {
      res["TodayLow"] = boost::any(*todayLow);
    }
    if (todayMedium) {
      res["TodayMedium"] = boost::any(*todayMedium);
    }
    if (todayTotal) {
      res["TodayTotal"] = boost::any(*todayTotal);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actioned") != m.end() && !m["Actioned"].empty()) {
      actioned = make_shared<long>(boost::any_cast<long>(m["Actioned"]));
    }
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      api = make_shared<long>(boost::any_cast<long>(m["Api"]));
    }
    if (m.find("Confirmed") != m.end() && !m["Confirmed"].empty()) {
      confirmed = make_shared<long>(boost::any_cast<long>(m["Confirmed"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<long>(boost::any_cast<long>(m["Domain"]));
    }
    if (m.find("Fixed") != m.end() && !m["Fixed"].empty()) {
      fixed = make_shared<long>(boost::any_cast<long>(m["Fixed"]));
    }
    if (m.find("High") != m.end() && !m["High"].empty()) {
      high = make_shared<long>(boost::any_cast<long>(m["High"]));
    }
    if (m.find("Ignore") != m.end() && !m["Ignore"].empty()) {
      ignore = make_shared<long>(boost::any_cast<long>(m["Ignore"]));
    }
    if (m.find("Low") != m.end() && !m["Low"].empty()) {
      low = make_shared<long>(boost::any_cast<long>(m["Low"]));
    }
    if (m.find("Medium") != m.end() && !m["Medium"].empty()) {
      medium = make_shared<long>(boost::any_cast<long>(m["Medium"]));
    }
    if (m.find("ToBeConfirmed") != m.end() && !m["ToBeConfirmed"].empty()) {
      toBeConfirmed = make_shared<long>(boost::any_cast<long>(m["ToBeConfirmed"]));
    }
    if (m.find("ToBeFixed") != m.end() && !m["ToBeFixed"].empty()) {
      toBeFixed = make_shared<long>(boost::any_cast<long>(m["ToBeFixed"]));
    }
    if (m.find("TodayHigh") != m.end() && !m["TodayHigh"].empty()) {
      todayHigh = make_shared<string>(boost::any_cast<string>(m["TodayHigh"]));
    }
    if (m.find("TodayLow") != m.end() && !m["TodayLow"].empty()) {
      todayLow = make_shared<long>(boost::any_cast<long>(m["TodayLow"]));
    }
    if (m.find("TodayMedium") != m.end() && !m["TodayMedium"].empty()) {
      todayMedium = make_shared<string>(boost::any_cast<string>(m["TodayMedium"]));
    }
    if (m.find("TodayTotal") != m.end() && !m["TodayTotal"].empty()) {
      todayTotal = make_shared<string>(boost::any_cast<string>(m["TodayTotal"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeApisecStatisticsResponseBodyData() = default;
};
class DescribeApisecStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisecStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeApisecStatisticsResponseBody() {}

  explicit DescribeApisecStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeApisecStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeApisecStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecStatisticsResponseBody() = default;
};
class DescribeApisecStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecStatisticsResponseBody> body{};

  DescribeApisecStatisticsResponse() {}

  explicit DescribeApisecStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecStatisticsResponse() = default;
};
class DescribeApisecSuggestionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeApisecSuggestionsRequest() {}

  explicit DescribeApisecSuggestionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeApisecSuggestionsRequest() = default;
};
class DescribeApisecSuggestionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> suggestId{};
  shared_ptr<string> suggestRule{};
  shared_ptr<string> suggestType{};

  DescribeApisecSuggestionsResponseBodyData() {}

  explicit DescribeApisecSuggestionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (suggestId) {
      res["SuggestId"] = boost::any(*suggestId);
    }
    if (suggestRule) {
      res["SuggestRule"] = boost::any(*suggestRule);
    }
    if (suggestType) {
      res["SuggestType"] = boost::any(*suggestType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("SuggestId") != m.end() && !m["SuggestId"].empty()) {
      suggestId = make_shared<string>(boost::any_cast<string>(m["SuggestId"]));
    }
    if (m.find("SuggestRule") != m.end() && !m["SuggestRule"].empty()) {
      suggestRule = make_shared<string>(boost::any_cast<string>(m["SuggestRule"]));
    }
    if (m.find("SuggestType") != m.end() && !m["SuggestType"].empty()) {
      suggestType = make_shared<string>(boost::any_cast<string>(m["SuggestType"]));
    }
  }


  virtual ~DescribeApisecSuggestionsResponseBodyData() = default;
};
class DescribeApisecSuggestionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecSuggestionsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeApisecSuggestionsResponseBody() {}

  explicit DescribeApisecSuggestionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecSuggestionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecSuggestionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecSuggestionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecSuggestionsResponseBody() = default;
};
class DescribeApisecSuggestionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecSuggestionsResponseBody> body{};

  DescribeApisecSuggestionsResponse() {}

  explicit DescribeApisecSuggestionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecSuggestionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecSuggestionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecSuggestionsResponse() = default;
};
class DescribeApisecUserOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> type{};

  DescribeApisecUserOperationsRequest() {}

  explicit DescribeApisecUserOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApisecUserOperationsRequest() = default;
};
class DescribeApisecUserOperationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fromStatus{};
  shared_ptr<string> note{};
  shared_ptr<string> objectId{};
  shared_ptr<long> time{};
  shared_ptr<string> toStatus{};
  shared_ptr<string> type{};
  shared_ptr<string> userId{};

  DescribeApisecUserOperationsResponseBodyData() {}

  explicit DescribeApisecUserOperationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromStatus) {
      res["FromStatus"] = boost::any(*fromStatus);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (toStatus) {
      res["ToStatus"] = boost::any(*toStatus);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromStatus") != m.end() && !m["FromStatus"].empty()) {
      fromStatus = make_shared<string>(boost::any_cast<string>(m["FromStatus"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("ToStatus") != m.end() && !m["ToStatus"].empty()) {
      toStatus = make_shared<string>(boost::any_cast<string>(m["ToStatus"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeApisecUserOperationsResponseBodyData() = default;
};
class DescribeApisecUserOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisecUserOperationsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeApisecUserOperationsResponseBody() {}

  explicit DescribeApisecUserOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeApisecUserOperationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisecUserOperationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeApisecUserOperationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApisecUserOperationsResponseBody() = default;
};
class DescribeApisecUserOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisecUserOperationsResponseBody> body{};

  DescribeApisecUserOperationsResponse() {}

  explicit DescribeApisecUserOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisecUserOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisecUserOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisecUserOperationsResponse() = default;
};
class DescribeCertDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeCertDetailRequest() {}

  explicit DescribeCertDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeCertDetailRequest() = default;
};
class DescribeCertDetailResponseBodyCertDetail : public Darabonba::Model {
public:
  shared_ptr<long> afterDate{};
  shared_ptr<long> beforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> sans{};

  DescribeCertDetailResponseBodyCertDetail() {}

  explicit DescribeCertDetailResponseBodyCertDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterDate) {
      res["AfterDate"] = boost::any(*afterDate);
    }
    if (beforeDate) {
      res["BeforeDate"] = boost::any(*beforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterDate") != m.end() && !m["AfterDate"].empty()) {
      afterDate = make_shared<long>(boost::any_cast<long>(m["AfterDate"]));
    }
    if (m.find("BeforeDate") != m.end() && !m["BeforeDate"].empty()) {
      beforeDate = make_shared<long>(boost::any_cast<long>(m["BeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sans"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sans"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sans = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCertDetailResponseBodyCertDetail() = default;
};
class DescribeCertDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCertDetailResponseBodyCertDetail> certDetail{};
  shared_ptr<string> requestId{};

  DescribeCertDetailResponseBody() {}

  explicit DescribeCertDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDetail) {
      res["CertDetail"] = certDetail ? boost::any(certDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDetail") != m.end() && !m["CertDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertDetail"].type()) {
        DescribeCertDetailResponseBodyCertDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertDetail"]));
        certDetail = make_shared<DescribeCertDetailResponseBodyCertDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCertDetailResponseBody() = default;
};
class DescribeCertDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCertDetailResponseBody> body{};

  DescribeCertDetailResponse() {}

  explicit DescribeCertDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCertDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCertDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCertDetailResponse() = default;
};
class DescribeCertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> algorithm{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeCertsRequest() {}

  explicit DescribeCertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithm) {
      res["Algorithm"] = boost::any(*algorithm);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Algorithm") != m.end() && !m["Algorithm"].empty()) {
      algorithm = make_shared<string>(boost::any_cast<string>(m["Algorithm"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeCertsRequest() = default;
};
class DescribeCertsResponseBodyCerts : public Darabonba::Model {
public:
  shared_ptr<long> afterDate{};
  shared_ptr<long> beforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<string> domain{};
  shared_ptr<bool> isChainCompleted{};

  DescribeCertsResponseBodyCerts() {}

  explicit DescribeCertsResponseBodyCerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterDate) {
      res["AfterDate"] = boost::any(*afterDate);
    }
    if (beforeDate) {
      res["BeforeDate"] = boost::any(*beforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (isChainCompleted) {
      res["IsChainCompleted"] = boost::any(*isChainCompleted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterDate") != m.end() && !m["AfterDate"].empty()) {
      afterDate = make_shared<long>(boost::any_cast<long>(m["AfterDate"]));
    }
    if (m.find("BeforeDate") != m.end() && !m["BeforeDate"].empty()) {
      beforeDate = make_shared<long>(boost::any_cast<long>(m["BeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IsChainCompleted") != m.end() && !m["IsChainCompleted"].empty()) {
      isChainCompleted = make_shared<bool>(boost::any_cast<bool>(m["IsChainCompleted"]));
    }
  }


  virtual ~DescribeCertsResponseBodyCerts() = default;
};
class DescribeCertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCertsResponseBodyCerts>> certs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCertsResponseBody() {}

  explicit DescribeCertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certs) {
      vector<boost::any> temp1;
      for(auto item1:*certs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certs") != m.end() && !m["Certs"].empty()) {
      if (typeid(vector<boost::any>) == m["Certs"].type()) {
        vector<DescribeCertsResponseBodyCerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCertsResponseBodyCerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certs = make_shared<vector<DescribeCertsResponseBodyCerts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCertsResponseBody() = default;
};
class DescribeCertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCertsResponseBody> body{};

  DescribeCertsResponse() {}

  explicit DescribeCertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCertsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCertsResponse() = default;
};
class DescribeCloudResourceAccessPortDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceProduct{};

  DescribeCloudResourceAccessPortDetailsRequest() {}

  explicit DescribeCloudResourceAccessPortDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsRequest() = default;
};
class DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};

  DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates() {}

  explicit DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates() = default;
};
class DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders() {}

  explicit DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders() = default;
};
class DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certId{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<string> domain{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> productCertId{};
  shared_ptr<string> productCertName{};
  shared_ptr<string> reasonCode{};

  DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails() {}

  explicit DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (productCertId) {
      res["ProductCertId"] = boost::any(*productCertId);
    }
    if (productCertName) {
      res["ProductCertName"] = boost::any(*productCertName);
    }
    if (reasonCode) {
      res["ReasonCode"] = boost::any(*reasonCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("ProductCertId") != m.end() && !m["ProductCertId"].empty()) {
      productCertId = make_shared<string>(boost::any_cast<string>(m["ProductCertId"]));
    }
    if (m.find("ProductCertName") != m.end() && !m["ProductCertName"].empty()) {
      productCertName = make_shared<string>(boost::any_cast<string>(m["ProductCertName"]));
    }
    if (m.find("ReasonCode") != m.end() && !m["ReasonCode"].empty()) {
      reasonCode = make_shared<string>(boost::any_cast<string>(m["ReasonCode"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails() = default;
};
class DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates>> certificates{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders>> logHeaders{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<long> readTimeout{};
  shared_ptr<long> status{};
  shared_ptr<string> subStatus{};
  shared_ptr<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails>> subStatusDetails{};
  shared_ptr<string> TLSVersion{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};
  shared_ptr<bool> xffProto{};

  DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails() {}

  explicit DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (logHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*logHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogHeaders"] = boost::any(temp1);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    if (subStatusDetails) {
      vector<boost::any> temp1;
      for(auto item1:*subStatusDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubStatusDetails"] = boost::any(temp1);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsCertificates>>(expect1);
      }
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("LogHeaders") != m.end() && !m["LogHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["LogHeaders"].type()) {
        vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logHeaders = make_shared<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsLogHeaders>>(expect1);
      }
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<string>(boost::any_cast<string>(m["SubStatus"]));
    }
    if (m.find("SubStatusDetails") != m.end() && !m["SubStatusDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SubStatusDetails"].type()) {
        vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubStatusDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subStatusDetails = make_shared<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetailsSubStatusDetails>>(expect1);
      }
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails() = default;
};
class DescribeCloudResourceAccessPortDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails>> accessPortDetails{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCloudResourceAccessPortDetailsResponseBody() {}

  explicit DescribeCloudResourceAccessPortDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPortDetails) {
      vector<boost::any> temp1;
      for(auto item1:*accessPortDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPortDetails"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPortDetails") != m.end() && !m["AccessPortDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPortDetails"].type()) {
        vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPortDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPortDetails = make_shared<vector<DescribeCloudResourceAccessPortDetailsResponseBodyAccessPortDetails>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponseBody() = default;
};
class DescribeCloudResourceAccessPortDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudResourceAccessPortDetailsResponseBody> body{};

  DescribeCloudResourceAccessPortDetailsResponse() {}

  explicit DescribeCloudResourceAccessPortDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudResourceAccessPortDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudResourceAccessPortDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudResourceAccessPortDetailsResponse() = default;
};
class DescribeCloudResourceAccessedPortsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeCloudResourceAccessedPortsRequest() {}

  explicit DescribeCloudResourceAccessedPortsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeCloudResourceAccessedPortsRequest() = default;
};
class DescribeCloudResourceAccessedPortsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<long>> http{};
  shared_ptr<vector<long>> https{};
  shared_ptr<string> requestId{};

  DescribeCloudResourceAccessedPortsResponseBody() {}

  explicit DescribeCloudResourceAccessedPortsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (http) {
      res["Http"] = boost::any(*http);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Http") != m.end() && !m["Http"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Http"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Http"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      http = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Https"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Https"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      https = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCloudResourceAccessedPortsResponseBody() = default;
};
class DescribeCloudResourceAccessedPortsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudResourceAccessedPortsResponseBody> body{};

  DescribeCloudResourceAccessedPortsResponse() {}

  explicit DescribeCloudResourceAccessedPortsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudResourceAccessedPortsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudResourceAccessedPortsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudResourceAccessedPortsResponse() = default;
};
class DescribeCloudResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceDomain{};
  shared_ptr<string> resourceFunction{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceInstanceName{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceRouteName{};

  DescribeCloudResourcesRequest() {}

  explicit DescribeCloudResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceDomain) {
      res["ResourceDomain"] = boost::any(*resourceDomain);
    }
    if (resourceFunction) {
      res["ResourceFunction"] = boost::any(*resourceFunction);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceInstanceName) {
      res["ResourceInstanceName"] = boost::any(*resourceInstanceName);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceRouteName) {
      res["ResourceRouteName"] = boost::any(*resourceRouteName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceDomain") != m.end() && !m["ResourceDomain"].empty()) {
      resourceDomain = make_shared<string>(boost::any_cast<string>(m["ResourceDomain"]));
    }
    if (m.find("ResourceFunction") != m.end() && !m["ResourceFunction"].empty()) {
      resourceFunction = make_shared<string>(boost::any_cast<string>(m["ResourceFunction"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceInstanceName") != m.end() && !m["ResourceInstanceName"].empty()) {
      resourceInstanceName = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceName"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceRouteName") != m.end() && !m["ResourceRouteName"].empty()) {
      resourceRouteName = make_shared<string>(boost::any_cast<string>(m["ResourceRouteName"]));
    }
  }


  virtual ~DescribeCloudResourcesRequest() = default;
};
class DescribeCloudResourcesResponseBodyCloudResources : public Darabonba::Model {
public:
  shared_ptr<long> httpPortCount{};
  shared_ptr<long> httpsPortCount{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> resourceDomain{};
  shared_ptr<string> resourceFunction{};
  shared_ptr<string> resourceInstance{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceInstanceIp{};
  shared_ptr<string> resourceInstanceName{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> resourceRegionId{};
  shared_ptr<string> resourceRouteName{};
  shared_ptr<string> resourceService{};

  DescribeCloudResourcesResponseBodyCloudResources() {}

  explicit DescribeCloudResourcesResponseBodyCloudResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpPortCount) {
      res["HttpPortCount"] = boost::any(*httpPortCount);
    }
    if (httpsPortCount) {
      res["HttpsPortCount"] = boost::any(*httpsPortCount);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (resourceDomain) {
      res["ResourceDomain"] = boost::any(*resourceDomain);
    }
    if (resourceFunction) {
      res["ResourceFunction"] = boost::any(*resourceFunction);
    }
    if (resourceInstance) {
      res["ResourceInstance"] = boost::any(*resourceInstance);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceInstanceIp) {
      res["ResourceInstanceIp"] = boost::any(*resourceInstanceIp);
    }
    if (resourceInstanceName) {
      res["ResourceInstanceName"] = boost::any(*resourceInstanceName);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    if (resourceRouteName) {
      res["ResourceRouteName"] = boost::any(*resourceRouteName);
    }
    if (resourceService) {
      res["ResourceService"] = boost::any(*resourceService);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpPortCount") != m.end() && !m["HttpPortCount"].empty()) {
      httpPortCount = make_shared<long>(boost::any_cast<long>(m["HttpPortCount"]));
    }
    if (m.find("HttpsPortCount") != m.end() && !m["HttpsPortCount"].empty()) {
      httpsPortCount = make_shared<long>(boost::any_cast<long>(m["HttpsPortCount"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ResourceDomain") != m.end() && !m["ResourceDomain"].empty()) {
      resourceDomain = make_shared<string>(boost::any_cast<string>(m["ResourceDomain"]));
    }
    if (m.find("ResourceFunction") != m.end() && !m["ResourceFunction"].empty()) {
      resourceFunction = make_shared<string>(boost::any_cast<string>(m["ResourceFunction"]));
    }
    if (m.find("ResourceInstance") != m.end() && !m["ResourceInstance"].empty()) {
      resourceInstance = make_shared<string>(boost::any_cast<string>(m["ResourceInstance"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceInstanceIp") != m.end() && !m["ResourceInstanceIp"].empty()) {
      resourceInstanceIp = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceIp"]));
    }
    if (m.find("ResourceInstanceName") != m.end() && !m["ResourceInstanceName"].empty()) {
      resourceInstanceName = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceName"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
    if (m.find("ResourceRouteName") != m.end() && !m["ResourceRouteName"].empty()) {
      resourceRouteName = make_shared<string>(boost::any_cast<string>(m["ResourceRouteName"]));
    }
    if (m.find("ResourceService") != m.end() && !m["ResourceService"].empty()) {
      resourceService = make_shared<string>(boost::any_cast<string>(m["ResourceService"]));
    }
  }


  virtual ~DescribeCloudResourcesResponseBodyCloudResources() = default;
};
class DescribeCloudResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudResourcesResponseBodyCloudResources>> cloudResources{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeCloudResourcesResponseBody() {}

  explicit DescribeCloudResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResources) {
      vector<boost::any> temp1;
      for(auto item1:*cloudResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudResources"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResources") != m.end() && !m["CloudResources"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudResources"].type()) {
        vector<DescribeCloudResourcesResponseBodyCloudResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudResourcesResponseBodyCloudResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudResources = make_shared<vector<DescribeCloudResourcesResponseBodyCloudResources>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeCloudResourcesResponseBody() = default;
};
class DescribeCloudResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudResourcesResponseBody> body{};

  DescribeCloudResourcesResponse() {}

  explicit DescribeCloudResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudResourcesResponse() = default;
};
class DescribeCnameCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeCnameCountRequest() {}

  explicit DescribeCnameCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeCnameCountRequest() = default;
};
class DescribeCnameCountResponseBodyCnameCount : public Darabonba::Model {
public:
  shared_ptr<long> cname{};
  shared_ptr<long> hybridCloudCname{};
  shared_ptr<long> total{};

  DescribeCnameCountResponseBodyCnameCount() {}

  explicit DescribeCnameCountResponseBodyCnameCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (hybridCloudCname) {
      res["HybridCloudCname"] = boost::any(*hybridCloudCname);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<long>(boost::any_cast<long>(m["Cname"]));
    }
    if (m.find("HybridCloudCname") != m.end() && !m["HybridCloudCname"].empty()) {
      hybridCloudCname = make_shared<long>(boost::any_cast<long>(m["HybridCloudCname"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeCnameCountResponseBodyCnameCount() = default;
};
class DescribeCnameCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCnameCountResponseBodyCnameCount> cnameCount{};
  shared_ptr<string> requestId{};

  DescribeCnameCountResponseBody() {}

  explicit DescribeCnameCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cnameCount) {
      res["CnameCount"] = cnameCount ? boost::any(cnameCount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CnameCount") != m.end() && !m["CnameCount"].empty()) {
      if (typeid(map<string, boost::any>) == m["CnameCount"].type()) {
        DescribeCnameCountResponseBodyCnameCount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CnameCount"]));
        cnameCount = make_shared<DescribeCnameCountResponseBodyCnameCount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCnameCountResponseBody() = default;
};
class DescribeCnameCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCnameCountResponseBody> body{};

  DescribeCnameCountResponse() {}

  explicit DescribeCnameCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCnameCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCnameCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCnameCountResponse() = default;
};
class DescribeDDoSStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDDoSStatusRequest() {}

  explicit DescribeDDoSStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDDoSStatusRequest() = default;
};
class DescribeDDoSStatusResponseBodyDDoSStatus : public Darabonba::Model {
public:
  shared_ptr<string> eventType{};
  shared_ptr<string> status{};

  DescribeDDoSStatusResponseBodyDDoSStatus() {}

  explicit DescribeDDoSStatusResponseBodyDDoSStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDDoSStatusResponseBodyDDoSStatus() = default;
};
class DescribeDDoSStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDDoSStatusResponseBodyDDoSStatus>> DDoSStatus{};
  shared_ptr<string> requestId{};

  DescribeDDoSStatusResponseBody() {}

  explicit DescribeDDoSStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DDoSStatus) {
      vector<boost::any> temp1;
      for(auto item1:*DDoSStatus){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DDoSStatus"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DDoSStatus") != m.end() && !m["DDoSStatus"].empty()) {
      if (typeid(vector<boost::any>) == m["DDoSStatus"].type()) {
        vector<DescribeDDoSStatusResponseBodyDDoSStatus> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DDoSStatus"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDDoSStatusResponseBodyDDoSStatus model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        DDoSStatus = make_shared<vector<DescribeDDoSStatusResponseBodyDDoSStatus>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDDoSStatusResponseBody() = default;
};
class DescribeDDoSStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDDoSStatusResponseBody> body{};

  DescribeDDoSStatusResponse() {}

  explicit DescribeDDoSStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDDoSStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDDoSStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDDoSStatusResponse() = default;
};
class DescribeDefaultHttpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefaultHttpsRequest() {}

  explicit DescribeDefaultHttpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefaultHttpsRequest() = default;
};
class DescribeDefaultHttpsResponseBodyDefaultHttps : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<string> cipherSuite{};
  shared_ptr<string> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<string> TLSVersion{};

  DescribeDefaultHttpsResponseBodyDefaultHttps() {}

  explicit DescribeDefaultHttpsResponseBodyDefaultHttps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<string>(boost::any_cast<string>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      customCiphers = make_shared<string>(boost::any_cast<string>(m["CustomCiphers"]));
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
  }


  virtual ~DescribeDefaultHttpsResponseBodyDefaultHttps() = default;
};
class DescribeDefaultHttpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDefaultHttpsResponseBodyDefaultHttps> defaultHttps{};
  shared_ptr<string> requestId{};

  DescribeDefaultHttpsResponseBody() {}

  explicit DescribeDefaultHttpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultHttps) {
      res["DefaultHttps"] = defaultHttps ? boost::any(defaultHttps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultHttps") != m.end() && !m["DefaultHttps"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultHttps"].type()) {
        DescribeDefaultHttpsResponseBodyDefaultHttps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultHttps"]));
        defaultHttps = make_shared<DescribeDefaultHttpsResponseBodyDefaultHttps>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDefaultHttpsResponseBody() = default;
};
class DescribeDefaultHttpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefaultHttpsResponseBody> body{};

  DescribeDefaultHttpsResponse() {}

  explicit DescribeDefaultHttpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefaultHttpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefaultHttpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefaultHttpsResponse() = default;
};
class DescribeDefenseResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefenseResourceRequest() {}

  explicit DescribeDefenseResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseResourceRequest() = default;
};
class DescribeDefenseResourceResponseBodyResourceResponseHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDefenseResourceResponseBodyResourceResponseHeaders() {}

  explicit DescribeDefenseResourceResponseBodyResourceResponseHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDefenseResourceResponseBodyResourceResponseHeaders() = default;
};
class DescribeDefenseResourceResponseBodyResource : public Darabonba::Model {
public:
  shared_ptr<long> acwCookieStatus{};
  shared_ptr<long> acwSecureStatus{};
  shared_ptr<long> acwV3SecureStatus{};
  shared_ptr<vector<string>> customHeaders{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> pattern{};
  shared_ptr<string> product{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceOrigin{};
  shared_ptr<vector<DescribeDefenseResourceResponseBodyResourceResponseHeaders>> responseHeaders{};
  shared_ptr<long> xffStatus{};

  DescribeDefenseResourceResponseBodyResource() {}

  explicit DescribeDefenseResourceResponseBodyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acwCookieStatus) {
      res["AcwCookieStatus"] = boost::any(*acwCookieStatus);
    }
    if (acwSecureStatus) {
      res["AcwSecureStatus"] = boost::any(*acwSecureStatus);
    }
    if (acwV3SecureStatus) {
      res["AcwV3SecureStatus"] = boost::any(*acwV3SecureStatus);
    }
    if (customHeaders) {
      res["CustomHeaders"] = boost::any(*customHeaders);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceOrigin) {
      res["ResourceOrigin"] = boost::any(*resourceOrigin);
    }
    if (responseHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaders"] = boost::any(temp1);
    }
    if (xffStatus) {
      res["XffStatus"] = boost::any(*xffStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcwCookieStatus") != m.end() && !m["AcwCookieStatus"].empty()) {
      acwCookieStatus = make_shared<long>(boost::any_cast<long>(m["AcwCookieStatus"]));
    }
    if (m.find("AcwSecureStatus") != m.end() && !m["AcwSecureStatus"].empty()) {
      acwSecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwSecureStatus"]));
    }
    if (m.find("AcwV3SecureStatus") != m.end() && !m["AcwV3SecureStatus"].empty()) {
      acwV3SecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwV3SecureStatus"]));
    }
    if (m.find("CustomHeaders") != m.end() && !m["CustomHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceOrigin") != m.end() && !m["ResourceOrigin"].empty()) {
      resourceOrigin = make_shared<string>(boost::any_cast<string>(m["ResourceOrigin"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<DescribeDefenseResourceResponseBodyResourceResponseHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourceResponseBodyResourceResponseHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaders = make_shared<vector<DescribeDefenseResourceResponseBodyResourceResponseHeaders>>(expect1);
      }
    }
    if (m.find("XffStatus") != m.end() && !m["XffStatus"].empty()) {
      xffStatus = make_shared<long>(boost::any_cast<long>(m["XffStatus"]));
    }
  }


  virtual ~DescribeDefenseResourceResponseBodyResource() = default;
};
class DescribeDefenseResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDefenseResourceResponseBodyResource> resource{};

  DescribeDefenseResourceResponseBody() {}

  explicit DescribeDefenseResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeDefenseResourceResponseBodyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeDefenseResourceResponseBodyResource>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceResponseBody() = default;
};
class DescribeDefenseResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceResponseBody> body{};

  DescribeDefenseResourceResponse() {}

  explicit DescribeDefenseResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceResponse() = default;
};
class DescribeDefenseResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefenseResourceGroupRequest() {}

  explicit DescribeDefenseResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupRequest() = default;
};
class DescribeDefenseResourceGroupResponseBodyGroup : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupName{};
  shared_ptr<string> resourceList{};

  DescribeDefenseResourceGroupResponseBodyGroup() {}

  explicit DescribeDefenseResourceGroupResponseBodyGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (resourceList) {
      res["ResourceList"] = boost::any(*resourceList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      resourceList = make_shared<string>(boost::any_cast<string>(m["ResourceList"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupResponseBodyGroup() = default;
};
class DescribeDefenseResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDefenseResourceGroupResponseBodyGroup> group{};
  shared_ptr<string> requestId{};

  DescribeDefenseResourceGroupResponseBody() {}

  explicit DescribeDefenseResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = group ? boost::any(group->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(map<string, boost::any>) == m["Group"].type()) {
        DescribeDefenseResourceGroupResponseBodyGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Group"]));
        group = make_shared<DescribeDefenseResourceGroupResponseBodyGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupResponseBody() = default;
};
class DescribeDefenseResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceGroupResponseBody> body{};

  DescribeDefenseResourceGroupResponse() {}

  explicit DescribeDefenseResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceGroupResponse() = default;
};
class DescribeDefenseResourceGroupNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupNameLike{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefenseResourceGroupNamesRequest() {}

  explicit DescribeDefenseResourceGroupNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNameLike) {
      res["GroupNameLike"] = boost::any(*groupNameLike);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNameLike") != m.end() && !m["GroupNameLike"].empty()) {
      groupNameLike = make_shared<string>(boost::any_cast<string>(m["GroupNameLike"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupNamesRequest() = default;
};
class DescribeDefenseResourceGroupNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupNames{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDefenseResourceGroupNamesResponseBody() {}

  explicit DescribeDefenseResourceGroupNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNames) {
      res["GroupNames"] = boost::any(*groupNames);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNames") != m.end() && !m["GroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupNamesResponseBody() = default;
};
class DescribeDefenseResourceGroupNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceGroupNamesResponseBody> body{};

  DescribeDefenseResourceGroupNamesResponse() {}

  explicit DescribeDefenseResourceGroupNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceGroupNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceGroupNamesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceGroupNamesResponse() = default;
};
class DescribeDefenseResourceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupNameLike{};
  shared_ptr<string> groupNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefenseResourceGroupsRequest() {}

  explicit DescribeDefenseResourceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupNameLike) {
      res["GroupNameLike"] = boost::any(*groupNameLike);
    }
    if (groupNames) {
      res["GroupNames"] = boost::any(*groupNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupNameLike") != m.end() && !m["GroupNameLike"].empty()) {
      groupNameLike = make_shared<string>(boost::any_cast<string>(m["GroupNameLike"]));
    }
    if (m.find("GroupNames") != m.end() && !m["GroupNames"].empty()) {
      groupNames = make_shared<string>(boost::any_cast<string>(m["GroupNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupsRequest() = default;
};
class DescribeDefenseResourceGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> groupName{};
  shared_ptr<string> resourceList{};

  DescribeDefenseResourceGroupsResponseBodyGroups() {}

  explicit DescribeDefenseResourceGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (resourceList) {
      res["ResourceList"] = boost::any(*resourceList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      resourceList = make_shared<string>(boost::any_cast<string>(m["ResourceList"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupsResponseBodyGroups() = default;
};
class DescribeDefenseResourceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDefenseResourceGroupsResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDefenseResourceGroupsResponseBody() {}

  explicit DescribeDefenseResourceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeDefenseResourceGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourceGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeDefenseResourceGroupsResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseResourceGroupsResponseBody() = default;
};
class DescribeDefenseResourceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceGroupsResponseBody> body{};

  DescribeDefenseResourceGroupsResponse() {}

  explicit DescribeDefenseResourceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceGroupsResponse() = default;
};
class DescribeDefenseResourceNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDefenseResourceNamesRequest() {}

  explicit DescribeDefenseResourceNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDefenseResourceNamesRequest() = default;
};
class DescribeDefenseResourceNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> resources{};
  shared_ptr<long> totalCount{};

  DescribeDefenseResourceNamesResponseBody() {}

  explicit DescribeDefenseResourceNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resources = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseResourceNamesResponseBody() = default;
};
class DescribeDefenseResourceNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceNamesResponseBody> body{};

  DescribeDefenseResourceNamesResponse() {}

  explicit DescribeDefenseResourceNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceNamesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceNamesResponse() = default;
};
class DescribeDefenseResourceTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> templateName{};

  DescribeDefenseResourceTemplatesRequest() {}

  explicit DescribeDefenseResourceTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~DescribeDefenseResourceTemplatesRequest() = default;
};
class DescribeDefenseResourceTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseSubScene{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateOrigin{};
  shared_ptr<long> templateStatus{};
  shared_ptr<string> templateType{};

  DescribeDefenseResourceTemplatesResponseBodyTemplates() {}

  explicit DescribeDefenseResourceTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseSubScene) {
      res["DefenseSubScene"] = boost::any(*defenseSubScene);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateOrigin) {
      res["TemplateOrigin"] = boost::any(*templateOrigin);
    }
    if (templateStatus) {
      res["TemplateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseSubScene") != m.end() && !m["DefenseSubScene"].empty()) {
      defenseSubScene = make_shared<string>(boost::any_cast<string>(m["DefenseSubScene"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateOrigin") != m.end() && !m["TemplateOrigin"].empty()) {
      templateOrigin = make_shared<string>(boost::any_cast<string>(m["TemplateOrigin"]));
    }
    if (m.find("TemplateStatus") != m.end() && !m["TemplateStatus"].empty()) {
      templateStatus = make_shared<long>(boost::any_cast<long>(m["TemplateStatus"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~DescribeDefenseResourceTemplatesResponseBodyTemplates() = default;
};
class DescribeDefenseResourceTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDefenseResourceTemplatesResponseBodyTemplates>> templates{};

  DescribeDefenseResourceTemplatesResponseBody() {}

  explicit DescribeDefenseResourceTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Templates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<DescribeDefenseResourceTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourceTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<DescribeDefenseResourceTemplatesResponseBodyTemplates>>(expect1);
      }
    }
  }


  virtual ~DescribeDefenseResourceTemplatesResponseBody() = default;
};
class DescribeDefenseResourceTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourceTemplatesResponseBody> body{};

  DescribeDefenseResourceTemplatesResponse() {}

  explicit DescribeDefenseResourceTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourceTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourceTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourceTemplatesResponse() = default;
};
class DescribeDefenseResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDefenseResourcesRequestTag() {}

  explicit DescribeDefenseResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDefenseResourcesRequestTag() = default;
};
class DescribeDefenseResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<DescribeDefenseResourcesRequestTag>> tag{};

  DescribeDefenseResourcesRequest() {}

  explicit DescribeDefenseResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDefenseResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDefenseResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDefenseResourcesRequest() = default;
};
class DescribeDefenseResourcesResponseBodyResourcesResponseHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDefenseResourcesResponseBodyResourcesResponseHeaders() {}

  explicit DescribeDefenseResourcesResponseBodyResourcesResponseHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDefenseResourcesResponseBodyResourcesResponseHeaders() = default;
};
class DescribeDefenseResourcesResponseBodyResources : public Darabonba::Model {
public:
  shared_ptr<long> acwCookieStatus{};
  shared_ptr<long> acwSecureStatus{};
  shared_ptr<long> acwV3SecureStatus{};
  shared_ptr<vector<string>> customHeaders{};
  shared_ptr<string> description{};
  shared_ptr<map<string, boost::any>> detail{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> pattern{};
  shared_ptr<string> product{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceGroup{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceOrigin{};
  shared_ptr<vector<DescribeDefenseResourcesResponseBodyResourcesResponseHeaders>> responseHeaders{};
  shared_ptr<long> xffStatus{};

  DescribeDefenseResourcesResponseBodyResources() {}

  explicit DescribeDefenseResourcesResponseBodyResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acwCookieStatus) {
      res["AcwCookieStatus"] = boost::any(*acwCookieStatus);
    }
    if (acwSecureStatus) {
      res["AcwSecureStatus"] = boost::any(*acwSecureStatus);
    }
    if (acwV3SecureStatus) {
      res["AcwV3SecureStatus"] = boost::any(*acwV3SecureStatus);
    }
    if (customHeaders) {
      res["CustomHeaders"] = boost::any(*customHeaders);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pattern) {
      res["Pattern"] = boost::any(*pattern);
    }
    if (product) {
      res["Product"] = boost::any(*product);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceGroup) {
      res["ResourceGroup"] = boost::any(*resourceGroup);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceOrigin) {
      res["ResourceOrigin"] = boost::any(*resourceOrigin);
    }
    if (responseHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaders"] = boost::any(temp1);
    }
    if (xffStatus) {
      res["XffStatus"] = boost::any(*xffStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcwCookieStatus") != m.end() && !m["AcwCookieStatus"].empty()) {
      acwCookieStatus = make_shared<long>(boost::any_cast<long>(m["AcwCookieStatus"]));
    }
    if (m.find("AcwSecureStatus") != m.end() && !m["AcwSecureStatus"].empty()) {
      acwSecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwSecureStatus"]));
    }
    if (m.find("AcwV3SecureStatus") != m.end() && !m["AcwV3SecureStatus"].empty()) {
      acwV3SecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwV3SecureStatus"]));
    }
    if (m.find("CustomHeaders") != m.end() && !m["CustomHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Detail"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      detail = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("Pattern") != m.end() && !m["Pattern"].empty()) {
      pattern = make_shared<string>(boost::any_cast<string>(m["Pattern"]));
    }
    if (m.find("Product") != m.end() && !m["Product"].empty()) {
      product = make_shared<string>(boost::any_cast<string>(m["Product"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceGroup") != m.end() && !m["ResourceGroup"].empty()) {
      resourceGroup = make_shared<string>(boost::any_cast<string>(m["ResourceGroup"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceOrigin") != m.end() && !m["ResourceOrigin"].empty()) {
      resourceOrigin = make_shared<string>(boost::any_cast<string>(m["ResourceOrigin"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<DescribeDefenseResourcesResponseBodyResourcesResponseHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourcesResponseBodyResourcesResponseHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaders = make_shared<vector<DescribeDefenseResourcesResponseBodyResourcesResponseHeaders>>(expect1);
      }
    }
    if (m.find("XffStatus") != m.end() && !m["XffStatus"].empty()) {
      xffStatus = make_shared<long>(boost::any_cast<long>(m["XffStatus"]));
    }
  }


  virtual ~DescribeDefenseResourcesResponseBodyResources() = default;
};
class DescribeDefenseResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDefenseResourcesResponseBodyResources>> resources{};
  shared_ptr<long> totalCount{};

  DescribeDefenseResourcesResponseBody() {}

  explicit DescribeDefenseResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      vector<boost::any> temp1;
      for(auto item1:*resources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Resources"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<DescribeDefenseResourcesResponseBodyResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Resources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseResourcesResponseBodyResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resources = make_shared<vector<DescribeDefenseResourcesResponseBodyResources>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseResourcesResponseBody() = default;
};
class DescribeDefenseResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseResourcesResponseBody> body{};

  DescribeDefenseResourcesResponse() {}

  explicit DescribeDefenseResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseResourcesResponse() = default;
};
class DescribeDefenseRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  DescribeDefenseRuleRequest() {}

  explicit DescribeDefenseRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseType) {
      res["DefenseType"] = boost::any(*defenseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseType") != m.end() && !m["DefenseType"].empty()) {
      defenseType = make_shared<string>(boost::any_cast<string>(m["DefenseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDefenseRuleRequest() = default;
};
class DescribeDefenseRuleResponseBodyRule : public Darabonba::Model {
public:
  shared_ptr<string> config{};
  shared_ptr<string> defenseOrigin{};
  shared_ptr<string> defenseScene{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> resource{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> status{};
  shared_ptr<long> templateId{};

  DescribeDefenseRuleResponseBodyRule() {}

  explicit DescribeDefenseRuleResponseBodyRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (defenseOrigin) {
      res["DefenseOrigin"] = boost::any(*defenseOrigin);
    }
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DefenseOrigin") != m.end() && !m["DefenseOrigin"].empty()) {
      defenseOrigin = make_shared<string>(boost::any_cast<string>(m["DefenseOrigin"]));
    }
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDefenseRuleResponseBodyRule() = default;
};
class DescribeDefenseRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDefenseRuleResponseBodyRule> rule{};

  DescribeDefenseRuleResponseBody() {}

  explicit DescribeDefenseRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        DescribeDefenseRuleResponseBodyRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<DescribeDefenseRuleResponseBodyRule>(model1);
      }
    }
  }


  virtual ~DescribeDefenseRuleResponseBody() = default;
};
class DescribeDefenseRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseRuleResponseBody> body{};

  DescribeDefenseRuleResponse() {}

  explicit DescribeDefenseRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseRuleResponse() = default;
};
class DescribeDefenseRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};

  DescribeDefenseRulesRequest() {}

  explicit DescribeDefenseRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeDefenseRulesRequest() = default;
};
class DescribeDefenseRulesResponseBodyRules : public Darabonba::Model {
public:
  shared_ptr<string> actionExternal{};
  shared_ptr<string> config{};
  shared_ptr<string> defenseOrigin{};
  shared_ptr<string> defenseScene{};
  shared_ptr<string> description{};
  shared_ptr<string> detailRuleIds{};
  shared_ptr<string> externalInfo{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> resource{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> ruleType{};
  shared_ptr<long> status{};
  shared_ptr<long> templateId{};

  DescribeDefenseRulesResponseBodyRules() {}

  explicit DescribeDefenseRulesResponseBodyRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionExternal) {
      res["ActionExternal"] = boost::any(*actionExternal);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    if (defenseOrigin) {
      res["DefenseOrigin"] = boost::any(*defenseOrigin);
    }
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (detailRuleIds) {
      res["DetailRuleIds"] = boost::any(*detailRuleIds);
    }
    if (externalInfo) {
      res["ExternalInfo"] = boost::any(*externalInfo);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionExternal") != m.end() && !m["ActionExternal"].empty()) {
      actionExternal = make_shared<string>(boost::any_cast<string>(m["ActionExternal"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
    if (m.find("DefenseOrigin") != m.end() && !m["DefenseOrigin"].empty()) {
      defenseOrigin = make_shared<string>(boost::any_cast<string>(m["DefenseOrigin"]));
    }
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DetailRuleIds") != m.end() && !m["DetailRuleIds"].empty()) {
      detailRuleIds = make_shared<string>(boost::any_cast<string>(m["DetailRuleIds"]));
    }
    if (m.find("ExternalInfo") != m.end() && !m["ExternalInfo"].empty()) {
      externalInfo = make_shared<string>(boost::any_cast<string>(m["ExternalInfo"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDefenseRulesResponseBodyRules() = default;
};
class DescribeDefenseRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDefenseRulesResponseBodyRules>> rules{};
  shared_ptr<long> totalCount{};

  DescribeDefenseRulesResponseBody() {}

  explicit DescribeDefenseRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<DescribeDefenseRulesResponseBodyRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseRulesResponseBodyRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<DescribeDefenseRulesResponseBodyRules>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseRulesResponseBody() = default;
};
class DescribeDefenseRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseRulesResponseBody> body{};

  DescribeDefenseRulesResponse() {}

  explicit DescribeDefenseRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseRulesResponse() = default;
};
class DescribeDefenseTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};

  DescribeDefenseTemplateRequest() {}

  explicit DescribeDefenseTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDefenseTemplateRequest() = default;
};
class DescribeDefenseTemplateResponseBodyTemplate : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseSubScene{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateOrigin{};
  shared_ptr<long> templateStatus{};
  shared_ptr<string> templateType{};

  DescribeDefenseTemplateResponseBodyTemplate() {}

  explicit DescribeDefenseTemplateResponseBodyTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseSubScene) {
      res["DefenseSubScene"] = boost::any(*defenseSubScene);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateOrigin) {
      res["TemplateOrigin"] = boost::any(*templateOrigin);
    }
    if (templateStatus) {
      res["TemplateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseSubScene") != m.end() && !m["DefenseSubScene"].empty()) {
      defenseSubScene = make_shared<string>(boost::any_cast<string>(m["DefenseSubScene"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateOrigin") != m.end() && !m["TemplateOrigin"].empty()) {
      templateOrigin = make_shared<string>(boost::any_cast<string>(m["TemplateOrigin"]));
    }
    if (m.find("TemplateStatus") != m.end() && !m["TemplateStatus"].empty()) {
      templateStatus = make_shared<long>(boost::any_cast<long>(m["TemplateStatus"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~DescribeDefenseTemplateResponseBodyTemplate() = default;
};
class DescribeDefenseTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDefenseTemplateResponseBodyTemplate> template_{};

  DescribeDefenseTemplateResponseBody() {}

  explicit DescribeDefenseTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (template_) {
      res["Template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(map<string, boost::any>) == m["Template"].type()) {
        DescribeDefenseTemplateResponseBodyTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Template"]));
        template_ = make_shared<DescribeDefenseTemplateResponseBodyTemplate>(model1);
      }
    }
  }


  virtual ~DescribeDefenseTemplateResponseBody() = default;
};
class DescribeDefenseTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseTemplateResponseBody> body{};

  DescribeDefenseTemplateResponse() {}

  explicit DescribeDefenseTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseTemplateResponse() = default;
};
class DescribeDefenseTemplateValidGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};

  DescribeDefenseTemplateValidGroupsRequest() {}

  explicit DescribeDefenseTemplateValidGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeDefenseTemplateValidGroupsRequest() = default;
};
class DescribeDefenseTemplateValidGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDefenseTemplateValidGroupsResponseBody() {}

  explicit DescribeDefenseTemplateValidGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      res["Groups"] = boost::any(*groups);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Groups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseTemplateValidGroupsResponseBody() = default;
};
class DescribeDefenseTemplateValidGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseTemplateValidGroupsResponseBody> body{};

  DescribeDefenseTemplateValidGroupsResponse() {}

  explicit DescribeDefenseTemplateValidGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseTemplateValidGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseTemplateValidGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseTemplateValidGroupsResponse() = default;
};
class DescribeDefenseTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseSubScene{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateIds{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateType{};

  DescribeDefenseTemplatesRequest() {}

  explicit DescribeDefenseTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseSubScene) {
      res["DefenseSubScene"] = boost::any(*defenseSubScene);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseSubScene") != m.end() && !m["DefenseSubScene"].empty()) {
      defenseSubScene = make_shared<string>(boost::any_cast<string>(m["DefenseSubScene"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~DescribeDefenseTemplatesRequest() = default;
};
class DescribeDefenseTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseSubScene{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};
  shared_ptr<string> templateOrigin{};
  shared_ptr<long> templateStatus{};
  shared_ptr<string> templateType{};

  DescribeDefenseTemplatesResponseBodyTemplates() {}

  explicit DescribeDefenseTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseSubScene) {
      res["DefenseSubScene"] = boost::any(*defenseSubScene);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    if (templateOrigin) {
      res["TemplateOrigin"] = boost::any(*templateOrigin);
    }
    if (templateStatus) {
      res["TemplateStatus"] = boost::any(*templateStatus);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseSubScene") != m.end() && !m["DefenseSubScene"].empty()) {
      defenseSubScene = make_shared<string>(boost::any_cast<string>(m["DefenseSubScene"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
    if (m.find("TemplateOrigin") != m.end() && !m["TemplateOrigin"].empty()) {
      templateOrigin = make_shared<string>(boost::any_cast<string>(m["TemplateOrigin"]));
    }
    if (m.find("TemplateStatus") != m.end() && !m["TemplateStatus"].empty()) {
      templateStatus = make_shared<long>(boost::any_cast<long>(m["TemplateStatus"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
  }


  virtual ~DescribeDefenseTemplatesResponseBodyTemplates() = default;
};
class DescribeDefenseTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDefenseTemplatesResponseBodyTemplates>> templates{};
  shared_ptr<long> totalCount{};

  DescribeDefenseTemplatesResponseBody() {}

  explicit DescribeDefenseTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      vector<boost::any> temp1;
      for(auto item1:*templates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Templates"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(vector<boost::any>) == m["Templates"].type()) {
        vector<DescribeDefenseTemplatesResponseBodyTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Templates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDefenseTemplatesResponseBodyTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        templates = make_shared<vector<DescribeDefenseTemplatesResponseBodyTemplates>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDefenseTemplatesResponseBody() = default;
};
class DescribeDefenseTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDefenseTemplatesResponseBody> body{};

  DescribeDefenseTemplatesResponse() {}

  explicit DescribeDefenseTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefenseTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefenseTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefenseTemplatesResponse() = default;
};
class DescribeDomainDNSRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeDomainDNSRecordRequest() {}

  explicit DescribeDomainDNSRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeDomainDNSRecordRequest() = default;
};
class DescribeDomainDNSRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> DNSStatus{};
  shared_ptr<string> requestId{};

  DescribeDomainDNSRecordResponseBody() {}

  explicit DescribeDomainDNSRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (DNSStatus) {
      res["DNSStatus"] = boost::any(*DNSStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DNSStatus") != m.end() && !m["DNSStatus"].empty()) {
      DNSStatus = make_shared<string>(boost::any_cast<string>(m["DNSStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDomainDNSRecordResponseBody() = default;
};
class DescribeDomainDNSRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainDNSRecordResponseBody> body{};

  DescribeDomainDNSRecordResponse() {}

  explicit DescribeDomainDNSRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDNSRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDNSRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDNSRecordResponse() = default;
};
class DescribeDomainDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeDomainDetailRequest() {}

  explicit DescribeDomainDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeDomainDetailRequest() = default;
};
class DescribeDomainDetailResponseBodyCertDetail : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> sans{};
  shared_ptr<long> startTime{};

  DescribeDomainDetailResponseBodyCertDetail() {}

  explicit DescribeDomainDetailResponseBodyCertDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sans"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sans"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sans = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyCertDetail() = default;
};
class DescribeDomainDetailResponseBodyListen : public Darabonba::Model {
public:
  shared_ptr<long> certId{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> exclusiveIp{};
  shared_ptr<bool> focusHttps{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<vector<long>> httpPorts{};
  shared_ptr<vector<long>> httpsPorts{};
  shared_ptr<bool> IPv6Enabled{};
  shared_ptr<string> protectionResource{};
  shared_ptr<bool> SM2AccessOnly{};
  shared_ptr<string> SM2CertId{};
  shared_ptr<bool> SM2Enabled{};
  shared_ptr<string> TLSVersion{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};

  DescribeDomainDetailResponseBodyListen() {}

  explicit DescribeDomainDetailResponseBodyListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (exclusiveIp) {
      res["ExclusiveIp"] = boost::any(*exclusiveIp);
    }
    if (focusHttps) {
      res["FocusHttps"] = boost::any(*focusHttps);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (IPv6Enabled) {
      res["IPv6Enabled"] = boost::any(*IPv6Enabled);
    }
    if (protectionResource) {
      res["ProtectionResource"] = boost::any(*protectionResource);
    }
    if (SM2AccessOnly) {
      res["SM2AccessOnly"] = boost::any(*SM2AccessOnly);
    }
    if (SM2CertId) {
      res["SM2CertId"] = boost::any(*SM2CertId);
    }
    if (SM2Enabled) {
      res["SM2Enabled"] = boost::any(*SM2Enabled);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<long>(boost::any_cast<long>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("ExclusiveIp") != m.end() && !m["ExclusiveIp"].empty()) {
      exclusiveIp = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveIp"]));
    }
    if (m.find("FocusHttps") != m.end() && !m["FocusHttps"].empty()) {
      focusHttps = make_shared<bool>(boost::any_cast<bool>(m["FocusHttps"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpsPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpsPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpsPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IPv6Enabled") != m.end() && !m["IPv6Enabled"].empty()) {
      IPv6Enabled = make_shared<bool>(boost::any_cast<bool>(m["IPv6Enabled"]));
    }
    if (m.find("ProtectionResource") != m.end() && !m["ProtectionResource"].empty()) {
      protectionResource = make_shared<string>(boost::any_cast<string>(m["ProtectionResource"]));
    }
    if (m.find("SM2AccessOnly") != m.end() && !m["SM2AccessOnly"].empty()) {
      SM2AccessOnly = make_shared<bool>(boost::any_cast<bool>(m["SM2AccessOnly"]));
    }
    if (m.find("SM2CertId") != m.end() && !m["SM2CertId"].empty()) {
      SM2CertId = make_shared<string>(boost::any_cast<string>(m["SM2CertId"]));
    }
    if (m.find("SM2Enabled") != m.end() && !m["SM2Enabled"].empty()) {
      SM2Enabled = make_shared<bool>(boost::any_cast<bool>(m["SM2Enabled"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDomainDetailResponseBodyListen() = default;
};
class DescribeDomainDetailResponseBodyRedirectBackends : public Darabonba::Model {
public:
  shared_ptr<string> backend{};

  DescribeDomainDetailResponseBodyRedirectBackends() {}

  explicit DescribeDomainDetailResponseBodyRedirectBackends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyRedirectBackends() = default;
};
class DescribeDomainDetailResponseBodyRedirectBackupBackends : public Darabonba::Model {
public:
  shared_ptr<string> backend{};

  DescribeDomainDetailResponseBodyRedirectBackupBackends() {}

  explicit DescribeDomainDetailResponseBodyRedirectBackupBackends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyRedirectBackupBackends() = default;
};
class DescribeDomainDetailResponseBodyRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDomainDetailResponseBodyRedirectRequestHeaders() {}

  explicit DescribeDomainDetailResponseBodyRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyRedirectRequestHeaders() = default;
};
class DescribeDomainDetailResponseBodyRedirect : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainDetailResponseBodyRedirectBackends>> backends{};
  shared_ptr<vector<DescribeDomainDetailResponseBodyRedirectBackupBackends>> backupBackends{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<bool> focusHttpBackend{};
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<string> loadbalance{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<DescribeDomainDetailResponseBodyRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<bool> retry{};
  shared_ptr<bool> sniEnabled{};
  shared_ptr<string> sniHost{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<bool> xffProto{};

  DescribeDomainDetailResponseBodyRedirect() {}

  explicit DescribeDomainDetailResponseBodyRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backends) {
      vector<boost::any> temp1;
      for(auto item1:*backends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Backends"] = boost::any(temp1);
    }
    if (backupBackends) {
      vector<boost::any> temp1;
      for(auto item1:*backupBackends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupBackends"] = boost::any(temp1);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (focusHttpBackend) {
      res["FocusHttpBackend"] = boost::any(*focusHttpBackend);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (loadbalance) {
      res["Loadbalance"] = boost::any(*loadbalance);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (sniEnabled) {
      res["SniEnabled"] = boost::any(*sniEnabled);
    }
    if (sniHost) {
      res["SniHost"] = boost::any(*sniHost);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backends") != m.end() && !m["Backends"].empty()) {
      if (typeid(vector<boost::any>) == m["Backends"].type()) {
        vector<DescribeDomainDetailResponseBodyRedirectBackends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Backends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailResponseBodyRedirectBackends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backends = make_shared<vector<DescribeDomainDetailResponseBodyRedirectBackends>>(expect1);
      }
    }
    if (m.find("BackupBackends") != m.end() && !m["BackupBackends"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupBackends"].type()) {
        vector<DescribeDomainDetailResponseBodyRedirectBackupBackends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupBackends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailResponseBodyRedirectBackupBackends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupBackends = make_shared<vector<DescribeDomainDetailResponseBodyRedirectBackupBackends>>(expect1);
      }
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("FocusHttpBackend") != m.end() && !m["FocusHttpBackend"].empty()) {
      focusHttpBackend = make_shared<bool>(boost::any_cast<bool>(m["FocusHttpBackend"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("Loadbalance") != m.end() && !m["Loadbalance"].empty()) {
      loadbalance = make_shared<string>(boost::any_cast<string>(m["Loadbalance"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<DescribeDomainDetailResponseBodyRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainDetailResponseBodyRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<DescribeDomainDetailResponseBodyRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["Retry"]));
    }
    if (m.find("SniEnabled") != m.end() && !m["SniEnabled"].empty()) {
      sniEnabled = make_shared<bool>(boost::any_cast<bool>(m["SniEnabled"]));
    }
    if (m.find("SniHost") != m.end() && !m["SniHost"].empty()) {
      sniHost = make_shared<string>(boost::any_cast<string>(m["SniHost"]));
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodyRedirect() = default;
};
class DescribeDomainDetailResponseBodySM2CertDetail : public Darabonba::Model {
public:
  shared_ptr<string> commonName{};
  shared_ptr<long> endTime{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> sans{};
  shared_ptr<long> startTime{};

  DescribeDomainDetailResponseBodySM2CertDetail() {}

  explicit DescribeDomainDetailResponseBodySM2CertDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sans) {
      res["Sans"] = boost::any(*sans);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sans") != m.end() && !m["Sans"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Sans"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Sans"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sans = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBodySM2CertDetail() = default;
};
class DescribeDomainDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainDetailResponseBodyCertDetail> certDetail{};
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<DescribeDomainDetailResponseBodyListen> listen{};
  shared_ptr<DescribeDomainDetailResponseBodyRedirect> redirect{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<DescribeDomainDetailResponseBodySM2CertDetail> SM2CertDetail{};
  shared_ptr<long> status{};

  DescribeDomainDetailResponseBody() {}

  explicit DescribeDomainDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certDetail) {
      res["CertDetail"] = certDetail ? boost::any(certDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (SM2CertDetail) {
      res["SM2CertDetail"] = SM2CertDetail ? boost::any(SM2CertDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertDetail") != m.end() && !m["CertDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["CertDetail"].type()) {
        DescribeDomainDetailResponseBodyCertDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CertDetail"]));
        certDetail = make_shared<DescribeDomainDetailResponseBodyCertDetail>(model1);
      }
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        DescribeDomainDetailResponseBodyListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<DescribeDomainDetailResponseBodyListen>(model1);
      }
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        DescribeDomainDetailResponseBodyRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<DescribeDomainDetailResponseBodyRedirect>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SM2CertDetail") != m.end() && !m["SM2CertDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["SM2CertDetail"].type()) {
        DescribeDomainDetailResponseBodySM2CertDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SM2CertDetail"]));
        SM2CertDetail = make_shared<DescribeDomainDetailResponseBodySM2CertDetail>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeDomainDetailResponseBody() = default;
};
class DescribeDomainDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainDetailResponseBody> body{};

  DescribeDomainDetailResponse() {}

  explicit DescribeDomainDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainDetailResponse() = default;
};
class DescribeDomainsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDomainsRequestTag() {}

  explicit DescribeDomainsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDomainsRequestTag() = default;
};
class DescribeDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> backend{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<DescribeDomainsRequestTag>> tag{};

  DescribeDomainsRequest() {}

  explicit DescribeDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDomainsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDomainsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsRequest() = default;
};
class DescribeDomainsResponseBodyDomainsBackedsHttp : public Darabonba::Model {
public:
  shared_ptr<string> backend{};

  DescribeDomainsResponseBodyDomainsBackedsHttp() {}

  explicit DescribeDomainsResponseBodyDomainsBackedsHttp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsBackedsHttp() = default;
};
class DescribeDomainsResponseBodyDomainsBackedsHttps : public Darabonba::Model {
public:
  shared_ptr<string> backend{};

  DescribeDomainsResponseBodyDomainsBackedsHttps() {}

  explicit DescribeDomainsResponseBodyDomainsBackedsHttps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsBackedsHttps() = default;
};
class DescribeDomainsResponseBodyDomainsBackeds : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsResponseBodyDomainsBackedsHttp>> http{};
  shared_ptr<vector<DescribeDomainsResponseBodyDomainsBackedsHttps>> https{};

  DescribeDomainsResponseBodyDomainsBackeds() {}

  explicit DescribeDomainsResponseBodyDomainsBackeds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (http) {
      vector<boost::any> temp1;
      for(auto item1:*http){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Http"] = boost::any(temp1);
    }
    if (https) {
      vector<boost::any> temp1;
      for(auto item1:*https){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Https"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Http") != m.end() && !m["Http"].empty()) {
      if (typeid(vector<boost::any>) == m["Http"].type()) {
        vector<DescribeDomainsResponseBodyDomainsBackedsHttp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Http"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsResponseBodyDomainsBackedsHttp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        http = make_shared<vector<DescribeDomainsResponseBodyDomainsBackedsHttp>>(expect1);
      }
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      if (typeid(vector<boost::any>) == m["Https"].type()) {
        vector<DescribeDomainsResponseBodyDomainsBackedsHttps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Https"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsResponseBodyDomainsBackedsHttps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        https = make_shared<vector<DescribeDomainsResponseBodyDomainsBackedsHttps>>(expect1);
      }
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsBackeds() = default;
};
class DescribeDomainsResponseBodyDomainsListenPorts : public Darabonba::Model {
public:
  shared_ptr<vector<long>> http{};
  shared_ptr<vector<long>> https{};

  DescribeDomainsResponseBodyDomainsListenPorts() {}

  explicit DescribeDomainsResponseBodyDomainsListenPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (http) {
      res["Http"] = boost::any(*http);
    }
    if (https) {
      res["Https"] = boost::any(*https);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Http") != m.end() && !m["Http"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Http"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Http"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      http = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Https") != m.end() && !m["Https"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Https"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Https"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      https = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DescribeDomainsResponseBodyDomainsListenPorts() = default;
};
class DescribeDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<DescribeDomainsResponseBodyDomainsBackeds> backeds{};
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<DescribeDomainsResponseBodyDomainsListenPorts> listenPorts{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> status{};

  DescribeDomainsResponseBodyDomains() {}

  explicit DescribeDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backeds) {
      res["Backeds"] = backeds ? boost::any(backeds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (listenPorts) {
      res["ListenPorts"] = listenPorts ? boost::any(listenPorts->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backeds") != m.end() && !m["Backeds"].empty()) {
      if (typeid(map<string, boost::any>) == m["Backeds"].type()) {
        DescribeDomainsResponseBodyDomainsBackeds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Backeds"]));
        backeds = make_shared<DescribeDomainsResponseBodyDomainsBackeds>(model1);
      }
    }
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ListenPorts") != m.end() && !m["ListenPorts"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListenPorts"].type()) {
        DescribeDomainsResponseBodyDomainsListenPorts model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListenPorts"]));
        listenPorts = make_shared<DescribeDomainsResponseBodyDomainsListenPorts>(model1);
      }
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeDomainsResponseBodyDomains() = default;
};
class DescribeDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDomainsResponseBodyDomains>> domains{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDomainsResponseBody() {}

  explicit DescribeDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDomainsResponseBody() = default;
};
class DescribeDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainsResponseBody> body{};

  DescribeDomainsResponse() {}

  explicit DescribeDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainsResponse() = default;
};
class DescribeFlowChartRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeFlowChartRequest() {}

  explicit DescribeFlowChartRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeFlowChartRequest() = default;
};
class DescribeFlowChartResponseBodyFlowChart : public Darabonba::Model {
public:
  shared_ptr<long> aclCustomBlockSum{};
  shared_ptr<long> aclCustomReportsSum{};
  shared_ptr<long> antiScanBlockSum{};
  shared_ptr<long> antibotBlockSum{};
  shared_ptr<string> antibotReportSum{};
  shared_ptr<long> antiscanReportsSum{};
  shared_ptr<string> blacklistBlockSum{};
  shared_ptr<long> blacklistReportsSum{};
  shared_ptr<long> ccCustomBlockSum{};
  shared_ptr<long> ccCustomReportsSum{};
  shared_ptr<long> ccSystemBlocksSum{};
  shared_ptr<long> ccSystemReportsSum{};
  shared_ptr<long> count{};
  shared_ptr<long> inBytes{};
  shared_ptr<long> index{};
  shared_ptr<long> maxPv{};
  shared_ptr<long> outBytes{};
  shared_ptr<long> ratelimitBlockSum{};
  shared_ptr<long> ratelimitReportSum{};
  shared_ptr<long> regionBlockBlocksSum{};
  shared_ptr<long> regionBlockReportsSum{};
  shared_ptr<long> robotCount{};
  shared_ptr<long> wafBlockSum{};
  shared_ptr<string> wafReportSum{};

  DescribeFlowChartResponseBodyFlowChart() {}

  explicit DescribeFlowChartResponseBodyFlowChart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclCustomBlockSum) {
      res["AclCustomBlockSum"] = boost::any(*aclCustomBlockSum);
    }
    if (aclCustomReportsSum) {
      res["AclCustomReportsSum"] = boost::any(*aclCustomReportsSum);
    }
    if (antiScanBlockSum) {
      res["AntiScanBlockSum"] = boost::any(*antiScanBlockSum);
    }
    if (antibotBlockSum) {
      res["AntibotBlockSum"] = boost::any(*antibotBlockSum);
    }
    if (antibotReportSum) {
      res["AntibotReportSum"] = boost::any(*antibotReportSum);
    }
    if (antiscanReportsSum) {
      res["AntiscanReportsSum"] = boost::any(*antiscanReportsSum);
    }
    if (blacklistBlockSum) {
      res["BlacklistBlockSum"] = boost::any(*blacklistBlockSum);
    }
    if (blacklistReportsSum) {
      res["BlacklistReportsSum"] = boost::any(*blacklistReportsSum);
    }
    if (ccCustomBlockSum) {
      res["CcCustomBlockSum"] = boost::any(*ccCustomBlockSum);
    }
    if (ccCustomReportsSum) {
      res["CcCustomReportsSum"] = boost::any(*ccCustomReportsSum);
    }
    if (ccSystemBlocksSum) {
      res["CcSystemBlocksSum"] = boost::any(*ccSystemBlocksSum);
    }
    if (ccSystemReportsSum) {
      res["CcSystemReportsSum"] = boost::any(*ccSystemReportsSum);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (inBytes) {
      res["InBytes"] = boost::any(*inBytes);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (maxPv) {
      res["MaxPv"] = boost::any(*maxPv);
    }
    if (outBytes) {
      res["OutBytes"] = boost::any(*outBytes);
    }
    if (ratelimitBlockSum) {
      res["RatelimitBlockSum"] = boost::any(*ratelimitBlockSum);
    }
    if (ratelimitReportSum) {
      res["RatelimitReportSum"] = boost::any(*ratelimitReportSum);
    }
    if (regionBlockBlocksSum) {
      res["RegionBlockBlocksSum"] = boost::any(*regionBlockBlocksSum);
    }
    if (regionBlockReportsSum) {
      res["RegionBlockReportsSum"] = boost::any(*regionBlockReportsSum);
    }
    if (robotCount) {
      res["RobotCount"] = boost::any(*robotCount);
    }
    if (wafBlockSum) {
      res["WafBlockSum"] = boost::any(*wafBlockSum);
    }
    if (wafReportSum) {
      res["WafReportSum"] = boost::any(*wafReportSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclCustomBlockSum") != m.end() && !m["AclCustomBlockSum"].empty()) {
      aclCustomBlockSum = make_shared<long>(boost::any_cast<long>(m["AclCustomBlockSum"]));
    }
    if (m.find("AclCustomReportsSum") != m.end() && !m["AclCustomReportsSum"].empty()) {
      aclCustomReportsSum = make_shared<long>(boost::any_cast<long>(m["AclCustomReportsSum"]));
    }
    if (m.find("AntiScanBlockSum") != m.end() && !m["AntiScanBlockSum"].empty()) {
      antiScanBlockSum = make_shared<long>(boost::any_cast<long>(m["AntiScanBlockSum"]));
    }
    if (m.find("AntibotBlockSum") != m.end() && !m["AntibotBlockSum"].empty()) {
      antibotBlockSum = make_shared<long>(boost::any_cast<long>(m["AntibotBlockSum"]));
    }
    if (m.find("AntibotReportSum") != m.end() && !m["AntibotReportSum"].empty()) {
      antibotReportSum = make_shared<string>(boost::any_cast<string>(m["AntibotReportSum"]));
    }
    if (m.find("AntiscanReportsSum") != m.end() && !m["AntiscanReportsSum"].empty()) {
      antiscanReportsSum = make_shared<long>(boost::any_cast<long>(m["AntiscanReportsSum"]));
    }
    if (m.find("BlacklistBlockSum") != m.end() && !m["BlacklistBlockSum"].empty()) {
      blacklistBlockSum = make_shared<string>(boost::any_cast<string>(m["BlacklistBlockSum"]));
    }
    if (m.find("BlacklistReportsSum") != m.end() && !m["BlacklistReportsSum"].empty()) {
      blacklistReportsSum = make_shared<long>(boost::any_cast<long>(m["BlacklistReportsSum"]));
    }
    if (m.find("CcCustomBlockSum") != m.end() && !m["CcCustomBlockSum"].empty()) {
      ccCustomBlockSum = make_shared<long>(boost::any_cast<long>(m["CcCustomBlockSum"]));
    }
    if (m.find("CcCustomReportsSum") != m.end() && !m["CcCustomReportsSum"].empty()) {
      ccCustomReportsSum = make_shared<long>(boost::any_cast<long>(m["CcCustomReportsSum"]));
    }
    if (m.find("CcSystemBlocksSum") != m.end() && !m["CcSystemBlocksSum"].empty()) {
      ccSystemBlocksSum = make_shared<long>(boost::any_cast<long>(m["CcSystemBlocksSum"]));
    }
    if (m.find("CcSystemReportsSum") != m.end() && !m["CcSystemReportsSum"].empty()) {
      ccSystemReportsSum = make_shared<long>(boost::any_cast<long>(m["CcSystemReportsSum"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InBytes") != m.end() && !m["InBytes"].empty()) {
      inBytes = make_shared<long>(boost::any_cast<long>(m["InBytes"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("MaxPv") != m.end() && !m["MaxPv"].empty()) {
      maxPv = make_shared<long>(boost::any_cast<long>(m["MaxPv"]));
    }
    if (m.find("OutBytes") != m.end() && !m["OutBytes"].empty()) {
      outBytes = make_shared<long>(boost::any_cast<long>(m["OutBytes"]));
    }
    if (m.find("RatelimitBlockSum") != m.end() && !m["RatelimitBlockSum"].empty()) {
      ratelimitBlockSum = make_shared<long>(boost::any_cast<long>(m["RatelimitBlockSum"]));
    }
    if (m.find("RatelimitReportSum") != m.end() && !m["RatelimitReportSum"].empty()) {
      ratelimitReportSum = make_shared<long>(boost::any_cast<long>(m["RatelimitReportSum"]));
    }
    if (m.find("RegionBlockBlocksSum") != m.end() && !m["RegionBlockBlocksSum"].empty()) {
      regionBlockBlocksSum = make_shared<long>(boost::any_cast<long>(m["RegionBlockBlocksSum"]));
    }
    if (m.find("RegionBlockReportsSum") != m.end() && !m["RegionBlockReportsSum"].empty()) {
      regionBlockReportsSum = make_shared<long>(boost::any_cast<long>(m["RegionBlockReportsSum"]));
    }
    if (m.find("RobotCount") != m.end() && !m["RobotCount"].empty()) {
      robotCount = make_shared<long>(boost::any_cast<long>(m["RobotCount"]));
    }
    if (m.find("WafBlockSum") != m.end() && !m["WafBlockSum"].empty()) {
      wafBlockSum = make_shared<long>(boost::any_cast<long>(m["WafBlockSum"]));
    }
    if (m.find("WafReportSum") != m.end() && !m["WafReportSum"].empty()) {
      wafReportSum = make_shared<string>(boost::any_cast<string>(m["WafReportSum"]));
    }
  }


  virtual ~DescribeFlowChartResponseBodyFlowChart() = default;
};
class DescribeFlowChartResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowChartResponseBodyFlowChart>> flowChart{};
  shared_ptr<string> requestId{};

  DescribeFlowChartResponseBody() {}

  explicit DescribeFlowChartResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowChart) {
      vector<boost::any> temp1;
      for(auto item1:*flowChart){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowChart"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowChart") != m.end() && !m["FlowChart"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowChart"].type()) {
        vector<DescribeFlowChartResponseBodyFlowChart> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowChart"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowChartResponseBodyFlowChart model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowChart = make_shared<vector<DescribeFlowChartResponseBodyFlowChart>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFlowChartResponseBody() = default;
};
class DescribeFlowChartResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowChartResponseBody> body{};

  DescribeFlowChartResponse() {}

  explicit DescribeFlowChartResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowChartResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowChartResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowChartResponse() = default;
};
class DescribeFlowTopResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeFlowTopResourceRequest() {}

  explicit DescribeFlowTopResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeFlowTopResourceRequest() = default;
};
class DescribeFlowTopResourceResponseBodyRuleHitsTopResource : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> resource{};

  DescribeFlowTopResourceResponseBodyRuleHitsTopResource() {}

  explicit DescribeFlowTopResourceResponseBodyRuleHitsTopResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~DescribeFlowTopResourceResponseBodyRuleHitsTopResource() = default;
};
class DescribeFlowTopResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFlowTopResourceResponseBodyRuleHitsTopResource>> ruleHitsTopResource{};

  DescribeFlowTopResourceResponseBody() {}

  explicit DescribeFlowTopResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopResource) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopResource") != m.end() && !m["RuleHitsTopResource"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopResource"].type()) {
        vector<DescribeFlowTopResourceResponseBodyRuleHitsTopResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowTopResourceResponseBodyRuleHitsTopResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopResource = make_shared<vector<DescribeFlowTopResourceResponseBodyRuleHitsTopResource>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowTopResourceResponseBody() = default;
};
class DescribeFlowTopResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowTopResourceResponseBody> body{};

  DescribeFlowTopResourceResponse() {}

  explicit DescribeFlowTopResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowTopResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowTopResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowTopResourceResponse() = default;
};
class DescribeFlowTopUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeFlowTopUrlRequest() {}

  explicit DescribeFlowTopUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeFlowTopUrlRequest() = default;
};
class DescribeFlowTopUrlResponseBodyRuleHitsTopUrl : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> url{};

  DescribeFlowTopUrlResponseBodyRuleHitsTopUrl() {}

  explicit DescribeFlowTopUrlResponseBodyRuleHitsTopUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeFlowTopUrlResponseBodyRuleHitsTopUrl() = default;
};
class DescribeFlowTopUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFlowTopUrlResponseBodyRuleHitsTopUrl>> ruleHitsTopUrl{};

  DescribeFlowTopUrlResponseBody() {}

  explicit DescribeFlowTopUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopUrl) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopUrl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopUrl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopUrl") != m.end() && !m["RuleHitsTopUrl"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopUrl"].type()) {
        vector<DescribeFlowTopUrlResponseBodyRuleHitsTopUrl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopUrl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowTopUrlResponseBodyRuleHitsTopUrl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopUrl = make_shared<vector<DescribeFlowTopUrlResponseBodyRuleHitsTopUrl>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowTopUrlResponseBody() = default;
};
class DescribeFlowTopUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFlowTopUrlResponseBody> body{};

  DescribeFlowTopUrlResponse() {}

  explicit DescribeFlowTopUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowTopUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowTopUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowTopUrlResponse() = default;
};
class DescribeFreeUserAssetCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeFreeUserAssetCountRequest() {}

  explicit DescribeFreeUserAssetCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeFreeUserAssetCountRequest() = default;
};
class DescribeFreeUserAssetCountResponseBodyAsset : public Darabonba::Model {
public:
  shared_ptr<long> assetActive{};
  shared_ptr<long> assetCount{};
  shared_ptr<long> assetOffline{};

  DescribeFreeUserAssetCountResponseBodyAsset() {}

  explicit DescribeFreeUserAssetCountResponseBodyAsset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetActive) {
      res["AssetActive"] = boost::any(*assetActive);
    }
    if (assetCount) {
      res["AssetCount"] = boost::any(*assetCount);
    }
    if (assetOffline) {
      res["AssetOffline"] = boost::any(*assetOffline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetActive") != m.end() && !m["AssetActive"].empty()) {
      assetActive = make_shared<long>(boost::any_cast<long>(m["AssetActive"]));
    }
    if (m.find("AssetCount") != m.end() && !m["AssetCount"].empty()) {
      assetCount = make_shared<long>(boost::any_cast<long>(m["AssetCount"]));
    }
    if (m.find("AssetOffline") != m.end() && !m["AssetOffline"].empty()) {
      assetOffline = make_shared<long>(boost::any_cast<long>(m["AssetOffline"]));
    }
  }


  virtual ~DescribeFreeUserAssetCountResponseBodyAsset() = default;
};
class DescribeFreeUserAssetCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFreeUserAssetCountResponseBodyAsset> asset{};
  shared_ptr<string> requestId{};

  DescribeFreeUserAssetCountResponseBody() {}

  explicit DescribeFreeUserAssetCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asset) {
      res["Asset"] = asset ? boost::any(asset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Asset") != m.end() && !m["Asset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Asset"].type()) {
        DescribeFreeUserAssetCountResponseBodyAsset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Asset"]));
        asset = make_shared<DescribeFreeUserAssetCountResponseBodyAsset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFreeUserAssetCountResponseBody() = default;
};
class DescribeFreeUserAssetCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFreeUserAssetCountResponseBody> body{};

  DescribeFreeUserAssetCountResponse() {}

  explicit DescribeFreeUserAssetCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFreeUserAssetCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFreeUserAssetCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFreeUserAssetCountResponse() = default;
};
class DescribeFreeUserEventCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeFreeUserEventCountRequest() {}

  explicit DescribeFreeUserEventCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeFreeUserEventCountRequest() = default;
};
class DescribeFreeUserEventCountResponseBodyEvent : public Darabonba::Model {
public:
  shared_ptr<long> eventHigh{};
  shared_ptr<long> eventLow{};
  shared_ptr<long> eventMedium{};
  shared_ptr<long> eventTotal{};

  DescribeFreeUserEventCountResponseBodyEvent() {}

  explicit DescribeFreeUserEventCountResponseBodyEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventHigh) {
      res["EventHigh"] = boost::any(*eventHigh);
    }
    if (eventLow) {
      res["EventLow"] = boost::any(*eventLow);
    }
    if (eventMedium) {
      res["EventMedium"] = boost::any(*eventMedium);
    }
    if (eventTotal) {
      res["EventTotal"] = boost::any(*eventTotal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventHigh") != m.end() && !m["EventHigh"].empty()) {
      eventHigh = make_shared<long>(boost::any_cast<long>(m["EventHigh"]));
    }
    if (m.find("EventLow") != m.end() && !m["EventLow"].empty()) {
      eventLow = make_shared<long>(boost::any_cast<long>(m["EventLow"]));
    }
    if (m.find("EventMedium") != m.end() && !m["EventMedium"].empty()) {
      eventMedium = make_shared<long>(boost::any_cast<long>(m["EventMedium"]));
    }
    if (m.find("EventTotal") != m.end() && !m["EventTotal"].empty()) {
      eventTotal = make_shared<long>(boost::any_cast<long>(m["EventTotal"]));
    }
  }


  virtual ~DescribeFreeUserEventCountResponseBodyEvent() = default;
};
class DescribeFreeUserEventCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeFreeUserEventCountResponseBodyEvent> event{};
  shared_ptr<string> requestId{};

  DescribeFreeUserEventCountResponseBody() {}

  explicit DescribeFreeUserEventCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = event ? boost::any(event->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(map<string, boost::any>) == m["Event"].type()) {
        DescribeFreeUserEventCountResponseBodyEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Event"]));
        event = make_shared<DescribeFreeUserEventCountResponseBodyEvent>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFreeUserEventCountResponseBody() = default;
};
class DescribeFreeUserEventCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFreeUserEventCountResponseBody> body{};

  DescribeFreeUserEventCountResponse() {}

  explicit DescribeFreeUserEventCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFreeUserEventCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFreeUserEventCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFreeUserEventCountResponse() = default;
};
class DescribeFreeUserEventTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeFreeUserEventTypesRequest() {}

  explicit DescribeFreeUserEventTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeFreeUserEventTypesRequest() = default;
};
class DescribeFreeUserEventTypesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> eventNum{};
  shared_ptr<string> eventType{};

  DescribeFreeUserEventTypesResponseBodyData() {}

  explicit DescribeFreeUserEventTypesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventNum) {
      res["EventNum"] = boost::any(*eventNum);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventNum") != m.end() && !m["EventNum"].empty()) {
      eventNum = make_shared<string>(boost::any_cast<string>(m["EventNum"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
  }


  virtual ~DescribeFreeUserEventTypesResponseBodyData() = default;
};
class DescribeFreeUserEventTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFreeUserEventTypesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeFreeUserEventTypesResponseBody() {}

  explicit DescribeFreeUserEventTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeFreeUserEventTypesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFreeUserEventTypesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeFreeUserEventTypesResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFreeUserEventTypesResponseBody() = default;
};
class DescribeFreeUserEventTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFreeUserEventTypesResponseBody> body{};

  DescribeFreeUserEventTypesResponse() {}

  explicit DescribeFreeUserEventTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFreeUserEventTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFreeUserEventTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFreeUserEventTypesResponse() = default;
};
class DescribeFreeUserEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeFreeUserEventsRequest() {}

  explicit DescribeFreeUserEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeFreeUserEventsRequest() = default;
};
class DescribeFreeUserEventsResponseBodyEvent : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> attackIP{};
  shared_ptr<long> attackTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> eventLevel{};
  shared_ptr<string> eventTag{};

  DescribeFreeUserEventsResponseBodyEvent() {}

  explicit DescribeFreeUserEventsResponseBodyEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (attackIP) {
      res["AttackIP"] = boost::any(*attackIP);
    }
    if (attackTime) {
      res["AttackTime"] = boost::any(*attackTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (eventLevel) {
      res["EventLevel"] = boost::any(*eventLevel);
    }
    if (eventTag) {
      res["EventTag"] = boost::any(*eventTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("AttackIP") != m.end() && !m["AttackIP"].empty()) {
      attackIP = make_shared<string>(boost::any_cast<string>(m["AttackIP"]));
    }
    if (m.find("AttackTime") != m.end() && !m["AttackTime"].empty()) {
      attackTime = make_shared<long>(boost::any_cast<long>(m["AttackTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("EventLevel") != m.end() && !m["EventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["EventLevel"]));
    }
    if (m.find("EventTag") != m.end() && !m["EventTag"].empty()) {
      eventTag = make_shared<string>(boost::any_cast<string>(m["EventTag"]));
    }
  }


  virtual ~DescribeFreeUserEventsResponseBodyEvent() = default;
};
class DescribeFreeUserEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFreeUserEventsResponseBodyEvent>> event{};
  shared_ptr<string> requestId{};

  DescribeFreeUserEventsResponseBody() {}

  explicit DescribeFreeUserEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      vector<boost::any> temp1;
      for(auto item1:*event){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Event"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(vector<boost::any>) == m["Event"].type()) {
        vector<DescribeFreeUserEventsResponseBodyEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Event"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFreeUserEventsResponseBodyEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        event = make_shared<vector<DescribeFreeUserEventsResponseBodyEvent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeFreeUserEventsResponseBody() = default;
};
class DescribeFreeUserEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFreeUserEventsResponseBody> body{};

  DescribeFreeUserEventsResponse() {}

  explicit DescribeFreeUserEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFreeUserEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFreeUserEventsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFreeUserEventsResponse() = default;
};
class DescribeHybridCloudClusterRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};

  DescribeHybridCloudClusterRuleRequest() {}

  explicit DescribeHybridCloudClusterRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeHybridCloudClusterRuleRequest() = default;
};
class DescribeHybridCloudClusterRuleResponseBodyClusterRule : public Darabonba::Model {
public:
  shared_ptr<string> ruleConfig{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<string> ruleType{};

  DescribeHybridCloudClusterRuleResponseBodyClusterRule() {}

  explicit DescribeHybridCloudClusterRuleResponseBodyClusterRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeHybridCloudClusterRuleResponseBodyClusterRule() = default;
};
class DescribeHybridCloudClusterRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHybridCloudClusterRuleResponseBodyClusterRule> clusterRule{};
  shared_ptr<string> requestId{};

  DescribeHybridCloudClusterRuleResponseBody() {}

  explicit DescribeHybridCloudClusterRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterRule) {
      res["ClusterRule"] = clusterRule ? boost::any(clusterRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterRule") != m.end() && !m["ClusterRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterRule"].type()) {
        DescribeHybridCloudClusterRuleResponseBodyClusterRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterRule"]));
        clusterRule = make_shared<DescribeHybridCloudClusterRuleResponseBodyClusterRule>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHybridCloudClusterRuleResponseBody() = default;
};
class DescribeHybridCloudClusterRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudClusterRuleResponseBody> body{};

  DescribeHybridCloudClusterRuleResponse() {}

  explicit DescribeHybridCloudClusterRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudClusterRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudClusterRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudClusterRuleResponse() = default;
};
class DescribeHybridCloudClustersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudClustersRequest() {}

  explicit DescribeHybridCloudClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudClustersRequest() = default;
};
class DescribeHybridCloudClustersResponseBodyClusterInfos : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};
  shared_ptr<string> accessRegion{};
  shared_ptr<string> clusterName{};
  shared_ptr<string> clusterResourceId{};
  shared_ptr<string> httpPorts{};
  shared_ptr<string> httpsPorts{};
  shared_ptr<long> id{};
  shared_ptr<long> protectionServerCount{};
  shared_ptr<string> proxyStatus{};
  shared_ptr<string> proxyType{};
  shared_ptr<string> remark{};
  shared_ptr<string> ruleConfig{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<string> ruleType{};

  DescribeHybridCloudClustersResponseBodyClusterInfos() {}

  explicit DescribeHybridCloudClustersResponseBodyClusterInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    if (accessRegion) {
      res["AccessRegion"] = boost::any(*accessRegion);
    }
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (clusterResourceId) {
      res["ClusterResourceId"] = boost::any(*clusterResourceId);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (protectionServerCount) {
      res["ProtectionServerCount"] = boost::any(*protectionServerCount);
    }
    if (proxyStatus) {
      res["ProxyStatus"] = boost::any(*proxyStatus);
    }
    if (proxyType) {
      res["ProxyType"] = boost::any(*proxyType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
    if (m.find("AccessRegion") != m.end() && !m["AccessRegion"].empty()) {
      accessRegion = make_shared<string>(boost::any_cast<string>(m["AccessRegion"]));
    }
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("ClusterResourceId") != m.end() && !m["ClusterResourceId"].empty()) {
      clusterResourceId = make_shared<string>(boost::any_cast<string>(m["ClusterResourceId"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      httpPorts = make_shared<string>(boost::any_cast<string>(m["HttpPorts"]));
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      httpsPorts = make_shared<string>(boost::any_cast<string>(m["HttpsPorts"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ProtectionServerCount") != m.end() && !m["ProtectionServerCount"].empty()) {
      protectionServerCount = make_shared<long>(boost::any_cast<long>(m["ProtectionServerCount"]));
    }
    if (m.find("ProxyStatus") != m.end() && !m["ProxyStatus"].empty()) {
      proxyStatus = make_shared<string>(boost::any_cast<string>(m["ProxyStatus"]));
    }
    if (m.find("ProxyType") != m.end() && !m["ProxyType"].empty()) {
      proxyType = make_shared<string>(boost::any_cast<string>(m["ProxyType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeHybridCloudClustersResponseBodyClusterInfos() = default;
};
class DescribeHybridCloudClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridCloudClustersResponseBodyClusterInfos>> clusterInfos{};
  shared_ptr<string> requestId{};

  DescribeHybridCloudClustersResponseBody() {}

  explicit DescribeHybridCloudClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clusterInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterInfos") != m.end() && !m["ClusterInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterInfos"].type()) {
        vector<DescribeHybridCloudClustersResponseBodyClusterInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudClustersResponseBodyClusterInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterInfos = make_shared<vector<DescribeHybridCloudClustersResponseBodyClusterInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHybridCloudClustersResponseBody() = default;
};
class DescribeHybridCloudClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudClustersResponseBody> body{};

  DescribeHybridCloudClustersResponse() {}

  explicit DescribeHybridCloudClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudClustersResponse() = default;
};
class DescribeHybridCloudGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<string> clusterProxyType{};
  shared_ptr<long> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudGroupsRequest() {}

  explicit DescribeHybridCloudGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (clusterProxyType) {
      res["ClusterProxyType"] = boost::any(*clusterProxyType);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("ClusterProxyType") != m.end() && !m["ClusterProxyType"].empty()) {
      clusterProxyType = make_shared<string>(boost::any_cast<string>(m["ClusterProxyType"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<long>(boost::any_cast<long>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudGroupsRequest() = default;
};
class DescribeHybridCloudGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> backSourceMark{};
  shared_ptr<long> continentsValue{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupType{};
  shared_ptr<string> loadBalanceIp{};
  shared_ptr<long> locationId{};
  shared_ptr<long> operatorValue{};
  shared_ptr<string> ports{};
  shared_ptr<long> regionCodeValue{};
  shared_ptr<string> remark{};

  DescribeHybridCloudGroupsResponseBodyGroups() {}

  explicit DescribeHybridCloudGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backSourceMark) {
      res["BackSourceMark"] = boost::any(*backSourceMark);
    }
    if (continentsValue) {
      res["ContinentsValue"] = boost::any(*continentsValue);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupType) {
      res["GroupType"] = boost::any(*groupType);
    }
    if (loadBalanceIp) {
      res["LoadBalanceIp"] = boost::any(*loadBalanceIp);
    }
    if (locationId) {
      res["LocationId"] = boost::any(*locationId);
    }
    if (operatorValue) {
      res["OperatorValue"] = boost::any(*operatorValue);
    }
    if (ports) {
      res["Ports"] = boost::any(*ports);
    }
    if (regionCodeValue) {
      res["RegionCodeValue"] = boost::any(*regionCodeValue);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackSourceMark") != m.end() && !m["BackSourceMark"].empty()) {
      backSourceMark = make_shared<string>(boost::any_cast<string>(m["BackSourceMark"]));
    }
    if (m.find("ContinentsValue") != m.end() && !m["ContinentsValue"].empty()) {
      continentsValue = make_shared<long>(boost::any_cast<long>(m["ContinentsValue"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupType") != m.end() && !m["GroupType"].empty()) {
      groupType = make_shared<string>(boost::any_cast<string>(m["GroupType"]));
    }
    if (m.find("LoadBalanceIp") != m.end() && !m["LoadBalanceIp"].empty()) {
      loadBalanceIp = make_shared<string>(boost::any_cast<string>(m["LoadBalanceIp"]));
    }
    if (m.find("LocationId") != m.end() && !m["LocationId"].empty()) {
      locationId = make_shared<long>(boost::any_cast<long>(m["LocationId"]));
    }
    if (m.find("OperatorValue") != m.end() && !m["OperatorValue"].empty()) {
      operatorValue = make_shared<long>(boost::any_cast<long>(m["OperatorValue"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      ports = make_shared<string>(boost::any_cast<string>(m["Ports"]));
    }
    if (m.find("RegionCodeValue") != m.end() && !m["RegionCodeValue"].empty()) {
      regionCodeValue = make_shared<long>(boost::any_cast<long>(m["RegionCodeValue"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~DescribeHybridCloudGroupsResponseBodyGroups() = default;
};
class DescribeHybridCloudGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridCloudGroupsResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHybridCloudGroupsResponseBody() {}

  explicit DescribeHybridCloudGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<DescribeHybridCloudGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<DescribeHybridCloudGroupsResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHybridCloudGroupsResponseBody() = default;
};
class DescribeHybridCloudGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudGroupsResponseBody> body{};

  DescribeHybridCloudGroupsResponse() {}

  explicit DescribeHybridCloudGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudGroupsResponse() = default;
};
class DescribeHybridCloudResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> backend{};
  shared_ptr<bool> cnameEnabled{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudResourcesRequest() {}

  explicit DescribeHybridCloudResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backend) {
      res["Backend"] = boost::any(*backend);
    }
    if (cnameEnabled) {
      res["CnameEnabled"] = boost::any(*cnameEnabled);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backend") != m.end() && !m["Backend"].empty()) {
      backend = make_shared<string>(boost::any_cast<string>(m["Backend"]));
    }
    if (m.find("CnameEnabled") != m.end() && !m["CnameEnabled"].empty()) {
      cnameEnabled = make_shared<bool>(boost::any_cast<bool>(m["CnameEnabled"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudResourcesRequest() = default;
};
class DescribeHybridCloudResourcesResponseBodyDomainsListen : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> exclusiveIp{};
  shared_ptr<bool> focusHttps{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<vector<long>> httpPorts{};
  shared_ptr<vector<long>> httpsPorts{};
  shared_ptr<bool> IPv6Enabled{};
  shared_ptr<string> protectionResource{};
  shared_ptr<string> TLSVersion{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};

  DescribeHybridCloudResourcesResponseBodyDomainsListen() {}

  explicit DescribeHybridCloudResourcesResponseBodyDomainsListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (exclusiveIp) {
      res["ExclusiveIp"] = boost::any(*exclusiveIp);
    }
    if (focusHttps) {
      res["FocusHttps"] = boost::any(*focusHttps);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (IPv6Enabled) {
      res["IPv6Enabled"] = boost::any(*IPv6Enabled);
    }
    if (protectionResource) {
      res["ProtectionResource"] = boost::any(*protectionResource);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("ExclusiveIp") != m.end() && !m["ExclusiveIp"].empty()) {
      exclusiveIp = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveIp"]));
    }
    if (m.find("FocusHttps") != m.end() && !m["FocusHttps"].empty()) {
      focusHttps = make_shared<bool>(boost::any_cast<bool>(m["FocusHttps"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpsPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpsPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpsPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IPv6Enabled") != m.end() && !m["IPv6Enabled"].empty()) {
      IPv6Enabled = make_shared<bool>(boost::any_cast<bool>(m["IPv6Enabled"]));
    }
    if (m.find("ProtectionResource") != m.end() && !m["ProtectionResource"].empty()) {
      protectionResource = make_shared<string>(boost::any_cast<string>(m["ProtectionResource"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeHybridCloudResourcesResponseBodyDomainsListen() = default;
};
class DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders() {}

  explicit DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders() = default;
};
class DescribeHybridCloudResourcesResponseBodyDomainsRedirect : public Darabonba::Model {
public:
  shared_ptr<vector<string>> backends{};
  shared_ptr<bool> cnameEnabled{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<bool> focusHttpBackend{};
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<string> loadbalance{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<bool> retry{};
  shared_ptr<string> routingRules{};
  shared_ptr<bool> sniEnabled{};
  shared_ptr<string> sniHost{};
  shared_ptr<long> writeTimeout{};

  DescribeHybridCloudResourcesResponseBodyDomainsRedirect() {}

  explicit DescribeHybridCloudResourcesResponseBodyDomainsRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backends) {
      res["Backends"] = boost::any(*backends);
    }
    if (cnameEnabled) {
      res["CnameEnabled"] = boost::any(*cnameEnabled);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (focusHttpBackend) {
      res["FocusHttpBackend"] = boost::any(*focusHttpBackend);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (loadbalance) {
      res["Loadbalance"] = boost::any(*loadbalance);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (routingRules) {
      res["RoutingRules"] = boost::any(*routingRules);
    }
    if (sniEnabled) {
      res["SniEnabled"] = boost::any(*sniEnabled);
    }
    if (sniHost) {
      res["SniHost"] = boost::any(*sniHost);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backends") != m.end() && !m["Backends"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Backends"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Backends"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backends = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CnameEnabled") != m.end() && !m["CnameEnabled"].empty()) {
      cnameEnabled = make_shared<bool>(boost::any_cast<bool>(m["CnameEnabled"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("FocusHttpBackend") != m.end() && !m["FocusHttpBackend"].empty()) {
      focusHttpBackend = make_shared<bool>(boost::any_cast<bool>(m["FocusHttpBackend"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("Loadbalance") != m.end() && !m["Loadbalance"].empty()) {
      loadbalance = make_shared<string>(boost::any_cast<string>(m["Loadbalance"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<DescribeHybridCloudResourcesResponseBodyDomainsRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["Retry"]));
    }
    if (m.find("RoutingRules") != m.end() && !m["RoutingRules"].empty()) {
      routingRules = make_shared<string>(boost::any_cast<string>(m["RoutingRules"]));
    }
    if (m.find("SniEnabled") != m.end() && !m["SniEnabled"].empty()) {
      sniEnabled = make_shared<bool>(boost::any_cast<bool>(m["SniEnabled"]));
    }
    if (m.find("SniHost") != m.end() && !m["SniHost"].empty()) {
      sniHost = make_shared<string>(boost::any_cast<string>(m["SniHost"]));
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
  }


  virtual ~DescribeHybridCloudResourcesResponseBodyDomainsRedirect() = default;
};
class DescribeHybridCloudResourcesResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<long> id{};
  shared_ptr<DescribeHybridCloudResourcesResponseBodyDomainsListen> listen{};
  shared_ptr<DescribeHybridCloudResourcesResponseBodyDomainsRedirect> redirect{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> status{};
  shared_ptr<string> uid{};

  DescribeHybridCloudResourcesResponseBodyDomains() {}

  explicit DescribeHybridCloudResourcesResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        DescribeHybridCloudResourcesResponseBodyDomainsListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<DescribeHybridCloudResourcesResponseBodyDomainsListen>(model1);
      }
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        DescribeHybridCloudResourcesResponseBodyDomainsRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<DescribeHybridCloudResourcesResponseBodyDomainsRedirect>(model1);
      }
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~DescribeHybridCloudResourcesResponseBodyDomains() = default;
};
class DescribeHybridCloudResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridCloudResourcesResponseBodyDomains>> domains{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHybridCloudResourcesResponseBody() {}

  explicit DescribeHybridCloudResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<DescribeHybridCloudResourcesResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudResourcesResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<DescribeHybridCloudResourcesResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHybridCloudResourcesResponseBody() = default;
};
class DescribeHybridCloudResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudResourcesResponseBody> body{};

  DescribeHybridCloudResourcesResponse() {}

  explicit DescribeHybridCloudResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudResourcesResponse() = default;
};
class DescribeHybridCloudServerRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> regionType{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudServerRegionsRequest() {}

  explicit DescribeHybridCloudServerRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionType) {
      res["RegionType"] = boost::any(*regionType);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionType") != m.end() && !m["RegionType"].empty()) {
      regionType = make_shared<string>(boost::any_cast<string>(m["RegionType"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudServerRegionsRequest() = default;
};
class DescribeHybridCloudServerRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<long> code{};
  shared_ptr<string> name{};

  DescribeHybridCloudServerRegionsResponseBodyRegions() {}

  explicit DescribeHybridCloudServerRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<long>(boost::any_cast<long>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeHybridCloudServerRegionsResponseBodyRegions() = default;
};
class DescribeHybridCloudServerRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHybridCloudServerRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  DescribeHybridCloudServerRegionsResponseBody() {}

  explicit DescribeHybridCloudServerRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeHybridCloudServerRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudServerRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeHybridCloudServerRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeHybridCloudServerRegionsResponseBody() = default;
};
class DescribeHybridCloudServerRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudServerRegionsResponseBody> body{};

  DescribeHybridCloudServerRegionsResponse() {}

  explicit DescribeHybridCloudServerRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudServerRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudServerRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudServerRegionsResponse() = default;
};
class DescribeHybridCloudUnassignedMachinesRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<string> hostName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudUnassignedMachinesRequest() {}

  explicit DescribeHybridCloudUnassignedMachinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudUnassignedMachinesRequest() = default;
};
class DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> customName{};
  shared_ptr<string> hostName{};
  shared_ptr<string> ip{};
  shared_ptr<string> mac{};
  shared_ptr<long> memory{};
  shared_ptr<string> mid{};

  DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines() {}

  explicit DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (customName) {
      res["CustomName"] = boost::any(*customName);
    }
    if (hostName) {
      res["HostName"] = boost::any(*hostName);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CustomName") != m.end() && !m["CustomName"].empty()) {
      customName = make_shared<string>(boost::any_cast<string>(m["CustomName"]));
    }
    if (m.find("HostName") != m.end() && !m["HostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["HostName"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
  }


  virtual ~DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines() = default;
};
class DescribeHybridCloudUnassignedMachinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines>> unassignedMachines{};

  DescribeHybridCloudUnassignedMachinesResponseBody() {}

  explicit DescribeHybridCloudUnassignedMachinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (unassignedMachines) {
      vector<boost::any> temp1;
      for(auto item1:*unassignedMachines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UnassignedMachines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UnassignedMachines") != m.end() && !m["UnassignedMachines"].empty()) {
      if (typeid(vector<boost::any>) == m["UnassignedMachines"].type()) {
        vector<DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UnassignedMachines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unassignedMachines = make_shared<vector<DescribeHybridCloudUnassignedMachinesResponseBodyUnassignedMachines>>(expect1);
      }
    }
  }


  virtual ~DescribeHybridCloudUnassignedMachinesResponseBody() = default;
};
class DescribeHybridCloudUnassignedMachinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudUnassignedMachinesResponseBody> body{};

  DescribeHybridCloudUnassignedMachinesResponse() {}

  explicit DescribeHybridCloudUnassignedMachinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudUnassignedMachinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudUnassignedMachinesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudUnassignedMachinesResponse() = default;
};
class DescribeHybridCloudUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeHybridCloudUserRequest() {}

  explicit DescribeHybridCloudUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeHybridCloudUserRequest() = default;
};
class DescribeHybridCloudUserResponseBodyUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> httpPorts{};
  shared_ptr<string> httpsPorts{};

  DescribeHybridCloudUserResponseBodyUserInfo() {}

  explicit DescribeHybridCloudUserResponseBodyUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      httpPorts = make_shared<string>(boost::any_cast<string>(m["HttpPorts"]));
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      httpsPorts = make_shared<string>(boost::any_cast<string>(m["HttpsPorts"]));
    }
  }


  virtual ~DescribeHybridCloudUserResponseBodyUserInfo() = default;
};
class DescribeHybridCloudUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeHybridCloudUserResponseBodyUserInfo> userInfo{};

  DescribeHybridCloudUserResponseBody() {}

  explicit DescribeHybridCloudUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        DescribeHybridCloudUserResponseBodyUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<DescribeHybridCloudUserResponseBodyUserInfo>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudUserResponseBody() = default;
};
class DescribeHybridCloudUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHybridCloudUserResponseBody> body{};

  DescribeHybridCloudUserResponse() {}

  explicit DescribeHybridCloudUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHybridCloudUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHybridCloudUserResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHybridCloudUserResponse() = default;
};
class DescribeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeInstanceRequest() {}

  explicit DescribeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeInstanceRequest() = default;
};
class DescribeInstanceResponseBodyDetails : public Darabonba::Model {
public:
  shared_ptr<long> aclRuleMaxIpCount{};
  shared_ptr<bool> antiScan{};
  shared_ptr<long> antiScanTemplateMaxCount{};
  shared_ptr<long> backendMaxCount{};
  shared_ptr<bool> baseWafGroup{};
  shared_ptr<long> baseWafGroupRuleInTemplateMaxCount{};
  shared_ptr<long> baseWafGroupRuleTemplateMaxCount{};
  shared_ptr<bool> bot{};
  shared_ptr<string> botApp{};
  shared_ptr<long> botTemplateMaxCount{};
  shared_ptr<string> botWeb{};
  shared_ptr<long> cnameResourceMaxCount{};
  shared_ptr<bool> customResponse{};
  shared_ptr<long> customResponseRuleInTemplateMaxCount{};
  shared_ptr<long> customResponseTemplateMaxCount{};
  shared_ptr<bool> customRule{};
  shared_ptr<string> customRuleAction{};
  shared_ptr<string> customRuleCondition{};
  shared_ptr<long> customRuleInTemplateMaxCount{};
  shared_ptr<string> customRuleRatelimitor{};
  shared_ptr<long> customRuleTemplateMaxCount{};
  shared_ptr<long> defenseGroupMaxCount{};
  shared_ptr<long> defenseObjectInGroupMaxCount{};
  shared_ptr<long> defenseObjectInTemplateMaxCount{};
  shared_ptr<long> defenseObjectMaxCount{};
  shared_ptr<bool> dlp{};
  shared_ptr<long> dlpRuleInTemplateMaxCount{};
  shared_ptr<long> dlpTemplateMaxCount{};
  shared_ptr<bool> exclusiveIp{};
  shared_ptr<bool> gslb{};
  shared_ptr<string> httpPorts{};
  shared_ptr<string> httpsPorts{};
  shared_ptr<bool> ipBlacklist{};
  shared_ptr<long> ipBlacklistIpInRuleMaxCount{};
  shared_ptr<long> ipBlacklistRuleInTemplateMaxCount{};
  shared_ptr<long> ipBlacklistTemplateMaxCount{};
  shared_ptr<bool> ipv6{};
  shared_ptr<bool> logService{};
  shared_ptr<bool> majorProtection{};
  shared_ptr<long> majorProtectionTemplateMaxCount{};
  shared_ptr<bool> tamperproof{};
  shared_ptr<long> tamperproofRuleInTemplateMaxCount{};
  shared_ptr<long> tamperproofTemplateMaxCount{};
  shared_ptr<long> vastIpBlacklistInFileMaxCount{};
  shared_ptr<long> vastIpBlacklistInOperationMaxCount{};
  shared_ptr<long> vastIpBlacklistMaxCount{};
  shared_ptr<bool> whitelist{};
  shared_ptr<string> whitelistLogical{};
  shared_ptr<string> whitelistRuleCondition{};
  shared_ptr<long> whitelistRuleInTemplateMaxCount{};
  shared_ptr<long> whitelistTemplateMaxCount{};

  DescribeInstanceResponseBodyDetails() {}

  explicit DescribeInstanceResponseBodyDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclRuleMaxIpCount) {
      res["AclRuleMaxIpCount"] = boost::any(*aclRuleMaxIpCount);
    }
    if (antiScan) {
      res["AntiScan"] = boost::any(*antiScan);
    }
    if (antiScanTemplateMaxCount) {
      res["AntiScanTemplateMaxCount"] = boost::any(*antiScanTemplateMaxCount);
    }
    if (backendMaxCount) {
      res["BackendMaxCount"] = boost::any(*backendMaxCount);
    }
    if (baseWafGroup) {
      res["BaseWafGroup"] = boost::any(*baseWafGroup);
    }
    if (baseWafGroupRuleInTemplateMaxCount) {
      res["BaseWafGroupRuleInTemplateMaxCount"] = boost::any(*baseWafGroupRuleInTemplateMaxCount);
    }
    if (baseWafGroupRuleTemplateMaxCount) {
      res["BaseWafGroupRuleTemplateMaxCount"] = boost::any(*baseWafGroupRuleTemplateMaxCount);
    }
    if (bot) {
      res["Bot"] = boost::any(*bot);
    }
    if (botApp) {
      res["BotApp"] = boost::any(*botApp);
    }
    if (botTemplateMaxCount) {
      res["BotTemplateMaxCount"] = boost::any(*botTemplateMaxCount);
    }
    if (botWeb) {
      res["BotWeb"] = boost::any(*botWeb);
    }
    if (cnameResourceMaxCount) {
      res["CnameResourceMaxCount"] = boost::any(*cnameResourceMaxCount);
    }
    if (customResponse) {
      res["CustomResponse"] = boost::any(*customResponse);
    }
    if (customResponseRuleInTemplateMaxCount) {
      res["CustomResponseRuleInTemplateMaxCount"] = boost::any(*customResponseRuleInTemplateMaxCount);
    }
    if (customResponseTemplateMaxCount) {
      res["CustomResponseTemplateMaxCount"] = boost::any(*customResponseTemplateMaxCount);
    }
    if (customRule) {
      res["CustomRule"] = boost::any(*customRule);
    }
    if (customRuleAction) {
      res["CustomRuleAction"] = boost::any(*customRuleAction);
    }
    if (customRuleCondition) {
      res["CustomRuleCondition"] = boost::any(*customRuleCondition);
    }
    if (customRuleInTemplateMaxCount) {
      res["CustomRuleInTemplateMaxCount"] = boost::any(*customRuleInTemplateMaxCount);
    }
    if (customRuleRatelimitor) {
      res["CustomRuleRatelimitor"] = boost::any(*customRuleRatelimitor);
    }
    if (customRuleTemplateMaxCount) {
      res["CustomRuleTemplateMaxCount"] = boost::any(*customRuleTemplateMaxCount);
    }
    if (defenseGroupMaxCount) {
      res["DefenseGroupMaxCount"] = boost::any(*defenseGroupMaxCount);
    }
    if (defenseObjectInGroupMaxCount) {
      res["DefenseObjectInGroupMaxCount"] = boost::any(*defenseObjectInGroupMaxCount);
    }
    if (defenseObjectInTemplateMaxCount) {
      res["DefenseObjectInTemplateMaxCount"] = boost::any(*defenseObjectInTemplateMaxCount);
    }
    if (defenseObjectMaxCount) {
      res["DefenseObjectMaxCount"] = boost::any(*defenseObjectMaxCount);
    }
    if (dlp) {
      res["Dlp"] = boost::any(*dlp);
    }
    if (dlpRuleInTemplateMaxCount) {
      res["DlpRuleInTemplateMaxCount"] = boost::any(*dlpRuleInTemplateMaxCount);
    }
    if (dlpTemplateMaxCount) {
      res["DlpTemplateMaxCount"] = boost::any(*dlpTemplateMaxCount);
    }
    if (exclusiveIp) {
      res["ExclusiveIp"] = boost::any(*exclusiveIp);
    }
    if (gslb) {
      res["Gslb"] = boost::any(*gslb);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (ipBlacklist) {
      res["IpBlacklist"] = boost::any(*ipBlacklist);
    }
    if (ipBlacklistIpInRuleMaxCount) {
      res["IpBlacklistIpInRuleMaxCount"] = boost::any(*ipBlacklistIpInRuleMaxCount);
    }
    if (ipBlacklistRuleInTemplateMaxCount) {
      res["IpBlacklistRuleInTemplateMaxCount"] = boost::any(*ipBlacklistRuleInTemplateMaxCount);
    }
    if (ipBlacklistTemplateMaxCount) {
      res["IpBlacklistTemplateMaxCount"] = boost::any(*ipBlacklistTemplateMaxCount);
    }
    if (ipv6) {
      res["Ipv6"] = boost::any(*ipv6);
    }
    if (logService) {
      res["LogService"] = boost::any(*logService);
    }
    if (majorProtection) {
      res["MajorProtection"] = boost::any(*majorProtection);
    }
    if (majorProtectionTemplateMaxCount) {
      res["MajorProtectionTemplateMaxCount"] = boost::any(*majorProtectionTemplateMaxCount);
    }
    if (tamperproof) {
      res["Tamperproof"] = boost::any(*tamperproof);
    }
    if (tamperproofRuleInTemplateMaxCount) {
      res["TamperproofRuleInTemplateMaxCount"] = boost::any(*tamperproofRuleInTemplateMaxCount);
    }
    if (tamperproofTemplateMaxCount) {
      res["TamperproofTemplateMaxCount"] = boost::any(*tamperproofTemplateMaxCount);
    }
    if (vastIpBlacklistInFileMaxCount) {
      res["VastIpBlacklistInFileMaxCount"] = boost::any(*vastIpBlacklistInFileMaxCount);
    }
    if (vastIpBlacklistInOperationMaxCount) {
      res["VastIpBlacklistInOperationMaxCount"] = boost::any(*vastIpBlacklistInOperationMaxCount);
    }
    if (vastIpBlacklistMaxCount) {
      res["VastIpBlacklistMaxCount"] = boost::any(*vastIpBlacklistMaxCount);
    }
    if (whitelist) {
      res["Whitelist"] = boost::any(*whitelist);
    }
    if (whitelistLogical) {
      res["WhitelistLogical"] = boost::any(*whitelistLogical);
    }
    if (whitelistRuleCondition) {
      res["WhitelistRuleCondition"] = boost::any(*whitelistRuleCondition);
    }
    if (whitelistRuleInTemplateMaxCount) {
      res["WhitelistRuleInTemplateMaxCount"] = boost::any(*whitelistRuleInTemplateMaxCount);
    }
    if (whitelistTemplateMaxCount) {
      res["WhitelistTemplateMaxCount"] = boost::any(*whitelistTemplateMaxCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclRuleMaxIpCount") != m.end() && !m["AclRuleMaxIpCount"].empty()) {
      aclRuleMaxIpCount = make_shared<long>(boost::any_cast<long>(m["AclRuleMaxIpCount"]));
    }
    if (m.find("AntiScan") != m.end() && !m["AntiScan"].empty()) {
      antiScan = make_shared<bool>(boost::any_cast<bool>(m["AntiScan"]));
    }
    if (m.find("AntiScanTemplateMaxCount") != m.end() && !m["AntiScanTemplateMaxCount"].empty()) {
      antiScanTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["AntiScanTemplateMaxCount"]));
    }
    if (m.find("BackendMaxCount") != m.end() && !m["BackendMaxCount"].empty()) {
      backendMaxCount = make_shared<long>(boost::any_cast<long>(m["BackendMaxCount"]));
    }
    if (m.find("BaseWafGroup") != m.end() && !m["BaseWafGroup"].empty()) {
      baseWafGroup = make_shared<bool>(boost::any_cast<bool>(m["BaseWafGroup"]));
    }
    if (m.find("BaseWafGroupRuleInTemplateMaxCount") != m.end() && !m["BaseWafGroupRuleInTemplateMaxCount"].empty()) {
      baseWafGroupRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["BaseWafGroupRuleInTemplateMaxCount"]));
    }
    if (m.find("BaseWafGroupRuleTemplateMaxCount") != m.end() && !m["BaseWafGroupRuleTemplateMaxCount"].empty()) {
      baseWafGroupRuleTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["BaseWafGroupRuleTemplateMaxCount"]));
    }
    if (m.find("Bot") != m.end() && !m["Bot"].empty()) {
      bot = make_shared<bool>(boost::any_cast<bool>(m["Bot"]));
    }
    if (m.find("BotApp") != m.end() && !m["BotApp"].empty()) {
      botApp = make_shared<string>(boost::any_cast<string>(m["BotApp"]));
    }
    if (m.find("BotTemplateMaxCount") != m.end() && !m["BotTemplateMaxCount"].empty()) {
      botTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["BotTemplateMaxCount"]));
    }
    if (m.find("BotWeb") != m.end() && !m["BotWeb"].empty()) {
      botWeb = make_shared<string>(boost::any_cast<string>(m["BotWeb"]));
    }
    if (m.find("CnameResourceMaxCount") != m.end() && !m["CnameResourceMaxCount"].empty()) {
      cnameResourceMaxCount = make_shared<long>(boost::any_cast<long>(m["CnameResourceMaxCount"]));
    }
    if (m.find("CustomResponse") != m.end() && !m["CustomResponse"].empty()) {
      customResponse = make_shared<bool>(boost::any_cast<bool>(m["CustomResponse"]));
    }
    if (m.find("CustomResponseRuleInTemplateMaxCount") != m.end() && !m["CustomResponseRuleInTemplateMaxCount"].empty()) {
      customResponseRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["CustomResponseRuleInTemplateMaxCount"]));
    }
    if (m.find("CustomResponseTemplateMaxCount") != m.end() && !m["CustomResponseTemplateMaxCount"].empty()) {
      customResponseTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["CustomResponseTemplateMaxCount"]));
    }
    if (m.find("CustomRule") != m.end() && !m["CustomRule"].empty()) {
      customRule = make_shared<bool>(boost::any_cast<bool>(m["CustomRule"]));
    }
    if (m.find("CustomRuleAction") != m.end() && !m["CustomRuleAction"].empty()) {
      customRuleAction = make_shared<string>(boost::any_cast<string>(m["CustomRuleAction"]));
    }
    if (m.find("CustomRuleCondition") != m.end() && !m["CustomRuleCondition"].empty()) {
      customRuleCondition = make_shared<string>(boost::any_cast<string>(m["CustomRuleCondition"]));
    }
    if (m.find("CustomRuleInTemplateMaxCount") != m.end() && !m["CustomRuleInTemplateMaxCount"].empty()) {
      customRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["CustomRuleInTemplateMaxCount"]));
    }
    if (m.find("CustomRuleRatelimitor") != m.end() && !m["CustomRuleRatelimitor"].empty()) {
      customRuleRatelimitor = make_shared<string>(boost::any_cast<string>(m["CustomRuleRatelimitor"]));
    }
    if (m.find("CustomRuleTemplateMaxCount") != m.end() && !m["CustomRuleTemplateMaxCount"].empty()) {
      customRuleTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["CustomRuleTemplateMaxCount"]));
    }
    if (m.find("DefenseGroupMaxCount") != m.end() && !m["DefenseGroupMaxCount"].empty()) {
      defenseGroupMaxCount = make_shared<long>(boost::any_cast<long>(m["DefenseGroupMaxCount"]));
    }
    if (m.find("DefenseObjectInGroupMaxCount") != m.end() && !m["DefenseObjectInGroupMaxCount"].empty()) {
      defenseObjectInGroupMaxCount = make_shared<long>(boost::any_cast<long>(m["DefenseObjectInGroupMaxCount"]));
    }
    if (m.find("DefenseObjectInTemplateMaxCount") != m.end() && !m["DefenseObjectInTemplateMaxCount"].empty()) {
      defenseObjectInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["DefenseObjectInTemplateMaxCount"]));
    }
    if (m.find("DefenseObjectMaxCount") != m.end() && !m["DefenseObjectMaxCount"].empty()) {
      defenseObjectMaxCount = make_shared<long>(boost::any_cast<long>(m["DefenseObjectMaxCount"]));
    }
    if (m.find("Dlp") != m.end() && !m["Dlp"].empty()) {
      dlp = make_shared<bool>(boost::any_cast<bool>(m["Dlp"]));
    }
    if (m.find("DlpRuleInTemplateMaxCount") != m.end() && !m["DlpRuleInTemplateMaxCount"].empty()) {
      dlpRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["DlpRuleInTemplateMaxCount"]));
    }
    if (m.find("DlpTemplateMaxCount") != m.end() && !m["DlpTemplateMaxCount"].empty()) {
      dlpTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["DlpTemplateMaxCount"]));
    }
    if (m.find("ExclusiveIp") != m.end() && !m["ExclusiveIp"].empty()) {
      exclusiveIp = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveIp"]));
    }
    if (m.find("Gslb") != m.end() && !m["Gslb"].empty()) {
      gslb = make_shared<bool>(boost::any_cast<bool>(m["Gslb"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      httpPorts = make_shared<string>(boost::any_cast<string>(m["HttpPorts"]));
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      httpsPorts = make_shared<string>(boost::any_cast<string>(m["HttpsPorts"]));
    }
    if (m.find("IpBlacklist") != m.end() && !m["IpBlacklist"].empty()) {
      ipBlacklist = make_shared<bool>(boost::any_cast<bool>(m["IpBlacklist"]));
    }
    if (m.find("IpBlacklistIpInRuleMaxCount") != m.end() && !m["IpBlacklistIpInRuleMaxCount"].empty()) {
      ipBlacklistIpInRuleMaxCount = make_shared<long>(boost::any_cast<long>(m["IpBlacklistIpInRuleMaxCount"]));
    }
    if (m.find("IpBlacklistRuleInTemplateMaxCount") != m.end() && !m["IpBlacklistRuleInTemplateMaxCount"].empty()) {
      ipBlacklistRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["IpBlacklistRuleInTemplateMaxCount"]));
    }
    if (m.find("IpBlacklistTemplateMaxCount") != m.end() && !m["IpBlacklistTemplateMaxCount"].empty()) {
      ipBlacklistTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["IpBlacklistTemplateMaxCount"]));
    }
    if (m.find("Ipv6") != m.end() && !m["Ipv6"].empty()) {
      ipv6 = make_shared<bool>(boost::any_cast<bool>(m["Ipv6"]));
    }
    if (m.find("LogService") != m.end() && !m["LogService"].empty()) {
      logService = make_shared<bool>(boost::any_cast<bool>(m["LogService"]));
    }
    if (m.find("MajorProtection") != m.end() && !m["MajorProtection"].empty()) {
      majorProtection = make_shared<bool>(boost::any_cast<bool>(m["MajorProtection"]));
    }
    if (m.find("MajorProtectionTemplateMaxCount") != m.end() && !m["MajorProtectionTemplateMaxCount"].empty()) {
      majorProtectionTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["MajorProtectionTemplateMaxCount"]));
    }
    if (m.find("Tamperproof") != m.end() && !m["Tamperproof"].empty()) {
      tamperproof = make_shared<bool>(boost::any_cast<bool>(m["Tamperproof"]));
    }
    if (m.find("TamperproofRuleInTemplateMaxCount") != m.end() && !m["TamperproofRuleInTemplateMaxCount"].empty()) {
      tamperproofRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["TamperproofRuleInTemplateMaxCount"]));
    }
    if (m.find("TamperproofTemplateMaxCount") != m.end() && !m["TamperproofTemplateMaxCount"].empty()) {
      tamperproofTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["TamperproofTemplateMaxCount"]));
    }
    if (m.find("VastIpBlacklistInFileMaxCount") != m.end() && !m["VastIpBlacklistInFileMaxCount"].empty()) {
      vastIpBlacklistInFileMaxCount = make_shared<long>(boost::any_cast<long>(m["VastIpBlacklistInFileMaxCount"]));
    }
    if (m.find("VastIpBlacklistInOperationMaxCount") != m.end() && !m["VastIpBlacklistInOperationMaxCount"].empty()) {
      vastIpBlacklistInOperationMaxCount = make_shared<long>(boost::any_cast<long>(m["VastIpBlacklistInOperationMaxCount"]));
    }
    if (m.find("VastIpBlacklistMaxCount") != m.end() && !m["VastIpBlacklistMaxCount"].empty()) {
      vastIpBlacklistMaxCount = make_shared<long>(boost::any_cast<long>(m["VastIpBlacklistMaxCount"]));
    }
    if (m.find("Whitelist") != m.end() && !m["Whitelist"].empty()) {
      whitelist = make_shared<bool>(boost::any_cast<bool>(m["Whitelist"]));
    }
    if (m.find("WhitelistLogical") != m.end() && !m["WhitelistLogical"].empty()) {
      whitelistLogical = make_shared<string>(boost::any_cast<string>(m["WhitelistLogical"]));
    }
    if (m.find("WhitelistRuleCondition") != m.end() && !m["WhitelistRuleCondition"].empty()) {
      whitelistRuleCondition = make_shared<string>(boost::any_cast<string>(m["WhitelistRuleCondition"]));
    }
    if (m.find("WhitelistRuleInTemplateMaxCount") != m.end() && !m["WhitelistRuleInTemplateMaxCount"].empty()) {
      whitelistRuleInTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["WhitelistRuleInTemplateMaxCount"]));
    }
    if (m.find("WhitelistTemplateMaxCount") != m.end() && !m["WhitelistTemplateMaxCount"].empty()) {
      whitelistTemplateMaxCount = make_shared<long>(boost::any_cast<long>(m["WhitelistTemplateMaxCount"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyDetails() = default;
};
class DescribeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceResponseBodyDetails> details{};
  shared_ptr<string> edition{};
  shared_ptr<long> endTime{};
  shared_ptr<string> inDebt{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> payType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> status{};

  DescribeInstanceResponseBody() {}

  explicit DescribeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (details) {
      res["Details"] = details ? boost::any(details->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (inDebt) {
      res["InDebt"] = boost::any(*inDebt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(map<string, boost::any>) == m["Details"].type()) {
        DescribeInstanceResponseBodyDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Details"]));
        details = make_shared<DescribeInstanceResponseBodyDetails>(model1);
      }
    }
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InDebt") != m.end() && !m["InDebt"].empty()) {
      inDebt = make_shared<string>(boost::any_cast<string>(m["InDebt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~DescribeInstanceResponseBody() = default;
};
class DescribeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceResponseBody> body{};

  DescribeInstanceResponse() {}

  explicit DescribeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceResponse() = default;
};
class DescribeIpAbroadCountryInfosRequest : public Darabonba::Model {
public:
  shared_ptr<string> abroadRegion{};
  shared_ptr<string> country{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> language{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeIpAbroadCountryInfosRequest() {}

  explicit DescribeIpAbroadCountryInfosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abroadRegion) {
      res["AbroadRegion"] = boost::any(*abroadRegion);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbroadRegion") != m.end() && !m["AbroadRegion"].empty()) {
      abroadRegion = make_shared<string>(boost::any_cast<string>(m["AbroadRegion"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeIpAbroadCountryInfosRequest() = default;
};
class DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions : public Darabonba::Model {
public:
  shared_ptr<string> abroadRegionId{};
  shared_ptr<string> abroadRegionName{};

  DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions() {}

  explicit DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abroadRegionId) {
      res["AbroadRegionId"] = boost::any(*abroadRegionId);
    }
    if (abroadRegionName) {
      res["AbroadRegionName"] = boost::any(*abroadRegionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbroadRegionId") != m.end() && !m["AbroadRegionId"].empty()) {
      abroadRegionId = make_shared<string>(boost::any_cast<string>(m["AbroadRegionId"]));
    }
    if (m.find("AbroadRegionName") != m.end() && !m["AbroadRegionName"].empty()) {
      abroadRegionName = make_shared<string>(boost::any_cast<string>(m["AbroadRegionName"]));
    }
  }


  virtual ~DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions() = default;
};
class DescribeIpAbroadCountryInfosResponseBodyAbroadInfos : public Darabonba::Model {
public:
  shared_ptr<string> continent{};
  shared_ptr<string> country{};
  shared_ptr<string> countryName{};
  shared_ptr<vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions>> regions{};

  DescribeIpAbroadCountryInfosResponseBodyAbroadInfos() {}

  explicit DescribeIpAbroadCountryInfosResponseBodyAbroadInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (continent) {
      res["Continent"] = boost::any(*continent);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Continent") != m.end() && !m["Continent"].empty()) {
      continent = make_shared<string>(boost::any_cast<string>(m["Continent"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfosRegions>>(expect1);
      }
    }
  }


  virtual ~DescribeIpAbroadCountryInfosResponseBodyAbroadInfos() = default;
};
class DescribeIpAbroadCountryInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfos>> abroadInfos{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpAbroadCountryInfosResponseBody() {}

  explicit DescribeIpAbroadCountryInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abroadInfos) {
      vector<boost::any> temp1;
      for(auto item1:*abroadInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AbroadInfos"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbroadInfos") != m.end() && !m["AbroadInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AbroadInfos"].type()) {
        vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AbroadInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpAbroadCountryInfosResponseBodyAbroadInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abroadInfos = make_shared<vector<DescribeIpAbroadCountryInfosResponseBodyAbroadInfos>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpAbroadCountryInfosResponseBody() = default;
};
class DescribeIpAbroadCountryInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpAbroadCountryInfosResponseBody> body{};

  DescribeIpAbroadCountryInfosResponse() {}

  explicit DescribeIpAbroadCountryInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpAbroadCountryInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpAbroadCountryInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpAbroadCountryInfosResponse() = default;
};
class DescribeMajorProtectionBlackIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipLike{};
  shared_ptr<string> orderBy{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  DescribeMajorProtectionBlackIpsRequest() {}

  explicit DescribeMajorProtectionBlackIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipLike) {
      res["IpLike"] = boost::any(*ipLike);
    }
    if (orderBy) {
      res["OrderBy"] = boost::any(*orderBy);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpLike") != m.end() && !m["IpLike"].empty()) {
      ipLike = make_shared<string>(boost::any_cast<string>(m["IpLike"]));
    }
    if (m.find("OrderBy") != m.end() && !m["OrderBy"].empty()) {
      orderBy = make_shared<string>(boost::any_cast<string>(m["OrderBy"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMajorProtectionBlackIpsRequest() = default;
};
class DescribeMajorProtectionBlackIpsResponseBodyIpList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> expiredTime{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> ip{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  DescribeMajorProtectionBlackIpsResponseBodyIpList() {}

  explicit DescribeMajorProtectionBlackIpsResponseBodyIpList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeMajorProtectionBlackIpsResponseBodyIpList() = default;
};
class DescribeMajorProtectionBlackIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMajorProtectionBlackIpsResponseBodyIpList>> ipList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeMajorProtectionBlackIpsResponseBody() {}

  explicit DescribeMajorProtectionBlackIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipList) {
      vector<boost::any> temp1;
      for(auto item1:*ipList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      if (typeid(vector<boost::any>) == m["IpList"].type()) {
        vector<DescribeMajorProtectionBlackIpsResponseBodyIpList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMajorProtectionBlackIpsResponseBodyIpList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipList = make_shared<vector<DescribeMajorProtectionBlackIpsResponseBodyIpList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeMajorProtectionBlackIpsResponseBody() = default;
};
class DescribeMajorProtectionBlackIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMajorProtectionBlackIpsResponseBody> body{};

  DescribeMajorProtectionBlackIpsResponse() {}

  explicit DescribeMajorProtectionBlackIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMajorProtectionBlackIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMajorProtectionBlackIpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMajorProtectionBlackIpsResponse() = default;
};
class DescribeMemberAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accountStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sourceIp{};

  DescribeMemberAccountsRequest() {}

  explicit DescribeMemberAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~DescribeMemberAccountsRequest() = default;
};
class DescribeMemberAccountsResponseBodyAccountInfos : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> accountName{};
  shared_ptr<string> accountStatus{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};

  DescribeMemberAccountsResponseBodyAccountInfos() {}

  explicit DescribeMemberAccountsResponseBodyAccountInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
  }


  virtual ~DescribeMemberAccountsResponseBodyAccountInfos() = default;
};
class DescribeMemberAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeMemberAccountsResponseBodyAccountInfos>> accountInfos{};
  shared_ptr<string> requestId{};

  DescribeMemberAccountsResponseBody() {}

  explicit DescribeMemberAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountInfos) {
      vector<boost::any> temp1;
      for(auto item1:*accountInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountInfos"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountInfos") != m.end() && !m["AccountInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountInfos"].type()) {
        vector<DescribeMemberAccountsResponseBodyAccountInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMemberAccountsResponseBodyAccountInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountInfos = make_shared<vector<DescribeMemberAccountsResponseBodyAccountInfos>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMemberAccountsResponseBody() = default;
};
class DescribeMemberAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMemberAccountsResponseBody> body{};

  DescribeMemberAccountsResponse() {}

  explicit DescribeMemberAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMemberAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMemberAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMemberAccountsResponse() = default;
};
class DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opValue{};
  shared_ptr<boost::any> values{};

  DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions() {}

  explicit DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opValue) {
      res["OpValue"] = boost::any(*opValue);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpValue") != m.end() && !m["OpValue"].empty()) {
      opValue = make_shared<string>(boost::any_cast<string>(m["OpValue"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<boost::any>(boost::any_cast<boost::any>(m["Values"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions() = default;
};
class DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange() {}

  explicit DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange() = default;
};
class DescribeNetworkFlowTimeSeriesMetricRequestFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions>> conditions{};
  shared_ptr<DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange> dateRange{};

  DescribeNetworkFlowTimeSeriesMetricRequestFilter() {}

  explicit DescribeNetworkFlowTimeSeriesMetricRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeNetworkFlowTimeSeriesMetricRequestFilterConditions>>(expect1);
      }
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeNetworkFlowTimeSeriesMetricRequestFilterDateRange>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricRequestFilter() = default;
};
class DescribeNetworkFlowTimeSeriesMetricRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkFlowTimeSeriesMetricRequestFilter> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeNetworkFlowTimeSeriesMetricRequest() {}

  explicit DescribeNetworkFlowTimeSeriesMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeNetworkFlowTimeSeriesMetricRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeNetworkFlowTimeSeriesMetricRequestFilter>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricRequest() = default;
};
class DescribeNetworkFlowTimeSeriesMetricShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeNetworkFlowTimeSeriesMetricShrinkRequest() {}

  explicit DescribeNetworkFlowTimeSeriesMetricShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricShrinkRequest() = default;
};
class DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<vector<string>> timestamps{};
  shared_ptr<vector<long>> values{};

  DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries() {}

  explicit DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (timestamps) {
      res["Timestamps"] = boost::any(*timestamps);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Timestamps") != m.end() && !m["Timestamps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Timestamps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Timestamps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timestamps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      values = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries() = default;
};
class DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange() {}

  explicit DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange() = default;
};
class DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData : public Darabonba::Model {
public:
  shared_ptr<string> aggregateInterval{};
  shared_ptr<DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange> dateRange{};
  shared_ptr<string> units{};

  DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData() {}

  explicit DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateInterval) {
      res["AggregateInterval"] = boost::any(*aggregateInterval);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (units) {
      res["Units"] = boost::any(*units);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateInterval") != m.end() && !m["AggregateInterval"].empty()) {
      aggregateInterval = make_shared<string>(boost::any_cast<string>(m["AggregateInterval"]));
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange>(model1);
      }
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      units = make_shared<string>(boost::any_cast<string>(m["Units"]));
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData() = default;
};
class DescribeNetworkFlowTimeSeriesMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries>> networkFlowTimeSeries{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData> timeSeriesMetaData{};

  DescribeNetworkFlowTimeSeriesMetricResponseBody() {}

  explicit DescribeNetworkFlowTimeSeriesMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkFlowTimeSeries) {
      vector<boost::any> temp1;
      for(auto item1:*networkFlowTimeSeries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkFlowTimeSeries"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeSeriesMetaData) {
      res["TimeSeriesMetaData"] = timeSeriesMetaData ? boost::any(timeSeriesMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkFlowTimeSeries") != m.end() && !m["NetworkFlowTimeSeries"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkFlowTimeSeries"].type()) {
        vector<DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkFlowTimeSeries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkFlowTimeSeries = make_shared<vector<DescribeNetworkFlowTimeSeriesMetricResponseBodyNetworkFlowTimeSeries>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeSeriesMetaData") != m.end() && !m["TimeSeriesMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSeriesMetaData"].type()) {
        DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSeriesMetaData"]));
        timeSeriesMetaData = make_shared<DescribeNetworkFlowTimeSeriesMetricResponseBodyTimeSeriesMetaData>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricResponseBody() = default;
};
class DescribeNetworkFlowTimeSeriesMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkFlowTimeSeriesMetricResponseBody> body{};

  DescribeNetworkFlowTimeSeriesMetricResponse() {}

  explicit DescribeNetworkFlowTimeSeriesMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkFlowTimeSeriesMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkFlowTimeSeriesMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTimeSeriesMetricResponse() = default;
};
class DescribeNetworkFlowTopNMetricRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opValue{};
  shared_ptr<boost::any> values{};

  DescribeNetworkFlowTopNMetricRequestFilterConditions() {}

  explicit DescribeNetworkFlowTopNMetricRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opValue) {
      res["OpValue"] = boost::any(*opValue);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpValue") != m.end() && !m["OpValue"].empty()) {
      opValue = make_shared<string>(boost::any_cast<string>(m["OpValue"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<boost::any>(boost::any_cast<boost::any>(m["Values"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricRequestFilterConditions() = default;
};
class DescribeNetworkFlowTopNMetricRequestFilterDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeNetworkFlowTopNMetricRequestFilterDateRange() {}

  explicit DescribeNetworkFlowTopNMetricRequestFilterDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricRequestFilterDateRange() = default;
};
class DescribeNetworkFlowTopNMetricRequestFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkFlowTopNMetricRequestFilterConditions>> conditions{};
  shared_ptr<DescribeNetworkFlowTopNMetricRequestFilterDateRange> dateRange{};

  DescribeNetworkFlowTopNMetricRequestFilter() {}

  explicit DescribeNetworkFlowTopNMetricRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeNetworkFlowTopNMetricRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkFlowTopNMetricRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeNetworkFlowTopNMetricRequestFilterConditions>>(expect1);
      }
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeNetworkFlowTopNMetricRequestFilterDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeNetworkFlowTopNMetricRequestFilterDateRange>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricRequestFilter() = default;
};
class DescribeNetworkFlowTopNMetricRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkFlowTopNMetricRequestFilter> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> limit{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeNetworkFlowTopNMetricRequest() {}

  explicit DescribeNetworkFlowTopNMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeNetworkFlowTopNMetricRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeNetworkFlowTopNMetricRequestFilter>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricRequest() = default;
};
class DescribeNetworkFlowTopNMetricShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> limit{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeNetworkFlowTopNMetricShrinkRequest() {}

  explicit DescribeNetworkFlowTopNMetricShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricShrinkRequest() = default;
};
class DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues : public Darabonba::Model {
public:
  shared_ptr<string> attribute{};
  shared_ptr<string> name{};
  shared_ptr<long> value{};

  DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues() {}

  explicit DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues() = default;
};
class DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange() {}

  explicit DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange() = default;
};
class DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData : public Darabonba::Model {
public:
  shared_ptr<DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange> dateRange{};
  shared_ptr<string> units{};

  DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData() {}

  explicit DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (units) {
      res["Units"] = boost::any(*units);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeNetworkFlowTopNMetricResponseBodyTopNMetaDataDateRange>(model1);
      }
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      units = make_shared<string>(boost::any_cast<string>(m["Units"]));
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData() = default;
};
class DescribeNetworkFlowTopNMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues>> networkFlowTopNValues{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData> topNMetaData{};

  DescribeNetworkFlowTopNMetricResponseBody() {}

  explicit DescribeNetworkFlowTopNMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkFlowTopNValues) {
      vector<boost::any> temp1;
      for(auto item1:*networkFlowTopNValues){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkFlowTopNValues"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topNMetaData) {
      res["TopNMetaData"] = topNMetaData ? boost::any(topNMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkFlowTopNValues") != m.end() && !m["NetworkFlowTopNValues"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkFlowTopNValues"].type()) {
        vector<DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkFlowTopNValues"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkFlowTopNValues = make_shared<vector<DescribeNetworkFlowTopNMetricResponseBodyNetworkFlowTopNValues>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TopNMetaData") != m.end() && !m["TopNMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopNMetaData"].type()) {
        DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopNMetaData"]));
        topNMetaData = make_shared<DescribeNetworkFlowTopNMetricResponseBodyTopNMetaData>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricResponseBody() = default;
};
class DescribeNetworkFlowTopNMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetworkFlowTopNMetricResponseBody> body{};

  DescribeNetworkFlowTopNMetricResponse() {}

  explicit DescribeNetworkFlowTopNMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetworkFlowTopNMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetworkFlowTopNMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetworkFlowTopNMetricResponse() = default;
};
class DescribePauseProtectionStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribePauseProtectionStatusRequest() {}

  explicit DescribePauseProtectionStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribePauseProtectionStatusRequest() = default;
};
class DescribePauseProtectionStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pauseStatus{};
  shared_ptr<string> requestId{};

  DescribePauseProtectionStatusResponseBody() {}

  explicit DescribePauseProtectionStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pauseStatus) {
      res["PauseStatus"] = boost::any(*pauseStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PauseStatus") != m.end() && !m["PauseStatus"].empty()) {
      pauseStatus = make_shared<long>(boost::any_cast<long>(m["PauseStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePauseProtectionStatusResponseBody() = default;
};
class DescribePauseProtectionStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePauseProtectionStatusResponseBody> body{};

  DescribePauseProtectionStatusResponse() {}

  explicit DescribePauseProtectionStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePauseProtectionStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePauseProtectionStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePauseProtectionStatusResponse() = default;
};
class DescribePeakTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribePeakTrendRequest() {}

  explicit DescribePeakTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribePeakTrendRequest() = default;
};
class DescribePeakTrendResponseBodyFlowChart : public Darabonba::Model {
public:
  shared_ptr<long> aclSum{};
  shared_ptr<long> antiScanSum{};
  shared_ptr<long> ccSum{};
  shared_ptr<long> count{};
  shared_ptr<long> index{};
  shared_ptr<long> wafSum{};

  DescribePeakTrendResponseBodyFlowChart() {}

  explicit DescribePeakTrendResponseBodyFlowChart(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclSum) {
      res["AclSum"] = boost::any(*aclSum);
    }
    if (antiScanSum) {
      res["AntiScanSum"] = boost::any(*antiScanSum);
    }
    if (ccSum) {
      res["CcSum"] = boost::any(*ccSum);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (wafSum) {
      res["WafSum"] = boost::any(*wafSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclSum") != m.end() && !m["AclSum"].empty()) {
      aclSum = make_shared<long>(boost::any_cast<long>(m["AclSum"]));
    }
    if (m.find("AntiScanSum") != m.end() && !m["AntiScanSum"].empty()) {
      antiScanSum = make_shared<long>(boost::any_cast<long>(m["AntiScanSum"]));
    }
    if (m.find("CcSum") != m.end() && !m["CcSum"].empty()) {
      ccSum = make_shared<long>(boost::any_cast<long>(m["CcSum"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("WafSum") != m.end() && !m["WafSum"].empty()) {
      wafSum = make_shared<long>(boost::any_cast<long>(m["WafSum"]));
    }
  }


  virtual ~DescribePeakTrendResponseBodyFlowChart() = default;
};
class DescribePeakTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePeakTrendResponseBodyFlowChart>> flowChart{};
  shared_ptr<string> requestId{};

  DescribePeakTrendResponseBody() {}

  explicit DescribePeakTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowChart) {
      vector<boost::any> temp1;
      for(auto item1:*flowChart){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowChart"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowChart") != m.end() && !m["FlowChart"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowChart"].type()) {
        vector<DescribePeakTrendResponseBodyFlowChart> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowChart"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePeakTrendResponseBodyFlowChart model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowChart = make_shared<vector<DescribePeakTrendResponseBodyFlowChart>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePeakTrendResponseBody() = default;
};
class DescribePeakTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePeakTrendResponseBody> body{};

  DescribePeakTrendResponse() {}

  explicit DescribePeakTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePeakTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePeakTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePeakTrendResponse() = default;
};
class DescribeProductInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceAccessStatus{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceInstanceIp{};
  shared_ptr<string> resourceInstanceName{};
  shared_ptr<string> resourceIp{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceName{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> resourceRegionId{};

  DescribeProductInstancesRequest() {}

  explicit DescribeProductInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceAccessStatus) {
      res["ResourceInstanceAccessStatus"] = boost::any(*resourceInstanceAccessStatus);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceInstanceIp) {
      res["ResourceInstanceIp"] = boost::any(*resourceInstanceIp);
    }
    if (resourceInstanceName) {
      res["ResourceInstanceName"] = boost::any(*resourceInstanceName);
    }
    if (resourceIp) {
      res["ResourceIp"] = boost::any(*resourceIp);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceAccessStatus") != m.end() && !m["ResourceInstanceAccessStatus"].empty()) {
      resourceInstanceAccessStatus = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceAccessStatus"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceInstanceIp") != m.end() && !m["ResourceInstanceIp"].empty()) {
      resourceInstanceIp = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceIp"]));
    }
    if (m.find("ResourceInstanceName") != m.end() && !m["ResourceInstanceName"].empty()) {
      resourceInstanceName = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceName"]));
    }
    if (m.find("ResourceIp") != m.end() && !m["ResourceIp"].empty()) {
      resourceIp = make_shared<string>(boost::any_cast<string>(m["ResourceIp"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
  }


  virtual ~DescribeProductInstancesRequest() = default;
};
class DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols : public Darabonba::Model {
public:
  shared_ptr<vector<string>> certificateIds{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols() {}

  explicit DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateIds) {
      res["CertificateIds"] = boost::any(*certificateIds);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateIds") != m.end() && !m["CertificateIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CertificateIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CertificateIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      certificateIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols() = default;
};
class DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> domain{};

  DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates() {}

  explicit DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
  }


  virtual ~DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates() = default;
};
class DescribeProductInstancesResponseBodyProductInstancesResourcePorts : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates>> certificates{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};

  DescribeProductInstancesResponseBodyProductInstancesResourcePorts() {}

  explicit DescribeProductInstancesResponseBodyProductInstancesResourcePorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<DescribeProductInstancesResponseBodyProductInstancesResourcePortsCertificates>>(expect1);
      }
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
  }


  virtual ~DescribeProductInstancesResponseBodyProductInstancesResourcePorts() = default;
};
class DescribeProductInstancesResponseBodyProductInstances : public Darabonba::Model {
public:
  shared_ptr<string> accessInstanceId{};
  shared_ptr<vector<DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols>> accessPortAndProtocols{};
  shared_ptr<vector<long>> accessPorts{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> resourceInstanceAccessStatus{};
  shared_ptr<string> resourceInstanceEdition{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceInstanceIp{};
  shared_ptr<string> resourceInstanceName{};
  shared_ptr<string> resourceIp{};
  shared_ptr<string> resourceName{};
  shared_ptr<vector<DescribeProductInstancesResponseBodyProductInstancesResourcePorts>> resourcePorts{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> resourceRegionId{};

  DescribeProductInstancesResponseBodyProductInstances() {}

  explicit DescribeProductInstancesResponseBodyProductInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessInstanceId) {
      res["AccessInstanceId"] = boost::any(*accessInstanceId);
    }
    if (accessPortAndProtocols) {
      vector<boost::any> temp1;
      for(auto item1:*accessPortAndProtocols){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPortAndProtocols"] = boost::any(temp1);
    }
    if (accessPorts) {
      res["AccessPorts"] = boost::any(*accessPorts);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (resourceInstanceAccessStatus) {
      res["ResourceInstanceAccessStatus"] = boost::any(*resourceInstanceAccessStatus);
    }
    if (resourceInstanceEdition) {
      res["ResourceInstanceEdition"] = boost::any(*resourceInstanceEdition);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceInstanceIp) {
      res["ResourceInstanceIp"] = boost::any(*resourceInstanceIp);
    }
    if (resourceInstanceName) {
      res["ResourceInstanceName"] = boost::any(*resourceInstanceName);
    }
    if (resourceIp) {
      res["ResourceIp"] = boost::any(*resourceIp);
    }
    if (resourceName) {
      res["ResourceName"] = boost::any(*resourceName);
    }
    if (resourcePorts) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePorts"] = boost::any(temp1);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (resourceRegionId) {
      res["ResourceRegionId"] = boost::any(*resourceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessInstanceId") != m.end() && !m["AccessInstanceId"].empty()) {
      accessInstanceId = make_shared<string>(boost::any_cast<string>(m["AccessInstanceId"]));
    }
    if (m.find("AccessPortAndProtocols") != m.end() && !m["AccessPortAndProtocols"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPortAndProtocols"].type()) {
        vector<DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPortAndProtocols"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPortAndProtocols = make_shared<vector<DescribeProductInstancesResponseBodyProductInstancesAccessPortAndProtocols>>(expect1);
      }
    }
    if (m.find("AccessPorts") != m.end() && !m["AccessPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AccessPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AccessPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      accessPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ResourceInstanceAccessStatus") != m.end() && !m["ResourceInstanceAccessStatus"].empty()) {
      resourceInstanceAccessStatus = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceAccessStatus"]));
    }
    if (m.find("ResourceInstanceEdition") != m.end() && !m["ResourceInstanceEdition"].empty()) {
      resourceInstanceEdition = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceEdition"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceInstanceIp") != m.end() && !m["ResourceInstanceIp"].empty()) {
      resourceInstanceIp = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceIp"]));
    }
    if (m.find("ResourceInstanceName") != m.end() && !m["ResourceInstanceName"].empty()) {
      resourceInstanceName = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceName"]));
    }
    if (m.find("ResourceIp") != m.end() && !m["ResourceIp"].empty()) {
      resourceIp = make_shared<string>(boost::any_cast<string>(m["ResourceIp"]));
    }
    if (m.find("ResourceName") != m.end() && !m["ResourceName"].empty()) {
      resourceName = make_shared<string>(boost::any_cast<string>(m["ResourceName"]));
    }
    if (m.find("ResourcePorts") != m.end() && !m["ResourcePorts"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePorts"].type()) {
        vector<DescribeProductInstancesResponseBodyProductInstancesResourcePorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductInstancesResponseBodyProductInstancesResourcePorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePorts = make_shared<vector<DescribeProductInstancesResponseBodyProductInstancesResourcePorts>>(expect1);
      }
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("ResourceRegionId") != m.end() && !m["ResourceRegionId"].empty()) {
      resourceRegionId = make_shared<string>(boost::any_cast<string>(m["ResourceRegionId"]));
    }
  }


  virtual ~DescribeProductInstancesResponseBodyProductInstances() = default;
};
class DescribeProductInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProductInstancesResponseBodyProductInstances>> productInstances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeProductInstancesResponseBody() {}

  explicit DescribeProductInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productInstances) {
      vector<boost::any> temp1;
      for(auto item1:*productInstances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProductInstances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductInstances") != m.end() && !m["ProductInstances"].empty()) {
      if (typeid(vector<boost::any>) == m["ProductInstances"].type()) {
        vector<DescribeProductInstancesResponseBodyProductInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProductInstances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProductInstancesResponseBodyProductInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        productInstances = make_shared<vector<DescribeProductInstancesResponseBodyProductInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProductInstancesResponseBody() = default;
};
class DescribeProductInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProductInstancesResponseBody> body{};

  DescribeProductInstancesResponse() {}

  explicit DescribeProductInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProductInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProductInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProductInstancesResponse() = default;
};
class DescribePunishedDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> punishType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribePunishedDomainsRequest() {}

  explicit DescribePunishedDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (punishType) {
      res["PunishType"] = boost::any(*punishType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PunishType") != m.end() && !m["PunishType"].empty()) {
      punishType = make_shared<string>(boost::any_cast<string>(m["PunishType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribePunishedDomainsRequest() = default;
};
class DescribePunishedDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> punishedDomains{};
  shared_ptr<string> requestId{};

  DescribePunishedDomainsResponseBody() {}

  explicit DescribePunishedDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (punishedDomains) {
      res["PunishedDomains"] = boost::any(*punishedDomains);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PunishedDomains") != m.end() && !m["PunishedDomains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PunishedDomains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PunishedDomains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      punishedDomains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePunishedDomainsResponseBody() = default;
};
class DescribePunishedDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePunishedDomainsResponseBody> body{};

  DescribePunishedDomainsResponse() {}

  explicit DescribePunishedDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePunishedDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePunishedDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePunishedDomainsResponse() = default;
};
class DescribeResourceInstanceCertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeResourceInstanceCertsRequest() {}

  explicit DescribeResourceInstanceCertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeResourceInstanceCertsRequest() = default;
};
class DescribeResourceInstanceCertsResponseBodyCerts : public Darabonba::Model {
public:
  shared_ptr<long> afterDate{};
  shared_ptr<long> beforeDate{};
  shared_ptr<string> certIdentifier{};
  shared_ptr<string> certName{};
  shared_ptr<string> commonName{};
  shared_ptr<string> domain{};
  shared_ptr<bool> isChainCompleted{};

  DescribeResourceInstanceCertsResponseBodyCerts() {}

  explicit DescribeResourceInstanceCertsResponseBodyCerts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (afterDate) {
      res["AfterDate"] = boost::any(*afterDate);
    }
    if (beforeDate) {
      res["BeforeDate"] = boost::any(*beforeDate);
    }
    if (certIdentifier) {
      res["CertIdentifier"] = boost::any(*certIdentifier);
    }
    if (certName) {
      res["CertName"] = boost::any(*certName);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (isChainCompleted) {
      res["IsChainCompleted"] = boost::any(*isChainCompleted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AfterDate") != m.end() && !m["AfterDate"].empty()) {
      afterDate = make_shared<long>(boost::any_cast<long>(m["AfterDate"]));
    }
    if (m.find("BeforeDate") != m.end() && !m["BeforeDate"].empty()) {
      beforeDate = make_shared<long>(boost::any_cast<long>(m["BeforeDate"]));
    }
    if (m.find("CertIdentifier") != m.end() && !m["CertIdentifier"].empty()) {
      certIdentifier = make_shared<string>(boost::any_cast<string>(m["CertIdentifier"]));
    }
    if (m.find("CertName") != m.end() && !m["CertName"].empty()) {
      certName = make_shared<string>(boost::any_cast<string>(m["CertName"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IsChainCompleted") != m.end() && !m["IsChainCompleted"].empty()) {
      isChainCompleted = make_shared<bool>(boost::any_cast<bool>(m["IsChainCompleted"]));
    }
  }


  virtual ~DescribeResourceInstanceCertsResponseBodyCerts() = default;
};
class DescribeResourceInstanceCertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeResourceInstanceCertsResponseBodyCerts>> certs{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeResourceInstanceCertsResponseBody() {}

  explicit DescribeResourceInstanceCertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certs) {
      vector<boost::any> temp1;
      for(auto item1:*certs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certs"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certs") != m.end() && !m["Certs"].empty()) {
      if (typeid(vector<boost::any>) == m["Certs"].type()) {
        vector<DescribeResourceInstanceCertsResponseBodyCerts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceInstanceCertsResponseBodyCerts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certs = make_shared<vector<DescribeResourceInstanceCertsResponseBodyCerts>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeResourceInstanceCertsResponseBody() = default;
};
class DescribeResourceInstanceCertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceInstanceCertsResponseBody> body{};

  DescribeResourceInstanceCertsResponse() {}

  explicit DescribeResourceInstanceCertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceInstanceCertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceInstanceCertsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceInstanceCertsResponse() = default;
};
class DescribeResourceLogStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resources{};

  DescribeResourceLogStatusRequest() {}

  explicit DescribeResourceLogStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~DescribeResourceLogStatusRequest() = default;
};
class DescribeResourceLogStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> resource{};
  shared_ptr<bool> status{};

  DescribeResourceLogStatusResponseBodyResult() {}

  explicit DescribeResourceLogStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeResourceLogStatusResponseBodyResult() = default;
};
class DescribeResourceLogStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResourceLogStatusResponseBodyResult>> result{};

  DescribeResourceLogStatusResponseBody() {}

  explicit DescribeResourceLogStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeResourceLogStatusResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceLogStatusResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeResourceLogStatusResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceLogStatusResponseBody() = default;
};
class DescribeResourceLogStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceLogStatusResponseBody> body{};

  DescribeResourceLogStatusResponse() {}

  explicit DescribeResourceLogStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceLogStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceLogStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceLogStatusResponse() = default;
};
class DescribeResourcePortRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeResourcePortRequest() {}

  explicit DescribeResourcePortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeResourcePortRequest() = default;
};
class DescribeResourcePortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> resourcePorts{};

  DescribeResourcePortResponseBody() {}

  explicit DescribeResourcePortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePorts) {
      res["ResourcePorts"] = boost::any(*resourcePorts);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePorts") != m.end() && !m["ResourcePorts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourcePorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourcePorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourcePorts = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourcePortResponseBody() = default;
};
class DescribeResourcePortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourcePortResponseBody> body{};

  DescribeResourcePortResponse() {}

  explicit DescribeResourcePortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourcePortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourcePortResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourcePortResponse() = default;
};
class DescribeResourceRegionIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeResourceRegionIdRequest() {}

  explicit DescribeResourceRegionIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeResourceRegionIdRequest() = default;
};
class DescribeResourceRegionIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> resourceRegionIds{};

  DescribeResourceRegionIdResponseBody() {}

  explicit DescribeResourceRegionIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceRegionIds) {
      res["ResourceRegionIds"] = boost::any(*resourceRegionIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceRegionIds") != m.end() && !m["ResourceRegionIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceRegionIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceRegionIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceRegionIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceRegionIdResponseBody() = default;
};
class DescribeResourceRegionIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceRegionIdResponseBody> body{};

  DescribeResourceRegionIdResponse() {}

  explicit DescribeResourceRegionIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceRegionIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceRegionIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceRegionIdResponse() = default;
};
class DescribeResourceSupportRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceProduct{};

  DescribeResourceSupportRegionsRequest() {}

  explicit DescribeResourceSupportRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
  }


  virtual ~DescribeResourceSupportRegionsRequest() = default;
};
class DescribeResourceSupportRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> supportRegions{};

  DescribeResourceSupportRegionsResponseBody() {}

  explicit DescribeResourceSupportRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportRegions) {
      res["SupportRegions"] = boost::any(*supportRegions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportRegions") != m.end() && !m["SupportRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportRegions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeResourceSupportRegionsResponseBody() = default;
};
class DescribeResourceSupportRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceSupportRegionsResponseBody> body{};

  DescribeResourceSupportRegionsResponse() {}

  explicit DescribeResourceSupportRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceSupportRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceSupportRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceSupportRegionsResponse() = default;
};
class DescribeResponseCodeTrendGraphRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};
  shared_ptr<string> type{};

  DescribeResponseCodeTrendGraphRequest() {}

  explicit DescribeResponseCodeTrendGraphRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeResponseCodeTrendGraphRequest() = default;
};
class DescribeResponseCodeTrendGraphResponseBodyResponseCodes : public Darabonba::Model {
public:
  shared_ptr<long> code302Pv{};
  shared_ptr<long> code405Pv{};
  shared_ptr<long> code444Pv{};
  shared_ptr<long> code499Pv{};
  shared_ptr<long> code5xxPv{};
  shared_ptr<long> index{};

  DescribeResponseCodeTrendGraphResponseBodyResponseCodes() {}

  explicit DescribeResponseCodeTrendGraphResponseBodyResponseCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code302Pv) {
      res["302Pv"] = boost::any(*code302Pv);
    }
    if (code405Pv) {
      res["405Pv"] = boost::any(*code405Pv);
    }
    if (code444Pv) {
      res["444Pv"] = boost::any(*code444Pv);
    }
    if (code499Pv) {
      res["499Pv"] = boost::any(*code499Pv);
    }
    if (code5xxPv) {
      res["5xxPv"] = boost::any(*code5xxPv);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("302Pv") != m.end() && !m["302Pv"].empty()) {
      code302Pv = make_shared<long>(boost::any_cast<long>(m["302Pv"]));
    }
    if (m.find("405Pv") != m.end() && !m["405Pv"].empty()) {
      code405Pv = make_shared<long>(boost::any_cast<long>(m["405Pv"]));
    }
    if (m.find("444Pv") != m.end() && !m["444Pv"].empty()) {
      code444Pv = make_shared<long>(boost::any_cast<long>(m["444Pv"]));
    }
    if (m.find("499Pv") != m.end() && !m["499Pv"].empty()) {
      code499Pv = make_shared<long>(boost::any_cast<long>(m["499Pv"]));
    }
    if (m.find("5xxPv") != m.end() && !m["5xxPv"].empty()) {
      code5xxPv = make_shared<long>(boost::any_cast<long>(m["5xxPv"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
  }


  virtual ~DescribeResponseCodeTrendGraphResponseBodyResponseCodes() = default;
};
class DescribeResponseCodeTrendGraphResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResponseCodeTrendGraphResponseBodyResponseCodes>> responseCodes{};

  DescribeResponseCodeTrendGraphResponseBody() {}

  explicit DescribeResponseCodeTrendGraphResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (responseCodes) {
      vector<boost::any> temp1;
      for(auto item1:*responseCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseCodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResponseCodes") != m.end() && !m["ResponseCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseCodes"].type()) {
        vector<DescribeResponseCodeTrendGraphResponseBodyResponseCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResponseCodeTrendGraphResponseBodyResponseCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseCodes = make_shared<vector<DescribeResponseCodeTrendGraphResponseBodyResponseCodes>>(expect1);
      }
    }
  }


  virtual ~DescribeResponseCodeTrendGraphResponseBody() = default;
};
class DescribeResponseCodeTrendGraphResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResponseCodeTrendGraphResponseBody> body{};

  DescribeResponseCodeTrendGraphResponse() {}

  explicit DescribeResponseCodeTrendGraphResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResponseCodeTrendGraphResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResponseCodeTrendGraphResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResponseCodeTrendGraphResponse() = default;
};
class DescribeRuleGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> searchType{};
  shared_ptr<string> searchValue{};

  DescribeRuleGroupsRequest() {}

  explicit DescribeRuleGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
  }


  virtual ~DescribeRuleGroupsRequest() = default;
};
class DescribeRuleGroupsResponseBodyRuleGroups : public Darabonba::Model {
public:
  shared_ptr<long> gmtModified{};
  shared_ptr<long> isSubscribe{};
  shared_ptr<long> parentRuleGroupId{};
  shared_ptr<long> ruleGroupId{};
  shared_ptr<string> ruleGroupName{};
  shared_ptr<long> ruleTotalCount{};

  DescribeRuleGroupsResponseBodyRuleGroups() {}

  explicit DescribeRuleGroupsResponseBodyRuleGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (isSubscribe) {
      res["IsSubscribe"] = boost::any(*isSubscribe);
    }
    if (parentRuleGroupId) {
      res["ParentRuleGroupId"] = boost::any(*parentRuleGroupId);
    }
    if (ruleGroupId) {
      res["RuleGroupId"] = boost::any(*ruleGroupId);
    }
    if (ruleGroupName) {
      res["RuleGroupName"] = boost::any(*ruleGroupName);
    }
    if (ruleTotalCount) {
      res["RuleTotalCount"] = boost::any(*ruleTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("IsSubscribe") != m.end() && !m["IsSubscribe"].empty()) {
      isSubscribe = make_shared<long>(boost::any_cast<long>(m["IsSubscribe"]));
    }
    if (m.find("ParentRuleGroupId") != m.end() && !m["ParentRuleGroupId"].empty()) {
      parentRuleGroupId = make_shared<long>(boost::any_cast<long>(m["ParentRuleGroupId"]));
    }
    if (m.find("RuleGroupId") != m.end() && !m["RuleGroupId"].empty()) {
      ruleGroupId = make_shared<long>(boost::any_cast<long>(m["RuleGroupId"]));
    }
    if (m.find("RuleGroupName") != m.end() && !m["RuleGroupName"].empty()) {
      ruleGroupName = make_shared<string>(boost::any_cast<string>(m["RuleGroupName"]));
    }
    if (m.find("RuleTotalCount") != m.end() && !m["RuleTotalCount"].empty()) {
      ruleTotalCount = make_shared<long>(boost::any_cast<long>(m["RuleTotalCount"]));
    }
  }


  virtual ~DescribeRuleGroupsResponseBodyRuleGroups() = default;
};
class DescribeRuleGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleGroupsResponseBodyRuleGroups>> ruleGroups{};
  shared_ptr<long> totalCount{};

  DescribeRuleGroupsResponseBody() {}

  explicit DescribeRuleGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleGroups) {
      vector<boost::any> temp1;
      for(auto item1:*ruleGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleGroups"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleGroups") != m.end() && !m["RuleGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleGroups"].type()) {
        vector<DescribeRuleGroupsResponseBodyRuleGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleGroupsResponseBodyRuleGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleGroups = make_shared<vector<DescribeRuleGroupsResponseBodyRuleGroups>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeRuleGroupsResponseBody() = default;
};
class DescribeRuleGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleGroupsResponseBody> body{};

  DescribeRuleGroupsResponse() {}

  explicit DescribeRuleGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleGroupsResponse() = default;
};
class DescribeRuleHitsTopClientIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopClientIpRequest() {}

  explicit DescribeRuleHitsTopClientIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopClientIpRequest() = default;
};
class DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<long> count{};

  DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp() {}

  explicit DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp() = default;
};
class DescribeRuleHitsTopClientIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp>> ruleHitsTopClientIp{};

  DescribeRuleHitsTopClientIpResponseBody() {}

  explicit DescribeRuleHitsTopClientIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopClientIp) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopClientIp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopClientIp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopClientIp") != m.end() && !m["RuleHitsTopClientIp"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopClientIp"].type()) {
        vector<DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopClientIp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopClientIp = make_shared<vector<DescribeRuleHitsTopClientIpResponseBodyRuleHitsTopClientIp>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopClientIpResponseBody() = default;
};
class DescribeRuleHitsTopClientIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopClientIpResponseBody> body{};

  DescribeRuleHitsTopClientIpResponse() {}

  explicit DescribeRuleHitsTopClientIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopClientIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopClientIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopClientIpResponse() = default;
};
class DescribeRuleHitsTopResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopResourceRequest() {}

  explicit DescribeRuleHitsTopResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopResourceRequest() = default;
};
class DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> resource{};

  DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource() {}

  explicit DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
  }


  virtual ~DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource() = default;
};
class DescribeRuleHitsTopResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource>> ruleHitsTopResource{};

  DescribeRuleHitsTopResourceResponseBody() {}

  explicit DescribeRuleHitsTopResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopResource) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopResource") != m.end() && !m["RuleHitsTopResource"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopResource"].type()) {
        vector<DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopResource = make_shared<vector<DescribeRuleHitsTopResourceResponseBodyRuleHitsTopResource>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopResourceResponseBody() = default;
};
class DescribeRuleHitsTopResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopResourceResponseBody> body{};

  DescribeRuleHitsTopResourceResponse() {}

  explicit DescribeRuleHitsTopResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopResourceResponse() = default;
};
class DescribeRuleHitsTopRuleIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isGroupResource{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopRuleIdRequest() {}

  explicit DescribeRuleHitsTopRuleIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isGroupResource) {
      res["IsGroupResource"] = boost::any(*isGroupResource);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsGroupResource") != m.end() && !m["IsGroupResource"].empty()) {
      isGroupResource = make_shared<string>(boost::any_cast<string>(m["IsGroupResource"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopRuleIdRequest() = default;
};
class DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> resource{};
  shared_ptr<string> ruleId{};

  DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId() {}

  explicit DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
  }


  virtual ~DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId() = default;
};
class DescribeRuleHitsTopRuleIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId>> ruleHitsTopRuleId{};

  DescribeRuleHitsTopRuleIdResponseBody() {}

  explicit DescribeRuleHitsTopRuleIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopRuleId) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopRuleId){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopRuleId"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopRuleId") != m.end() && !m["RuleHitsTopRuleId"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopRuleId"].type()) {
        vector<DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopRuleId"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopRuleId = make_shared<vector<DescribeRuleHitsTopRuleIdResponseBodyRuleHitsTopRuleId>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopRuleIdResponseBody() = default;
};
class DescribeRuleHitsTopRuleIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopRuleIdResponseBody> body{};

  DescribeRuleHitsTopRuleIdResponse() {}

  explicit DescribeRuleHitsTopRuleIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopRuleIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopRuleIdResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopRuleIdResponse() = default;
};
class DescribeRuleHitsTopTuleTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopTuleTypeRequest() {}

  explicit DescribeRuleHitsTopTuleTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopTuleTypeRequest() = default;
};
class DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> ruleType{};

  DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType() {}

  explicit DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType() = default;
};
class DescribeRuleHitsTopTuleTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType>> ruleHitsTopTuleType{};

  DescribeRuleHitsTopTuleTypeResponseBody() {}

  explicit DescribeRuleHitsTopTuleTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopTuleType) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopTuleType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopTuleType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopTuleType") != m.end() && !m["RuleHitsTopTuleType"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopTuleType"].type()) {
        vector<DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopTuleType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopTuleType = make_shared<vector<DescribeRuleHitsTopTuleTypeResponseBodyRuleHitsTopTuleType>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopTuleTypeResponseBody() = default;
};
class DescribeRuleHitsTopTuleTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopTuleTypeResponseBody> body{};

  DescribeRuleHitsTopTuleTypeResponse() {}

  explicit DescribeRuleHitsTopTuleTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopTuleTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopTuleTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopTuleTypeResponse() = default;
};
class DescribeRuleHitsTopUaRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopUaRequest() {}

  explicit DescribeRuleHitsTopUaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopUaRequest() = default;
};
class DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> ua{};

  DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa() {}

  explicit DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ua) {
      res["Ua"] = boost::any(*ua);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Ua") != m.end() && !m["Ua"].empty()) {
      ua = make_shared<string>(boost::any_cast<string>(m["Ua"]));
    }
  }


  virtual ~DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa() = default;
};
class DescribeRuleHitsTopUaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa>> ruleHitsTopUa{};

  DescribeRuleHitsTopUaResponseBody() {}

  explicit DescribeRuleHitsTopUaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopUa) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopUa){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopUa"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopUa") != m.end() && !m["RuleHitsTopUa"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopUa"].type()) {
        vector<DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopUa"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopUa = make_shared<vector<DescribeRuleHitsTopUaResponseBodyRuleHitsTopUa>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopUaResponseBody() = default;
};
class DescribeRuleHitsTopUaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopUaResponseBody> body{};

  DescribeRuleHitsTopUaResponse() {}

  explicit DescribeRuleHitsTopUaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopUaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopUaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopUaResponse() = default;
};
class DescribeRuleHitsTopUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleType{};
  shared_ptr<string> startTimestamp{};

  DescribeRuleHitsTopUrlRequest() {}

  explicit DescribeRuleHitsTopUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeRuleHitsTopUrlRequest() = default;
};
class DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> url{};

  DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl() {}

  explicit DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl() = default;
};
class DescribeRuleHitsTopUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl>> ruleHitsTopUrl{};

  DescribeRuleHitsTopUrlResponseBody() {}

  explicit DescribeRuleHitsTopUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleHitsTopUrl) {
      vector<boost::any> temp1;
      for(auto item1:*ruleHitsTopUrl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleHitsTopUrl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleHitsTopUrl") != m.end() && !m["RuleHitsTopUrl"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleHitsTopUrl"].type()) {
        vector<DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleHitsTopUrl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleHitsTopUrl = make_shared<vector<DescribeRuleHitsTopUrlResponseBodyRuleHitsTopUrl>>(expect1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopUrlResponseBody() = default;
};
class DescribeRuleHitsTopUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRuleHitsTopUrlResponseBody> body{};

  DescribeRuleHitsTopUrlResponse() {}

  explicit DescribeRuleHitsTopUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRuleHitsTopUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRuleHitsTopUrlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRuleHitsTopUrlResponse() = default;
};
class DescribeSecurityEventLogsRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opValue{};
  shared_ptr<boost::any> values{};

  DescribeSecurityEventLogsRequestFilterConditions() {}

  explicit DescribeSecurityEventLogsRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opValue) {
      res["OpValue"] = boost::any(*opValue);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpValue") != m.end() && !m["OpValue"].empty()) {
      opValue = make_shared<string>(boost::any_cast<string>(m["OpValue"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<boost::any>(boost::any_cast<boost::any>(m["Values"]));
    }
  }


  virtual ~DescribeSecurityEventLogsRequestFilterConditions() = default;
};
class DescribeSecurityEventLogsRequestFilterDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventLogsRequestFilterDateRange() {}

  explicit DescribeSecurityEventLogsRequestFilterDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventLogsRequestFilterDateRange() = default;
};
class DescribeSecurityEventLogsRequestFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityEventLogsRequestFilterConditions>> conditions{};
  shared_ptr<DescribeSecurityEventLogsRequestFilterDateRange> dateRange{};

  DescribeSecurityEventLogsRequestFilter() {}

  explicit DescribeSecurityEventLogsRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeSecurityEventLogsRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventLogsRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeSecurityEventLogsRequestFilterConditions>>(expect1);
      }
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventLogsRequestFilterDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventLogsRequestFilterDateRange>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventLogsRequestFilter() = default;
};
class DescribeSecurityEventLogsRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityEventLogsRequestFilter> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventLogsRequest() {}

  explicit DescribeSecurityEventLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeSecurityEventLogsRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeSecurityEventLogsRequestFilter>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventLogsRequest() = default;
};
class DescribeSecurityEventLogsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventLogsShrinkRequest() {}

  explicit DescribeSecurityEventLogsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventLogsShrinkRequest() = default;
};
class DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange() {}

  explicit DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange() = default;
};
class DescribeSecurityEventLogsResponseBodySecurityEventMetaData : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange> dateRange{};
  shared_ptr<string> units{};

  DescribeSecurityEventLogsResponseBodySecurityEventMetaData() {}

  explicit DescribeSecurityEventLogsResponseBodySecurityEventMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (units) {
      res["Units"] = boost::any(*units);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventLogsResponseBodySecurityEventMetaDataDateRange>(model1);
      }
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      units = make_shared<string>(boost::any_cast<string>(m["Units"]));
    }
  }


  virtual ~DescribeSecurityEventLogsResponseBodySecurityEventMetaData() = default;
};
class DescribeSecurityEventLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<boost::any>> securityEventLogs{};
  shared_ptr<long> securityEventLogsTotalCount{};
  shared_ptr<DescribeSecurityEventLogsResponseBodySecurityEventMetaData> securityEventMetaData{};

  DescribeSecurityEventLogsResponseBody() {}

  explicit DescribeSecurityEventLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventLogs) {
      res["SecurityEventLogs"] = boost::any(*securityEventLogs);
    }
    if (securityEventLogsTotalCount) {
      res["SecurityEventLogsTotalCount"] = boost::any(*securityEventLogsTotalCount);
    }
    if (securityEventMetaData) {
      res["SecurityEventMetaData"] = securityEventMetaData ? boost::any(securityEventMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventLogs") != m.end() && !m["SecurityEventLogs"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SecurityEventLogs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SecurityEventLogs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      securityEventLogs = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("SecurityEventLogsTotalCount") != m.end() && !m["SecurityEventLogsTotalCount"].empty()) {
      securityEventLogsTotalCount = make_shared<long>(boost::any_cast<long>(m["SecurityEventLogsTotalCount"]));
    }
    if (m.find("SecurityEventMetaData") != m.end() && !m["SecurityEventMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityEventMetaData"].type()) {
        DescribeSecurityEventLogsResponseBodySecurityEventMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityEventMetaData"]));
        securityEventMetaData = make_shared<DescribeSecurityEventLogsResponseBodySecurityEventMetaData>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventLogsResponseBody() = default;
};
class DescribeSecurityEventLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityEventLogsResponseBody> body{};

  DescribeSecurityEventLogsResponse() {}

  explicit DescribeSecurityEventLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventLogsResponse() = default;
};
class DescribeSecurityEventTimeSeriesMetricRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opValue{};
  shared_ptr<boost::any> values{};

  DescribeSecurityEventTimeSeriesMetricRequestFilterConditions() {}

  explicit DescribeSecurityEventTimeSeriesMetricRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opValue) {
      res["OpValue"] = boost::any(*opValue);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpValue") != m.end() && !m["OpValue"].empty()) {
      opValue = make_shared<string>(boost::any_cast<string>(m["OpValue"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<boost::any>(boost::any_cast<boost::any>(m["Values"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricRequestFilterConditions() = default;
};
class DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange() {}

  explicit DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange() = default;
};
class DescribeSecurityEventTimeSeriesMetricRequestFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityEventTimeSeriesMetricRequestFilterConditions>> conditions{};
  shared_ptr<DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange> dateRange{};

  DescribeSecurityEventTimeSeriesMetricRequestFilter() {}

  explicit DescribeSecurityEventTimeSeriesMetricRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeSecurityEventTimeSeriesMetricRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventTimeSeriesMetricRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeSecurityEventTimeSeriesMetricRequestFilterConditions>>(expect1);
      }
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventTimeSeriesMetricRequestFilterDateRange>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricRequestFilter() = default;
};
class DescribeSecurityEventTimeSeriesMetricRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityEventTimeSeriesMetricRequestFilter> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventTimeSeriesMetricRequest() {}

  explicit DescribeSecurityEventTimeSeriesMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeSecurityEventTimeSeriesMetricRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeSecurityEventTimeSeriesMetricRequestFilter>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricRequest() = default;
};
class DescribeSecurityEventTimeSeriesMetricShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventTimeSeriesMetricShrinkRequest() {}

  explicit DescribeSecurityEventTimeSeriesMetricShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricShrinkRequest() = default;
};
class DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries : public Darabonba::Model {
public:
  shared_ptr<string> metric{};
  shared_ptr<vector<string>> timestamps{};
  shared_ptr<vector<long>> values{};

  DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries() {}

  explicit DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (timestamps) {
      res["Timestamps"] = boost::any(*timestamps);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Timestamps") != m.end() && !m["Timestamps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Timestamps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Timestamps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      timestamps = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      values = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries() = default;
};
class DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange() {}

  explicit DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange() = default;
};
class DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData : public Darabonba::Model {
public:
  shared_ptr<string> aggregateInterval{};
  shared_ptr<DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange> dateRange{};
  shared_ptr<string> units{};

  DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData() {}

  explicit DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregateInterval) {
      res["AggregateInterval"] = boost::any(*aggregateInterval);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (units) {
      res["Units"] = boost::any(*units);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AggregateInterval") != m.end() && !m["AggregateInterval"].empty()) {
      aggregateInterval = make_shared<string>(boost::any_cast<string>(m["AggregateInterval"]));
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaDataDateRange>(model1);
      }
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      units = make_shared<string>(boost::any_cast<string>(m["Units"]));
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData() = default;
};
class DescribeSecurityEventTimeSeriesMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries>> securityEventTimeSeries{};
  shared_ptr<DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData> timeSeriesMetaData{};

  DescribeSecurityEventTimeSeriesMetricResponseBody() {}

  explicit DescribeSecurityEventTimeSeriesMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventTimeSeries) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventTimeSeries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventTimeSeries"] = boost::any(temp1);
    }
    if (timeSeriesMetaData) {
      res["TimeSeriesMetaData"] = timeSeriesMetaData ? boost::any(timeSeriesMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventTimeSeries") != m.end() && !m["SecurityEventTimeSeries"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventTimeSeries"].type()) {
        vector<DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventTimeSeries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventTimeSeries = make_shared<vector<DescribeSecurityEventTimeSeriesMetricResponseBodySecurityEventTimeSeries>>(expect1);
      }
    }
    if (m.find("TimeSeriesMetaData") != m.end() && !m["TimeSeriesMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeSeriesMetaData"].type()) {
        DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeSeriesMetaData"]));
        timeSeriesMetaData = make_shared<DescribeSecurityEventTimeSeriesMetricResponseBodyTimeSeriesMetaData>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricResponseBody() = default;
};
class DescribeSecurityEventTimeSeriesMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityEventTimeSeriesMetricResponseBody> body{};

  DescribeSecurityEventTimeSeriesMetricResponse() {}

  explicit DescribeSecurityEventTimeSeriesMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventTimeSeriesMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventTimeSeriesMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTimeSeriesMetricResponse() = default;
};
class DescribeSecurityEventTopNMetricRequestFilterConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> opValue{};
  shared_ptr<boost::any> values{};

  DescribeSecurityEventTopNMetricRequestFilterConditions() {}

  explicit DescribeSecurityEventTopNMetricRequestFilterConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (opValue) {
      res["OpValue"] = boost::any(*opValue);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OpValue") != m.end() && !m["OpValue"].empty()) {
      opValue = make_shared<string>(boost::any_cast<string>(m["OpValue"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      values = make_shared<boost::any>(boost::any_cast<boost::any>(m["Values"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricRequestFilterConditions() = default;
};
class DescribeSecurityEventTopNMetricRequestFilterDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventTopNMetricRequestFilterDateRange() {}

  explicit DescribeSecurityEventTopNMetricRequestFilterDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricRequestFilterDateRange() = default;
};
class DescribeSecurityEventTopNMetricRequestFilter : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSecurityEventTopNMetricRequestFilterConditions>> conditions{};
  shared_ptr<DescribeSecurityEventTopNMetricRequestFilterDateRange> dateRange{};

  DescribeSecurityEventTopNMetricRequestFilter() {}

  explicit DescribeSecurityEventTopNMetricRequestFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Conditions"] = boost::any(temp1);
    }
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Conditions") != m.end() && !m["Conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["Conditions"].type()) {
        vector<DescribeSecurityEventTopNMetricRequestFilterConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventTopNMetricRequestFilterConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<DescribeSecurityEventTopNMetricRequestFilterConditions>>(expect1);
      }
    }
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventTopNMetricRequestFilterDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventTopNMetricRequestFilterDateRange>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTopNMetricRequestFilter() = default;
};
class DescribeSecurityEventTopNMetricRequest : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityEventTopNMetricRequestFilter> filter{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> limit{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventTopNMetricRequest() {}

  explicit DescribeSecurityEventTopNMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filter) {
      res["Filter"] = filter ? boost::any(filter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filter"].type()) {
        DescribeSecurityEventTopNMetricRequestFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filter"]));
        filter = make_shared<DescribeSecurityEventTopNMetricRequestFilter>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricRequest() = default;
};
class DescribeSecurityEventTopNMetricShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filterShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> limit{};
  shared_ptr<string> metric{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSecurityEventTopNMetricShrinkRequest() {}

  explicit DescribeSecurityEventTopNMetricShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterShrink) {
      res["Filter"] = boost::any(*filterShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filter") != m.end() && !m["Filter"].empty()) {
      filterShrink = make_shared<string>(boost::any_cast<string>(m["Filter"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<long>(boost::any_cast<long>(m["Limit"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricShrinkRequest() = default;
};
class DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues : public Darabonba::Model {
public:
  shared_ptr<string> attribute{};
  shared_ptr<string> name{};
  shared_ptr<long> value{};

  DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues() {}

  explicit DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attribute) {
      res["Attribute"] = boost::any(*attribute);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attribute") != m.end() && !m["Attribute"].empty()) {
      attribute = make_shared<string>(boost::any_cast<string>(m["Attribute"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["Value"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues() = default;
};
class DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange : public Darabonba::Model {
public:
  shared_ptr<long> endDate{};
  shared_ptr<long> startDate{};

  DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange() {}

  explicit DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endDate) {
      res["EndDate"] = boost::any(*endDate);
    }
    if (startDate) {
      res["StartDate"] = boost::any(*startDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndDate") != m.end() && !m["EndDate"].empty()) {
      endDate = make_shared<long>(boost::any_cast<long>(m["EndDate"]));
    }
    if (m.find("StartDate") != m.end() && !m["StartDate"].empty()) {
      startDate = make_shared<long>(boost::any_cast<long>(m["StartDate"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange() = default;
};
class DescribeSecurityEventTopNMetricResponseBodyTopNMetaData : public Darabonba::Model {
public:
  shared_ptr<DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange> dateRange{};
  shared_ptr<string> units{};

  DescribeSecurityEventTopNMetricResponseBodyTopNMetaData() {}

  explicit DescribeSecurityEventTopNMetricResponseBodyTopNMetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateRange) {
      res["DateRange"] = dateRange ? boost::any(dateRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (units) {
      res["Units"] = boost::any(*units);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateRange") != m.end() && !m["DateRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateRange"].type()) {
        DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateRange"]));
        dateRange = make_shared<DescribeSecurityEventTopNMetricResponseBodyTopNMetaDataDateRange>(model1);
      }
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      units = make_shared<string>(boost::any_cast<string>(m["Units"]));
    }
  }


  virtual ~DescribeSecurityEventTopNMetricResponseBodyTopNMetaData() = default;
};
class DescribeSecurityEventTopNMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues>> securityEventTopNValues{};
  shared_ptr<DescribeSecurityEventTopNMetricResponseBodyTopNMetaData> topNMetaData{};

  DescribeSecurityEventTopNMetricResponseBody() {}

  explicit DescribeSecurityEventTopNMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityEventTopNValues) {
      vector<boost::any> temp1;
      for(auto item1:*securityEventTopNValues){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityEventTopNValues"] = boost::any(temp1);
    }
    if (topNMetaData) {
      res["TopNMetaData"] = topNMetaData ? boost::any(topNMetaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityEventTopNValues") != m.end() && !m["SecurityEventTopNValues"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityEventTopNValues"].type()) {
        vector<DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityEventTopNValues"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityEventTopNValues = make_shared<vector<DescribeSecurityEventTopNMetricResponseBodySecurityEventTopNValues>>(expect1);
      }
    }
    if (m.find("TopNMetaData") != m.end() && !m["TopNMetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopNMetaData"].type()) {
        DescribeSecurityEventTopNMetricResponseBodyTopNMetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopNMetaData"]));
        topNMetaData = make_shared<DescribeSecurityEventTopNMetricResponseBodyTopNMetaData>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTopNMetricResponseBody() = default;
};
class DescribeSecurityEventTopNMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityEventTopNMetricResponseBody> body{};

  DescribeSecurityEventTopNMetricResponse() {}

  explicit DescribeSecurityEventTopNMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityEventTopNMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityEventTopNMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityEventTopNMetricResponse() = default;
};
class DescribeSensitiveApiStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeSensitiveApiStatisticRequest() {}

  explicit DescribeSensitiveApiStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveApiStatisticRequest() = default;
};
class DescribeSensitiveApiStatisticResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<long> infoCount{};
  shared_ptr<vector<string>> sensitiveCode{};
  shared_ptr<long> sensitiveCount{};

  DescribeSensitiveApiStatisticResponseBodyDataList() {}

  explicit DescribeSensitiveApiStatisticResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (infoCount) {
      res["InfoCount"] = boost::any(*infoCount);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveCount) {
      res["SensitiveCount"] = boost::any(*sensitiveCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      infoCount = make_shared<long>(boost::any_cast<long>(m["InfoCount"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SensitiveCode"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SensitiveCode"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sensitiveCode = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SensitiveCount") != m.end() && !m["SensitiveCount"].empty()) {
      sensitiveCount = make_shared<long>(boost::any_cast<long>(m["SensitiveCount"]));
    }
  }


  virtual ~DescribeSensitiveApiStatisticResponseBodyDataList() = default;
};
class DescribeSensitiveApiStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> infoOutboundCount{};
  shared_ptr<vector<DescribeSensitiveApiStatisticResponseBodyDataList>> list{};
  shared_ptr<string> matchedHost{};
  shared_ptr<long> sensitiveOutboundCount{};

  DescribeSensitiveApiStatisticResponseBodyData() {}

  explicit DescribeSensitiveApiStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoOutboundCount) {
      res["InfoOutboundCount"] = boost::any(*infoOutboundCount);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (sensitiveOutboundCount) {
      res["SensitiveOutboundCount"] = boost::any(*sensitiveOutboundCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoOutboundCount") != m.end() && !m["InfoOutboundCount"].empty()) {
      infoOutboundCount = make_shared<long>(boost::any_cast<long>(m["InfoOutboundCount"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeSensitiveApiStatisticResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveApiStatisticResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeSensitiveApiStatisticResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("SensitiveOutboundCount") != m.end() && !m["SensitiveOutboundCount"].empty()) {
      sensitiveOutboundCount = make_shared<long>(boost::any_cast<long>(m["SensitiveOutboundCount"]));
    }
  }


  virtual ~DescribeSensitiveApiStatisticResponseBodyData() = default;
};
class DescribeSensitiveApiStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveApiStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveApiStatisticResponseBody() {}

  explicit DescribeSensitiveApiStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveApiStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveApiStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveApiStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveApiStatisticResponseBody() = default;
};
class DescribeSensitiveApiStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveApiStatisticResponseBody> body{};

  DescribeSensitiveApiStatisticResponse() {}

  explicit DescribeSensitiveApiStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveApiStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveApiStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveApiStatisticResponse() = default;
};
class DescribeSensitiveDetectionResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeSensitiveDetectionResultRequest() {}

  explicit DescribeSensitiveDetectionResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveDetectionResultRequest() = default;
};
class DescribeSensitiveDetectionResultResponseBodyDataResultList : public Darabonba::Model {
public:
  shared_ptr<long> infoCount{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> sensitiveCode{};

  DescribeSensitiveDetectionResultResponseBodyDataResultList() {}

  explicit DescribeSensitiveDetectionResultResponseBodyDataResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoCount) {
      res["InfoCount"] = boost::any(*infoCount);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      infoCount = make_shared<long>(boost::any_cast<long>(m["InfoCount"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<long>(boost::any_cast<long>(m["SensitiveCode"]));
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponseBodyDataResultList() = default;
};
class DescribeSensitiveDetectionResultResponseBodyDataResultMax : public Darabonba::Model {
public:
  shared_ptr<long> infoCount{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> sensitiveCode{};

  DescribeSensitiveDetectionResultResponseBodyDataResultMax() {}

  explicit DescribeSensitiveDetectionResultResponseBodyDataResultMax(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoCount) {
      res["InfoCount"] = boost::any(*infoCount);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      infoCount = make_shared<long>(boost::any_cast<long>(m["InfoCount"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<long>(boost::any_cast<long>(m["SensitiveCode"]));
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponseBodyDataResultMax() = default;
};
class DescribeSensitiveDetectionResultResponseBodyDataResult : public Darabonba::Model {
public:
  shared_ptr<string> detectionResult{};
  shared_ptr<vector<DescribeSensitiveDetectionResultResponseBodyDataResultList>> list{};
  shared_ptr<DescribeSensitiveDetectionResultResponseBodyDataResultMax> max{};

  DescribeSensitiveDetectionResultResponseBodyDataResult() {}

  explicit DescribeSensitiveDetectionResultResponseBodyDataResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectionResult) {
      res["DetectionResult"] = boost::any(*detectionResult);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (max) {
      res["Max"] = max ? boost::any(max->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectionResult") != m.end() && !m["DetectionResult"].empty()) {
      detectionResult = make_shared<string>(boost::any_cast<string>(m["DetectionResult"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeSensitiveDetectionResultResponseBodyDataResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveDetectionResultResponseBodyDataResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeSensitiveDetectionResultResponseBodyDataResultList>>(expect1);
      }
    }
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      if (typeid(map<string, boost::any>) == m["Max"].type()) {
        DescribeSensitiveDetectionResultResponseBodyDataResultMax model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Max"]));
        max = make_shared<DescribeSensitiveDetectionResultResponseBodyDataResultMax>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponseBodyDataResult() = default;
};
class DescribeSensitiveDetectionResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveDetectionResultResponseBodyDataResult>> result{};

  DescribeSensitiveDetectionResultResponseBodyData() {}

  explicit DescribeSensitiveDetectionResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeSensitiveDetectionResultResponseBodyDataResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveDetectionResultResponseBodyDataResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeSensitiveDetectionResultResponseBodyDataResult>>(expect1);
      }
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponseBodyData() = default;
};
class DescribeSensitiveDetectionResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSensitiveDetectionResultResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeSensitiveDetectionResultResponseBody() {}

  explicit DescribeSensitiveDetectionResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSensitiveDetectionResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSensitiveDetectionResultResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponseBody() = default;
};
class DescribeSensitiveDetectionResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveDetectionResultResponseBody> body{};

  DescribeSensitiveDetectionResultResponse() {}

  explicit DescribeSensitiveDetectionResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveDetectionResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveDetectionResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveDetectionResultResponse() = default;
};
class DescribeSensitiveOutboundDistributionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeSensitiveOutboundDistributionRequest() {}

  explicit DescribeSensitiveOutboundDistributionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveOutboundDistributionRequest() = default;
};
class DescribeSensitiveOutboundDistributionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> country{};
  shared_ptr<long> infoOutboundCount{};
  shared_ptr<long> sensitiveOutboundCount{};

  DescribeSensitiveOutboundDistributionResponseBodyData() {}

  explicit DescribeSensitiveOutboundDistributionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (infoOutboundCount) {
      res["InfoOutboundCount"] = boost::any(*infoOutboundCount);
    }
    if (sensitiveOutboundCount) {
      res["SensitiveOutboundCount"] = boost::any(*sensitiveOutboundCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("InfoOutboundCount") != m.end() && !m["InfoOutboundCount"].empty()) {
      infoOutboundCount = make_shared<long>(boost::any_cast<long>(m["InfoOutboundCount"]));
    }
    if (m.find("SensitiveOutboundCount") != m.end() && !m["SensitiveOutboundCount"].empty()) {
      sensitiveOutboundCount = make_shared<long>(boost::any_cast<long>(m["SensitiveOutboundCount"]));
    }
  }


  virtual ~DescribeSensitiveOutboundDistributionResponseBodyData() = default;
};
class DescribeSensitiveOutboundDistributionResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveOutboundDistributionResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeSensitiveOutboundDistributionResponseBody() {}

  explicit DescribeSensitiveOutboundDistributionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveOutboundDistributionResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveOutboundDistributionResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveOutboundDistributionResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSensitiveOutboundDistributionResponseBody() = default;
};
class DescribeSensitiveOutboundDistributionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveOutboundDistributionResponseBody> body{};

  DescribeSensitiveOutboundDistributionResponse() {}

  explicit DescribeSensitiveOutboundDistributionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveOutboundDistributionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveOutboundDistributionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveOutboundDistributionResponse() = default;
};
class DescribeSensitiveOutboundStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> detectionResult{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderKey{};
  shared_ptr<string> orderWay{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sensitiveCode{};
  shared_ptr<string> sensitiveLevel{};
  shared_ptr<string> sensitiveType{};
  shared_ptr<long> startTime{};

  DescribeSensitiveOutboundStatisticRequest() {}

  explicit DescribeSensitiveOutboundStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (detectionResult) {
      res["DetectionResult"] = boost::any(*detectionResult);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderKey) {
      res["OrderKey"] = boost::any(*orderKey);
    }
    if (orderWay) {
      res["OrderWay"] = boost::any(*orderWay);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveLevel) {
      res["SensitiveLevel"] = boost::any(*sensitiveLevel);
    }
    if (sensitiveType) {
      res["SensitiveType"] = boost::any(*sensitiveType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DetectionResult") != m.end() && !m["DetectionResult"].empty()) {
      detectionResult = make_shared<string>(boost::any_cast<string>(m["DetectionResult"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderKey") != m.end() && !m["OrderKey"].empty()) {
      orderKey = make_shared<string>(boost::any_cast<string>(m["OrderKey"]));
    }
    if (m.find("OrderWay") != m.end() && !m["OrderWay"].empty()) {
      orderWay = make_shared<string>(boost::any_cast<string>(m["OrderWay"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<string>(boost::any_cast<string>(m["SensitiveCode"]));
    }
    if (m.find("SensitiveLevel") != m.end() && !m["SensitiveLevel"].empty()) {
      sensitiveLevel = make_shared<string>(boost::any_cast<string>(m["SensitiveLevel"]));
    }
    if (m.find("SensitiveType") != m.end() && !m["SensitiveType"].empty()) {
      sensitiveType = make_shared<string>(boost::any_cast<string>(m["SensitiveType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveOutboundStatisticRequest() = default;
};
class DescribeSensitiveOutboundStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> detectionResult{};
  shared_ptr<long> infoCount{};
  shared_ptr<long> outboundCount{};
  shared_ptr<long> sensitiveCode{};
  shared_ptr<string> sensitiveLevel{};
  shared_ptr<string> sensitiveType{};

  DescribeSensitiveOutboundStatisticResponseBodyData() {}

  explicit DescribeSensitiveOutboundStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detectionResult) {
      res["DetectionResult"] = boost::any(*detectionResult);
    }
    if (infoCount) {
      res["InfoCount"] = boost::any(*infoCount);
    }
    if (outboundCount) {
      res["OutboundCount"] = boost::any(*outboundCount);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveLevel) {
      res["SensitiveLevel"] = boost::any(*sensitiveLevel);
    }
    if (sensitiveType) {
      res["SensitiveType"] = boost::any(*sensitiveType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DetectionResult") != m.end() && !m["DetectionResult"].empty()) {
      detectionResult = make_shared<string>(boost::any_cast<string>(m["DetectionResult"]));
    }
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      infoCount = make_shared<long>(boost::any_cast<long>(m["InfoCount"]));
    }
    if (m.find("OutboundCount") != m.end() && !m["OutboundCount"].empty()) {
      outboundCount = make_shared<long>(boost::any_cast<long>(m["OutboundCount"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<long>(boost::any_cast<long>(m["SensitiveCode"]));
    }
    if (m.find("SensitiveLevel") != m.end() && !m["SensitiveLevel"].empty()) {
      sensitiveLevel = make_shared<string>(boost::any_cast<string>(m["SensitiveLevel"]));
    }
    if (m.find("SensitiveType") != m.end() && !m["SensitiveType"].empty()) {
      sensitiveType = make_shared<string>(boost::any_cast<string>(m["SensitiveType"]));
    }
  }


  virtual ~DescribeSensitiveOutboundStatisticResponseBodyData() = default;
};
class DescribeSensitiveOutboundStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveOutboundStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveOutboundStatisticResponseBody() {}

  explicit DescribeSensitiveOutboundStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveOutboundStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveOutboundStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveOutboundStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveOutboundStatisticResponseBody() = default;
};
class DescribeSensitiveOutboundStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveOutboundStatisticResponseBody> body{};

  DescribeSensitiveOutboundStatisticResponse() {}

  explicit DescribeSensitiveOutboundStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveOutboundStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveOutboundStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveOutboundStatisticResponse() = default;
};
class DescribeSensitiveOutboundTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeSensitiveOutboundTrendRequest() {}

  explicit DescribeSensitiveOutboundTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveOutboundTrendRequest() = default;
};
class DescribeSensitiveOutboundTrendResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> infoCount{};
  shared_ptr<long> infoOutboundCount{};
  shared_ptr<long> sensitiveOutboundCount{};
  shared_ptr<long> timestamp{};

  DescribeSensitiveOutboundTrendResponseBodyData() {}

  explicit DescribeSensitiveOutboundTrendResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (infoCount) {
      res["InfoCount"] = boost::any(*infoCount);
    }
    if (infoOutboundCount) {
      res["InfoOutboundCount"] = boost::any(*infoOutboundCount);
    }
    if (sensitiveOutboundCount) {
      res["SensitiveOutboundCount"] = boost::any(*sensitiveOutboundCount);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      infoCount = make_shared<long>(boost::any_cast<long>(m["InfoCount"]));
    }
    if (m.find("InfoOutboundCount") != m.end() && !m["InfoOutboundCount"].empty()) {
      infoOutboundCount = make_shared<long>(boost::any_cast<long>(m["InfoOutboundCount"]));
    }
    if (m.find("SensitiveOutboundCount") != m.end() && !m["SensitiveOutboundCount"].empty()) {
      sensitiveOutboundCount = make_shared<long>(boost::any_cast<long>(m["SensitiveOutboundCount"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeSensitiveOutboundTrendResponseBodyData() = default;
};
class DescribeSensitiveOutboundTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveOutboundTrendResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveOutboundTrendResponseBody() {}

  explicit DescribeSensitiveOutboundTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveOutboundTrendResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveOutboundTrendResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveOutboundTrendResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveOutboundTrendResponseBody() = default;
};
class DescribeSensitiveOutboundTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveOutboundTrendResponseBody> body{};

  DescribeSensitiveOutboundTrendResponse() {}

  explicit DescribeSensitiveOutboundTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveOutboundTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveOutboundTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveOutboundTrendResponse() = default;
};
class DescribeSensitiveRequestLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> clientIP{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> matchedHost{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sensitiveCode{};
  shared_ptr<string> sensitiveData{};
  shared_ptr<long> startTime{};

  DescribeSensitiveRequestLogRequest() {}

  explicit DescribeSensitiveRequestLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveData) {
      res["SensitiveData"] = boost::any(*sensitiveData);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<string>(boost::any_cast<string>(m["SensitiveCode"]));
    }
    if (m.find("SensitiveData") != m.end() && !m["SensitiveData"].empty()) {
      sensitiveData = make_shared<string>(boost::any_cast<string>(m["SensitiveData"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveRequestLogRequest() = default;
};
class DescribeSensitiveRequestLogResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> clientIP{};
  shared_ptr<long> count{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> remoteCountryId{};
  shared_ptr<long> requestTime{};
  shared_ptr<string> sensitiveList{};
  shared_ptr<string> traceId{};

  DescribeSensitiveRequestLogResponseBodyData() {}

  explicit DescribeSensitiveRequestLogResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (remoteCountryId) {
      res["RemoteCountryId"] = boost::any(*remoteCountryId);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (sensitiveList) {
      res["SensitiveList"] = boost::any(*sensitiveList);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("RemoteCountryId") != m.end() && !m["RemoteCountryId"].empty()) {
      remoteCountryId = make_shared<string>(boost::any_cast<string>(m["RemoteCountryId"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<long>(boost::any_cast<long>(m["RequestTime"]));
    }
    if (m.find("SensitiveList") != m.end() && !m["SensitiveList"].empty()) {
      sensitiveList = make_shared<string>(boost::any_cast<string>(m["SensitiveList"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeSensitiveRequestLogResponseBodyData() = default;
};
class DescribeSensitiveRequestLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveRequestLogResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveRequestLogResponseBody() {}

  explicit DescribeSensitiveRequestLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveRequestLogResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveRequestLogResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveRequestLogResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveRequestLogResponseBody() = default;
};
class DescribeSensitiveRequestLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveRequestLogResponseBody> body{};

  DescribeSensitiveRequestLogResponse() {}

  explicit DescribeSensitiveRequestLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveRequestLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveRequestLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveRequestLogResponse() = default;
};
class DescribeSensitiveRequestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> sensitiveCode{};
  shared_ptr<string> sensitiveData{};
  shared_ptr<long> startTime{};

  DescribeSensitiveRequestsRequest() {}

  explicit DescribeSensitiveRequestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    if (sensitiveData) {
      res["SensitiveData"] = boost::any(*sensitiveData);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<long>(boost::any_cast<long>(m["SensitiveCode"]));
    }
    if (m.find("SensitiveData") != m.end() && !m["SensitiveData"].empty()) {
      sensitiveData = make_shared<string>(boost::any_cast<string>(m["SensitiveData"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeSensitiveRequestsRequest() = default;
};
class DescribeSensitiveRequestsResponseBodyDataInfoCount : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> count{};

  DescribeSensitiveRequestsResponseBodyDataInfoCount() {}

  explicit DescribeSensitiveRequestsResponseBodyDataInfoCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeSensitiveRequestsResponseBodyDataInfoCount() = default;
};
class DescribeSensitiveRequestsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> abnormalCount{};
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> clientIP{};
  shared_ptr<string> detectionResult{};
  shared_ptr<long> eventCount{};
  shared_ptr<vector<DescribeSensitiveRequestsResponseBodyDataInfoCount>> infoCount{};
  shared_ptr<string> matchedHost{};
  shared_ptr<vector<string>> sensitiveList{};

  DescribeSensitiveRequestsResponseBodyData() {}

  explicit DescribeSensitiveRequestsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalCount) {
      res["AbnormalCount"] = boost::any(*abnormalCount);
    }
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (detectionResult) {
      res["DetectionResult"] = boost::any(*detectionResult);
    }
    if (eventCount) {
      res["EventCount"] = boost::any(*eventCount);
    }
    if (infoCount) {
      vector<boost::any> temp1;
      for(auto item1:*infoCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InfoCount"] = boost::any(temp1);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (sensitiveList) {
      res["SensitiveList"] = boost::any(*sensitiveList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalCount") != m.end() && !m["AbnormalCount"].empty()) {
      abnormalCount = make_shared<long>(boost::any_cast<long>(m["AbnormalCount"]));
    }
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("DetectionResult") != m.end() && !m["DetectionResult"].empty()) {
      detectionResult = make_shared<string>(boost::any_cast<string>(m["DetectionResult"]));
    }
    if (m.find("EventCount") != m.end() && !m["EventCount"].empty()) {
      eventCount = make_shared<long>(boost::any_cast<long>(m["EventCount"]));
    }
    if (m.find("InfoCount") != m.end() && !m["InfoCount"].empty()) {
      if (typeid(vector<boost::any>) == m["InfoCount"].type()) {
        vector<DescribeSensitiveRequestsResponseBodyDataInfoCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InfoCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveRequestsResponseBodyDataInfoCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        infoCount = make_shared<vector<DescribeSensitiveRequestsResponseBodyDataInfoCount>>(expect1);
      }
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("SensitiveList") != m.end() && !m["SensitiveList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SensitiveList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SensitiveList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sensitiveList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSensitiveRequestsResponseBodyData() = default;
};
class DescribeSensitiveRequestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveRequestsResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveRequestsResponseBody() {}

  explicit DescribeSensitiveRequestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveRequestsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveRequestsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveRequestsResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveRequestsResponseBody() = default;
};
class DescribeSensitiveRequestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveRequestsResponseBody> body{};

  DescribeSensitiveRequestsResponse() {}

  explicit DescribeSensitiveRequestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveRequestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveRequestsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveRequestsResponse() = default;
};
class DescribeSensitiveStatisticRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> statisticType{};

  DescribeSensitiveStatisticRequest() {}

  explicit DescribeSensitiveStatisticRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (statisticType) {
      res["StatisticType"] = boost::any(*statisticType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StatisticType") != m.end() && !m["StatisticType"].empty()) {
      statisticType = make_shared<string>(boost::any_cast<string>(m["StatisticType"]));
    }
  }


  virtual ~DescribeSensitiveStatisticRequest() = default;
};
class DescribeSensitiveStatisticResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> clientIP{};
  shared_ptr<long> count{};
  shared_ptr<string> matchedHost{};
  shared_ptr<string> sensitiveCode{};

  DescribeSensitiveStatisticResponseBodyData() {}

  explicit DescribeSensitiveStatisticResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (clientIP) {
      res["ClientIP"] = boost::any(*clientIP);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (matchedHost) {
      res["MatchedHost"] = boost::any(*matchedHost);
    }
    if (sensitiveCode) {
      res["SensitiveCode"] = boost::any(*sensitiveCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ClientIP") != m.end() && !m["ClientIP"].empty()) {
      clientIP = make_shared<string>(boost::any_cast<string>(m["ClientIP"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("MatchedHost") != m.end() && !m["MatchedHost"].empty()) {
      matchedHost = make_shared<string>(boost::any_cast<string>(m["MatchedHost"]));
    }
    if (m.find("SensitiveCode") != m.end() && !m["SensitiveCode"].empty()) {
      sensitiveCode = make_shared<string>(boost::any_cast<string>(m["SensitiveCode"]));
    }
  }


  virtual ~DescribeSensitiveStatisticResponseBodyData() = default;
};
class DescribeSensitiveStatisticResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSensitiveStatisticResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeSensitiveStatisticResponseBody() {}

  explicit DescribeSensitiveStatisticResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSensitiveStatisticResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSensitiveStatisticResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSensitiveStatisticResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSensitiveStatisticResponseBody() = default;
};
class DescribeSensitiveStatisticResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSensitiveStatisticResponseBody> body{};

  DescribeSensitiveStatisticResponse() {}

  explicit DescribeSensitiveStatisticResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSensitiveStatisticResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSensitiveStatisticResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSensitiveStatisticResponse() = default;
};
class DescribeSlsAuthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSlsAuthStatusRequest() {}

  explicit DescribeSlsAuthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsAuthStatusRequest() = default;
};
class DescribeSlsAuthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> status{};

  DescribeSlsAuthStatusResponseBody() {}

  explicit DescribeSlsAuthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~DescribeSlsAuthStatusResponseBody() = default;
};
class DescribeSlsAuthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsAuthStatusResponseBody> body{};

  DescribeSlsAuthStatusResponse() {}

  explicit DescribeSlsAuthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsAuthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsAuthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsAuthStatusResponse() = default;
};
class DescribeSlsLogStoreRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSlsLogStoreRequest() {}

  explicit DescribeSlsLogStoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsLogStoreRequest() = default;
};
class DescribeSlsLogStoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quota{};
  shared_ptr<string> requestId{};
  shared_ptr<long> ttl{};
  shared_ptr<long> used{};

  DescribeSlsLogStoreResponseBody() {}

  explicit DescribeSlsLogStoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ttl) {
      res["Ttl"] = boost::any(*ttl);
    }
    if (used) {
      res["Used"] = boost::any(*used);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Ttl") != m.end() && !m["Ttl"].empty()) {
      ttl = make_shared<long>(boost::any_cast<long>(m["Ttl"]));
    }
    if (m.find("Used") != m.end() && !m["Used"].empty()) {
      used = make_shared<long>(boost::any_cast<long>(m["Used"]));
    }
  }


  virtual ~DescribeSlsLogStoreResponseBody() = default;
};
class DescribeSlsLogStoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsLogStoreResponseBody> body{};

  DescribeSlsLogStoreResponse() {}

  explicit DescribeSlsLogStoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsLogStoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsLogStoreResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsLogStoreResponse() = default;
};
class DescribeSlsLogStoreStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeSlsLogStoreStatusRequest() {}

  explicit DescribeSlsLogStoreStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeSlsLogStoreStatusRequest() = default;
};
class DescribeSlsLogStoreStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> existStatus{};
  shared_ptr<string> requestId{};

  DescribeSlsLogStoreStatusResponseBody() {}

  explicit DescribeSlsLogStoreStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (existStatus) {
      res["ExistStatus"] = boost::any(*existStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExistStatus") != m.end() && !m["ExistStatus"].empty()) {
      existStatus = make_shared<bool>(boost::any_cast<bool>(m["ExistStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSlsLogStoreStatusResponseBody() = default;
};
class DescribeSlsLogStoreStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlsLogStoreStatusResponseBody> body{};

  DescribeSlsLogStoreStatusResponse() {}

  explicit DescribeSlsLogStoreStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlsLogStoreStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlsLogStoreStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlsLogStoreStatusResponse() = default;
};
class DescribeTemplateResourceCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> templateIds{};

  DescribeTemplateResourceCountRequest() {}

  explicit DescribeTemplateResourceCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateIds) {
      res["TemplateIds"] = boost::any(*templateIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateIds") != m.end() && !m["TemplateIds"].empty()) {
      templateIds = make_shared<string>(boost::any_cast<string>(m["TemplateIds"]));
    }
  }


  virtual ~DescribeTemplateResourceCountRequest() = default;
};
class DescribeTemplateResourceCountResponseBodyResourceCount : public Darabonba::Model {
public:
  shared_ptr<long> groupCount{};
  shared_ptr<long> singleCount{};
  shared_ptr<long> templateId{};

  DescribeTemplateResourceCountResponseBodyResourceCount() {}

  explicit DescribeTemplateResourceCountResponseBodyResourceCount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupCount) {
      res["GroupCount"] = boost::any(*groupCount);
    }
    if (singleCount) {
      res["SingleCount"] = boost::any(*singleCount);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupCount") != m.end() && !m["GroupCount"].empty()) {
      groupCount = make_shared<long>(boost::any_cast<long>(m["GroupCount"]));
    }
    if (m.find("SingleCount") != m.end() && !m["SingleCount"].empty()) {
      singleCount = make_shared<long>(boost::any_cast<long>(m["SingleCount"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeTemplateResourceCountResponseBodyResourceCount() = default;
};
class DescribeTemplateResourceCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTemplateResourceCountResponseBodyResourceCount>> resourceCount{};

  DescribeTemplateResourceCountResponseBody() {}

  explicit DescribeTemplateResourceCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceCount) {
      vector<boost::any> temp1;
      for(auto item1:*resourceCount){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceCount"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceCount") != m.end() && !m["ResourceCount"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceCount"].type()) {
        vector<DescribeTemplateResourceCountResponseBodyResourceCount> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceCount"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplateResourceCountResponseBodyResourceCount model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceCount = make_shared<vector<DescribeTemplateResourceCountResponseBodyResourceCount>>(expect1);
      }
    }
  }


  virtual ~DescribeTemplateResourceCountResponseBody() = default;
};
class DescribeTemplateResourceCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateResourceCountResponseBody> body{};

  DescribeTemplateResourceCountResponse() {}

  explicit DescribeTemplateResourceCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateResourceCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateResourceCountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateResourceCountResponse() = default;
};
class DescribeTemplateResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> templateId{};

  DescribeTemplateResourcesRequest() {}

  explicit DescribeTemplateResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~DescribeTemplateResourcesRequest() = default;
};
class DescribeTemplateResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> resources{};

  DescribeTemplateResourcesResponseBody() {}

  explicit DescribeTemplateResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Resources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Resources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTemplateResourcesResponseBody() = default;
};
class DescribeTemplateResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplateResourcesResponseBody> body{};

  DescribeTemplateResourcesResponse() {}

  explicit DescribeTemplateResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplateResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplateResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplateResourcesResponse() = default;
};
class DescribeUserAbnormalTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeUserAbnormalTrendRequest() {}

  explicit DescribeUserAbnormalTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeUserAbnormalTrendRequest() = default;
};
class DescribeUserAbnormalTrendResponseBodyTrend : public Darabonba::Model {
public:
  shared_ptr<long> abnormalHigh{};
  shared_ptr<long> abnormalLow{};
  shared_ptr<long> abnormalMedium{};
  shared_ptr<long> timeStamp{};
  shared_ptr<long> timestamp{};

  DescribeUserAbnormalTrendResponseBodyTrend() {}

  explicit DescribeUserAbnormalTrendResponseBodyTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalHigh) {
      res["AbnormalHigh"] = boost::any(*abnormalHigh);
    }
    if (abnormalLow) {
      res["AbnormalLow"] = boost::any(*abnormalLow);
    }
    if (abnormalMedium) {
      res["AbnormalMedium"] = boost::any(*abnormalMedium);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalHigh") != m.end() && !m["AbnormalHigh"].empty()) {
      abnormalHigh = make_shared<long>(boost::any_cast<long>(m["AbnormalHigh"]));
    }
    if (m.find("AbnormalLow") != m.end() && !m["AbnormalLow"].empty()) {
      abnormalLow = make_shared<long>(boost::any_cast<long>(m["AbnormalLow"]));
    }
    if (m.find("AbnormalMedium") != m.end() && !m["AbnormalMedium"].empty()) {
      abnormalMedium = make_shared<long>(boost::any_cast<long>(m["AbnormalMedium"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeUserAbnormalTrendResponseBodyTrend() = default;
};
class DescribeUserAbnormalTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUserAbnormalTrendResponseBodyTrend>> trend{};

  DescribeUserAbnormalTrendResponseBody() {}

  explicit DescribeUserAbnormalTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trend) {
      vector<boost::any> temp1;
      for(auto item1:*trend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      if (typeid(vector<boost::any>) == m["Trend"].type()) {
        vector<DescribeUserAbnormalTrendResponseBodyTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserAbnormalTrendResponseBodyTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trend = make_shared<vector<DescribeUserAbnormalTrendResponseBodyTrend>>(expect1);
      }
    }
  }


  virtual ~DescribeUserAbnormalTrendResponseBody() = default;
};
class DescribeUserAbnormalTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserAbnormalTrendResponseBody> body{};

  DescribeUserAbnormalTrendResponse() {}

  explicit DescribeUserAbnormalTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserAbnormalTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserAbnormalTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserAbnormalTrendResponse() = default;
};
class DescribeUserAbnormalTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeUserAbnormalTypeRequest() {}

  explicit DescribeUserAbnormalTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeUserAbnormalTypeRequest() = default;
};
class DescribeUserAbnormalTypeResponseBodyAbnormal : public Darabonba::Model {
public:
  shared_ptr<string> abnormalCode{};
  shared_ptr<long> abnormalCount{};
  shared_ptr<string> abnormalParentType{};
  shared_ptr<string> abnormalType{};

  DescribeUserAbnormalTypeResponseBodyAbnormal() {}

  explicit DescribeUserAbnormalTypeResponseBodyAbnormal(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalCode) {
      res["AbnormalCode"] = boost::any(*abnormalCode);
    }
    if (abnormalCount) {
      res["AbnormalCount"] = boost::any(*abnormalCount);
    }
    if (abnormalParentType) {
      res["AbnormalParentType"] = boost::any(*abnormalParentType);
    }
    if (abnormalType) {
      res["AbnormalType"] = boost::any(*abnormalType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalCode") != m.end() && !m["AbnormalCode"].empty()) {
      abnormalCode = make_shared<string>(boost::any_cast<string>(m["AbnormalCode"]));
    }
    if (m.find("AbnormalCount") != m.end() && !m["AbnormalCount"].empty()) {
      abnormalCount = make_shared<long>(boost::any_cast<long>(m["AbnormalCount"]));
    }
    if (m.find("AbnormalParentType") != m.end() && !m["AbnormalParentType"].empty()) {
      abnormalParentType = make_shared<string>(boost::any_cast<string>(m["AbnormalParentType"]));
    }
    if (m.find("AbnormalType") != m.end() && !m["AbnormalType"].empty()) {
      abnormalType = make_shared<string>(boost::any_cast<string>(m["AbnormalType"]));
    }
  }


  virtual ~DescribeUserAbnormalTypeResponseBodyAbnormal() = default;
};
class DescribeUserAbnormalTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserAbnormalTypeResponseBodyAbnormal>> abnormal{};
  shared_ptr<string> requestId{};

  DescribeUserAbnormalTypeResponseBody() {}

  explicit DescribeUserAbnormalTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormal) {
      vector<boost::any> temp1;
      for(auto item1:*abnormal){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Abnormal"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abnormal") != m.end() && !m["Abnormal"].empty()) {
      if (typeid(vector<boost::any>) == m["Abnormal"].type()) {
        vector<DescribeUserAbnormalTypeResponseBodyAbnormal> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Abnormal"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserAbnormalTypeResponseBodyAbnormal model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        abnormal = make_shared<vector<DescribeUserAbnormalTypeResponseBodyAbnormal>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserAbnormalTypeResponseBody() = default;
};
class DescribeUserAbnormalTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserAbnormalTypeResponseBody> body{};

  DescribeUserAbnormalTypeResponse() {}

  explicit DescribeUserAbnormalTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserAbnormalTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserAbnormalTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserAbnormalTypeResponse() = default;
};
class DescribeUserApiRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiFormat{};
  shared_ptr<string> apiId{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> type{};

  DescribeUserApiRequestRequest() {}

  explicit DescribeUserApiRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiFormat) {
      res["ApiFormat"] = boost::any(*apiFormat);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiFormat") != m.end() && !m["ApiFormat"].empty()) {
      apiFormat = make_shared<string>(boost::any_cast<string>(m["ApiFormat"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeUserApiRequestRequest() = default;
};
class DescribeUserApiRequestResponseBodyRequests : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> value{};

  DescribeUserApiRequestResponseBodyRequests() {}

  explicit DescribeUserApiRequestResponseBodyRequests(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeUserApiRequestResponseBodyRequests() = default;
};
class DescribeUserApiRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUserApiRequestResponseBodyRequests>> requests{};

  DescribeUserApiRequestResponseBody() {}

  explicit DescribeUserApiRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requests) {
      vector<boost::any> temp1;
      for(auto item1:*requests){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Requests"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Requests") != m.end() && !m["Requests"].empty()) {
      if (typeid(vector<boost::any>) == m["Requests"].type()) {
        vector<DescribeUserApiRequestResponseBodyRequests> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Requests"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserApiRequestResponseBodyRequests model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requests = make_shared<vector<DescribeUserApiRequestResponseBodyRequests>>(expect1);
      }
    }
  }


  virtual ~DescribeUserApiRequestResponseBody() = default;
};
class DescribeUserApiRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserApiRequestResponseBody> body{};

  DescribeUserApiRequestResponse() {}

  explicit DescribeUserApiRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserApiRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserApiRequestResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserApiRequestResponse() = default;
};
class DescribeUserAssetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> dataType{};
  shared_ptr<string> days{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeUserAssetRequest() {}

  explicit DescribeUserAssetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (days) {
      res["Days"] = boost::any(*days);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Days") != m.end() && !m["Days"].empty()) {
      days = make_shared<string>(boost::any_cast<string>(m["Days"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeUserAssetRequest() = default;
};
class DescribeUserAssetResponseBodyAssets : public Darabonba::Model {
public:
  shared_ptr<long> assetNum{};
  shared_ptr<long> timeStamp{};

  DescribeUserAssetResponseBodyAssets() {}

  explicit DescribeUserAssetResponseBodyAssets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assetNum) {
      res["AssetNum"] = boost::any(*assetNum);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssetNum") != m.end() && !m["AssetNum"].empty()) {
      assetNum = make_shared<long>(boost::any_cast<long>(m["AssetNum"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~DescribeUserAssetResponseBodyAssets() = default;
};
class DescribeUserAssetResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserAssetResponseBodyAssets>> assets{};
  shared_ptr<string> requestId{};

  DescribeUserAssetResponseBody() {}

  explicit DescribeUserAssetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assets) {
      vector<boost::any> temp1;
      for(auto item1:*assets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Assets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Assets") != m.end() && !m["Assets"].empty()) {
      if (typeid(vector<boost::any>) == m["Assets"].type()) {
        vector<DescribeUserAssetResponseBodyAssets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Assets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserAssetResponseBodyAssets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        assets = make_shared<vector<DescribeUserAssetResponseBodyAssets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserAssetResponseBody() = default;
};
class DescribeUserAssetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserAssetResponseBody> body{};

  DescribeUserAssetResponse() {}

  explicit DescribeUserAssetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserAssetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserAssetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserAssetResponse() = default;
};
class DescribeUserEventTrendRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeUserEventTrendRequest() {}

  explicit DescribeUserEventTrendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeUserEventTrendRequest() = default;
};
class DescribeUserEventTrendResponseBodyTrend : public Darabonba::Model {
public:
  shared_ptr<long> eventHigh{};
  shared_ptr<long> eventLow{};
  shared_ptr<long> eventMedium{};
  shared_ptr<long> timeStamp{};
  shared_ptr<long> timestamp{};

  DescribeUserEventTrendResponseBodyTrend() {}

  explicit DescribeUserEventTrendResponseBodyTrend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventHigh) {
      res["EventHigh"] = boost::any(*eventHigh);
    }
    if (eventLow) {
      res["EventLow"] = boost::any(*eventLow);
    }
    if (eventMedium) {
      res["EventMedium"] = boost::any(*eventMedium);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventHigh") != m.end() && !m["EventHigh"].empty()) {
      eventHigh = make_shared<long>(boost::any_cast<long>(m["EventHigh"]));
    }
    if (m.find("EventLow") != m.end() && !m["EventLow"].empty()) {
      eventLow = make_shared<long>(boost::any_cast<long>(m["EventLow"]));
    }
    if (m.find("EventMedium") != m.end() && !m["EventMedium"].empty()) {
      eventMedium = make_shared<long>(boost::any_cast<long>(m["EventMedium"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
  }


  virtual ~DescribeUserEventTrendResponseBodyTrend() = default;
};
class DescribeUserEventTrendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeUserEventTrendResponseBodyTrend>> trend{};

  DescribeUserEventTrendResponseBody() {}

  explicit DescribeUserEventTrendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trend) {
      vector<boost::any> temp1;
      for(auto item1:*trend){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trend"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Trend") != m.end() && !m["Trend"].empty()) {
      if (typeid(vector<boost::any>) == m["Trend"].type()) {
        vector<DescribeUserEventTrendResponseBodyTrend> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trend"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserEventTrendResponseBodyTrend model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trend = make_shared<vector<DescribeUserEventTrendResponseBodyTrend>>(expect1);
      }
    }
  }


  virtual ~DescribeUserEventTrendResponseBody() = default;
};
class DescribeUserEventTrendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserEventTrendResponseBody> body{};

  DescribeUserEventTrendResponse() {}

  explicit DescribeUserEventTrendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserEventTrendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserEventTrendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserEventTrendResponse() = default;
};
class DescribeUserEventTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> startTime{};

  DescribeUserEventTypeRequest() {}

  explicit DescribeUserEventTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~DescribeUserEventTypeRequest() = default;
};
class DescribeUserEventTypeResponseBodyEvent : public Darabonba::Model {
public:
  shared_ptr<string> eventCode{};
  shared_ptr<long> eventCount{};
  shared_ptr<string> eventParentType{};
  shared_ptr<string> eventType{};

  DescribeUserEventTypeResponseBodyEvent() {}

  explicit DescribeUserEventTypeResponseBodyEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCode) {
      res["EventCode"] = boost::any(*eventCode);
    }
    if (eventCount) {
      res["EventCount"] = boost::any(*eventCount);
    }
    if (eventParentType) {
      res["EventParentType"] = boost::any(*eventParentType);
    }
    if (eventType) {
      res["EventType"] = boost::any(*eventType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventCode") != m.end() && !m["EventCode"].empty()) {
      eventCode = make_shared<string>(boost::any_cast<string>(m["EventCode"]));
    }
    if (m.find("EventCount") != m.end() && !m["EventCount"].empty()) {
      eventCount = make_shared<long>(boost::any_cast<long>(m["EventCount"]));
    }
    if (m.find("EventParentType") != m.end() && !m["EventParentType"].empty()) {
      eventParentType = make_shared<string>(boost::any_cast<string>(m["EventParentType"]));
    }
    if (m.find("EventType") != m.end() && !m["EventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["EventType"]));
    }
  }


  virtual ~DescribeUserEventTypeResponseBodyEvent() = default;
};
class DescribeUserEventTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserEventTypeResponseBodyEvent>> event{};
  shared_ptr<string> requestId{};

  DescribeUserEventTypeResponseBody() {}

  explicit DescribeUserEventTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      vector<boost::any> temp1;
      for(auto item1:*event){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Event"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(vector<boost::any>) == m["Event"].type()) {
        vector<DescribeUserEventTypeResponseBodyEvent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Event"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserEventTypeResponseBodyEvent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        event = make_shared<vector<DescribeUserEventTypeResponseBodyEvent>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserEventTypeResponseBody() = default;
};
class DescribeUserEventTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserEventTypeResponseBody> body{};

  DescribeUserEventTypeResponse() {}

  explicit DescribeUserEventTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserEventTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserEventTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserEventTypeResponse() = default;
};
class DescribeUserSlsLogRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeUserSlsLogRegionsRequest() {}

  explicit DescribeUserSlsLogRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeUserSlsLogRegionsRequest() = default;
};
class DescribeUserSlsLogRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> logRegions{};
  shared_ptr<string> requestId{};

  DescribeUserSlsLogRegionsResponseBody() {}

  explicit DescribeUserSlsLogRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logRegions) {
      res["LogRegions"] = boost::any(*logRegions);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogRegions") != m.end() && !m["LogRegions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LogRegions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LogRegions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logRegions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserSlsLogRegionsResponseBody() = default;
};
class DescribeUserSlsLogRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserSlsLogRegionsResponseBody> body{};

  DescribeUserSlsLogRegionsResponse() {}

  explicit DescribeUserSlsLogRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserSlsLogRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserSlsLogRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserSlsLogRegionsResponse() = default;
};
class DescribeUserWafLogStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeUserWafLogStatusRequest() {}

  explicit DescribeUserWafLogStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeUserWafLogStatusRequest() = default;
};
class DescribeUserWafLogStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logRegionId{};
  shared_ptr<string> logStatus{};
  shared_ptr<string> requestId{};
  shared_ptr<long> statusUpdateTime{};

  DescribeUserWafLogStatusResponseBody() {}

  explicit DescribeUserWafLogStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logRegionId) {
      res["LogRegionId"] = boost::any(*logRegionId);
    }
    if (logStatus) {
      res["LogStatus"] = boost::any(*logStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statusUpdateTime) {
      res["StatusUpdateTime"] = boost::any(*statusUpdateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogRegionId") != m.end() && !m["LogRegionId"].empty()) {
      logRegionId = make_shared<string>(boost::any_cast<string>(m["LogRegionId"]));
    }
    if (m.find("LogStatus") != m.end() && !m["LogStatus"].empty()) {
      logStatus = make_shared<string>(boost::any_cast<string>(m["LogStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StatusUpdateTime") != m.end() && !m["StatusUpdateTime"].empty()) {
      statusUpdateTime = make_shared<long>(boost::any_cast<long>(m["StatusUpdateTime"]));
    }
  }


  virtual ~DescribeUserWafLogStatusResponseBody() = default;
};
class DescribeUserWafLogStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUserWafLogStatusResponseBody> body{};

  DescribeUserWafLogStatusResponse() {}

  explicit DescribeUserWafLogStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserWafLogStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserWafLogStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserWafLogStatusResponse() = default;
};
class DescribeVisitTopIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeVisitTopIpRequest() {}

  explicit DescribeVisitTopIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeVisitTopIpRequest() = default;
};
class DescribeVisitTopIpResponseBodyTopIp : public Darabonba::Model {
public:
  shared_ptr<string> area{};
  shared_ptr<long> count{};
  shared_ptr<string> ip{};
  shared_ptr<string> isp{};

  DescribeVisitTopIpResponseBodyTopIp() {}

  explicit DescribeVisitTopIpResponseBodyTopIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (area) {
      res["Area"] = boost::any(*area);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Area") != m.end() && !m["Area"].empty()) {
      area = make_shared<string>(boost::any_cast<string>(m["Area"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
  }


  virtual ~DescribeVisitTopIpResponseBodyTopIp() = default;
};
class DescribeVisitTopIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVisitTopIpResponseBodyTopIp>> topIp{};

  DescribeVisitTopIpResponseBody() {}

  explicit DescribeVisitTopIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topIp) {
      vector<boost::any> temp1;
      for(auto item1:*topIp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopIp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TopIp") != m.end() && !m["TopIp"].empty()) {
      if (typeid(vector<boost::any>) == m["TopIp"].type()) {
        vector<DescribeVisitTopIpResponseBodyTopIp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopIp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVisitTopIpResponseBodyTopIp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topIp = make_shared<vector<DescribeVisitTopIpResponseBodyTopIp>>(expect1);
      }
    }
  }


  virtual ~DescribeVisitTopIpResponseBody() = default;
};
class DescribeVisitTopIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVisitTopIpResponseBody> body{};

  DescribeVisitTopIpResponse() {}

  explicit DescribeVisitTopIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVisitTopIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVisitTopIpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVisitTopIpResponse() = default;
};
class DescribeVisitUasRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimestamp{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> startTimestamp{};

  DescribeVisitUasRequest() {}

  explicit DescribeVisitUasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<string>(boost::any_cast<string>(m["EndTimestamp"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
  }


  virtual ~DescribeVisitUasRequest() = default;
};
class DescribeVisitUasResponseBodyUas : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> ua{};

  DescribeVisitUasResponseBodyUas() {}

  explicit DescribeVisitUasResponseBodyUas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (ua) {
      res["Ua"] = boost::any(*ua);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Ua") != m.end() && !m["Ua"].empty()) {
      ua = make_shared<string>(boost::any_cast<string>(m["Ua"]));
    }
  }


  virtual ~DescribeVisitUasResponseBodyUas() = default;
};
class DescribeVisitUasResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeVisitUasResponseBodyUas>> uas{};

  DescribeVisitUasResponseBody() {}

  explicit DescribeVisitUasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uas) {
      vector<boost::any> temp1;
      for(auto item1:*uas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Uas"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Uas") != m.end() && !m["Uas"].empty()) {
      if (typeid(vector<boost::any>) == m["Uas"].type()) {
        vector<DescribeVisitUasResponseBodyUas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Uas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVisitUasResponseBodyUas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        uas = make_shared<vector<DescribeVisitUasResponseBodyUas>>(expect1);
      }
    }
  }


  virtual ~DescribeVisitUasResponseBody() = default;
};
class DescribeVisitUasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVisitUasResponseBody> body{};

  DescribeVisitUasResponse() {}

  explicit DescribeVisitUasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVisitUasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVisitUasResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVisitUasResponse() = default;
};
class DescribeWafSourceIpSegmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  DescribeWafSourceIpSegmentRequest() {}

  explicit DescribeWafSourceIpSegmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~DescribeWafSourceIpSegmentRequest() = default;
};
class DescribeWafSourceIpSegmentResponseBodyWafSourceIp : public Darabonba::Model {
public:
  shared_ptr<vector<string>> IPv4{};
  shared_ptr<vector<string>> IPv6{};

  DescribeWafSourceIpSegmentResponseBodyWafSourceIp() {}

  explicit DescribeWafSourceIpSegmentResponseBodyWafSourceIp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IPv4) {
      res["IPv4"] = boost::any(*IPv4);
    }
    if (IPv6) {
      res["IPv6"] = boost::any(*IPv6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IPv4") != m.end() && !m["IPv4"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv4"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv4"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv4 = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IPv6") != m.end() && !m["IPv6"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IPv6"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IPv6"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      IPv6 = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeWafSourceIpSegmentResponseBodyWafSourceIp() = default;
};
class DescribeWafSourceIpSegmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeWafSourceIpSegmentResponseBodyWafSourceIp> wafSourceIp{};

  DescribeWafSourceIpSegmentResponseBody() {}

  explicit DescribeWafSourceIpSegmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (wafSourceIp) {
      res["WafSourceIp"] = wafSourceIp ? boost::any(wafSourceIp->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WafSourceIp") != m.end() && !m["WafSourceIp"].empty()) {
      if (typeid(map<string, boost::any>) == m["WafSourceIp"].type()) {
        DescribeWafSourceIpSegmentResponseBodyWafSourceIp model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WafSourceIp"]));
        wafSourceIp = make_shared<DescribeWafSourceIpSegmentResponseBodyWafSourceIp>(model1);
      }
    }
  }


  virtual ~DescribeWafSourceIpSegmentResponseBody() = default;
};
class DescribeWafSourceIpSegmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeWafSourceIpSegmentResponseBody> body{};

  DescribeWafSourceIpSegmentResponse() {}

  explicit DescribeWafSourceIpSegmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeWafSourceIpSegmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeWafSourceIpSegmentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeWafSourceIpSegmentResponse() = default;
};
class ListTagKeysRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceType{};

  ListTagKeysRequest() {}

  explicit ListTagKeysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListTagKeysRequest() = default;
};
class ListTagKeysResponseBodyKeys : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> key{};

  ListTagKeysResponseBodyKeys() {}

  explicit ListTagKeysResponseBodyKeys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~ListTagKeysResponseBodyKeys() = default;
};
class ListTagKeysResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagKeysResponseBodyKeys>> keys{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListTagKeysResponseBody() {}

  explicit ListTagKeysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      vector<boost::any> temp1;
      for(auto item1:*keys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keys"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keys") != m.end() && !m["Keys"].empty()) {
      if (typeid(vector<boost::any>) == m["Keys"].type()) {
        vector<ListTagKeysResponseBodyKeys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagKeysResponseBodyKeys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keys = make_shared<vector<ListTagKeysResponseBodyKeys>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListTagKeysResponseBody() = default;
};
class ListTagKeysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagKeysResponseBody> body{};

  ListTagKeysResponse() {}

  explicit ListTagKeysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagKeysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagKeysResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagKeysResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListTagValuesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> key{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceType{};

  ListTagValuesRequest() {}

  explicit ListTagValuesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ListTagValuesRequest() = default;
};
class ListTagValuesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> values{};

  ListTagValuesResponseBody() {}

  explicit ListTagValuesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTagValuesResponseBody() = default;
};
class ListTagValuesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagValuesResponseBody> body{};

  ListTagValuesResponse() {}

  explicit ListTagValuesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagValuesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagValuesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagValuesResponse() = default;
};
class ModifyApisecAbnormalsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> abnormalIds{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> note{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> userStatus{};

  ModifyApisecAbnormalsRequest() {}

  explicit ModifyApisecAbnormalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalIds) {
      res["AbnormalIds"] = boost::any(*abnormalIds);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalIds") != m.end() && !m["AbnormalIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AbnormalIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AbnormalIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      abnormalIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~ModifyApisecAbnormalsRequest() = default;
};
class ModifyApisecAbnormalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecAbnormalsResponseBody() {}

  explicit ModifyApisecAbnormalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecAbnormalsResponseBody() = default;
};
class ModifyApisecAbnormalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecAbnormalsResponseBody> body{};

  ModifyApisecAbnormalsResponse() {}

  explicit ModifyApisecAbnormalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecAbnormalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecAbnormalsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecAbnormalsResponse() = default;
};
class ModifyApisecApiResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> clusterId{};
  shared_ptr<long> follow{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> note{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyApisecApiResourceRequest() {}

  explicit ModifyApisecApiResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (follow) {
      res["Follow"] = boost::any(*follow);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Follow") != m.end() && !m["Follow"].empty()) {
      follow = make_shared<long>(boost::any_cast<long>(m["Follow"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyApisecApiResourceRequest() = default;
};
class ModifyApisecApiResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecApiResourceResponseBody() {}

  explicit ModifyApisecApiResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecApiResourceResponseBody() = default;
};
class ModifyApisecApiResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecApiResourceResponseBody> body{};

  ModifyApisecApiResourceResponse() {}

  explicit ModifyApisecApiResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecApiResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecApiResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecApiResourceResponse() = default;
};
class ModifyApisecEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<vector<string>> eventIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> note{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> userStatus{};

  ModifyApisecEventsRequest() {}

  explicit ModifyApisecEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (eventIds) {
      res["EventIds"] = boost::any(*eventIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("EventIds") != m.end() && !m["EventIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EventIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EventIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~ModifyApisecEventsRequest() = default;
};
class ModifyApisecEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecEventsResponseBody() {}

  explicit ModifyApisecEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecEventsResponseBody() = default;
};
class ModifyApisecEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecEventsResponseBody> body{};

  ModifyApisecEventsResponse() {}

  explicit ModifyApisecEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecEventsResponse() = default;
};
class ModifyApisecLogDeliveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> assertKey{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logRegionId{};
  shared_ptr<string> logStoreName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyApisecLogDeliveryRequest() {}

  explicit ModifyApisecLogDeliveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertKey) {
      res["AssertKey"] = boost::any(*assertKey);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logRegionId) {
      res["LogRegionId"] = boost::any(*logRegionId);
    }
    if (logStoreName) {
      res["LogStoreName"] = boost::any(*logStoreName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssertKey") != m.end() && !m["AssertKey"].empty()) {
      assertKey = make_shared<string>(boost::any_cast<string>(m["AssertKey"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogRegionId") != m.end() && !m["LogRegionId"].empty()) {
      logRegionId = make_shared<string>(boost::any_cast<string>(m["LogRegionId"]));
    }
    if (m.find("LogStoreName") != m.end() && !m["LogStoreName"].empty()) {
      logStoreName = make_shared<string>(boost::any_cast<string>(m["LogStoreName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyApisecLogDeliveryRequest() = default;
};
class ModifyApisecLogDeliveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecLogDeliveryResponseBody() {}

  explicit ModifyApisecLogDeliveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecLogDeliveryResponseBody() = default;
};
class ModifyApisecLogDeliveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecLogDeliveryResponseBody> body{};

  ModifyApisecLogDeliveryResponse() {}

  explicit ModifyApisecLogDeliveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecLogDeliveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecLogDeliveryResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecLogDeliveryResponse() = default;
};
class ModifyApisecLogDeliveryStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> assertKey{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<bool> status{};

  ModifyApisecLogDeliveryStatusRequest() {}

  explicit ModifyApisecLogDeliveryStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertKey) {
      res["AssertKey"] = boost::any(*assertKey);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssertKey") != m.end() && !m["AssertKey"].empty()) {
      assertKey = make_shared<string>(boost::any_cast<string>(m["AssertKey"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~ModifyApisecLogDeliveryStatusRequest() = default;
};
class ModifyApisecLogDeliveryStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecLogDeliveryStatusResponseBody() {}

  explicit ModifyApisecLogDeliveryStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecLogDeliveryStatusResponseBody() = default;
};
class ModifyApisecLogDeliveryStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecLogDeliveryStatusResponseBody> body{};

  ModifyApisecLogDeliveryStatusResponse() {}

  explicit ModifyApisecLogDeliveryStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecLogDeliveryStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecLogDeliveryStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecLogDeliveryStatusResponse() = default;
};
class ModifyApisecModuleStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> reportStatus{};
  shared_ptr<string> resourceGroups{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resources{};
  shared_ptr<long> traceStatus{};

  ModifyApisecModuleStatusRequest() {}

  explicit ModifyApisecModuleStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (reportStatus) {
      res["ReportStatus"] = boost::any(*reportStatus);
    }
    if (resourceGroups) {
      res["ResourceGroups"] = boost::any(*resourceGroups);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    if (traceStatus) {
      res["TraceStatus"] = boost::any(*traceStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ReportStatus") != m.end() && !m["ReportStatus"].empty()) {
      reportStatus = make_shared<long>(boost::any_cast<long>(m["ReportStatus"]));
    }
    if (m.find("ResourceGroups") != m.end() && !m["ResourceGroups"].empty()) {
      resourceGroups = make_shared<string>(boost::any_cast<string>(m["ResourceGroups"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
    if (m.find("TraceStatus") != m.end() && !m["TraceStatus"].empty()) {
      traceStatus = make_shared<long>(boost::any_cast<long>(m["TraceStatus"]));
    }
  }


  virtual ~ModifyApisecModuleStatusRequest() = default;
};
class ModifyApisecModuleStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecModuleStatusResponseBody() {}

  explicit ModifyApisecModuleStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecModuleStatusResponseBody() = default;
};
class ModifyApisecModuleStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecModuleStatusResponseBody> body{};

  ModifyApisecModuleStatusResponse() {}

  explicit ModifyApisecModuleStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecModuleStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecModuleStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecModuleStatusResponse() = default;
};
class ModifyApisecStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> apisecStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroups{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resources{};

  ModifyApisecStatusRequest() {}

  explicit ModifyApisecStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apisecStatus) {
      res["ApisecStatus"] = boost::any(*apisecStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroups) {
      res["ResourceGroups"] = boost::any(*resourceGroups);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resources) {
      res["Resources"] = boost::any(*resources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApisecStatus") != m.end() && !m["ApisecStatus"].empty()) {
      apisecStatus = make_shared<long>(boost::any_cast<long>(m["ApisecStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroups") != m.end() && !m["ResourceGroups"].empty()) {
      resourceGroups = make_shared<string>(boost::any_cast<string>(m["ResourceGroups"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Resources") != m.end() && !m["Resources"].empty()) {
      resources = make_shared<string>(boost::any_cast<string>(m["Resources"]));
    }
  }


  virtual ~ModifyApisecStatusRequest() = default;
};
class ModifyApisecStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApisecStatusResponseBody() {}

  explicit ModifyApisecStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApisecStatusResponseBody() = default;
};
class ModifyApisecStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApisecStatusResponseBody> body{};

  ModifyApisecStatusResponse() {}

  explicit ModifyApisecStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApisecStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApisecStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApisecStatusResponse() = default;
};
class ModifyCloudResourceRequestListenCertificates : public Darabonba::Model {
public:
  shared_ptr<string> appliedType{};
  shared_ptr<string> certificateId{};

  ModifyCloudResourceRequestListenCertificates() {}

  explicit ModifyCloudResourceRequestListenCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appliedType) {
      res["AppliedType"] = boost::any(*appliedType);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppliedType") != m.end() && !m["AppliedType"].empty()) {
      appliedType = make_shared<string>(boost::any_cast<string>(m["AppliedType"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
  }


  virtual ~ModifyCloudResourceRequestListenCertificates() = default;
};
class ModifyCloudResourceRequestListen : public Darabonba::Model {
public:
  shared_ptr<vector<ModifyCloudResourceRequestListenCertificates>> certificates{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<long> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceProduct{};
  shared_ptr<string> TLSVersion{};

  ModifyCloudResourceRequestListen() {}

  explicit ModifyCloudResourceRequestListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<ModifyCloudResourceRequestListenCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCloudResourceRequestListenCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<ModifyCloudResourceRequestListenCertificates>>(expect1);
      }
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
  }


  virtual ~ModifyCloudResourceRequestListen() = default;
};
class ModifyCloudResourceRequestRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyCloudResourceRequestRedirectRequestHeaders() {}

  explicit ModifyCloudResourceRequestRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyCloudResourceRequestRedirectRequestHeaders() = default;
};
class ModifyCloudResourceRequestRedirect : public Darabonba::Model {
public:
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<ModifyCloudResourceRequestRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};
  shared_ptr<bool> xffProto{};

  ModifyCloudResourceRequestRedirect() {}

  explicit ModifyCloudResourceRequestRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<ModifyCloudResourceRequestRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyCloudResourceRequestRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<ModifyCloudResourceRequestRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~ModifyCloudResourceRequestRedirect() = default;
};
class ModifyCloudResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<ModifyCloudResourceRequestListen> listen{};
  shared_ptr<ModifyCloudResourceRequestRedirect> redirect{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyCloudResourceRequest() {}

  explicit ModifyCloudResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        ModifyCloudResourceRequestListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<ModifyCloudResourceRequestListen>(model1);
      }
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        ModifyCloudResourceRequestRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<ModifyCloudResourceRequestRedirect>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyCloudResourceRequest() = default;
};
class ModifyCloudResourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> listenShrink{};
  shared_ptr<string> redirectShrink{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyCloudResourceShrinkRequest() {}

  explicit ModifyCloudResourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listenShrink) {
      res["Listen"] = boost::any(*listenShrink);
    }
    if (redirectShrink) {
      res["Redirect"] = boost::any(*redirectShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      listenShrink = make_shared<string>(boost::any_cast<string>(m["Listen"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      redirectShrink = make_shared<string>(boost::any_cast<string>(m["Redirect"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyCloudResourceShrinkRequest() = default;
};
class ModifyCloudResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> cloudResource{};
  shared_ptr<string> requestId{};

  ModifyCloudResourceResponseBody() {}

  explicit ModifyCloudResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudResource) {
      res["CloudResource"] = boost::any(*cloudResource);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudResource") != m.end() && !m["CloudResource"].empty()) {
      cloudResource = make_shared<string>(boost::any_cast<string>(m["CloudResource"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCloudResourceResponseBody() = default;
};
class ModifyCloudResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCloudResourceResponseBody> body{};

  ModifyCloudResourceResponse() {}

  explicit ModifyCloudResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCloudResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCloudResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCloudResourceResponse() = default;
};
class ModifyDefaultHttpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> TLSVersion{};

  ModifyDefaultHttpsRequest() {}

  explicit ModifyDefaultHttpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
  }


  virtual ~ModifyDefaultHttpsRequest() = default;
};
class ModifyDefaultHttpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefaultHttpsResponseBody() {}

  explicit ModifyDefaultHttpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefaultHttpsResponseBody() = default;
};
class ModifyDefaultHttpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefaultHttpsResponseBody> body{};

  ModifyDefaultHttpsResponse() {}

  explicit ModifyDefaultHttpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefaultHttpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefaultHttpsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefaultHttpsResponse() = default;
};
class ModifyDefenseResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> addList{};
  shared_ptr<string> deleteList{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyDefenseResourceGroupRequest() {}

  explicit ModifyDefenseResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addList) {
      res["AddList"] = boost::any(*addList);
    }
    if (deleteList) {
      res["DeleteList"] = boost::any(*deleteList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddList") != m.end() && !m["AddList"].empty()) {
      addList = make_shared<string>(boost::any_cast<string>(m["AddList"]));
    }
    if (m.find("DeleteList") != m.end() && !m["DeleteList"].empty()) {
      deleteList = make_shared<string>(boost::any_cast<string>(m["DeleteList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyDefenseResourceGroupRequest() = default;
};
class ModifyDefenseResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseResourceGroupResponseBody() {}

  explicit ModifyDefenseResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseResourceGroupResponseBody() = default;
};
class ModifyDefenseResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseResourceGroupResponseBody> body{};

  ModifyDefenseResourceGroupResponse() {}

  explicit ModifyDefenseResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseResourceGroupResponse() = default;
};
class ModifyDefenseResourceXffRequestResponseHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyDefenseResourceXffRequestResponseHeaders() {}

  explicit ModifyDefenseResourceXffRequestResponseHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyDefenseResourceXffRequestResponseHeaders() = default;
};
class ModifyDefenseResourceXffRequest : public Darabonba::Model {
public:
  shared_ptr<long> acwCookieStatus{};
  shared_ptr<long> acwSecureStatus{};
  shared_ptr<long> acwV3SecureStatus{};
  shared_ptr<vector<string>> customHeaders{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<vector<ModifyDefenseResourceXffRequestResponseHeaders>> responseHeaders{};
  shared_ptr<long> xffStatus{};

  ModifyDefenseResourceXffRequest() {}

  explicit ModifyDefenseResourceXffRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acwCookieStatus) {
      res["AcwCookieStatus"] = boost::any(*acwCookieStatus);
    }
    if (acwSecureStatus) {
      res["AcwSecureStatus"] = boost::any(*acwSecureStatus);
    }
    if (acwV3SecureStatus) {
      res["AcwV3SecureStatus"] = boost::any(*acwV3SecureStatus);
    }
    if (customHeaders) {
      res["CustomHeaders"] = boost::any(*customHeaders);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (responseHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*responseHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseHeaders"] = boost::any(temp1);
    }
    if (xffStatus) {
      res["XffStatus"] = boost::any(*xffStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcwCookieStatus") != m.end() && !m["AcwCookieStatus"].empty()) {
      acwCookieStatus = make_shared<long>(boost::any_cast<long>(m["AcwCookieStatus"]));
    }
    if (m.find("AcwSecureStatus") != m.end() && !m["AcwSecureStatus"].empty()) {
      acwSecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwSecureStatus"]));
    }
    if (m.find("AcwV3SecureStatus") != m.end() && !m["AcwV3SecureStatus"].empty()) {
      acwV3SecureStatus = make_shared<long>(boost::any_cast<long>(m["AcwV3SecureStatus"]));
    }
    if (m.find("CustomHeaders") != m.end() && !m["CustomHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customHeaders = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseHeaders"].type()) {
        vector<ModifyDefenseResourceXffRequestResponseHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDefenseResourceXffRequestResponseHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseHeaders = make_shared<vector<ModifyDefenseResourceXffRequestResponseHeaders>>(expect1);
      }
    }
    if (m.find("XffStatus") != m.end() && !m["XffStatus"].empty()) {
      xffStatus = make_shared<long>(boost::any_cast<long>(m["XffStatus"]));
    }
  }


  virtual ~ModifyDefenseResourceXffRequest() = default;
};
class ModifyDefenseResourceXffResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseResourceXffResponseBody() {}

  explicit ModifyDefenseResourceXffResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseResourceXffResponseBody() = default;
};
class ModifyDefenseResourceXffResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseResourceXffResponseBody> body{};

  ModifyDefenseResourceXffResponse() {}

  explicit ModifyDefenseResourceXffResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseResourceXffResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseResourceXffResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseResourceXffResponse() = default;
};
class ModifyDefenseRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> defenseScene{};
  shared_ptr<string> defenseType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> rules{};
  shared_ptr<long> templateId{};

  ModifyDefenseRuleRequest() {}

  explicit ModifyDefenseRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defenseScene) {
      res["DefenseScene"] = boost::any(*defenseScene);
    }
    if (defenseType) {
      res["DefenseType"] = boost::any(*defenseType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (rules) {
      res["Rules"] = boost::any(*rules);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefenseScene") != m.end() && !m["DefenseScene"].empty()) {
      defenseScene = make_shared<string>(boost::any_cast<string>(m["DefenseScene"]));
    }
    if (m.find("DefenseType") != m.end() && !m["DefenseType"].empty()) {
      defenseType = make_shared<string>(boost::any_cast<string>(m["DefenseType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      rules = make_shared<string>(boost::any_cast<string>(m["Rules"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ModifyDefenseRuleRequest() = default;
};
class ModifyDefenseRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseRuleResponseBody() {}

  explicit ModifyDefenseRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseRuleResponseBody() = default;
};
class ModifyDefenseRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseRuleResponseBody> body{};

  ModifyDefenseRuleResponse() {}

  explicit ModifyDefenseRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseRuleResponse() = default;
};
class ModifyDefenseRuleCacheRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  ModifyDefenseRuleCacheRequest() {}

  explicit ModifyDefenseRuleCacheRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ModifyDefenseRuleCacheRequest() = default;
};
class ModifyDefenseRuleCacheResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseRuleCacheResponseBody() {}

  explicit ModifyDefenseRuleCacheResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseRuleCacheResponseBody() = default;
};
class ModifyDefenseRuleCacheResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseRuleCacheResponseBody> body{};

  ModifyDefenseRuleCacheResponse() {}

  explicit ModifyDefenseRuleCacheResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseRuleCacheResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseRuleCacheResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseRuleCacheResponse() = default;
};
class ModifyDefenseRuleStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> ruleStatus{};
  shared_ptr<long> templateId{};

  ModifyDefenseRuleStatusRequest() {}

  explicit ModifyDefenseRuleStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<long>(boost::any_cast<long>(m["RuleStatus"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ModifyDefenseRuleStatusRequest() = default;
};
class ModifyDefenseRuleStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseRuleStatusResponseBody() {}

  explicit ModifyDefenseRuleStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseRuleStatusResponseBody() = default;
};
class ModifyDefenseRuleStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseRuleStatusResponseBody> body{};

  ModifyDefenseRuleStatusResponse() {}

  explicit ModifyDefenseRuleStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseRuleStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseRuleStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseRuleStatusResponse() = default;
};
class ModifyDefenseTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};
  shared_ptr<string> templateName{};

  ModifyDefenseTemplateRequest() {}

  explicit ModifyDefenseTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateName) {
      res["TemplateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateName") != m.end() && !m["TemplateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["TemplateName"]));
    }
  }


  virtual ~ModifyDefenseTemplateRequest() = default;
};
class ModifyDefenseTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseTemplateResponseBody() {}

  explicit ModifyDefenseTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseTemplateResponseBody() = default;
};
class ModifyDefenseTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseTemplateResponseBody> body{};

  ModifyDefenseTemplateResponse() {}

  explicit ModifyDefenseTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseTemplateResponse() = default;
};
class ModifyDefenseTemplateStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};
  shared_ptr<long> templateStatus{};

  ModifyDefenseTemplateStatusRequest() {}

  explicit ModifyDefenseTemplateStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (templateStatus) {
      res["TemplateStatus"] = boost::any(*templateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("TemplateStatus") != m.end() && !m["TemplateStatus"].empty()) {
      templateStatus = make_shared<long>(boost::any_cast<long>(m["TemplateStatus"]));
    }
  }


  virtual ~ModifyDefenseTemplateStatusRequest() = default;
};
class ModifyDefenseTemplateStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDefenseTemplateStatusResponseBody() {}

  explicit ModifyDefenseTemplateStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDefenseTemplateStatusResponseBody() = default;
};
class ModifyDefenseTemplateStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDefenseTemplateStatusResponseBody> body{};

  ModifyDefenseTemplateStatusResponse() {}

  explicit ModifyDefenseTemplateStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDefenseTemplateStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDefenseTemplateStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDefenseTemplateStatusResponse() = default;
};
class ModifyDomainRequestListen : public Darabonba::Model {
public:
  shared_ptr<string> certId{};
  shared_ptr<long> cipherSuite{};
  shared_ptr<vector<string>> customCiphers{};
  shared_ptr<bool> enableTLSv3{};
  shared_ptr<bool> exclusiveIp{};
  shared_ptr<bool> focusHttps{};
  shared_ptr<bool> http2Enabled{};
  shared_ptr<vector<long>> httpPorts{};
  shared_ptr<vector<long>> httpsPorts{};
  shared_ptr<bool> IPv6Enabled{};
  shared_ptr<string> protectionResource{};
  shared_ptr<bool> SM2AccessOnly{};
  shared_ptr<string> SM2CertId{};
  shared_ptr<bool> SM2Enabled{};
  shared_ptr<string> TLSVersion{};
  shared_ptr<long> xffHeaderMode{};
  shared_ptr<vector<string>> xffHeaders{};

  ModifyDomainRequestListen() {}

  explicit ModifyDomainRequestListen(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certId) {
      res["CertId"] = boost::any(*certId);
    }
    if (cipherSuite) {
      res["CipherSuite"] = boost::any(*cipherSuite);
    }
    if (customCiphers) {
      res["CustomCiphers"] = boost::any(*customCiphers);
    }
    if (enableTLSv3) {
      res["EnableTLSv3"] = boost::any(*enableTLSv3);
    }
    if (exclusiveIp) {
      res["ExclusiveIp"] = boost::any(*exclusiveIp);
    }
    if (focusHttps) {
      res["FocusHttps"] = boost::any(*focusHttps);
    }
    if (http2Enabled) {
      res["Http2Enabled"] = boost::any(*http2Enabled);
    }
    if (httpPorts) {
      res["HttpPorts"] = boost::any(*httpPorts);
    }
    if (httpsPorts) {
      res["HttpsPorts"] = boost::any(*httpsPorts);
    }
    if (IPv6Enabled) {
      res["IPv6Enabled"] = boost::any(*IPv6Enabled);
    }
    if (protectionResource) {
      res["ProtectionResource"] = boost::any(*protectionResource);
    }
    if (SM2AccessOnly) {
      res["SM2AccessOnly"] = boost::any(*SM2AccessOnly);
    }
    if (SM2CertId) {
      res["SM2CertId"] = boost::any(*SM2CertId);
    }
    if (SM2Enabled) {
      res["SM2Enabled"] = boost::any(*SM2Enabled);
    }
    if (TLSVersion) {
      res["TLSVersion"] = boost::any(*TLSVersion);
    }
    if (xffHeaderMode) {
      res["XffHeaderMode"] = boost::any(*xffHeaderMode);
    }
    if (xffHeaders) {
      res["XffHeaders"] = boost::any(*xffHeaders);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertId") != m.end() && !m["CertId"].empty()) {
      certId = make_shared<string>(boost::any_cast<string>(m["CertId"]));
    }
    if (m.find("CipherSuite") != m.end() && !m["CipherSuite"].empty()) {
      cipherSuite = make_shared<long>(boost::any_cast<long>(m["CipherSuite"]));
    }
    if (m.find("CustomCiphers") != m.end() && !m["CustomCiphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomCiphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomCiphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customCiphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTLSv3") != m.end() && !m["EnableTLSv3"].empty()) {
      enableTLSv3 = make_shared<bool>(boost::any_cast<bool>(m["EnableTLSv3"]));
    }
    if (m.find("ExclusiveIp") != m.end() && !m["ExclusiveIp"].empty()) {
      exclusiveIp = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveIp"]));
    }
    if (m.find("FocusHttps") != m.end() && !m["FocusHttps"].empty()) {
      focusHttps = make_shared<bool>(boost::any_cast<bool>(m["FocusHttps"]));
    }
    if (m.find("Http2Enabled") != m.end() && !m["Http2Enabled"].empty()) {
      http2Enabled = make_shared<bool>(boost::any_cast<bool>(m["Http2Enabled"]));
    }
    if (m.find("HttpPorts") != m.end() && !m["HttpPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("HttpsPorts") != m.end() && !m["HttpsPorts"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["HttpsPorts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["HttpsPorts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      httpsPorts = make_shared<vector<long>>(toVec1);
    }
    if (m.find("IPv6Enabled") != m.end() && !m["IPv6Enabled"].empty()) {
      IPv6Enabled = make_shared<bool>(boost::any_cast<bool>(m["IPv6Enabled"]));
    }
    if (m.find("ProtectionResource") != m.end() && !m["ProtectionResource"].empty()) {
      protectionResource = make_shared<string>(boost::any_cast<string>(m["ProtectionResource"]));
    }
    if (m.find("SM2AccessOnly") != m.end() && !m["SM2AccessOnly"].empty()) {
      SM2AccessOnly = make_shared<bool>(boost::any_cast<bool>(m["SM2AccessOnly"]));
    }
    if (m.find("SM2CertId") != m.end() && !m["SM2CertId"].empty()) {
      SM2CertId = make_shared<string>(boost::any_cast<string>(m["SM2CertId"]));
    }
    if (m.find("SM2Enabled") != m.end() && !m["SM2Enabled"].empty()) {
      SM2Enabled = make_shared<bool>(boost::any_cast<bool>(m["SM2Enabled"]));
    }
    if (m.find("TLSVersion") != m.end() && !m["TLSVersion"].empty()) {
      TLSVersion = make_shared<string>(boost::any_cast<string>(m["TLSVersion"]));
    }
    if (m.find("XffHeaderMode") != m.end() && !m["XffHeaderMode"].empty()) {
      xffHeaderMode = make_shared<long>(boost::any_cast<long>(m["XffHeaderMode"]));
    }
    if (m.find("XffHeaders") != m.end() && !m["XffHeaders"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["XffHeaders"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["XffHeaders"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      xffHeaders = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyDomainRequestListen() = default;
};
class ModifyDomainRequestRedirectRequestHeaders : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyDomainRequestRedirectRequestHeaders() {}

  explicit ModifyDomainRequestRedirectRequestHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyDomainRequestRedirectRequestHeaders() = default;
};
class ModifyDomainRequestRedirect : public Darabonba::Model {
public:
  shared_ptr<vector<string>> backends{};
  shared_ptr<vector<string>> backupBackends{};
  shared_ptr<bool> cnameEnabled{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<bool> focusHttpBackend{};
  shared_ptr<bool> keepalive{};
  shared_ptr<long> keepaliveRequests{};
  shared_ptr<long> keepaliveTimeout{};
  shared_ptr<string> loadbalance{};
  shared_ptr<long> readTimeout{};
  shared_ptr<vector<ModifyDomainRequestRedirectRequestHeaders>> requestHeaders{};
  shared_ptr<bool> retry{};
  shared_ptr<string> routingRules{};
  shared_ptr<bool> sniEnabled{};
  shared_ptr<string> sniHost{};
  shared_ptr<long> writeTimeout{};
  shared_ptr<bool> xffProto{};

  ModifyDomainRequestRedirect() {}

  explicit ModifyDomainRequestRedirect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backends) {
      res["Backends"] = boost::any(*backends);
    }
    if (backupBackends) {
      res["BackupBackends"] = boost::any(*backupBackends);
    }
    if (cnameEnabled) {
      res["CnameEnabled"] = boost::any(*cnameEnabled);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (focusHttpBackend) {
      res["FocusHttpBackend"] = boost::any(*focusHttpBackend);
    }
    if (keepalive) {
      res["Keepalive"] = boost::any(*keepalive);
    }
    if (keepaliveRequests) {
      res["KeepaliveRequests"] = boost::any(*keepaliveRequests);
    }
    if (keepaliveTimeout) {
      res["KeepaliveTimeout"] = boost::any(*keepaliveTimeout);
    }
    if (loadbalance) {
      res["Loadbalance"] = boost::any(*loadbalance);
    }
    if (readTimeout) {
      res["ReadTimeout"] = boost::any(*readTimeout);
    }
    if (requestHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*requestHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestHeaders"] = boost::any(temp1);
    }
    if (retry) {
      res["Retry"] = boost::any(*retry);
    }
    if (routingRules) {
      res["RoutingRules"] = boost::any(*routingRules);
    }
    if (sniEnabled) {
      res["SniEnabled"] = boost::any(*sniEnabled);
    }
    if (sniHost) {
      res["SniHost"] = boost::any(*sniHost);
    }
    if (writeTimeout) {
      res["WriteTimeout"] = boost::any(*writeTimeout);
    }
    if (xffProto) {
      res["XffProto"] = boost::any(*xffProto);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backends") != m.end() && !m["Backends"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Backends"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Backends"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backends = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BackupBackends") != m.end() && !m["BackupBackends"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BackupBackends"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BackupBackends"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      backupBackends = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CnameEnabled") != m.end() && !m["CnameEnabled"].empty()) {
      cnameEnabled = make_shared<bool>(boost::any_cast<bool>(m["CnameEnabled"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("FocusHttpBackend") != m.end() && !m["FocusHttpBackend"].empty()) {
      focusHttpBackend = make_shared<bool>(boost::any_cast<bool>(m["FocusHttpBackend"]));
    }
    if (m.find("Keepalive") != m.end() && !m["Keepalive"].empty()) {
      keepalive = make_shared<bool>(boost::any_cast<bool>(m["Keepalive"]));
    }
    if (m.find("KeepaliveRequests") != m.end() && !m["KeepaliveRequests"].empty()) {
      keepaliveRequests = make_shared<long>(boost::any_cast<long>(m["KeepaliveRequests"]));
    }
    if (m.find("KeepaliveTimeout") != m.end() && !m["KeepaliveTimeout"].empty()) {
      keepaliveTimeout = make_shared<long>(boost::any_cast<long>(m["KeepaliveTimeout"]));
    }
    if (m.find("Loadbalance") != m.end() && !m["Loadbalance"].empty()) {
      loadbalance = make_shared<string>(boost::any_cast<string>(m["Loadbalance"]));
    }
    if (m.find("ReadTimeout") != m.end() && !m["ReadTimeout"].empty()) {
      readTimeout = make_shared<long>(boost::any_cast<long>(m["ReadTimeout"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestHeaders"].type()) {
        vector<ModifyDomainRequestRedirectRequestHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDomainRequestRedirectRequestHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestHeaders = make_shared<vector<ModifyDomainRequestRedirectRequestHeaders>>(expect1);
      }
    }
    if (m.find("Retry") != m.end() && !m["Retry"].empty()) {
      retry = make_shared<bool>(boost::any_cast<bool>(m["Retry"]));
    }
    if (m.find("RoutingRules") != m.end() && !m["RoutingRules"].empty()) {
      routingRules = make_shared<string>(boost::any_cast<string>(m["RoutingRules"]));
    }
    if (m.find("SniEnabled") != m.end() && !m["SniEnabled"].empty()) {
      sniEnabled = make_shared<bool>(boost::any_cast<bool>(m["SniEnabled"]));
    }
    if (m.find("SniHost") != m.end() && !m["SniHost"].empty()) {
      sniHost = make_shared<string>(boost::any_cast<string>(m["SniHost"]));
    }
    if (m.find("WriteTimeout") != m.end() && !m["WriteTimeout"].empty()) {
      writeTimeout = make_shared<long>(boost::any_cast<long>(m["WriteTimeout"]));
    }
    if (m.find("XffProto") != m.end() && !m["XffProto"].empty()) {
      xffProto = make_shared<bool>(boost::any_cast<bool>(m["XffProto"]));
    }
  }


  virtual ~ModifyDomainRequestRedirect() = default;
};
class ModifyDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<ModifyDomainRequestListen> listen{};
  shared_ptr<ModifyDomainRequestRedirect> redirect{};
  shared_ptr<string> regionId{};

  ModifyDomainRequest() {}

  explicit ModifyDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listen) {
      res["Listen"] = listen ? boost::any(listen->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (redirect) {
      res["Redirect"] = redirect ? boost::any(redirect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      if (typeid(map<string, boost::any>) == m["Listen"].type()) {
        ModifyDomainRequestListen model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Listen"]));
        listen = make_shared<ModifyDomainRequestListen>(model1);
      }
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      if (typeid(map<string, boost::any>) == m["Redirect"].type()) {
        ModifyDomainRequestRedirect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Redirect"]));
        redirect = make_shared<ModifyDomainRequestRedirect>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDomainRequest() = default;
};
class ModifyDomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessType{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> listenShrink{};
  shared_ptr<string> redirectShrink{};
  shared_ptr<string> regionId{};

  ModifyDomainShrinkRequest() {}

  explicit ModifyDomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessType) {
      res["AccessType"] = boost::any(*accessType);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (listenShrink) {
      res["Listen"] = boost::any(*listenShrink);
    }
    if (redirectShrink) {
      res["Redirect"] = boost::any(*redirectShrink);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessType") != m.end() && !m["AccessType"].empty()) {
      accessType = make_shared<string>(boost::any_cast<string>(m["AccessType"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Listen") != m.end() && !m["Listen"].empty()) {
      listenShrink = make_shared<string>(boost::any_cast<string>(m["Listen"]));
    }
    if (m.find("Redirect") != m.end() && !m["Redirect"].empty()) {
      redirectShrink = make_shared<string>(boost::any_cast<string>(m["Redirect"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ModifyDomainShrinkRequest() = default;
};
class ModifyDomainResponseBodyDomainInfo : public Darabonba::Model {
public:
  shared_ptr<string> cname{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainId{};

  ModifyDomainResponseBodyDomainInfo() {}

  explicit ModifyDomainResponseBodyDomainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cname) {
      res["Cname"] = boost::any(*cname);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cname") != m.end() && !m["Cname"].empty()) {
      cname = make_shared<string>(boost::any_cast<string>(m["Cname"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
  }


  virtual ~ModifyDomainResponseBodyDomainInfo() = default;
};
class ModifyDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyDomainResponseBodyDomainInfo> domainInfo{};
  shared_ptr<string> requestId{};

  ModifyDomainResponseBody() {}

  explicit ModifyDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainInfo) {
      res["DomainInfo"] = domainInfo ? boost::any(domainInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainInfo") != m.end() && !m["DomainInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainInfo"].type()) {
        ModifyDomainResponseBodyDomainInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainInfo"]));
        domainInfo = make_shared<ModifyDomainResponseBodyDomainInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDomainResponseBody() = default;
};
class ModifyDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDomainResponseBody> body{};

  ModifyDomainResponse() {}

  explicit ModifyDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDomainResponse() = default;
};
class ModifyDomainPunishStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyDomainPunishStatusRequest() {}

  explicit ModifyDomainPunishStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyDomainPunishStatusRequest() = default;
};
class ModifyDomainPunishStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDomainPunishStatusResponseBody() {}

  explicit ModifyDomainPunishStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDomainPunishStatusResponseBody() = default;
};
class ModifyDomainPunishStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDomainPunishStatusResponseBody> body{};

  ModifyDomainPunishStatusResponse() {}

  explicit ModifyDomainPunishStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDomainPunishStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDomainPunishStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDomainPunishStatusResponse() = default;
};
class ModifyHybridCloudClusterBypassStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterResourceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleStatus{};

  ModifyHybridCloudClusterBypassStatusRequest() {}

  explicit ModifyHybridCloudClusterBypassStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterResourceId) {
      res["ClusterResourceId"] = boost::any(*clusterResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterResourceId") != m.end() && !m["ClusterResourceId"].empty()) {
      clusterResourceId = make_shared<string>(boost::any_cast<string>(m["ClusterResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
  }


  virtual ~ModifyHybridCloudClusterBypassStatusRequest() = default;
};
class ModifyHybridCloudClusterBypassStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudClusterBypassStatusResponseBody() {}

  explicit ModifyHybridCloudClusterBypassStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudClusterBypassStatusResponseBody() = default;
};
class ModifyHybridCloudClusterBypassStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudClusterBypassStatusResponseBody> body{};

  ModifyHybridCloudClusterBypassStatusResponse() {}

  explicit ModifyHybridCloudClusterBypassStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudClusterBypassStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudClusterBypassStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudClusterBypassStatusResponse() = default;
};
class ModifyHybridCloudClusterRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> ruleConfig{};
  shared_ptr<string> ruleStatus{};
  shared_ptr<string> ruleType{};

  ModifyHybridCloudClusterRuleRequest() {}

  explicit ModifyHybridCloudClusterRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleConfig) {
      res["RuleConfig"] = boost::any(*ruleConfig);
    }
    if (ruleStatus) {
      res["RuleStatus"] = boost::any(*ruleStatus);
    }
    if (ruleType) {
      res["RuleType"] = boost::any(*ruleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleConfig") != m.end() && !m["RuleConfig"].empty()) {
      ruleConfig = make_shared<string>(boost::any_cast<string>(m["RuleConfig"]));
    }
    if (m.find("RuleStatus") != m.end() && !m["RuleStatus"].empty()) {
      ruleStatus = make_shared<string>(boost::any_cast<string>(m["RuleStatus"]));
    }
    if (m.find("RuleType") != m.end() && !m["RuleType"].empty()) {
      ruleType = make_shared<string>(boost::any_cast<string>(m["RuleType"]));
    }
  }


  virtual ~ModifyHybridCloudClusterRuleRequest() = default;
};
class ModifyHybridCloudClusterRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudClusterRuleResponseBody() {}

  explicit ModifyHybridCloudClusterRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudClusterRuleResponseBody() = default;
};
class ModifyHybridCloudClusterRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudClusterRuleResponseBody> body{};

  ModifyHybridCloudClusterRuleResponse() {}

  explicit ModifyHybridCloudClusterRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudClusterRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudClusterRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudClusterRuleResponse() = default;
};
class ModifyHybridCloudGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> remark{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyHybridCloudGroupRequest() {}

  explicit ModifyHybridCloudGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupRequest() = default;
};
class ModifyHybridCloudGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudGroupResponseBody() {}

  explicit ModifyHybridCloudGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupResponseBody() = default;
};
class ModifyHybridCloudGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudGroupResponseBody> body{};

  ModifyHybridCloudGroupResponse() {}

  explicit ModifyHybridCloudGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudGroupResponse() = default;
};
class ModifyHybridCloudGroupExpansionServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mids{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyHybridCloudGroupExpansionServerRequest() {}

  explicit ModifyHybridCloudGroupExpansionServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mids) {
      res["Mids"] = boost::any(*mids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mids") != m.end() && !m["Mids"].empty()) {
      mids = make_shared<string>(boost::any_cast<string>(m["Mids"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupExpansionServerRequest() = default;
};
class ModifyHybridCloudGroupExpansionServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudGroupExpansionServerResponseBody() {}

  explicit ModifyHybridCloudGroupExpansionServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupExpansionServerResponseBody() = default;
};
class ModifyHybridCloudGroupExpansionServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudGroupExpansionServerResponseBody> body{};

  ModifyHybridCloudGroupExpansionServerResponse() {}

  explicit ModifyHybridCloudGroupExpansionServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudGroupExpansionServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudGroupExpansionServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudGroupExpansionServerResponse() = default;
};
class ModifyHybridCloudGroupShrinkServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> clusterId{};
  shared_ptr<long> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mids{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyHybridCloudGroupShrinkServerRequest() {}

  explicit ModifyHybridCloudGroupShrinkServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mids) {
      res["Mids"] = boost::any(*mids);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<long>(boost::any_cast<long>(m["ClusterId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mids") != m.end() && !m["Mids"].empty()) {
      mids = make_shared<string>(boost::any_cast<string>(m["Mids"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupShrinkServerRequest() = default;
};
class ModifyHybridCloudGroupShrinkServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudGroupShrinkServerResponseBody() {}

  explicit ModifyHybridCloudGroupShrinkServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudGroupShrinkServerResponseBody() = default;
};
class ModifyHybridCloudGroupShrinkServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudGroupShrinkServerResponseBody> body{};

  ModifyHybridCloudGroupShrinkServerResponse() {}

  explicit ModifyHybridCloudGroupShrinkServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudGroupShrinkServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudGroupShrinkServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudGroupShrinkServerResponse() = default;
};
class ModifyHybridCloudSdkPullinStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> mid{};
  shared_ptr<string> pullinStatus{};

  ModifyHybridCloudSdkPullinStatusRequest() {}

  explicit ModifyHybridCloudSdkPullinStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (pullinStatus) {
      res["PullinStatus"] = boost::any(*pullinStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("PullinStatus") != m.end() && !m["PullinStatus"].empty()) {
      pullinStatus = make_shared<string>(boost::any_cast<string>(m["PullinStatus"]));
    }
  }


  virtual ~ModifyHybridCloudSdkPullinStatusRequest() = default;
};
class ModifyHybridCloudSdkPullinStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudSdkPullinStatusResponseBody() {}

  explicit ModifyHybridCloudSdkPullinStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudSdkPullinStatusResponseBody() = default;
};
class ModifyHybridCloudSdkPullinStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudSdkPullinStatusResponseBody> body{};

  ModifyHybridCloudSdkPullinStatusResponse() {}

  explicit ModifyHybridCloudSdkPullinStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudSdkPullinStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudSdkPullinStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudSdkPullinStatusResponse() = default;
};
class ModifyHybridCloudServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> continents{};
  shared_ptr<string> customName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mid{};
  shared_ptr<string> operator_{};
  shared_ptr<string> regionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyHybridCloudServerRequest() {}

  explicit ModifyHybridCloudServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (continents) {
      res["Continents"] = boost::any(*continents);
    }
    if (customName) {
      res["CustomName"] = boost::any(*customName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (regionCode) {
      res["RegionCode"] = boost::any(*regionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Continents") != m.end() && !m["Continents"].empty()) {
      continents = make_shared<string>(boost::any_cast<string>(m["Continents"]));
    }
    if (m.find("CustomName") != m.end() && !m["CustomName"].empty()) {
      customName = make_shared<string>(boost::any_cast<string>(m["CustomName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("RegionCode") != m.end() && !m["RegionCode"].empty()) {
      regionCode = make_shared<string>(boost::any_cast<string>(m["RegionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyHybridCloudServerRequest() = default;
};
class ModifyHybridCloudServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHybridCloudServerResponseBody() {}

  explicit ModifyHybridCloudServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHybridCloudServerResponseBody() = default;
};
class ModifyHybridCloudServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyHybridCloudServerResponseBody> body{};

  ModifyHybridCloudServerResponse() {}

  explicit ModifyHybridCloudServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHybridCloudServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHybridCloudServerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHybridCloudServerResponse() = default;
};
class ModifyMajorProtectionBlackIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ipList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> ruleId{};
  shared_ptr<long> templateId{};

  ModifyMajorProtectionBlackIpRequest() {}

  explicit ModifyMajorProtectionBlackIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ipList) {
      res["IpList"] = boost::any(*ipList);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IpList") != m.end() && !m["IpList"].empty()) {
      ipList = make_shared<string>(boost::any_cast<string>(m["IpList"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
  }


  virtual ~ModifyMajorProtectionBlackIpRequest() = default;
};
class ModifyMajorProtectionBlackIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyMajorProtectionBlackIpResponseBody() {}

  explicit ModifyMajorProtectionBlackIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyMajorProtectionBlackIpResponseBody() = default;
};
class ModifyMajorProtectionBlackIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMajorProtectionBlackIpResponseBody> body{};

  ModifyMajorProtectionBlackIpResponse() {}

  explicit ModifyMajorProtectionBlackIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMajorProtectionBlackIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMajorProtectionBlackIpResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMajorProtectionBlackIpResponse() = default;
};
class ModifyMemberAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> memberAccountId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> sourceIp{};

  ModifyMemberAccountRequest() {}

  explicit ModifyMemberAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (memberAccountId) {
      res["MemberAccountId"] = boost::any(*memberAccountId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (sourceIp) {
      res["SourceIp"] = boost::any(*sourceIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MemberAccountId") != m.end() && !m["MemberAccountId"].empty()) {
      memberAccountId = make_shared<string>(boost::any_cast<string>(m["MemberAccountId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("SourceIp") != m.end() && !m["SourceIp"].empty()) {
      sourceIp = make_shared<string>(boost::any_cast<string>(m["SourceIp"]));
    }
  }


  virtual ~ModifyMemberAccountRequest() = default;
};
class ModifyMemberAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyMemberAccountResponseBody() {}

  explicit ModifyMemberAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyMemberAccountResponseBody() = default;
};
class ModifyMemberAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyMemberAccountResponseBody> body{};

  ModifyMemberAccountResponse() {}

  explicit ModifyMemberAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyMemberAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyMemberAccountResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyMemberAccountResponse() = default;
};
class ModifyPauseProtectionStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pauseStatus{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ModifyPauseProtectionStatusRequest() {}

  explicit ModifyPauseProtectionStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pauseStatus) {
      res["PauseStatus"] = boost::any(*pauseStatus);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PauseStatus") != m.end() && !m["PauseStatus"].empty()) {
      pauseStatus = make_shared<long>(boost::any_cast<long>(m["PauseStatus"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ModifyPauseProtectionStatusRequest() = default;
};
class ModifyPauseProtectionStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPauseProtectionStatusResponseBody() {}

  explicit ModifyPauseProtectionStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPauseProtectionStatusResponseBody() = default;
};
class ModifyPauseProtectionStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPauseProtectionStatusResponseBody> body{};

  ModifyPauseProtectionStatusResponse() {}

  explicit ModifyPauseProtectionStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPauseProtectionStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPauseProtectionStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPauseProtectionStatusResponse() = default;
};
class ModifyResourceLogStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resource{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<bool> status{};

  ModifyResourceLogStatusRequest() {}

  explicit ModifyResourceLogStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resource) {
      res["Resource"] = boost::any(*resource);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      resource = make_shared<string>(boost::any_cast<string>(m["Resource"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~ModifyResourceLogStatusRequest() = default;
};
class ModifyResourceLogStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> status{};

  ModifyResourceLogStatusResponseBody() {}

  explicit ModifyResourceLogStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
  }


  virtual ~ModifyResourceLogStatusResponseBody() = default;
};
class ModifyResourceLogStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyResourceLogStatusResponseBody> body{};

  ModifyResourceLogStatusResponse() {}

  explicit ModifyResourceLogStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyResourceLogStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyResourceLogStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyResourceLogStatusResponse() = default;
};
class ModifyTemplateResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> bindResourceGroups{};
  shared_ptr<vector<string>> bindResources{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<long> templateId{};
  shared_ptr<vector<string>> unbindResourceGroups{};
  shared_ptr<vector<string>> unbindResources{};

  ModifyTemplateResourcesRequest() {}

  explicit ModifyTemplateResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindResourceGroups) {
      res["BindResourceGroups"] = boost::any(*bindResourceGroups);
    }
    if (bindResources) {
      res["BindResources"] = boost::any(*bindResources);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (unbindResourceGroups) {
      res["UnbindResourceGroups"] = boost::any(*unbindResourceGroups);
    }
    if (unbindResources) {
      res["UnbindResources"] = boost::any(*unbindResources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindResourceGroups") != m.end() && !m["BindResourceGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BindResourceGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BindResourceGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bindResourceGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BindResources") != m.end() && !m["BindResources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BindResources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BindResources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bindResources = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["TemplateId"]));
    }
    if (m.find("UnbindResourceGroups") != m.end() && !m["UnbindResourceGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnbindResourceGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnbindResourceGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unbindResourceGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UnbindResources") != m.end() && !m["UnbindResources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UnbindResources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UnbindResources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      unbindResources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyTemplateResourcesRequest() = default;
};
class ModifyTemplateResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTemplateResourcesResponseBody() {}

  explicit ModifyTemplateResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTemplateResourcesResponseBody() = default;
};
class ModifyTemplateResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTemplateResourcesResponseBody> body{};

  ModifyTemplateResourcesResponse() {}

  explicit ModifyTemplateResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTemplateResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTemplateResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTemplateResourcesResponse() = default;
};
class ReCreateCloudResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceInstanceId{};
  shared_ptr<string> resourceManagerResourceGroupId{};
  shared_ptr<string> resourceProduct{};

  ReCreateCloudResourceRequest() {}

  explicit ReCreateCloudResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceInstanceId) {
      res["ResourceInstanceId"] = boost::any(*resourceInstanceId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    if (resourceProduct) {
      res["ResourceProduct"] = boost::any(*resourceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceInstanceId") != m.end() && !m["ResourceInstanceId"].empty()) {
      resourceInstanceId = make_shared<string>(boost::any_cast<string>(m["ResourceInstanceId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
    if (m.find("ResourceProduct") != m.end() && !m["ResourceProduct"].empty()) {
      resourceProduct = make_shared<string>(boost::any_cast<string>(m["ResourceProduct"]));
    }
  }


  virtual ~ReCreateCloudResourceRequest() = default;
};
class ReCreateCloudResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReCreateCloudResourceResponseBody() {}

  explicit ReCreateCloudResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReCreateCloudResourceResponseBody() = default;
};
class ReCreateCloudResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReCreateCloudResourceResponseBody> body{};

  ReCreateCloudResourceResponse() {}

  explicit ReCreateCloudResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReCreateCloudResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReCreateCloudResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ReCreateCloudResourceResponse() = default;
};
class ReleaseInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  ReleaseInstanceRequest() {}

  explicit ReleaseInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~ReleaseInstanceRequest() = default;
};
class ReleaseInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReleaseInstanceResponseBody() {}

  explicit ReleaseInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseInstanceResponseBody() = default;
};
class ReleaseInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseInstanceResponseBody> body{};

  ReleaseInstanceResponse() {}

  explicit ReleaseInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseInstanceResponse() = default;
};
class SyncProductInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceManagerResourceGroupId{};

  SyncProductInstanceRequest() {}

  explicit SyncProductInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceManagerResourceGroupId) {
      res["ResourceManagerResourceGroupId"] = boost::any(*resourceManagerResourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceManagerResourceGroupId") != m.end() && !m["ResourceManagerResourceGroupId"].empty()) {
      resourceManagerResourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceManagerResourceGroupId"]));
    }
  }


  virtual ~SyncProductInstanceRequest() = default;
};
class SyncProductInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SyncProductInstanceResponseBody() {}

  explicit SyncProductInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SyncProductInstanceResponseBody() = default;
};
class SyncProductInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncProductInstanceResponseBody> body{};

  SyncProductInstanceResponse() {}

  explicit SyncProductInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncProductInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncProductInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~SyncProductInstanceResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  ClearMajorProtectionBlackIpResponse clearMajorProtectionBlackIpWithOptions(shared_ptr<ClearMajorProtectionBlackIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearMajorProtectionBlackIpResponse clearMajorProtectionBlackIp(shared_ptr<ClearMajorProtectionBlackIpRequest> request);
  CopyDefenseTemplateResponse copyDefenseTemplateWithOptions(shared_ptr<CopyDefenseTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyDefenseTemplateResponse copyDefenseTemplate(shared_ptr<CopyDefenseTemplateRequest> request);
  CreateApiExportResponse createApiExportWithOptions(shared_ptr<CreateApiExportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiExportResponse createApiExport(shared_ptr<CreateApiExportRequest> request);
  CreateCloudResourceResponse createCloudResourceWithOptions(shared_ptr<CreateCloudResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudResourceResponse createCloudResource(shared_ptr<CreateCloudResourceRequest> request);
  CreateDefenseResourceResponse createDefenseResourceWithOptions(shared_ptr<CreateDefenseResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefenseResourceResponse createDefenseResource(shared_ptr<CreateDefenseResourceRequest> request);
  CreateDefenseResourceGroupResponse createDefenseResourceGroupWithOptions(shared_ptr<CreateDefenseResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefenseResourceGroupResponse createDefenseResourceGroup(shared_ptr<CreateDefenseResourceGroupRequest> request);
  CreateDefenseRuleResponse createDefenseRuleWithOptions(shared_ptr<CreateDefenseRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefenseRuleResponse createDefenseRule(shared_ptr<CreateDefenseRuleRequest> request);
  CreateDefenseTemplateResponse createDefenseTemplateWithOptions(shared_ptr<CreateDefenseTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDefenseTemplateResponse createDefenseTemplate(shared_ptr<CreateDefenseTemplateRequest> request);
  CreateDomainResponse createDomainWithOptions(shared_ptr<CreateDomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDomainResponse createDomain(shared_ptr<CreateDomainRequest> request);
  CreateHybridCloudGroupResponse createHybridCloudGroupWithOptions(shared_ptr<CreateHybridCloudGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHybridCloudGroupResponse createHybridCloudGroup(shared_ptr<CreateHybridCloudGroupRequest> request);
  CreateMajorProtectionBlackIpResponse createMajorProtectionBlackIpWithOptions(shared_ptr<CreateMajorProtectionBlackIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMajorProtectionBlackIpResponse createMajorProtectionBlackIp(shared_ptr<CreateMajorProtectionBlackIpRequest> request);
  CreateMemberAccountsResponse createMemberAccountsWithOptions(shared_ptr<CreateMemberAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMemberAccountsResponse createMemberAccounts(shared_ptr<CreateMemberAccountsRequest> request);
  CreatePostpaidInstanceResponse createPostpaidInstanceWithOptions(shared_ptr<CreatePostpaidInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePostpaidInstanceResponse createPostpaidInstance(shared_ptr<CreatePostpaidInstanceRequest> request);
  CreateSM2CertResponse createSM2CertWithOptions(shared_ptr<CreateSM2CertRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSM2CertResponse createSM2Cert(shared_ptr<CreateSM2CertRequest> request);
  DeleteApisecAbnormalsResponse deleteApisecAbnormalsWithOptions(shared_ptr<DeleteApisecAbnormalsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApisecAbnormalsResponse deleteApisecAbnormals(shared_ptr<DeleteApisecAbnormalsRequest> request);
  DeleteApisecEventsResponse deleteApisecEventsWithOptions(shared_ptr<DeleteApisecEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApisecEventsResponse deleteApisecEvents(shared_ptr<DeleteApisecEventsRequest> request);
  DeleteCloudResourceResponse deleteCloudResourceWithOptions(shared_ptr<DeleteCloudResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudResourceResponse deleteCloudResource(shared_ptr<DeleteCloudResourceRequest> request);
  DeleteDefenseResourceResponse deleteDefenseResourceWithOptions(shared_ptr<DeleteDefenseResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDefenseResourceResponse deleteDefenseResource(shared_ptr<DeleteDefenseResourceRequest> request);
  DeleteDefenseResourceGroupResponse deleteDefenseResourceGroupWithOptions(shared_ptr<DeleteDefenseResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDefenseResourceGroupResponse deleteDefenseResourceGroup(shared_ptr<DeleteDefenseResourceGroupRequest> request);
  DeleteDefenseRuleResponse deleteDefenseRuleWithOptions(shared_ptr<DeleteDefenseRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDefenseRuleResponse deleteDefenseRule(shared_ptr<DeleteDefenseRuleRequest> request);
  DeleteDefenseTemplateResponse deleteDefenseTemplateWithOptions(shared_ptr<DeleteDefenseTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDefenseTemplateResponse deleteDefenseTemplate(shared_ptr<DeleteDefenseTemplateRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteMajorProtectionBlackIpResponse deleteMajorProtectionBlackIpWithOptions(shared_ptr<DeleteMajorProtectionBlackIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMajorProtectionBlackIpResponse deleteMajorProtectionBlackIp(shared_ptr<DeleteMajorProtectionBlackIpRequest> request);
  DeleteMemberAccountResponse deleteMemberAccountWithOptions(shared_ptr<DeleteMemberAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMemberAccountResponse deleteMemberAccount(shared_ptr<DeleteMemberAccountRequest> request);
  DescribeAbnormalCloudResourcesResponse describeAbnormalCloudResourcesWithOptions(shared_ptr<DescribeAbnormalCloudResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAbnormalCloudResourcesResponse describeAbnormalCloudResources(shared_ptr<DescribeAbnormalCloudResourcesRequest> request);
  DescribeAccountDelegatedStatusResponse describeAccountDelegatedStatusWithOptions(shared_ptr<DescribeAccountDelegatedStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccountDelegatedStatusResponse describeAccountDelegatedStatus(shared_ptr<DescribeAccountDelegatedStatusRequest> request);
  DescribeApiExportsResponse describeApiExportsWithOptions(shared_ptr<DescribeApiExportsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiExportsResponse describeApiExports(shared_ptr<DescribeApiExportsRequest> request);
  DescribeApisecAbnormalDomainStatisticResponse describeApisecAbnormalDomainStatisticWithOptions(shared_ptr<DescribeApisecAbnormalDomainStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecAbnormalDomainStatisticResponse describeApisecAbnormalDomainStatistic(shared_ptr<DescribeApisecAbnormalDomainStatisticRequest> request);
  DescribeApisecAbnormalsResponse describeApisecAbnormalsWithOptions(shared_ptr<DescribeApisecAbnormalsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecAbnormalsResponse describeApisecAbnormals(shared_ptr<DescribeApisecAbnormalsRequest> request);
  DescribeApisecApiResourcesResponse describeApisecApiResourcesWithOptions(shared_ptr<DescribeApisecApiResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecApiResourcesResponse describeApisecApiResources(shared_ptr<DescribeApisecApiResourcesRequest> request);
  DescribeApisecAssetTrendResponse describeApisecAssetTrendWithOptions(shared_ptr<DescribeApisecAssetTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecAssetTrendResponse describeApisecAssetTrend(shared_ptr<DescribeApisecAssetTrendRequest> request);
  DescribeApisecEventDomainStatisticResponse describeApisecEventDomainStatisticWithOptions(shared_ptr<DescribeApisecEventDomainStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecEventDomainStatisticResponse describeApisecEventDomainStatistic(shared_ptr<DescribeApisecEventDomainStatisticRequest> request);
  DescribeApisecEventsResponse describeApisecEventsWithOptions(shared_ptr<DescribeApisecEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecEventsResponse describeApisecEvents(shared_ptr<DescribeApisecEventsRequest> request);
  DescribeApisecLogDeliveriesResponse describeApisecLogDeliveriesWithOptions(shared_ptr<DescribeApisecLogDeliveriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecLogDeliveriesResponse describeApisecLogDeliveries(shared_ptr<DescribeApisecLogDeliveriesRequest> request);
  DescribeApisecMatchedHostsResponse describeApisecMatchedHostsWithOptions(shared_ptr<DescribeApisecMatchedHostsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecMatchedHostsResponse describeApisecMatchedHosts(shared_ptr<DescribeApisecMatchedHostsRequest> request);
  DescribeApisecProtectionGroupsResponse describeApisecProtectionGroupsWithOptions(shared_ptr<DescribeApisecProtectionGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecProtectionGroupsResponse describeApisecProtectionGroups(shared_ptr<DescribeApisecProtectionGroupsRequest> request);
  DescribeApisecProtectionResourcesResponse describeApisecProtectionResourcesWithOptions(shared_ptr<DescribeApisecProtectionResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecProtectionResourcesResponse describeApisecProtectionResources(shared_ptr<DescribeApisecProtectionResourcesRequest> request);
  DescribeApisecRulesResponse describeApisecRulesWithOptions(shared_ptr<DescribeApisecRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecRulesResponse describeApisecRules(shared_ptr<DescribeApisecRulesRequest> request);
  DescribeApisecSensitiveDomainStatisticResponse describeApisecSensitiveDomainStatisticWithOptions(shared_ptr<DescribeApisecSensitiveDomainStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecSensitiveDomainStatisticResponse describeApisecSensitiveDomainStatistic(shared_ptr<DescribeApisecSensitiveDomainStatisticRequest> request);
  DescribeApisecSlsLogStoresResponse describeApisecSlsLogStoresWithOptions(shared_ptr<DescribeApisecSlsLogStoresRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecSlsLogStoresResponse describeApisecSlsLogStores(shared_ptr<DescribeApisecSlsLogStoresRequest> request);
  DescribeApisecSlsProjectsResponse describeApisecSlsProjectsWithOptions(shared_ptr<DescribeApisecSlsProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecSlsProjectsResponse describeApisecSlsProjects(shared_ptr<DescribeApisecSlsProjectsRequest> request);
  DescribeApisecStatisticsResponse describeApisecStatisticsWithOptions(shared_ptr<DescribeApisecStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecStatisticsResponse describeApisecStatistics(shared_ptr<DescribeApisecStatisticsRequest> request);
  DescribeApisecSuggestionsResponse describeApisecSuggestionsWithOptions(shared_ptr<DescribeApisecSuggestionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecSuggestionsResponse describeApisecSuggestions(shared_ptr<DescribeApisecSuggestionsRequest> request);
  DescribeApisecUserOperationsResponse describeApisecUserOperationsWithOptions(shared_ptr<DescribeApisecUserOperationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisecUserOperationsResponse describeApisecUserOperations(shared_ptr<DescribeApisecUserOperationsRequest> request);
  DescribeCertDetailResponse describeCertDetailWithOptions(shared_ptr<DescribeCertDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCertDetailResponse describeCertDetail(shared_ptr<DescribeCertDetailRequest> request);
  DescribeCertsResponse describeCertsWithOptions(shared_ptr<DescribeCertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCertsResponse describeCerts(shared_ptr<DescribeCertsRequest> request);
  DescribeCloudResourceAccessPortDetailsResponse describeCloudResourceAccessPortDetailsWithOptions(shared_ptr<DescribeCloudResourceAccessPortDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudResourceAccessPortDetailsResponse describeCloudResourceAccessPortDetails(shared_ptr<DescribeCloudResourceAccessPortDetailsRequest> request);
  DescribeCloudResourceAccessedPortsResponse describeCloudResourceAccessedPortsWithOptions(shared_ptr<DescribeCloudResourceAccessedPortsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudResourceAccessedPortsResponse describeCloudResourceAccessedPorts(shared_ptr<DescribeCloudResourceAccessedPortsRequest> request);
  DescribeCloudResourcesResponse describeCloudResourcesWithOptions(shared_ptr<DescribeCloudResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudResourcesResponse describeCloudResources(shared_ptr<DescribeCloudResourcesRequest> request);
  DescribeCnameCountResponse describeCnameCountWithOptions(shared_ptr<DescribeCnameCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCnameCountResponse describeCnameCount(shared_ptr<DescribeCnameCountRequest> request);
  DescribeDDoSStatusResponse describeDDoSStatusWithOptions(shared_ptr<DescribeDDoSStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDDoSStatusResponse describeDDoSStatus(shared_ptr<DescribeDDoSStatusRequest> request);
  DescribeDefaultHttpsResponse describeDefaultHttpsWithOptions(shared_ptr<DescribeDefaultHttpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefaultHttpsResponse describeDefaultHttps(shared_ptr<DescribeDefaultHttpsRequest> request);
  DescribeDefenseResourceResponse describeDefenseResourceWithOptions(shared_ptr<DescribeDefenseResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceResponse describeDefenseResource(shared_ptr<DescribeDefenseResourceRequest> request);
  DescribeDefenseResourceGroupResponse describeDefenseResourceGroupWithOptions(shared_ptr<DescribeDefenseResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceGroupResponse describeDefenseResourceGroup(shared_ptr<DescribeDefenseResourceGroupRequest> request);
  DescribeDefenseResourceGroupNamesResponse describeDefenseResourceGroupNamesWithOptions(shared_ptr<DescribeDefenseResourceGroupNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceGroupNamesResponse describeDefenseResourceGroupNames(shared_ptr<DescribeDefenseResourceGroupNamesRequest> request);
  DescribeDefenseResourceGroupsResponse describeDefenseResourceGroupsWithOptions(shared_ptr<DescribeDefenseResourceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceGroupsResponse describeDefenseResourceGroups(shared_ptr<DescribeDefenseResourceGroupsRequest> request);
  DescribeDefenseResourceNamesResponse describeDefenseResourceNamesWithOptions(shared_ptr<DescribeDefenseResourceNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceNamesResponse describeDefenseResourceNames(shared_ptr<DescribeDefenseResourceNamesRequest> request);
  DescribeDefenseResourceTemplatesResponse describeDefenseResourceTemplatesWithOptions(shared_ptr<DescribeDefenseResourceTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourceTemplatesResponse describeDefenseResourceTemplates(shared_ptr<DescribeDefenseResourceTemplatesRequest> request);
  DescribeDefenseResourcesResponse describeDefenseResourcesWithOptions(shared_ptr<DescribeDefenseResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseResourcesResponse describeDefenseResources(shared_ptr<DescribeDefenseResourcesRequest> request);
  DescribeDefenseRuleResponse describeDefenseRuleWithOptions(shared_ptr<DescribeDefenseRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseRuleResponse describeDefenseRule(shared_ptr<DescribeDefenseRuleRequest> request);
  DescribeDefenseRulesResponse describeDefenseRulesWithOptions(shared_ptr<DescribeDefenseRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseRulesResponse describeDefenseRules(shared_ptr<DescribeDefenseRulesRequest> request);
  DescribeDefenseTemplateResponse describeDefenseTemplateWithOptions(shared_ptr<DescribeDefenseTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseTemplateResponse describeDefenseTemplate(shared_ptr<DescribeDefenseTemplateRequest> request);
  DescribeDefenseTemplateValidGroupsResponse describeDefenseTemplateValidGroupsWithOptions(shared_ptr<DescribeDefenseTemplateValidGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseTemplateValidGroupsResponse describeDefenseTemplateValidGroups(shared_ptr<DescribeDefenseTemplateValidGroupsRequest> request);
  DescribeDefenseTemplatesResponse describeDefenseTemplatesWithOptions(shared_ptr<DescribeDefenseTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefenseTemplatesResponse describeDefenseTemplates(shared_ptr<DescribeDefenseTemplatesRequest> request);
  DescribeDomainDNSRecordResponse describeDomainDNSRecordWithOptions(shared_ptr<DescribeDomainDNSRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDNSRecordResponse describeDomainDNSRecord(shared_ptr<DescribeDomainDNSRecordRequest> request);
  DescribeDomainDetailResponse describeDomainDetailWithOptions(shared_ptr<DescribeDomainDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainDetailResponse describeDomainDetail(shared_ptr<DescribeDomainDetailRequest> request);
  DescribeDomainsResponse describeDomainsWithOptions(shared_ptr<DescribeDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainsResponse describeDomains(shared_ptr<DescribeDomainsRequest> request);
  DescribeFlowChartResponse describeFlowChartWithOptions(shared_ptr<DescribeFlowChartRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowChartResponse describeFlowChart(shared_ptr<DescribeFlowChartRequest> request);
  DescribeFlowTopResourceResponse describeFlowTopResourceWithOptions(shared_ptr<DescribeFlowTopResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowTopResourceResponse describeFlowTopResource(shared_ptr<DescribeFlowTopResourceRequest> request);
  DescribeFlowTopUrlResponse describeFlowTopUrlWithOptions(shared_ptr<DescribeFlowTopUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowTopUrlResponse describeFlowTopUrl(shared_ptr<DescribeFlowTopUrlRequest> request);
  DescribeFreeUserAssetCountResponse describeFreeUserAssetCountWithOptions(shared_ptr<DescribeFreeUserAssetCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFreeUserAssetCountResponse describeFreeUserAssetCount(shared_ptr<DescribeFreeUserAssetCountRequest> request);
  DescribeFreeUserEventCountResponse describeFreeUserEventCountWithOptions(shared_ptr<DescribeFreeUserEventCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFreeUserEventCountResponse describeFreeUserEventCount(shared_ptr<DescribeFreeUserEventCountRequest> request);
  DescribeFreeUserEventTypesResponse describeFreeUserEventTypesWithOptions(shared_ptr<DescribeFreeUserEventTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFreeUserEventTypesResponse describeFreeUserEventTypes(shared_ptr<DescribeFreeUserEventTypesRequest> request);
  DescribeFreeUserEventsResponse describeFreeUserEventsWithOptions(shared_ptr<DescribeFreeUserEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFreeUserEventsResponse describeFreeUserEvents(shared_ptr<DescribeFreeUserEventsRequest> request);
  DescribeHybridCloudClusterRuleResponse describeHybridCloudClusterRuleWithOptions(shared_ptr<DescribeHybridCloudClusterRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudClusterRuleResponse describeHybridCloudClusterRule(shared_ptr<DescribeHybridCloudClusterRuleRequest> request);
  DescribeHybridCloudClustersResponse describeHybridCloudClustersWithOptions(shared_ptr<DescribeHybridCloudClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudClustersResponse describeHybridCloudClusters(shared_ptr<DescribeHybridCloudClustersRequest> request);
  DescribeHybridCloudGroupsResponse describeHybridCloudGroupsWithOptions(shared_ptr<DescribeHybridCloudGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudGroupsResponse describeHybridCloudGroups(shared_ptr<DescribeHybridCloudGroupsRequest> request);
  DescribeHybridCloudResourcesResponse describeHybridCloudResourcesWithOptions(shared_ptr<DescribeHybridCloudResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudResourcesResponse describeHybridCloudResources(shared_ptr<DescribeHybridCloudResourcesRequest> request);
  DescribeHybridCloudServerRegionsResponse describeHybridCloudServerRegionsWithOptions(shared_ptr<DescribeHybridCloudServerRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudServerRegionsResponse describeHybridCloudServerRegions(shared_ptr<DescribeHybridCloudServerRegionsRequest> request);
  DescribeHybridCloudUnassignedMachinesResponse describeHybridCloudUnassignedMachinesWithOptions(shared_ptr<DescribeHybridCloudUnassignedMachinesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudUnassignedMachinesResponse describeHybridCloudUnassignedMachines(shared_ptr<DescribeHybridCloudUnassignedMachinesRequest> request);
  DescribeHybridCloudUserResponse describeHybridCloudUserWithOptions(shared_ptr<DescribeHybridCloudUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHybridCloudUserResponse describeHybridCloudUser(shared_ptr<DescribeHybridCloudUserRequest> request);
  DescribeInstanceResponse describeInstanceWithOptions(shared_ptr<DescribeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceResponse describeInstance(shared_ptr<DescribeInstanceRequest> request);
  DescribeIpAbroadCountryInfosResponse describeIpAbroadCountryInfosWithOptions(shared_ptr<DescribeIpAbroadCountryInfosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpAbroadCountryInfosResponse describeIpAbroadCountryInfos(shared_ptr<DescribeIpAbroadCountryInfosRequest> request);
  DescribeMajorProtectionBlackIpsResponse describeMajorProtectionBlackIpsWithOptions(shared_ptr<DescribeMajorProtectionBlackIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMajorProtectionBlackIpsResponse describeMajorProtectionBlackIps(shared_ptr<DescribeMajorProtectionBlackIpsRequest> request);
  DescribeMemberAccountsResponse describeMemberAccountsWithOptions(shared_ptr<DescribeMemberAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMemberAccountsResponse describeMemberAccounts(shared_ptr<DescribeMemberAccountsRequest> request);
  DescribeNetworkFlowTimeSeriesMetricResponse describeNetworkFlowTimeSeriesMetricWithOptions(shared_ptr<DescribeNetworkFlowTimeSeriesMetricRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkFlowTimeSeriesMetricResponse describeNetworkFlowTimeSeriesMetric(shared_ptr<DescribeNetworkFlowTimeSeriesMetricRequest> request);
  DescribeNetworkFlowTopNMetricResponse describeNetworkFlowTopNMetricWithOptions(shared_ptr<DescribeNetworkFlowTopNMetricRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetworkFlowTopNMetricResponse describeNetworkFlowTopNMetric(shared_ptr<DescribeNetworkFlowTopNMetricRequest> request);
  DescribePauseProtectionStatusResponse describePauseProtectionStatusWithOptions(shared_ptr<DescribePauseProtectionStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePauseProtectionStatusResponse describePauseProtectionStatus(shared_ptr<DescribePauseProtectionStatusRequest> request);
  DescribePeakTrendResponse describePeakTrendWithOptions(shared_ptr<DescribePeakTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePeakTrendResponse describePeakTrend(shared_ptr<DescribePeakTrendRequest> request);
  DescribeProductInstancesResponse describeProductInstancesWithOptions(shared_ptr<DescribeProductInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProductInstancesResponse describeProductInstances(shared_ptr<DescribeProductInstancesRequest> request);
  DescribePunishedDomainsResponse describePunishedDomainsWithOptions(shared_ptr<DescribePunishedDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePunishedDomainsResponse describePunishedDomains(shared_ptr<DescribePunishedDomainsRequest> request);
  DescribeResourceInstanceCertsResponse describeResourceInstanceCertsWithOptions(shared_ptr<DescribeResourceInstanceCertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceInstanceCertsResponse describeResourceInstanceCerts(shared_ptr<DescribeResourceInstanceCertsRequest> request);
  DescribeResourceLogStatusResponse describeResourceLogStatusWithOptions(shared_ptr<DescribeResourceLogStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceLogStatusResponse describeResourceLogStatus(shared_ptr<DescribeResourceLogStatusRequest> request);
  DescribeResourcePortResponse describeResourcePortWithOptions(shared_ptr<DescribeResourcePortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourcePortResponse describeResourcePort(shared_ptr<DescribeResourcePortRequest> request);
  DescribeResourceRegionIdResponse describeResourceRegionIdWithOptions(shared_ptr<DescribeResourceRegionIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceRegionIdResponse describeResourceRegionId(shared_ptr<DescribeResourceRegionIdRequest> request);
  DescribeResourceSupportRegionsResponse describeResourceSupportRegionsWithOptions(shared_ptr<DescribeResourceSupportRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceSupportRegionsResponse describeResourceSupportRegions(shared_ptr<DescribeResourceSupportRegionsRequest> request);
  DescribeResponseCodeTrendGraphResponse describeResponseCodeTrendGraphWithOptions(shared_ptr<DescribeResponseCodeTrendGraphRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResponseCodeTrendGraphResponse describeResponseCodeTrendGraph(shared_ptr<DescribeResponseCodeTrendGraphRequest> request);
  DescribeRuleGroupsResponse describeRuleGroupsWithOptions(shared_ptr<DescribeRuleGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleGroupsResponse describeRuleGroups(shared_ptr<DescribeRuleGroupsRequest> request);
  DescribeRuleHitsTopClientIpResponse describeRuleHitsTopClientIpWithOptions(shared_ptr<DescribeRuleHitsTopClientIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopClientIpResponse describeRuleHitsTopClientIp(shared_ptr<DescribeRuleHitsTopClientIpRequest> request);
  DescribeRuleHitsTopResourceResponse describeRuleHitsTopResourceWithOptions(shared_ptr<DescribeRuleHitsTopResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopResourceResponse describeRuleHitsTopResource(shared_ptr<DescribeRuleHitsTopResourceRequest> request);
  DescribeRuleHitsTopRuleIdResponse describeRuleHitsTopRuleIdWithOptions(shared_ptr<DescribeRuleHitsTopRuleIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopRuleIdResponse describeRuleHitsTopRuleId(shared_ptr<DescribeRuleHitsTopRuleIdRequest> request);
  DescribeRuleHitsTopTuleTypeResponse describeRuleHitsTopTuleTypeWithOptions(shared_ptr<DescribeRuleHitsTopTuleTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopTuleTypeResponse describeRuleHitsTopTuleType(shared_ptr<DescribeRuleHitsTopTuleTypeRequest> request);
  DescribeRuleHitsTopUaResponse describeRuleHitsTopUaWithOptions(shared_ptr<DescribeRuleHitsTopUaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopUaResponse describeRuleHitsTopUa(shared_ptr<DescribeRuleHitsTopUaRequest> request);
  DescribeRuleHitsTopUrlResponse describeRuleHitsTopUrlWithOptions(shared_ptr<DescribeRuleHitsTopUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRuleHitsTopUrlResponse describeRuleHitsTopUrl(shared_ptr<DescribeRuleHitsTopUrlRequest> request);
  DescribeSecurityEventLogsResponse describeSecurityEventLogsWithOptions(shared_ptr<DescribeSecurityEventLogsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventLogsResponse describeSecurityEventLogs(shared_ptr<DescribeSecurityEventLogsRequest> request);
  DescribeSecurityEventTimeSeriesMetricResponse describeSecurityEventTimeSeriesMetricWithOptions(shared_ptr<DescribeSecurityEventTimeSeriesMetricRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventTimeSeriesMetricResponse describeSecurityEventTimeSeriesMetric(shared_ptr<DescribeSecurityEventTimeSeriesMetricRequest> request);
  DescribeSecurityEventTopNMetricResponse describeSecurityEventTopNMetricWithOptions(shared_ptr<DescribeSecurityEventTopNMetricRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityEventTopNMetricResponse describeSecurityEventTopNMetric(shared_ptr<DescribeSecurityEventTopNMetricRequest> request);
  DescribeSensitiveApiStatisticResponse describeSensitiveApiStatisticWithOptions(shared_ptr<DescribeSensitiveApiStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveApiStatisticResponse describeSensitiveApiStatistic(shared_ptr<DescribeSensitiveApiStatisticRequest> request);
  DescribeSensitiveDetectionResultResponse describeSensitiveDetectionResultWithOptions(shared_ptr<DescribeSensitiveDetectionResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveDetectionResultResponse describeSensitiveDetectionResult(shared_ptr<DescribeSensitiveDetectionResultRequest> request);
  DescribeSensitiveOutboundDistributionResponse describeSensitiveOutboundDistributionWithOptions(shared_ptr<DescribeSensitiveOutboundDistributionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveOutboundDistributionResponse describeSensitiveOutboundDistribution(shared_ptr<DescribeSensitiveOutboundDistributionRequest> request);
  DescribeSensitiveOutboundStatisticResponse describeSensitiveOutboundStatisticWithOptions(shared_ptr<DescribeSensitiveOutboundStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveOutboundStatisticResponse describeSensitiveOutboundStatistic(shared_ptr<DescribeSensitiveOutboundStatisticRequest> request);
  DescribeSensitiveOutboundTrendResponse describeSensitiveOutboundTrendWithOptions(shared_ptr<DescribeSensitiveOutboundTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveOutboundTrendResponse describeSensitiveOutboundTrend(shared_ptr<DescribeSensitiveOutboundTrendRequest> request);
  DescribeSensitiveRequestLogResponse describeSensitiveRequestLogWithOptions(shared_ptr<DescribeSensitiveRequestLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveRequestLogResponse describeSensitiveRequestLog(shared_ptr<DescribeSensitiveRequestLogRequest> request);
  DescribeSensitiveRequestsResponse describeSensitiveRequestsWithOptions(shared_ptr<DescribeSensitiveRequestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveRequestsResponse describeSensitiveRequests(shared_ptr<DescribeSensitiveRequestsRequest> request);
  DescribeSensitiveStatisticResponse describeSensitiveStatisticWithOptions(shared_ptr<DescribeSensitiveStatisticRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSensitiveStatisticResponse describeSensitiveStatistic(shared_ptr<DescribeSensitiveStatisticRequest> request);
  DescribeSlsAuthStatusResponse describeSlsAuthStatusWithOptions(shared_ptr<DescribeSlsAuthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsAuthStatusResponse describeSlsAuthStatus(shared_ptr<DescribeSlsAuthStatusRequest> request);
  DescribeSlsLogStoreResponse describeSlsLogStoreWithOptions(shared_ptr<DescribeSlsLogStoreRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsLogStoreResponse describeSlsLogStore(shared_ptr<DescribeSlsLogStoreRequest> request);
  DescribeSlsLogStoreStatusResponse describeSlsLogStoreStatusWithOptions(shared_ptr<DescribeSlsLogStoreStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlsLogStoreStatusResponse describeSlsLogStoreStatus(shared_ptr<DescribeSlsLogStoreStatusRequest> request);
  DescribeTemplateResourceCountResponse describeTemplateResourceCountWithOptions(shared_ptr<DescribeTemplateResourceCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateResourceCountResponse describeTemplateResourceCount(shared_ptr<DescribeTemplateResourceCountRequest> request);
  DescribeTemplateResourcesResponse describeTemplateResourcesWithOptions(shared_ptr<DescribeTemplateResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplateResourcesResponse describeTemplateResources(shared_ptr<DescribeTemplateResourcesRequest> request);
  DescribeUserAbnormalTrendResponse describeUserAbnormalTrendWithOptions(shared_ptr<DescribeUserAbnormalTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserAbnormalTrendResponse describeUserAbnormalTrend(shared_ptr<DescribeUserAbnormalTrendRequest> request);
  DescribeUserAbnormalTypeResponse describeUserAbnormalTypeWithOptions(shared_ptr<DescribeUserAbnormalTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserAbnormalTypeResponse describeUserAbnormalType(shared_ptr<DescribeUserAbnormalTypeRequest> request);
  DescribeUserApiRequestResponse describeUserApiRequestWithOptions(shared_ptr<DescribeUserApiRequestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserApiRequestResponse describeUserApiRequest(shared_ptr<DescribeUserApiRequestRequest> request);
  DescribeUserAssetResponse describeUserAssetWithOptions(shared_ptr<DescribeUserAssetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserAssetResponse describeUserAsset(shared_ptr<DescribeUserAssetRequest> request);
  DescribeUserEventTrendResponse describeUserEventTrendWithOptions(shared_ptr<DescribeUserEventTrendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserEventTrendResponse describeUserEventTrend(shared_ptr<DescribeUserEventTrendRequest> request);
  DescribeUserEventTypeResponse describeUserEventTypeWithOptions(shared_ptr<DescribeUserEventTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserEventTypeResponse describeUserEventType(shared_ptr<DescribeUserEventTypeRequest> request);
  DescribeUserSlsLogRegionsResponse describeUserSlsLogRegionsWithOptions(shared_ptr<DescribeUserSlsLogRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserSlsLogRegionsResponse describeUserSlsLogRegions(shared_ptr<DescribeUserSlsLogRegionsRequest> request);
  DescribeUserWafLogStatusResponse describeUserWafLogStatusWithOptions(shared_ptr<DescribeUserWafLogStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserWafLogStatusResponse describeUserWafLogStatus(shared_ptr<DescribeUserWafLogStatusRequest> request);
  DescribeVisitTopIpResponse describeVisitTopIpWithOptions(shared_ptr<DescribeVisitTopIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVisitTopIpResponse describeVisitTopIp(shared_ptr<DescribeVisitTopIpRequest> request);
  DescribeVisitUasResponse describeVisitUasWithOptions(shared_ptr<DescribeVisitUasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVisitUasResponse describeVisitUas(shared_ptr<DescribeVisitUasRequest> request);
  DescribeWafSourceIpSegmentResponse describeWafSourceIpSegmentWithOptions(shared_ptr<DescribeWafSourceIpSegmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeWafSourceIpSegmentResponse describeWafSourceIpSegment(shared_ptr<DescribeWafSourceIpSegmentRequest> request);
  ListTagKeysResponse listTagKeysWithOptions(shared_ptr<ListTagKeysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagKeysResponse listTagKeys(shared_ptr<ListTagKeysRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagValuesResponse listTagValuesWithOptions(shared_ptr<ListTagValuesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagValuesResponse listTagValues(shared_ptr<ListTagValuesRequest> request);
  ModifyApisecAbnormalsResponse modifyApisecAbnormalsWithOptions(shared_ptr<ModifyApisecAbnormalsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecAbnormalsResponse modifyApisecAbnormals(shared_ptr<ModifyApisecAbnormalsRequest> request);
  ModifyApisecApiResourceResponse modifyApisecApiResourceWithOptions(shared_ptr<ModifyApisecApiResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecApiResourceResponse modifyApisecApiResource(shared_ptr<ModifyApisecApiResourceRequest> request);
  ModifyApisecEventsResponse modifyApisecEventsWithOptions(shared_ptr<ModifyApisecEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecEventsResponse modifyApisecEvents(shared_ptr<ModifyApisecEventsRequest> request);
  ModifyApisecLogDeliveryResponse modifyApisecLogDeliveryWithOptions(shared_ptr<ModifyApisecLogDeliveryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecLogDeliveryResponse modifyApisecLogDelivery(shared_ptr<ModifyApisecLogDeliveryRequest> request);
  ModifyApisecLogDeliveryStatusResponse modifyApisecLogDeliveryStatusWithOptions(shared_ptr<ModifyApisecLogDeliveryStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecLogDeliveryStatusResponse modifyApisecLogDeliveryStatus(shared_ptr<ModifyApisecLogDeliveryStatusRequest> request);
  ModifyApisecModuleStatusResponse modifyApisecModuleStatusWithOptions(shared_ptr<ModifyApisecModuleStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecModuleStatusResponse modifyApisecModuleStatus(shared_ptr<ModifyApisecModuleStatusRequest> request);
  ModifyApisecStatusResponse modifyApisecStatusWithOptions(shared_ptr<ModifyApisecStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApisecStatusResponse modifyApisecStatus(shared_ptr<ModifyApisecStatusRequest> request);
  ModifyCloudResourceResponse modifyCloudResourceWithOptions(shared_ptr<ModifyCloudResourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCloudResourceResponse modifyCloudResource(shared_ptr<ModifyCloudResourceRequest> request);
  ModifyDefaultHttpsResponse modifyDefaultHttpsWithOptions(shared_ptr<ModifyDefaultHttpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefaultHttpsResponse modifyDefaultHttps(shared_ptr<ModifyDefaultHttpsRequest> request);
  ModifyDefenseResourceGroupResponse modifyDefenseResourceGroupWithOptions(shared_ptr<ModifyDefenseResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseResourceGroupResponse modifyDefenseResourceGroup(shared_ptr<ModifyDefenseResourceGroupRequest> request);
  ModifyDefenseResourceXffResponse modifyDefenseResourceXffWithOptions(shared_ptr<ModifyDefenseResourceXffRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseResourceXffResponse modifyDefenseResourceXff(shared_ptr<ModifyDefenseResourceXffRequest> request);
  ModifyDefenseRuleResponse modifyDefenseRuleWithOptions(shared_ptr<ModifyDefenseRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseRuleResponse modifyDefenseRule(shared_ptr<ModifyDefenseRuleRequest> request);
  ModifyDefenseRuleCacheResponse modifyDefenseRuleCacheWithOptions(shared_ptr<ModifyDefenseRuleCacheRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseRuleCacheResponse modifyDefenseRuleCache(shared_ptr<ModifyDefenseRuleCacheRequest> request);
  ModifyDefenseRuleStatusResponse modifyDefenseRuleStatusWithOptions(shared_ptr<ModifyDefenseRuleStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseRuleStatusResponse modifyDefenseRuleStatus(shared_ptr<ModifyDefenseRuleStatusRequest> request);
  ModifyDefenseTemplateResponse modifyDefenseTemplateWithOptions(shared_ptr<ModifyDefenseTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseTemplateResponse modifyDefenseTemplate(shared_ptr<ModifyDefenseTemplateRequest> request);
  ModifyDefenseTemplateStatusResponse modifyDefenseTemplateStatusWithOptions(shared_ptr<ModifyDefenseTemplateStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDefenseTemplateStatusResponse modifyDefenseTemplateStatus(shared_ptr<ModifyDefenseTemplateStatusRequest> request);
  ModifyDomainResponse modifyDomainWithOptions(shared_ptr<ModifyDomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDomainResponse modifyDomain(shared_ptr<ModifyDomainRequest> request);
  ModifyDomainPunishStatusResponse modifyDomainPunishStatusWithOptions(shared_ptr<ModifyDomainPunishStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDomainPunishStatusResponse modifyDomainPunishStatus(shared_ptr<ModifyDomainPunishStatusRequest> request);
  ModifyHybridCloudClusterBypassStatusResponse modifyHybridCloudClusterBypassStatusWithOptions(shared_ptr<ModifyHybridCloudClusterBypassStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudClusterBypassStatusResponse modifyHybridCloudClusterBypassStatus(shared_ptr<ModifyHybridCloudClusterBypassStatusRequest> request);
  ModifyHybridCloudClusterRuleResponse modifyHybridCloudClusterRuleWithOptions(shared_ptr<ModifyHybridCloudClusterRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudClusterRuleResponse modifyHybridCloudClusterRule(shared_ptr<ModifyHybridCloudClusterRuleRequest> request);
  ModifyHybridCloudGroupResponse modifyHybridCloudGroupWithOptions(shared_ptr<ModifyHybridCloudGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudGroupResponse modifyHybridCloudGroup(shared_ptr<ModifyHybridCloudGroupRequest> request);
  ModifyHybridCloudGroupExpansionServerResponse modifyHybridCloudGroupExpansionServerWithOptions(shared_ptr<ModifyHybridCloudGroupExpansionServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudGroupExpansionServerResponse modifyHybridCloudGroupExpansionServer(shared_ptr<ModifyHybridCloudGroupExpansionServerRequest> request);
  ModifyHybridCloudGroupShrinkServerResponse modifyHybridCloudGroupShrinkServerWithOptions(shared_ptr<ModifyHybridCloudGroupShrinkServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudGroupShrinkServerResponse modifyHybridCloudGroupShrinkServer(shared_ptr<ModifyHybridCloudGroupShrinkServerRequest> request);
  ModifyHybridCloudSdkPullinStatusResponse modifyHybridCloudSdkPullinStatusWithOptions(shared_ptr<ModifyHybridCloudSdkPullinStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudSdkPullinStatusResponse modifyHybridCloudSdkPullinStatus(shared_ptr<ModifyHybridCloudSdkPullinStatusRequest> request);
  ModifyHybridCloudServerResponse modifyHybridCloudServerWithOptions(shared_ptr<ModifyHybridCloudServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHybridCloudServerResponse modifyHybridCloudServer(shared_ptr<ModifyHybridCloudServerRequest> request);
  ModifyMajorProtectionBlackIpResponse modifyMajorProtectionBlackIpWithOptions(shared_ptr<ModifyMajorProtectionBlackIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMajorProtectionBlackIpResponse modifyMajorProtectionBlackIp(shared_ptr<ModifyMajorProtectionBlackIpRequest> request);
  ModifyMemberAccountResponse modifyMemberAccountWithOptions(shared_ptr<ModifyMemberAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyMemberAccountResponse modifyMemberAccount(shared_ptr<ModifyMemberAccountRequest> request);
  ModifyPauseProtectionStatusResponse modifyPauseProtectionStatusWithOptions(shared_ptr<ModifyPauseProtectionStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPauseProtectionStatusResponse modifyPauseProtectionStatus(shared_ptr<ModifyPauseProtectionStatusRequest> request);
  ModifyResourceLogStatusResponse modifyResourceLogStatusWithOptions(shared_ptr<ModifyResourceLogStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyResourceLogStatusResponse modifyResourceLogStatus(shared_ptr<ModifyResourceLogStatusRequest> request);
  ModifyTemplateResourcesResponse modifyTemplateResourcesWithOptions(shared_ptr<ModifyTemplateResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTemplateResourcesResponse modifyTemplateResources(shared_ptr<ModifyTemplateResourcesRequest> request);
  ReCreateCloudResourceResponse reCreateCloudResourceWithOptions(shared_ptr<ReCreateCloudResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReCreateCloudResourceResponse reCreateCloudResource(shared_ptr<ReCreateCloudResourceRequest> request);
  ReleaseInstanceResponse releaseInstanceWithOptions(shared_ptr<ReleaseInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseInstanceResponse releaseInstance(shared_ptr<ReleaseInstanceRequest> request);
  SyncProductInstanceResponse syncProductInstanceWithOptions(shared_ptr<SyncProductInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncProductInstanceResponse syncProductInstance(shared_ptr<SyncProductInstanceRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Waf-openapi20211001

#endif
