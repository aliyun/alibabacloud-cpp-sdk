// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_AIMIAOBI20230801_H_
#define ALIBABACLOUD_AIMIAOBI20230801_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_AiMiaoBi20230801 {
class AddDatasetDocumentRequestDocumentMultimodalMedias : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  AddDatasetDocumentRequestDocumentMultimodalMedias() {}

  explicit AddDatasetDocumentRequestDocumentMultimodalMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~AddDatasetDocumentRequestDocumentMultimodalMedias() = default;
};
class AddDatasetDocumentRequestDocument : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> disableHandleMultimodalMedia{};
  shared_ptr<string> docId{};
  shared_ptr<string> docType{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> extend1{};
  shared_ptr<string> extend2{};
  shared_ptr<string> extend3{};
  shared_ptr<string> multimodalIndexName{};
  shared_ptr<vector<AddDatasetDocumentRequestDocumentMultimodalMedias>> multimodalMedias{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> sourceFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  AddDatasetDocumentRequestDocument() {}

  explicit AddDatasetDocumentRequestDocument(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (disableHandleMultimodalMedia) {
      res["DisableHandleMultimodalMedia"] = boost::any(*disableHandleMultimodalMedia);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (extend2) {
      res["Extend2"] = boost::any(*extend2);
    }
    if (extend3) {
      res["Extend3"] = boost::any(*extend3);
    }
    if (multimodalIndexName) {
      res["MultimodalIndexName"] = boost::any(*multimodalIndexName);
    }
    if (multimodalMedias) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMedias){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMedias"] = boost::any(temp1);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (sourceFrom) {
      res["SourceFrom"] = boost::any(*sourceFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DisableHandleMultimodalMedia") != m.end() && !m["DisableHandleMultimodalMedia"].empty()) {
      disableHandleMultimodalMedia = make_shared<bool>(boost::any_cast<bool>(m["DisableHandleMultimodalMedia"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("Extend2") != m.end() && !m["Extend2"].empty()) {
      extend2 = make_shared<string>(boost::any_cast<string>(m["Extend2"]));
    }
    if (m.find("Extend3") != m.end() && !m["Extend3"].empty()) {
      extend3 = make_shared<string>(boost::any_cast<string>(m["Extend3"]));
    }
    if (m.find("MultimodalIndexName") != m.end() && !m["MultimodalIndexName"].empty()) {
      multimodalIndexName = make_shared<string>(boost::any_cast<string>(m["MultimodalIndexName"]));
    }
    if (m.find("MultimodalMedias") != m.end() && !m["MultimodalMedias"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMedias"].type()) {
        vector<AddDatasetDocumentRequestDocumentMultimodalMedias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMedias"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddDatasetDocumentRequestDocumentMultimodalMedias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMedias = make_shared<vector<AddDatasetDocumentRequestDocumentMultimodalMedias>>(expect1);
      }
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SourceFrom") != m.end() && !m["SourceFrom"].empty()) {
      sourceFrom = make_shared<string>(boost::any_cast<string>(m["SourceFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~AddDatasetDocumentRequestDocument() = default;
};
class AddDatasetDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<AddDatasetDocumentRequestDocument> document{};
  shared_ptr<string> workspaceId{};

  AddDatasetDocumentRequest() {}

  explicit AddDatasetDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (document) {
      res["Document"] = document ? boost::any(document->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Document") != m.end() && !m["Document"].empty()) {
      if (typeid(map<string, boost::any>) == m["Document"].type()) {
        AddDatasetDocumentRequestDocument model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Document"]));
        document = make_shared<AddDatasetDocumentRequestDocument>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddDatasetDocumentRequest() = default;
};
class AddDatasetDocumentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> documentShrink{};
  shared_ptr<string> workspaceId{};

  AddDatasetDocumentShrinkRequest() {}

  explicit AddDatasetDocumentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (documentShrink) {
      res["Document"] = boost::any(*documentShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Document") != m.end() && !m["Document"].empty()) {
      documentShrink = make_shared<string>(boost::any_cast<string>(m["Document"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~AddDatasetDocumentShrinkRequest() = default;
};
class AddDatasetDocumentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<long> status{};

  AddDatasetDocumentResponseBodyData() {}

  explicit AddDatasetDocumentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~AddDatasetDocumentResponseBodyData() = default;
};
class AddDatasetDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AddDatasetDocumentResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddDatasetDocumentResponseBody() {}

  explicit AddDatasetDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AddDatasetDocumentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AddDatasetDocumentResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddDatasetDocumentResponseBody() = default;
};
class AddDatasetDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddDatasetDocumentResponseBody> body{};

  AddDatasetDocumentResponse() {}

  explicit AddDatasetDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDatasetDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDatasetDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~AddDatasetDocumentResponse() = default;
};
class CancelAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  CancelAsyncTaskRequest() {}

  explicit CancelAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CancelAsyncTaskRequest() = default;
};
class CancelAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CancelAsyncTaskResponseBody() {}

  explicit CancelAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CancelAsyncTaskResponseBody() = default;
};
class CancelAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelAsyncTaskResponseBody> body{};

  CancelAsyncTaskResponse() {}

  explicit CancelAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CancelAsyncTaskResponse() = default;
};
class ClearIntervenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  ClearIntervenesRequest() {}

  explicit ClearIntervenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~ClearIntervenesRequest() = default;
};
class ClearIntervenesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failIdList{};
  shared_ptr<string> taskId{};

  ClearIntervenesResponseBodyData() {}

  explicit ClearIntervenesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failIdList) {
      res["FailIdList"] = boost::any(*failIdList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailIdList") != m.end() && !m["FailIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ClearIntervenesResponseBodyData() = default;
};
class ClearIntervenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ClearIntervenesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ClearIntervenesResponseBody() {}

  explicit ClearIntervenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ClearIntervenesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ClearIntervenesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ClearIntervenesResponseBody() = default;
};
class ClearIntervenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ClearIntervenesResponseBody> body{};

  ClearIntervenesResponse() {}

  explicit ClearIntervenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearIntervenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearIntervenesResponseBody>(model1);
      }
    }
  }


  virtual ~ClearIntervenesResponse() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>> headers{};
  shared_ptr<string> method{};
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>> params{};
  shared_ptr<bool> pathParamsEnable{};
  shared_ptr<long> socketTimeout{};
  shared_ptr<string> url{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (params) {
      vector<boost::any> temp1;
      for(auto item1:*params){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Params"] = boost::any(temp1);
    }
    if (pathParamsEnable) {
      res["PathParamsEnable"] = boost::any(*pathParamsEnable);
    }
    if (socketTimeout) {
      res["SocketTimeout"] = boost::any(*socketTimeout);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Params"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        params = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>>(expect1);
      }
    }
    if (m.find("PathParamsEnable") != m.end() && !m["PathParamsEnable"].empty()) {
      pathParamsEnable = make_shared<bool>(boost::any_cast<bool>(m["PathParamsEnable"]));
    }
    if (m.find("SocketTimeout") != m.end() && !m["SocketTimeout"].empty()) {
      socketTimeout = make_shared<long>(boost::any_cast<long>(m["SocketTimeout"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>> jqNodes{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>>(expect1);
      }
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() = default;
};
class CreateDatasetRequestDatasetConfigSearchSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> demoQuery{};
  shared_ptr<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig> searchSourceRequestConfig{};
  shared_ptr<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig> searchSourceResponseConfig{};
  shared_ptr<long> size{};

  CreateDatasetRequestDatasetConfigSearchSourceConfigs() {}

  explicit CreateDatasetRequestDatasetConfigSearchSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoQuery) {
      res["DemoQuery"] = boost::any(*demoQuery);
    }
    if (searchSourceRequestConfig) {
      res["SearchSourceRequestConfig"] = searchSourceRequestConfig ? boost::any(searchSourceRequestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchSourceResponseConfig) {
      res["SearchSourceResponseConfig"] = searchSourceResponseConfig ? boost::any(searchSourceResponseConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoQuery") != m.end() && !m["DemoQuery"].empty()) {
      demoQuery = make_shared<string>(boost::any_cast<string>(m["DemoQuery"]));
    }
    if (m.find("SearchSourceRequestConfig") != m.end() && !m["SearchSourceRequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceRequestConfig"].type()) {
        CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceRequestConfig"]));
        searchSourceRequestConfig = make_shared<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig>(model1);
      }
    }
    if (m.find("SearchSourceResponseConfig") != m.end() && !m["SearchSourceResponseConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceResponseConfig"].type()) {
        CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceResponseConfig"]));
        searchSourceResponseConfig = make_shared<CreateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~CreateDatasetRequestDatasetConfigSearchSourceConfigs() = default;
};
class CreateDatasetRequestDatasetConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigs>> searchSourceConfigs{};

  CreateDatasetRequestDatasetConfig() {}

  explicit CreateDatasetRequestDatasetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*searchSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSourceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchSourceConfigs") != m.end() && !m["SearchSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSourceConfigs"].type()) {
        vector<CreateDatasetRequestDatasetConfigSearchSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestDatasetConfigSearchSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSourceConfigs = make_shared<vector<CreateDatasetRequestDatasetConfigSearchSourceConfigs>>(expect1);
      }
    }
  }


  virtual ~CreateDatasetRequestDatasetConfig() = default;
};
class CreateDatasetRequestDocumentHandleConfig : public Darabonba::Model {
public:
  shared_ptr<bool> disableHandleMultimodalMedia{};

  CreateDatasetRequestDocumentHandleConfig() {}

  explicit CreateDatasetRequestDocumentHandleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableHandleMultimodalMedia) {
      res["DisableHandleMultimodalMedia"] = boost::any(*disableHandleMultimodalMedia);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableHandleMultimodalMedia") != m.end() && !m["DisableHandleMultimodalMedia"].empty()) {
      disableHandleMultimodalMedia = make_shared<bool>(boost::any_cast<bool>(m["DisableHandleMultimodalMedia"]));
    }
  }


  virtual ~CreateDatasetRequestDocumentHandleConfig() = default;
};
class CreateDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDatasetRequestDatasetConfig> datasetConfig{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<CreateDatasetRequestDocumentHandleConfig> documentHandleConfig{};
  shared_ptr<long> searchDatasetEnable{};
  shared_ptr<string> workspaceId{};

  CreateDatasetRequest() {}

  explicit CreateDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetConfig) {
      res["DatasetConfig"] = datasetConfig ? boost::any(datasetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (documentHandleConfig) {
      res["DocumentHandleConfig"] = documentHandleConfig ? boost::any(documentHandleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetConfig") != m.end() && !m["DatasetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatasetConfig"].type()) {
        CreateDatasetRequestDatasetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatasetConfig"]));
        datasetConfig = make_shared<CreateDatasetRequestDatasetConfig>(model1);
      }
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("DocumentHandleConfig") != m.end() && !m["DocumentHandleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DocumentHandleConfig"].type()) {
        CreateDatasetRequestDocumentHandleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DocumentHandleConfig"]));
        documentHandleConfig = make_shared<CreateDatasetRequestDocumentHandleConfig>(model1);
      }
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateDatasetRequest() = default;
};
class CreateDatasetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetConfigShrink{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<string> documentHandleConfigShrink{};
  shared_ptr<long> searchDatasetEnable{};
  shared_ptr<string> workspaceId{};

  CreateDatasetShrinkRequest() {}

  explicit CreateDatasetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetConfigShrink) {
      res["DatasetConfig"] = boost::any(*datasetConfigShrink);
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (documentHandleConfigShrink) {
      res["DocumentHandleConfig"] = boost::any(*documentHandleConfigShrink);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetConfig") != m.end() && !m["DatasetConfig"].empty()) {
      datasetConfigShrink = make_shared<string>(boost::any_cast<string>(m["DatasetConfig"]));
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("DocumentHandleConfig") != m.end() && !m["DocumentHandleConfig"].empty()) {
      documentHandleConfigShrink = make_shared<string>(boost::any_cast<string>(m["DocumentHandleConfig"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~CreateDatasetShrinkRequest() = default;
};
class CreateDatasetResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<long> searchDatasetEnable{};

  CreateDatasetResponseBodyData() {}

  explicit CreateDatasetResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
  }


  virtual ~CreateDatasetResponseBodyData() = default;
};
class CreateDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDatasetResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDatasetResponseBody() {}

  explicit CreateDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateDatasetResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateDatasetResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDatasetResponseBody() = default;
};
class CreateDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatasetResponseBody> body{};

  CreateDatasetResponse() {}

  explicit CreateDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatasetResponse() = default;
};
class CreateGeneratedContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> contentDomain{};
  shared_ptr<string> contentText{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};
  shared_ptr<string> uuid{};

  CreateGeneratedContentRequest() {}

  explicit CreateGeneratedContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentDomain) {
      res["ContentDomain"] = boost::any(*contentDomain);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentDomain") != m.end() && !m["ContentDomain"].empty()) {
      contentDomain = make_shared<string>(boost::any_cast<string>(m["ContentDomain"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CreateGeneratedContentRequest() = default;
};
class CreateGeneratedContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> contentDomain{};
  shared_ptr<string> contentText{};
  shared_ptr<string> keywordsShrink{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};
  shared_ptr<string> uuid{};

  CreateGeneratedContentShrinkRequest() {}

  explicit CreateGeneratedContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentDomain) {
      res["ContentDomain"] = boost::any(*contentDomain);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (keywordsShrink) {
      res["Keywords"] = boost::any(*keywordsShrink);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentDomain") != m.end() && !m["ContentDomain"].empty()) {
      contentDomain = make_shared<string>(boost::any_cast<string>(m["ContentDomain"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywordsShrink = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~CreateGeneratedContentShrinkRequest() = default;
};
class CreateGeneratedContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateGeneratedContentResponseBody() {}

  explicit CreateGeneratedContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateGeneratedContentResponseBody() = default;
};
class CreateGeneratedContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGeneratedContentResponseBody> body{};

  CreateGeneratedContentResponse() {}

  explicit CreateGeneratedContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGeneratedContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGeneratedContentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGeneratedContentResponse() = default;
};
class CreateTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  CreateTokenRequest() {}

  explicit CreateTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~CreateTokenRequest() = default;
};
class CreateTokenResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> expiredTime{};
  shared_ptr<string> token{};

  CreateTokenResponseBodyData() {}

  explicit CreateTokenResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~CreateTokenResponseBodyData() = default;
};
class CreateTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateTokenResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateTokenResponseBody() {}

  explicit CreateTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateTokenResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateTokenResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTokenResponseBody() = default;
};
class CreateTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTokenResponseBody> body{};

  CreateTokenResponse() {}

  explicit CreateTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTokenResponse() = default;
};
class DeleteCustomTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> commodityCode{};
  shared_ptr<long> id{};

  DeleteCustomTextRequest() {}

  explicit DeleteCustomTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteCustomTextRequest() = default;
};
class DeleteCustomTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomTextResponseBody() {}

  explicit DeleteCustomTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomTextResponseBody() = default;
};
class DeleteCustomTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTextResponseBody> body{};

  DeleteCustomTextResponse() {}

  explicit DeleteCustomTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTextResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTextResponse() = default;
};
class DeleteCustomTopicByTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> topic{};

  DeleteCustomTopicByTopicRequest() {}

  explicit DeleteCustomTopicByTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~DeleteCustomTopicByTopicRequest() = default;
};
class DeleteCustomTopicByTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomTopicByTopicResponseBody() {}

  explicit DeleteCustomTopicByTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomTopicByTopicResponseBody() = default;
};
class DeleteCustomTopicByTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTopicByTopicResponseBody> body{};

  DeleteCustomTopicByTopicResponse() {}

  explicit DeleteCustomTopicByTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTopicByTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTopicByTopicResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTopicByTopicResponse() = default;
};
class DeleteCustomTopicViewPointByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customViewPointId{};

  DeleteCustomTopicViewPointByIdRequest() {}

  explicit DeleteCustomTopicViewPointByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
  }


  virtual ~DeleteCustomTopicViewPointByIdRequest() = default;
};
class DeleteCustomTopicViewPointByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteCustomTopicViewPointByIdResponseBody() {}

  explicit DeleteCustomTopicViewPointByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteCustomTopicViewPointByIdResponseBody() = default;
};
class DeleteCustomTopicViewPointByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomTopicViewPointByIdResponseBody> body{};

  DeleteCustomTopicViewPointByIdResponse() {}

  explicit DeleteCustomTopicViewPointByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomTopicViewPointByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomTopicViewPointByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomTopicViewPointByIdResponse() = default;
};
class DeleteDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> workspaceId{};

  DeleteDatasetRequest() {}

  explicit DeleteDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteDatasetRequest() = default;
};
class DeleteDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDatasetResponseBody() {}

  explicit DeleteDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDatasetResponseBody() = default;
};
class DeleteDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatasetResponseBody> body{};

  DeleteDatasetResponse() {}

  explicit DeleteDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatasetResponse() = default;
};
class DeleteDatasetDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> workspaceId{};

  DeleteDatasetDocumentRequest() {}

  explicit DeleteDatasetDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteDatasetDocumentRequest() = default;
};
class DeleteDatasetDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDatasetDocumentResponseBody() {}

  explicit DeleteDatasetDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDatasetDocumentResponseBody() = default;
};
class DeleteDatasetDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatasetDocumentResponseBody> body{};

  DeleteDatasetDocumentResponse() {}

  explicit DeleteDatasetDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatasetDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatasetDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatasetDocumentResponse() = default;
};
class DeleteDocsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> docIds{};
  shared_ptr<string> workspaceId{};

  DeleteDocsRequest() {}

  explicit DeleteDocsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteDocsRequest() = default;
};
class DeleteDocsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> docIdsShrink{};
  shared_ptr<string> workspaceId{};

  DeleteDocsShrinkRequest() {}

  explicit DeleteDocsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIdsShrink) {
      res["DocIds"] = boost::any(*docIdsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      docIdsShrink = make_shared<string>(boost::any_cast<string>(m["DocIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~DeleteDocsShrinkRequest() = default;
};
class DeleteDocsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDocsResponseBody() {}

  explicit DeleteDocsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDocsResponseBody() = default;
};
class DeleteDocsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDocsResponseBody> body{};

  DeleteDocsResponse() {}

  explicit DeleteDocsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDocsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDocsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDocsResponse() = default;
};
class DeleteGeneratedContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> id{};
  shared_ptr<string> regionId{};

  DeleteGeneratedContentRequest() {}

  explicit DeleteGeneratedContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteGeneratedContentRequest() = default;
};
class DeleteGeneratedContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteGeneratedContentResponseBody() {}

  explicit DeleteGeneratedContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGeneratedContentResponseBody() = default;
};
class DeleteGeneratedContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGeneratedContentResponseBody> body{};

  DeleteGeneratedContentResponse() {}

  explicit DeleteGeneratedContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGeneratedContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGeneratedContentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGeneratedContentResponse() = default;
};
class DeleteInterveneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> ruleId{};

  DeleteInterveneRuleRequest() {}

  explicit DeleteInterveneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~DeleteInterveneRuleRequest() = default;
};
class DeleteInterveneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failIdList{};
  shared_ptr<string> taskId{};

  DeleteInterveneRuleResponseBodyData() {}

  explicit DeleteInterveneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failIdList) {
      res["FailIdList"] = boost::any(*failIdList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailIdList") != m.end() && !m["FailIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteInterveneRuleResponseBodyData() = default;
};
class DeleteInterveneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<DeleteInterveneRuleResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteInterveneRuleResponseBody() {}

  explicit DeleteInterveneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteInterveneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteInterveneRuleResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteInterveneRuleResponseBody() = default;
};
class DeleteInterveneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInterveneRuleResponseBody> body{};

  DeleteInterveneRuleResponse() {}

  explicit DeleteInterveneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInterveneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInterveneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInterveneRuleResponse() = default;
};
class DeleteMaterialByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> id{};

  DeleteMaterialByIdRequest() {}

  explicit DeleteMaterialByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteMaterialByIdRequest() = default;
};
class DeleteMaterialByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteMaterialByIdResponseBody() {}

  explicit DeleteMaterialByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteMaterialByIdResponseBody() = default;
};
class DeleteMaterialByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMaterialByIdResponseBody> body{};

  DeleteMaterialByIdResponse() {}

  explicit DeleteMaterialByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMaterialByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMaterialByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMaterialByIdResponse() = default;
};
class DocumentExtractionRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<string>> urls{};

  DocumentExtractionRequest() {}

  explicit DocumentExtractionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (urls) {
      res["Urls"] = boost::any(*urls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Urls") != m.end() && !m["Urls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Urls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Urls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      urls = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DocumentExtractionRequest() = default;
};
class DocumentExtractionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> urlsShrink{};

  DocumentExtractionShrinkRequest() {}

  explicit DocumentExtractionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (urlsShrink) {
      res["Urls"] = boost::any(*urlsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Urls") != m.end() && !m["Urls"].empty()) {
      urlsShrink = make_shared<string>(boost::any_cast<string>(m["Urls"]));
    }
  }


  virtual ~DocumentExtractionShrinkRequest() = default;
};
class DocumentExtractionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  DocumentExtractionResponseBodyData() {}

  explicit DocumentExtractionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DocumentExtractionResponseBodyData() = default;
};
class DocumentExtractionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<DocumentExtractionResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DocumentExtractionResponseBody() {}

  explicit DocumentExtractionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DocumentExtractionResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DocumentExtractionResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DocumentExtractionResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DocumentExtractionResponseBody() = default;
};
class DocumentExtractionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DocumentExtractionResponseBody> body{};

  DocumentExtractionResponse() {}

  explicit DocumentExtractionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DocumentExtractionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DocumentExtractionResponseBody>(model1);
      }
    }
  }


  virtual ~DocumentExtractionResponse() = default;
};
class ExportAnalysisTagDetailByTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ExportAnalysisTagDetailByTaskIdRequest() {}

  explicit ExportAnalysisTagDetailByTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ExportAnalysisTagDetailByTaskIdRequest() = default;
};
class ExportAnalysisTagDetailByTaskIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoriesShrink{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ExportAnalysisTagDetailByTaskIdShrinkRequest() {}

  explicit ExportAnalysisTagDetailByTaskIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoriesShrink) {
      res["Categories"] = boost::any(*categoriesShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      categoriesShrink = make_shared<string>(boost::any_cast<string>(m["Categories"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ExportAnalysisTagDetailByTaskIdShrinkRequest() = default;
};
class ExportAnalysisTagDetailByTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportAnalysisTagDetailByTaskIdResponseBody() {}

  explicit ExportAnalysisTagDetailByTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportAnalysisTagDetailByTaskIdResponseBody() = default;
};
class ExportAnalysisTagDetailByTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportAnalysisTagDetailByTaskIdResponseBody> body{};

  ExportAnalysisTagDetailByTaskIdResponse() {}

  explicit ExportAnalysisTagDetailByTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportAnalysisTagDetailByTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportAnalysisTagDetailByTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~ExportAnalysisTagDetailByTaskIdResponse() = default;
};
class ExportGeneratedContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> id{};

  ExportGeneratedContentRequest() {}

  explicit ExportGeneratedContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ExportGeneratedContentRequest() = default;
};
class ExportGeneratedContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportGeneratedContentResponseBody() {}

  explicit ExportGeneratedContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportGeneratedContentResponseBody() = default;
};
class ExportGeneratedContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportGeneratedContentResponseBody> body{};

  ExportGeneratedContentResponse() {}

  explicit ExportGeneratedContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportGeneratedContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportGeneratedContentResponseBody>(model1);
      }
    }
  }


  virtual ~ExportGeneratedContentResponse() = default;
};
class ExportHotTopicPlanningProposalsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<string>> customViewPointIds{};
  shared_ptr<string> exportType{};
  shared_ptr<vector<string>> titles{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> viewPointType{};

  ExportHotTopicPlanningProposalsRequest() {}

  explicit ExportHotTopicPlanningProposalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customViewPointIds) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIds);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (titles) {
      res["Titles"] = boost::any(*titles);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (viewPointType) {
      res["ViewPointType"] = boost::any(*viewPointType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomViewPointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomViewPointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customViewPointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Titles") != m.end() && !m["Titles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Titles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Titles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      titles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("ViewPointType") != m.end() && !m["ViewPointType"].empty()) {
      viewPointType = make_shared<string>(boost::any_cast<string>(m["ViewPointType"]));
    }
  }


  virtual ~ExportHotTopicPlanningProposalsRequest() = default;
};
class ExportHotTopicPlanningProposalsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customViewPointIdsShrink{};
  shared_ptr<string> exportType{};
  shared_ptr<string> titlesShrink{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> viewPointType{};

  ExportHotTopicPlanningProposalsShrinkRequest() {}

  explicit ExportHotTopicPlanningProposalsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customViewPointIdsShrink) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIdsShrink);
    }
    if (exportType) {
      res["ExportType"] = boost::any(*exportType);
    }
    if (titlesShrink) {
      res["Titles"] = boost::any(*titlesShrink);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (viewPointType) {
      res["ViewPointType"] = boost::any(*viewPointType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      customViewPointIdsShrink = make_shared<string>(boost::any_cast<string>(m["CustomViewPointIds"]));
    }
    if (m.find("ExportType") != m.end() && !m["ExportType"].empty()) {
      exportType = make_shared<string>(boost::any_cast<string>(m["ExportType"]));
    }
    if (m.find("Titles") != m.end() && !m["Titles"].empty()) {
      titlesShrink = make_shared<string>(boost::any_cast<string>(m["Titles"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("ViewPointType") != m.end() && !m["ViewPointType"].empty()) {
      viewPointType = make_shared<string>(boost::any_cast<string>(m["ViewPointType"]));
    }
  }


  virtual ~ExportHotTopicPlanningProposalsShrinkRequest() = default;
};
class ExportHotTopicPlanningProposalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportHotTopicPlanningProposalsResponseBody() {}

  explicit ExportHotTopicPlanningProposalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportHotTopicPlanningProposalsResponseBody() = default;
};
class ExportHotTopicPlanningProposalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportHotTopicPlanningProposalsResponseBody> body{};

  ExportHotTopicPlanningProposalsResponse() {}

  explicit ExportHotTopicPlanningProposalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportHotTopicPlanningProposalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportHotTopicPlanningProposalsResponseBody>(model1);
      }
    }
  }


  virtual ~ExportHotTopicPlanningProposalsResponse() = default;
};
class ExportIntervenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  ExportIntervenesRequest() {}

  explicit ExportIntervenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~ExportIntervenesRequest() = default;
};
class ExportIntervenesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};

  ExportIntervenesResponseBodyData() {}

  explicit ExportIntervenesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~ExportIntervenesResponseBodyData() = default;
};
class ExportIntervenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ExportIntervenesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExportIntervenesResponseBody() {}

  explicit ExportIntervenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ExportIntervenesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ExportIntervenesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExportIntervenesResponseBody() = default;
};
class ExportIntervenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportIntervenesResponseBody> body{};

  ExportIntervenesResponse() {}

  explicit ExportIntervenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportIntervenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportIntervenesResponseBody>(model1);
      }
    }
  }


  virtual ~ExportIntervenesResponse() = default;
};
class FeedbackDialogueRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customerResponse{};
  shared_ptr<string> goodText{};
  shared_ptr<string> modifiedResponse{};
  shared_ptr<string> rating{};
  shared_ptr<vector<string>> ratingTags{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};

  FeedbackDialogueRequest() {}

  explicit FeedbackDialogueRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customerResponse) {
      res["CustomerResponse"] = boost::any(*customerResponse);
    }
    if (goodText) {
      res["GoodText"] = boost::any(*goodText);
    }
    if (modifiedResponse) {
      res["ModifiedResponse"] = boost::any(*modifiedResponse);
    }
    if (rating) {
      res["Rating"] = boost::any(*rating);
    }
    if (ratingTags) {
      res["RatingTags"] = boost::any(*ratingTags);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomerResponse") != m.end() && !m["CustomerResponse"].empty()) {
      customerResponse = make_shared<string>(boost::any_cast<string>(m["CustomerResponse"]));
    }
    if (m.find("GoodText") != m.end() && !m["GoodText"].empty()) {
      goodText = make_shared<string>(boost::any_cast<string>(m["GoodText"]));
    }
    if (m.find("ModifiedResponse") != m.end() && !m["ModifiedResponse"].empty()) {
      modifiedResponse = make_shared<string>(boost::any_cast<string>(m["ModifiedResponse"]));
    }
    if (m.find("Rating") != m.end() && !m["Rating"].empty()) {
      rating = make_shared<string>(boost::any_cast<string>(m["Rating"]));
    }
    if (m.find("RatingTags") != m.end() && !m["RatingTags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RatingTags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RatingTags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ratingTags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~FeedbackDialogueRequest() = default;
};
class FeedbackDialogueShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customerResponse{};
  shared_ptr<string> goodText{};
  shared_ptr<string> modifiedResponse{};
  shared_ptr<string> rating{};
  shared_ptr<string> ratingTagsShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};

  FeedbackDialogueShrinkRequest() {}

  explicit FeedbackDialogueShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customerResponse) {
      res["CustomerResponse"] = boost::any(*customerResponse);
    }
    if (goodText) {
      res["GoodText"] = boost::any(*goodText);
    }
    if (modifiedResponse) {
      res["ModifiedResponse"] = boost::any(*modifiedResponse);
    }
    if (rating) {
      res["Rating"] = boost::any(*rating);
    }
    if (ratingTagsShrink) {
      res["RatingTags"] = boost::any(*ratingTagsShrink);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomerResponse") != m.end() && !m["CustomerResponse"].empty()) {
      customerResponse = make_shared<string>(boost::any_cast<string>(m["CustomerResponse"]));
    }
    if (m.find("GoodText") != m.end() && !m["GoodText"].empty()) {
      goodText = make_shared<string>(boost::any_cast<string>(m["GoodText"]));
    }
    if (m.find("ModifiedResponse") != m.end() && !m["ModifiedResponse"].empty()) {
      modifiedResponse = make_shared<string>(boost::any_cast<string>(m["ModifiedResponse"]));
    }
    if (m.find("Rating") != m.end() && !m["Rating"].empty()) {
      rating = make_shared<string>(boost::any_cast<string>(m["Rating"]));
    }
    if (m.find("RatingTags") != m.end() && !m["RatingTags"].empty()) {
      ratingTagsShrink = make_shared<string>(boost::any_cast<string>(m["RatingTags"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~FeedbackDialogueShrinkRequest() = default;
};
class FeedbackDialogueResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  FeedbackDialogueResponseBody() {}

  explicit FeedbackDialogueResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FeedbackDialogueResponseBody() = default;
};
class FeedbackDialogueResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FeedbackDialogueResponseBody> body{};

  FeedbackDialogueResponse() {}

  explicit FeedbackDialogueResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FeedbackDialogueResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FeedbackDialogueResponseBody>(model1);
      }
    }
  }


  virtual ~FeedbackDialogueResponse() = default;
};
class FetchImageTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> articleTaskId{};
  shared_ptr<vector<string>> taskIdList{};

  FetchImageTaskRequest() {}

  explicit FetchImageTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (articleTaskId) {
      res["ArticleTaskId"] = boost::any(*articleTaskId);
    }
    if (taskIdList) {
      res["TaskIdList"] = boost::any(*taskIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ArticleTaskId") != m.end() && !m["ArticleTaskId"].empty()) {
      articleTaskId = make_shared<string>(boost::any_cast<string>(m["ArticleTaskId"]));
    }
    if (m.find("TaskIdList") != m.end() && !m["TaskIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FetchImageTaskRequest() = default;
};
class FetchImageTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> articleTaskId{};
  shared_ptr<string> taskIdListShrink{};

  FetchImageTaskShrinkRequest() {}

  explicit FetchImageTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (articleTaskId) {
      res["ArticleTaskId"] = boost::any(*articleTaskId);
    }
    if (taskIdListShrink) {
      res["TaskIdList"] = boost::any(*taskIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ArticleTaskId") != m.end() && !m["ArticleTaskId"].empty()) {
      articleTaskId = make_shared<string>(boost::any_cast<string>(m["ArticleTaskId"]));
    }
    if (m.find("TaskIdList") != m.end() && !m["TaskIdList"].empty()) {
      taskIdListShrink = make_shared<string>(boost::any_cast<string>(m["TaskIdList"]));
    }
  }


  virtual ~FetchImageTaskShrinkRequest() = default;
};
class FetchImageTaskResponseBodyDataTaskInfoListImageList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> url{};

  FetchImageTaskResponseBodyDataTaskInfoListImageList() {}

  explicit FetchImageTaskResponseBodyDataTaskInfoListImageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~FetchImageTaskResponseBodyDataTaskInfoListImageList() = default;
};
class FetchImageTaskResponseBodyDataTaskInfoList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<FetchImageTaskResponseBodyDataTaskInfoListImageList>> imageList{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  FetchImageTaskResponseBodyDataTaskInfoList() {}

  explicit FetchImageTaskResponseBodyDataTaskInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (imageList) {
      vector<boost::any> temp1;
      for(auto item1:*imageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ImageList"] = boost::any(temp1);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ImageList") != m.end() && !m["ImageList"].empty()) {
      if (typeid(vector<boost::any>) == m["ImageList"].type()) {
        vector<FetchImageTaskResponseBodyDataTaskInfoListImageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ImageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FetchImageTaskResponseBodyDataTaskInfoListImageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        imageList = make_shared<vector<FetchImageTaskResponseBodyDataTaskInfoListImageList>>(expect1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~FetchImageTaskResponseBodyDataTaskInfoList() = default;
};
class FetchImageTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<FetchImageTaskResponseBodyDataTaskInfoList>> taskInfoList{};

  FetchImageTaskResponseBodyData() {}

  explicit FetchImageTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*taskInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskInfoList") != m.end() && !m["TaskInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskInfoList"].type()) {
        vector<FetchImageTaskResponseBodyDataTaskInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FetchImageTaskResponseBodyDataTaskInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskInfoList = make_shared<vector<FetchImageTaskResponseBodyDataTaskInfoList>>(expect1);
      }
    }
  }


  virtual ~FetchImageTaskResponseBodyData() = default;
};
class FetchImageTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<FetchImageTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  FetchImageTaskResponseBody() {}

  explicit FetchImageTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        FetchImageTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<FetchImageTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FetchImageTaskResponseBody() = default;
};
class FetchImageTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FetchImageTaskResponseBody> body{};

  FetchImageTaskResponse() {}

  explicit FetchImageTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FetchImageTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FetchImageTaskResponseBody>(model1);
      }
    }
  }


  virtual ~FetchImageTaskResponse() = default;
};
class GenerateFileUrlByKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> fileKey{};
  shared_ptr<string> fileName{};

  GenerateFileUrlByKeyRequest() {}

  explicit GenerateFileUrlByKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GenerateFileUrlByKeyRequest() = default;
};
class GenerateFileUrlByKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateFileUrlByKeyResponseBody() {}

  explicit GenerateFileUrlByKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateFileUrlByKeyResponseBody() = default;
};
class GenerateFileUrlByKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateFileUrlByKeyResponseBody> body{};

  GenerateFileUrlByKeyResponse() {}

  explicit GenerateFileUrlByKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateFileUrlByKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateFileUrlByKeyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateFileUrlByKeyResponse() = default;
};
class GenerateImageTaskRequestParagraphList : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  GenerateImageTaskRequestParagraphList() {}

  explicit GenerateImageTaskRequestParagraphList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GenerateImageTaskRequestParagraphList() = default;
};
class GenerateImageTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> articleTaskId{};
  shared_ptr<vector<GenerateImageTaskRequestParagraphList>> paragraphList{};
  shared_ptr<string> size{};
  shared_ptr<string> style{};

  GenerateImageTaskRequest() {}

  explicit GenerateImageTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (articleTaskId) {
      res["ArticleTaskId"] = boost::any(*articleTaskId);
    }
    if (paragraphList) {
      vector<boost::any> temp1;
      for(auto item1:*paragraphList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParagraphList"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (style) {
      res["Style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ArticleTaskId") != m.end() && !m["ArticleTaskId"].empty()) {
      articleTaskId = make_shared<string>(boost::any_cast<string>(m["ArticleTaskId"]));
    }
    if (m.find("ParagraphList") != m.end() && !m["ParagraphList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParagraphList"].type()) {
        vector<GenerateImageTaskRequestParagraphList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParagraphList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateImageTaskRequestParagraphList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paragraphList = make_shared<vector<GenerateImageTaskRequestParagraphList>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
  }


  virtual ~GenerateImageTaskRequest() = default;
};
class GenerateImageTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> articleTaskId{};
  shared_ptr<string> paragraphListShrink{};
  shared_ptr<string> size{};
  shared_ptr<string> style{};

  GenerateImageTaskShrinkRequest() {}

  explicit GenerateImageTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (articleTaskId) {
      res["ArticleTaskId"] = boost::any(*articleTaskId);
    }
    if (paragraphListShrink) {
      res["ParagraphList"] = boost::any(*paragraphListShrink);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (style) {
      res["Style"] = boost::any(*style);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ArticleTaskId") != m.end() && !m["ArticleTaskId"].empty()) {
      articleTaskId = make_shared<string>(boost::any_cast<string>(m["ArticleTaskId"]));
    }
    if (m.find("ParagraphList") != m.end() && !m["ParagraphList"].empty()) {
      paragraphListShrink = make_shared<string>(boost::any_cast<string>(m["ParagraphList"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
  }


  virtual ~GenerateImageTaskShrinkRequest() = default;
};
class GenerateImageTaskResponseBodyDataTaskList : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  GenerateImageTaskResponseBodyDataTaskList() {}

  explicit GenerateImageTaskResponseBodyDataTaskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GenerateImageTaskResponseBodyDataTaskList() = default;
};
class GenerateImageTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GenerateImageTaskResponseBodyDataTaskList>> taskList{};

  GenerateImageTaskResponseBodyData() {}

  explicit GenerateImageTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskList) {
      vector<boost::any> temp1;
      for(auto item1:*taskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskList") != m.end() && !m["TaskList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskList"].type()) {
        vector<GenerateImageTaskResponseBodyDataTaskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateImageTaskResponseBodyDataTaskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskList = make_shared<vector<GenerateImageTaskResponseBodyDataTaskList>>(expect1);
      }
    }
  }


  virtual ~GenerateImageTaskResponseBodyData() = default;
};
class GenerateImageTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateImageTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateImageTaskResponseBody() {}

  explicit GenerateImageTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateImageTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateImageTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateImageTaskResponseBody() = default;
};
class GenerateImageTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateImageTaskResponseBody> body{};

  GenerateImageTaskResponse() {}

  explicit GenerateImageTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateImageTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateImageTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateImageTaskResponse() = default;
};
class GenerateUploadConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> fileName{};
  shared_ptr<string> parentDir{};

  GenerateUploadConfigRequest() {}

  explicit GenerateUploadConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (parentDir) {
      res["ParentDir"] = boost::any(*parentDir);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("ParentDir") != m.end() && !m["ParentDir"].empty()) {
      parentDir = make_shared<string>(boost::any_cast<string>(m["ParentDir"]));
    }
  }


  virtual ~GenerateUploadConfigRequest() = default;
};
class GenerateUploadConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileKey{};
  shared_ptr<map<string, boost::any>> formDatas{};
  shared_ptr<string> postUrl{};

  GenerateUploadConfigResponseBodyData() {}

  explicit GenerateUploadConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (formDatas) {
      res["FormDatas"] = boost::any(*formDatas);
    }
    if (postUrl) {
      res["PostUrl"] = boost::any(*postUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FormDatas") != m.end() && !m["FormDatas"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FormDatas"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      formDatas = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("PostUrl") != m.end() && !m["PostUrl"].empty()) {
      postUrl = make_shared<string>(boost::any_cast<string>(m["PostUrl"]));
    }
  }


  virtual ~GenerateUploadConfigResponseBodyData() = default;
};
class GenerateUploadConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GenerateUploadConfigResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateUploadConfigResponseBody() {}

  explicit GenerateUploadConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GenerateUploadConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GenerateUploadConfigResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateUploadConfigResponseBody() = default;
};
class GenerateUploadConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateUploadConfigResponseBody> body{};

  GenerateUploadConfigResponse() {}

  explicit GenerateUploadConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateUploadConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateUploadConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateUploadConfigResponse() = default;
};
class GenerateViewPointRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> miniDoc{};

  GenerateViewPointRequestReferenceData() {}

  explicit GenerateViewPointRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (miniDoc) {
      res["MiniDoc"] = boost::any(*miniDoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MiniDoc") != m.end() && !m["MiniDoc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MiniDoc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MiniDoc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      miniDoc = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GenerateViewPointRequestReferenceData() = default;
};
class GenerateViewPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<GenerateViewPointRequestReferenceData> referenceData{};

  GenerateViewPointRequest() {}

  explicit GenerateViewPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        GenerateViewPointRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<GenerateViewPointRequestReferenceData>(model1);
      }
    }
  }


  virtual ~GenerateViewPointRequest() = default;
};
class GenerateViewPointShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> referenceDataShrink{};

  GenerateViewPointShrinkRequest() {}

  explicit GenerateViewPointShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
  }


  virtual ~GenerateViewPointShrinkRequest() = default;
};
class GenerateViewPointResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> point{};

  GenerateViewPointResponseBodyData() {}

  explicit GenerateViewPointResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (point) {
      res["Point"] = boost::any(*point);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
  }


  virtual ~GenerateViewPointResponseBodyData() = default;
};
class GenerateViewPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GenerateViewPointResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GenerateViewPointResponseBody() {}

  explicit GenerateViewPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GenerateViewPointResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateViewPointResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GenerateViewPointResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GenerateViewPointResponseBody() = default;
};
class GenerateViewPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateViewPointResponseBody> body{};

  GenerateViewPointResponse() {}

  explicit GenerateViewPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateViewPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateViewPointResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateViewPointResponse() = default;
};
class GetCategoriesByTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  GetCategoriesByTaskIdRequest() {}

  explicit GetCategoriesByTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetCategoriesByTaskIdRequest() = default;
};
class GetCategoriesByTaskIdResponseBodyDataChildren : public Darabonba::Model {
public:
  shared_ptr<string> category{};

  GetCategoriesByTaskIdResponseBodyDataChildren() {}

  explicit GetCategoriesByTaskIdResponseBodyDataChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
  }


  virtual ~GetCategoriesByTaskIdResponseBodyDataChildren() = default;
};
class GetCategoriesByTaskIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<vector<GetCategoriesByTaskIdResponseBodyDataChildren>> children{};
  shared_ptr<long> count{};

  GetCategoriesByTaskIdResponseBodyData() {}

  explicit GetCategoriesByTaskIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (children) {
      vector<boost::any> temp1;
      for(auto item1:*children){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Children"] = boost::any(temp1);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<GetCategoriesByTaskIdResponseBodyDataChildren> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Children"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoriesByTaskIdResponseBodyDataChildren model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        children = make_shared<vector<GetCategoriesByTaskIdResponseBodyDataChildren>>(expect1);
      }
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~GetCategoriesByTaskIdResponseBodyData() = default;
};
class GetCategoriesByTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetCategoriesByTaskIdResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCategoriesByTaskIdResponseBody() {}

  explicit GetCategoriesByTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetCategoriesByTaskIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCategoriesByTaskIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetCategoriesByTaskIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCategoriesByTaskIdResponseBody() = default;
};
class GetCategoriesByTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCategoriesByTaskIdResponseBody> body{};

  GetCategoriesByTaskIdResponse() {}

  explicit GetCategoriesByTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCategoriesByTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCategoriesByTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetCategoriesByTaskIdResponse() = default;
};
class GetCustomHotTopicBroadcastJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  GetCustomHotTopicBroadcastJobRequest() {}

  explicit GetCustomHotTopicBroadcastJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetCustomHotTopicBroadcastJobRequest() = default;
};
class GetCustomHotTopicBroadcastJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<string> status{};

  GetCustomHotTopicBroadcastJobResponseBodyData() {}

  explicit GetCustomHotTopicBroadcastJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetCustomHotTopicBroadcastJobResponseBodyData() = default;
};
class GetCustomHotTopicBroadcastJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCustomHotTopicBroadcastJobResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomHotTopicBroadcastJobResponseBody() {}

  explicit GetCustomHotTopicBroadcastJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCustomHotTopicBroadcastJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCustomHotTopicBroadcastJobResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCustomHotTopicBroadcastJobResponseBody() = default;
};
class GetCustomHotTopicBroadcastJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomHotTopicBroadcastJobResponseBody> body{};

  GetCustomHotTopicBroadcastJobResponse() {}

  explicit GetCustomHotTopicBroadcastJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomHotTopicBroadcastJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomHotTopicBroadcastJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomHotTopicBroadcastJobResponse() = default;
};
class GetCustomTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> commodityCode{};
  shared_ptr<long> id{};

  GetCustomTextRequest() {}

  explicit GetCustomTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetCustomTextRequest() = default;
};
class GetCustomTextResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};

  GetCustomTextResponseBodyData() {}

  explicit GetCustomTextResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
  }


  virtual ~GetCustomTextResponseBodyData() = default;
};
class GetCustomTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCustomTextResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomTextResponseBody() {}

  explicit GetCustomTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCustomTextResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCustomTextResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCustomTextResponseBody() = default;
};
class GetCustomTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTextResponseBody> body{};

  GetCustomTextResponse() {}

  explicit GetCustomTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTextResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTextResponse() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskRequest() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskRequest() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints>> viewPoints{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudesViewPoints>>(expect1);
      }
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes>> attitudes{};
  shared_ptr<string> topic{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitudes) {
      vector<boost::any> temp1;
      for(auto item1:*attitudes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attitudes"] = boost::any(temp1);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attitudes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attitudes = make_shared<vector<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResultAttitudes>>(expect1);
      }
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult> customViewPointsResult{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> status{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customViewPointsResult) {
      res["CustomViewPointsResult"] = customViewPointsResult ? boost::any(customViewPointsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomViewPointsResult") != m.end() && !m["CustomViewPointsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomViewPointsResult"].type()) {
        GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomViewPointsResult"]));
        customViewPointsResult = make_shared<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyDataCustomViewPointsResult>(model1);
      }
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody() = default;
};
class GetCustomTopicSelectionPerspectiveAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody> body{};

  GetCustomTopicSelectionPerspectiveAnalysisTaskResponse() {}

  explicit GetCustomTopicSelectionPerspectiveAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCustomTopicSelectionPerspectiveAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetCustomTopicSelectionPerspectiveAnalysisTaskResponse() = default;
};
class GetDataSourceOrderConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> productCode{};

  GetDataSourceOrderConfigRequest() {}

  explicit GetDataSourceOrderConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
  }


  virtual ~GetDataSourceOrderConfigRequest() = default;
};
class GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> number{};
  shared_ptr<string> type{};

  GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList() {}

  explicit GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList() = default;
};
class GetDataSourceOrderConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList>> userConfigDataSourceList{};

  GetDataSourceOrderConfigResponseBodyData() {}

  explicit GetDataSourceOrderConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userConfigDataSourceList) {
      vector<boost::any> temp1;
      for(auto item1:*userConfigDataSourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserConfigDataSourceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserConfigDataSourceList") != m.end() && !m["UserConfigDataSourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserConfigDataSourceList"].type()) {
        vector<GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserConfigDataSourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userConfigDataSourceList = make_shared<vector<GetDataSourceOrderConfigResponseBodyDataUserConfigDataSourceList>>(expect1);
      }
    }
  }


  virtual ~GetDataSourceOrderConfigResponseBodyData() = default;
};
class GetDataSourceOrderConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDataSourceOrderConfigResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataSourceOrderConfigResponseBody() {}

  explicit GetDataSourceOrderConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDataSourceOrderConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDataSourceOrderConfigResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataSourceOrderConfigResponseBody() = default;
};
class GetDataSourceOrderConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataSourceOrderConfigResponseBody> body{};

  GetDataSourceOrderConfigResponse() {}

  explicit GetDataSourceOrderConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataSourceOrderConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataSourceOrderConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataSourceOrderConfigResponse() = default;
};
class GetDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> workspaceId{};

  GetDatasetRequest() {}

  explicit GetDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetDatasetRequest() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>> headers{};
  shared_ptr<string> method{};
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>> params{};
  shared_ptr<bool> pathParamsEnable{};
  shared_ptr<long> socketTimeout{};
  shared_ptr<string> url{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (params) {
      vector<boost::any> temp1;
      for(auto item1:*params){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Params"] = boost::any(temp1);
    }
    if (pathParamsEnable) {
      res["PathParamsEnable"] = boost::any(*pathParamsEnable);
    }
    if (socketTimeout) {
      res["SocketTimeout"] = boost::any(*socketTimeout);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Params"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        params = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>>(expect1);
      }
    }
    if (m.find("PathParamsEnable") != m.end() && !m["PathParamsEnable"].empty()) {
      pathParamsEnable = make_shared<bool>(boost::any_cast<bool>(m["PathParamsEnable"]));
    }
    if (m.find("SocketTimeout") != m.end() && !m["SocketTimeout"].empty()) {
      socketTimeout = make_shared<long>(boost::any_cast<long>(m["SocketTimeout"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>> jqNodes{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>>(expect1);
      }
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() = default;
};
class GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> demoQuery{};
  shared_ptr<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig> searchSourceRequestConfig{};
  shared_ptr<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig> searchSourceResponseConfig{};
  shared_ptr<long> size{};

  GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs() {}

  explicit GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoQuery) {
      res["DemoQuery"] = boost::any(*demoQuery);
    }
    if (searchSourceRequestConfig) {
      res["SearchSourceRequestConfig"] = searchSourceRequestConfig ? boost::any(searchSourceRequestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchSourceResponseConfig) {
      res["SearchSourceResponseConfig"] = searchSourceResponseConfig ? boost::any(searchSourceResponseConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoQuery") != m.end() && !m["DemoQuery"].empty()) {
      demoQuery = make_shared<string>(boost::any_cast<string>(m["DemoQuery"]));
    }
    if (m.find("SearchSourceRequestConfig") != m.end() && !m["SearchSourceRequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceRequestConfig"].type()) {
        GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceRequestConfig"]));
        searchSourceRequestConfig = make_shared<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceRequestConfig>(model1);
      }
    }
    if (m.find("SearchSourceResponseConfig") != m.end() && !m["SearchSourceResponseConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceResponseConfig"].type()) {
        GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceResponseConfig"]));
        searchSourceResponseConfig = make_shared<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigsSearchSourceResponseConfig>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs() = default;
};
class GetDatasetResponseBodyDataDatasetConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs>> searchSourceConfigs{};

  GetDatasetResponseBodyDataDatasetConfig() {}

  explicit GetDatasetResponseBodyDataDatasetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*searchSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSourceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchSourceConfigs") != m.end() && !m["SearchSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSourceConfigs"].type()) {
        vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSourceConfigs = make_shared<vector<GetDatasetResponseBodyDataDatasetConfigSearchSourceConfigs>>(expect1);
      }
    }
  }


  virtual ~GetDatasetResponseBodyDataDatasetConfig() = default;
};
class GetDatasetResponseBodyDataDocumentHandleConfig : public Darabonba::Model {
public:
  shared_ptr<bool> disableHandleMultimodalMedia{};

  GetDatasetResponseBodyDataDocumentHandleConfig() {}

  explicit GetDatasetResponseBodyDataDocumentHandleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableHandleMultimodalMedia) {
      res["DisableHandleMultimodalMedia"] = boost::any(*disableHandleMultimodalMedia);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableHandleMultimodalMedia") != m.end() && !m["DisableHandleMultimodalMedia"].empty()) {
      disableHandleMultimodalMedia = make_shared<bool>(boost::any_cast<bool>(m["DisableHandleMultimodalMedia"]));
    }
  }


  virtual ~GetDatasetResponseBodyDataDocumentHandleConfig() = default;
};
class GetDatasetResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<GetDatasetResponseBodyDataDatasetConfig> datasetConfig{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<GetDatasetResponseBodyDataDocumentHandleConfig> documentHandleConfig{};
  shared_ptr<long> searchDatasetEnable{};

  GetDatasetResponseBodyData() {}

  explicit GetDatasetResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (datasetConfig) {
      res["DatasetConfig"] = datasetConfig ? boost::any(datasetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (documentHandleConfig) {
      res["DocumentHandleConfig"] = documentHandleConfig ? boost::any(documentHandleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DatasetConfig") != m.end() && !m["DatasetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatasetConfig"].type()) {
        GetDatasetResponseBodyDataDatasetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatasetConfig"]));
        datasetConfig = make_shared<GetDatasetResponseBodyDataDatasetConfig>(model1);
      }
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("DocumentHandleConfig") != m.end() && !m["DocumentHandleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DocumentHandleConfig"].type()) {
        GetDatasetResponseBodyDataDocumentHandleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DocumentHandleConfig"]));
        documentHandleConfig = make_shared<GetDatasetResponseBodyDataDocumentHandleConfig>(model1);
      }
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
  }


  virtual ~GetDatasetResponseBodyData() = default;
};
class GetDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDatasetResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDatasetResponseBody() {}

  explicit GetDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDatasetResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDatasetResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDatasetResponseBody() = default;
};
class GetDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatasetResponseBody> body{};

  GetDatasetResponse() {}

  explicit GetDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatasetResponse() = default;
};
class GetDatasetDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> workspaceId{};

  GetDatasetDocumentRequest() {}

  explicit GetDatasetDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetDatasetDocumentRequest() = default;
};
class GetDatasetDocumentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> disableHandleMultimodalMedia{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> sourceFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  GetDatasetDocumentResponseBodyData() {}

  explicit GetDatasetDocumentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (disableHandleMultimodalMedia) {
      res["DisableHandleMultimodalMedia"] = boost::any(*disableHandleMultimodalMedia);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (sourceFrom) {
      res["SourceFrom"] = boost::any(*sourceFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DisableHandleMultimodalMedia") != m.end() && !m["DisableHandleMultimodalMedia"].empty()) {
      disableHandleMultimodalMedia = make_shared<bool>(boost::any_cast<bool>(m["DisableHandleMultimodalMedia"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SourceFrom") != m.end() && !m["SourceFrom"].empty()) {
      sourceFrom = make_shared<string>(boost::any_cast<string>(m["SourceFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetDatasetDocumentResponseBodyData() = default;
};
class GetDatasetDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDatasetDocumentResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDatasetDocumentResponseBody() {}

  explicit GetDatasetDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDatasetDocumentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDatasetDocumentResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDatasetDocumentResponseBody() = default;
};
class GetDatasetDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatasetDocumentResponseBody> body{};

  GetDatasetDocumentResponse() {}

  explicit GetDatasetDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatasetDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatasetDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatasetDocumentResponse() = default;
};
class GetDocClusterTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  GetDocClusterTaskRequest() {}

  explicit GetDocClusterTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetDocClusterTaskRequest() = default;
};
class GetDocClusterTaskResponseBodyDataTopics : public Darabonba::Model {
public:
  shared_ptr<vector<string>> docIds{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  GetDocClusterTaskResponseBodyDataTopics() {}

  explicit GetDocClusterTaskResponseBodyDataTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetDocClusterTaskResponseBodyDataTopics() = default;
};
class GetDocClusterTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetDocClusterTaskResponseBodyDataTopics>> topics{};

  GetDocClusterTaskResponseBodyData() {}

  explicit GetDocClusterTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (topics) {
      vector<boost::any> temp1;
      for(auto item1:*topics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Topics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<GetDocClusterTaskResponseBodyDataTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Topics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDocClusterTaskResponseBodyDataTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topics = make_shared<vector<GetDocClusterTaskResponseBodyDataTopics>>(expect1);
      }
    }
  }


  virtual ~GetDocClusterTaskResponseBodyData() = default;
};
class GetDocClusterTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDocClusterTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDocClusterTaskResponseBody() {}

  explicit GetDocClusterTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDocClusterTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDocClusterTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDocClusterTaskResponseBody() = default;
};
class GetDocClusterTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDocClusterTaskResponseBody> body{};

  GetDocClusterTaskResponse() {}

  explicit GetDocClusterTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDocClusterTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDocClusterTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetDocClusterTaskResponse() = default;
};
class GetDocInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docId{};
  shared_ptr<string> workspaceId{};

  GetDocInfoRequest() {}

  explicit GetDocInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetDocInfoRequest() = default;
};
class GetDocInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docName{};
  shared_ptr<string> docType{};
  shared_ptr<string> fileUrl{};
  shared_ptr<long> status{};
  shared_ptr<string> statusMessage{};
  shared_ptr<vector<string>> videoContents{};

  GetDocInfoResponseBodyData() {}

  explicit GetDocInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusMessage) {
      res["StatusMessage"] = boost::any(*statusMessage);
    }
    if (videoContents) {
      res["VideoContents"] = boost::any(*videoContents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusMessage") != m.end() && !m["StatusMessage"].empty()) {
      statusMessage = make_shared<string>(boost::any_cast<string>(m["StatusMessage"]));
    }
    if (m.find("VideoContents") != m.end() && !m["VideoContents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VideoContents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VideoContents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      videoContents = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetDocInfoResponseBodyData() = default;
};
class GetDocInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDocInfoResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDocInfoResponseBody() {}

  explicit GetDocInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDocInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDocInfoResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDocInfoResponseBody() = default;
};
class GetDocInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDocInfoResponseBody> body{};

  GetDocInfoResponse() {}

  explicit GetDocInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDocInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDocInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetDocInfoResponse() = default;
};
class GetEnterpriseVocAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  GetEnterpriseVocAnalysisTaskRequest() {}

  explicit GetEnterpriseVocAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskRequest() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagTaskType{};
  shared_ptr<long> valueCount{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagTaskType) {
      res["TagTaskType"] = boost::any(*tagTaskType);
    }
    if (valueCount) {
      res["ValueCount"] = boost::any(*valueCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagTaskType") != m.end() && !m["TagTaskType"].empty()) {
      tagTaskType = make_shared<string>(boost::any_cast<string>(m["TagTaskType"]));
    }
    if (m.find("ValueCount") != m.end() && !m["ValueCount"].empty()) {
      valueCount = make_shared<long>(boost::any_cast<long>(m["ValueCount"]));
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic>> tagValueCountStatistic{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValueCountStatistic) {
      vector<boost::any> temp1;
      for(auto item1:*tagValueCountStatistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagValueCountStatistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValueCountStatistic") != m.end() && !m["TagValueCountStatistic"].empty()) {
      if (typeid(vector<boost::any>) == m["TagValueCountStatistic"].type()) {
        vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagValueCountStatistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagValueCountStatistic = make_shared<vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatisticsTagValueCountStatistic>>(expect1);
      }
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic : public Darabonba::Model {
public:
  shared_ptr<string> tagName{};
  shared_ptr<string> tagTaskType{};
  shared_ptr<long> valueCount{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagTaskType) {
      res["TagTaskType"] = boost::any(*tagTaskType);
    }
    if (valueCount) {
      res["ValueCount"] = boost::any(*valueCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagTaskType") != m.end() && !m["TagTaskType"].empty()) {
      tagTaskType = make_shared<string>(boost::any_cast<string>(m["TagTaskType"]));
    }
    if (m.find("ValueCount") != m.end() && !m["ValueCount"].empty()) {
      valueCount = make_shared<long>(boost::any_cast<long>(m["ValueCount"]));
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic>> tagValueCountStatistic{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagValueCountStatistic) {
      vector<boost::any> temp1;
      for(auto item1:*tagValueCountStatistic){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagValueCountStatistic"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagValueCountStatistic") != m.end() && !m["TagValueCountStatistic"].empty()) {
      if (typeid(vector<boost::any>) == m["TagValueCountStatistic"].type()) {
        vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagValueCountStatistic"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagValueCountStatistic = make_shared<vector<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatisticsTagValueCountStatistic>>(expect1);
      }
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics> filterDimensionStatistics{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics> tagDimensionStatistics{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (filterDimensionStatistics) {
      res["FilterDimensionStatistics"] = filterDimensionStatistics ? boost::any(filterDimensionStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagDimensionStatistics) {
      res["TagDimensionStatistics"] = tagDimensionStatistics ? boost::any(tagDimensionStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FilterDimensionStatistics") != m.end() && !m["FilterDimensionStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterDimensionStatistics"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterDimensionStatistics"]));
        filterDimensionStatistics = make_shared<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewFilterDimensionStatistics>(model1);
      }
    }
    if (m.find("TagDimensionStatistics") != m.end() && !m["TagDimensionStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagDimensionStatistics"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagDimensionStatistics"]));
        tagDimensionStatistics = make_shared<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverviewTagDimensionStatistics>(model1);
      }
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyDataUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};

  GetEnterpriseVocAnalysisTaskResponseBodyDataUsage() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyDataUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyDataUsage() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview> statisticsOverview{};
  shared_ptr<string> status{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBodyDataUsage> usage{};

  GetEnterpriseVocAnalysisTaskResponseBodyData() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (statisticsOverview) {
      res["StatisticsOverview"] = statisticsOverview ? boost::any(statisticsOverview->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("StatisticsOverview") != m.end() && !m["StatisticsOverview"].empty()) {
      if (typeid(map<string, boost::any>) == m["StatisticsOverview"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StatisticsOverview"]));
        statisticsOverview = make_shared<GetEnterpriseVocAnalysisTaskResponseBodyDataStatisticsOverview>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBodyDataUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<GetEnterpriseVocAnalysisTaskResponseBodyDataUsage>(model1);
      }
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBodyData() = default;
};
class GetEnterpriseVocAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEnterpriseVocAnalysisTaskResponseBody() {}

  explicit GetEnterpriseVocAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetEnterpriseVocAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponseBody() = default;
};
class GetEnterpriseVocAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEnterpriseVocAnalysisTaskResponseBody> body{};

  GetEnterpriseVocAnalysisTaskResponse() {}

  explicit GetEnterpriseVocAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEnterpriseVocAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEnterpriseVocAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetEnterpriseVocAnalysisTaskResponse() = default;
};
class GetGeneratedContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> id{};

  GetGeneratedContentRequest() {}

  explicit GetGeneratedContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetGeneratedContentRequest() = default;
};
class GetGeneratedContentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentDomain{};
  shared_ptr<string> contentText{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> keywordList{};
  shared_ptr<string> keywords{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};
  shared_ptr<string> uuid{};

  GetGeneratedContentResponseBodyData() {}

  explicit GetGeneratedContentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentDomain) {
      res["ContentDomain"] = boost::any(*contentDomain);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywordList) {
      res["KeywordList"] = boost::any(*keywordList);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentDomain") != m.end() && !m["ContentDomain"].empty()) {
      contentDomain = make_shared<string>(boost::any_cast<string>(m["ContentDomain"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("KeywordList") != m.end() && !m["KeywordList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["KeywordList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["KeywordList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywordList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~GetGeneratedContentResponseBodyData() = default;
};
class GetGeneratedContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetGeneratedContentResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetGeneratedContentResponseBody() {}

  explicit GetGeneratedContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetGeneratedContentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetGeneratedContentResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetGeneratedContentResponseBody() = default;
};
class GetGeneratedContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGeneratedContentResponseBody> body{};

  GetGeneratedContentResponse() {}

  explicit GetGeneratedContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGeneratedContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGeneratedContentResponseBody>(model1);
      }
    }
  }


  virtual ~GetGeneratedContentResponse() = default;
};
class GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig : public Darabonba::Model {
public:
  shared_ptr<long> summaryImageCount{};
  shared_ptr<string> summaryModel{};
  shared_ptr<string> summaryPrompt{};

  GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig() {}

  explicit GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryImageCount) {
      res["SummaryImageCount"] = boost::any(*summaryImageCount);
    }
    if (summaryModel) {
      res["SummaryModel"] = boost::any(*summaryModel);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryImageCount") != m.end() && !m["SummaryImageCount"].empty()) {
      summaryImageCount = make_shared<long>(boost::any_cast<long>(m["SummaryImageCount"]));
    }
    if (m.find("SummaryModel") != m.end() && !m["SummaryModel"].empty()) {
      summaryModel = make_shared<string>(boost::any_cast<string>(m["SummaryModel"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
  }


  virtual ~GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig() = default;
};
class GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<long> weight{};

  GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights() {}

  explicit GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights() = default;
};
class GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<vector<GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights>> customHotValueWeights{};
  shared_ptr<long> topicCount{};

  GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig() {}

  explicit GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (customHotValueWeights) {
      vector<boost::any> temp1;
      for(auto item1:*customHotValueWeights){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomHotValueWeights"] = boost::any(temp1);
    }
    if (topicCount) {
      res["TopicCount"] = boost::any(*topicCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomHotValueWeights") != m.end() && !m["CustomHotValueWeights"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomHotValueWeights"].type()) {
        vector<GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomHotValueWeights"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customHotValueWeights = make_shared<vector<GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfigCustomHotValueWeights>>(expect1);
      }
    }
    if (m.find("TopicCount") != m.end() && !m["TopicCount"].empty()) {
      topicCount = make_shared<long>(boost::any_cast<long>(m["TopicCount"]));
    }
  }


  virtual ~GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig() = default;
};
class GetHotTopicBroadcastRequest : public Darabonba::Model {
public:
  shared_ptr<bool> calcTotalToken{};
  shared_ptr<string> category{};
  shared_ptr<long> current{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<string> locationQuery{};
  shared_ptr<vector<string>> locations{};
  shared_ptr<string> query{};
  shared_ptr<long> size{};
  shared_ptr<GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig> stepForCustomSummaryStyleConfig{};
  shared_ptr<GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig> stepForNewsBroadcastContentConfig{};
  shared_ptr<vector<string>> topics{};
  shared_ptr<string> workspaceId{};

  GetHotTopicBroadcastRequest() {}

  explicit GetHotTopicBroadcastRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calcTotalToken) {
      res["CalcTotalToken"] = boost::any(*calcTotalToken);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (locationQuery) {
      res["LocationQuery"] = boost::any(*locationQuery);
    }
    if (locations) {
      res["Locations"] = boost::any(*locations);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (stepForCustomSummaryStyleConfig) {
      res["StepForCustomSummaryStyleConfig"] = stepForCustomSummaryStyleConfig ? boost::any(stepForCustomSummaryStyleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepForNewsBroadcastContentConfig) {
      res["StepForNewsBroadcastContentConfig"] = stepForNewsBroadcastContentConfig ? boost::any(stepForNewsBroadcastContentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topics) {
      res["Topics"] = boost::any(*topics);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalcTotalToken") != m.end() && !m["CalcTotalToken"].empty()) {
      calcTotalToken = make_shared<bool>(boost::any_cast<bool>(m["CalcTotalToken"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("LocationQuery") != m.end() && !m["LocationQuery"].empty()) {
      locationQuery = make_shared<string>(boost::any_cast<string>(m["LocationQuery"]));
    }
    if (m.find("Locations") != m.end() && !m["Locations"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Locations"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Locations"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locations = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StepForCustomSummaryStyleConfig") != m.end() && !m["StepForCustomSummaryStyleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StepForCustomSummaryStyleConfig"].type()) {
        GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StepForCustomSummaryStyleConfig"]));
        stepForCustomSummaryStyleConfig = make_shared<GetHotTopicBroadcastRequestStepForCustomSummaryStyleConfig>(model1);
      }
    }
    if (m.find("StepForNewsBroadcastContentConfig") != m.end() && !m["StepForNewsBroadcastContentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StepForNewsBroadcastContentConfig"].type()) {
        GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StepForNewsBroadcastContentConfig"]));
        stepForNewsBroadcastContentConfig = make_shared<GetHotTopicBroadcastRequestStepForNewsBroadcastContentConfig>(model1);
      }
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetHotTopicBroadcastRequest() = default;
};
class GetHotTopicBroadcastShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> calcTotalToken{};
  shared_ptr<string> category{};
  shared_ptr<long> current{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<string> locationQuery{};
  shared_ptr<string> locationsShrink{};
  shared_ptr<string> query{};
  shared_ptr<long> size{};
  shared_ptr<string> stepForCustomSummaryStyleConfigShrink{};
  shared_ptr<string> stepForNewsBroadcastContentConfigShrink{};
  shared_ptr<string> topicsShrink{};
  shared_ptr<string> workspaceId{};

  GetHotTopicBroadcastShrinkRequest() {}

  explicit GetHotTopicBroadcastShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calcTotalToken) {
      res["CalcTotalToken"] = boost::any(*calcTotalToken);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (locationQuery) {
      res["LocationQuery"] = boost::any(*locationQuery);
    }
    if (locationsShrink) {
      res["Locations"] = boost::any(*locationsShrink);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (stepForCustomSummaryStyleConfigShrink) {
      res["StepForCustomSummaryStyleConfig"] = boost::any(*stepForCustomSummaryStyleConfigShrink);
    }
    if (stepForNewsBroadcastContentConfigShrink) {
      res["StepForNewsBroadcastContentConfig"] = boost::any(*stepForNewsBroadcastContentConfigShrink);
    }
    if (topicsShrink) {
      res["Topics"] = boost::any(*topicsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalcTotalToken") != m.end() && !m["CalcTotalToken"].empty()) {
      calcTotalToken = make_shared<bool>(boost::any_cast<bool>(m["CalcTotalToken"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("LocationQuery") != m.end() && !m["LocationQuery"].empty()) {
      locationQuery = make_shared<string>(boost::any_cast<string>(m["LocationQuery"]));
    }
    if (m.find("Locations") != m.end() && !m["Locations"].empty()) {
      locationsShrink = make_shared<string>(boost::any_cast<string>(m["Locations"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StepForCustomSummaryStyleConfig") != m.end() && !m["StepForCustomSummaryStyleConfig"].empty()) {
      stepForCustomSummaryStyleConfigShrink = make_shared<string>(boost::any_cast<string>(m["StepForCustomSummaryStyleConfig"]));
    }
    if (m.find("StepForNewsBroadcastContentConfig") != m.end() && !m["StepForNewsBroadcastContentConfig"].empty()) {
      stepForNewsBroadcastContentConfigShrink = make_shared<string>(boost::any_cast<string>(m["StepForNewsBroadcastContentConfig"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      topicsShrink = make_shared<string>(boost::any_cast<string>(m["Topics"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetHotTopicBroadcastShrinkRequest() = default;
};
class GetHotTopicBroadcastResponseBodyDataDataImages : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  GetHotTopicBroadcastResponseBodyDataDataImages() {}

  explicit GetHotTopicBroadcastResponseBodyDataDataImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataDataImages() = default;
};
class GetHotTopicBroadcastResponseBodyDataDataNewsComments : public Darabonba::Model {
public:
  shared_ptr<string> text{};
  shared_ptr<string> username{};

  GetHotTopicBroadcastResponseBodyDataDataNewsComments() {}

  explicit GetHotTopicBroadcastResponseBodyDataDataNewsComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataDataNewsComments() = default;
};
class GetHotTopicBroadcastResponseBodyDataDataNews : public Darabonba::Model {
public:
  shared_ptr<string> analysisCategory{};
  shared_ptr<string> analysisTopic{};
  shared_ptr<string> author{};
  shared_ptr<vector<string>> category{};
  shared_ptr<vector<GetHotTopicBroadcastResponseBodyDataDataNewsComments>> comments{};
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> dt{};
  shared_ptr<string> hotTopic{};
  shared_ptr<vector<string>> imgList{};
  shared_ptr<string> logo{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<string> uuid{};
  shared_ptr<string> website{};

  GetHotTopicBroadcastResponseBodyDataDataNews() {}

  explicit GetHotTopicBroadcastResponseBodyDataDataNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analysisCategory) {
      res["AnalysisCategory"] = boost::any(*analysisCategory);
    }
    if (analysisTopic) {
      res["AnalysisTopic"] = boost::any(*analysisTopic);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Comments"] = boost::any(temp1);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (dt) {
      res["Dt"] = boost::any(*dt);
    }
    if (hotTopic) {
      res["HotTopic"] = boost::any(*hotTopic);
    }
    if (imgList) {
      res["ImgList"] = boost::any(*imgList);
    }
    if (logo) {
      res["Logo"] = boost::any(*logo);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (website) {
      res["Website"] = boost::any(*website);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnalysisCategory") != m.end() && !m["AnalysisCategory"].empty()) {
      analysisCategory = make_shared<string>(boost::any_cast<string>(m["AnalysisCategory"]));
    }
    if (m.find("AnalysisTopic") != m.end() && !m["AnalysisTopic"].empty()) {
      analysisTopic = make_shared<string>(boost::any_cast<string>(m["AnalysisTopic"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Category"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Category"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      category = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      if (typeid(vector<boost::any>) == m["Comments"].type()) {
        vector<GetHotTopicBroadcastResponseBodyDataDataNewsComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastResponseBodyDataDataNewsComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<GetHotTopicBroadcastResponseBodyDataDataNewsComments>>(expect1);
      }
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Dt") != m.end() && !m["Dt"].empty()) {
      dt = make_shared<string>(boost::any_cast<string>(m["Dt"]));
    }
    if (m.find("HotTopic") != m.end() && !m["HotTopic"].empty()) {
      hotTopic = make_shared<string>(boost::any_cast<string>(m["HotTopic"]));
    }
    if (m.find("ImgList") != m.end() && !m["ImgList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImgList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImgList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imgList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Logo") != m.end() && !m["Logo"].empty()) {
      logo = make_shared<string>(boost::any_cast<string>(m["Logo"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("Website") != m.end() && !m["Website"].empty()) {
      website = make_shared<string>(boost::any_cast<string>(m["Website"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataDataNews() = default;
};
class GetHotTopicBroadcastResponseBodyDataDataSummarySummaries : public Darabonba::Model {
public:
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  GetHotTopicBroadcastResponseBodyDataDataSummarySummaries() {}

  explicit GetHotTopicBroadcastResponseBodyDataDataSummarySummaries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataDataSummarySummaries() = default;
};
class GetHotTopicBroadcastResponseBodyDataDataSummary : public Darabonba::Model {
public:
  shared_ptr<long> inputToken{};
  shared_ptr<long> outputToken{};
  shared_ptr<vector<GetHotTopicBroadcastResponseBodyDataDataSummarySummaries>> summaries{};

  GetHotTopicBroadcastResponseBodyDataDataSummary() {}

  explicit GetHotTopicBroadcastResponseBodyDataDataSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputToken) {
      res["InputToken"] = boost::any(*inputToken);
    }
    if (outputToken) {
      res["OutputToken"] = boost::any(*outputToken);
    }
    if (summaries) {
      vector<boost::any> temp1;
      for(auto item1:*summaries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summaries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputToken") != m.end() && !m["InputToken"].empty()) {
      inputToken = make_shared<long>(boost::any_cast<long>(m["InputToken"]));
    }
    if (m.find("OutputToken") != m.end() && !m["OutputToken"].empty()) {
      outputToken = make_shared<long>(boost::any_cast<long>(m["OutputToken"]));
    }
    if (m.find("Summaries") != m.end() && !m["Summaries"].empty()) {
      if (typeid(vector<boost::any>) == m["Summaries"].type()) {
        vector<GetHotTopicBroadcastResponseBodyDataDataSummarySummaries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summaries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastResponseBodyDataDataSummarySummaries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summaries = make_shared<vector<GetHotTopicBroadcastResponseBodyDataDataSummarySummaries>>(expect1);
      }
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataDataSummary() = default;
};
class GetHotTopicBroadcastResponseBodyDataData : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> createTime{};
  shared_ptr<double> customHotValue{};
  shared_ptr<string> customTextSummary{};
  shared_ptr<string> hotTopic{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<double> hotValue{};
  shared_ptr<string> id{};
  shared_ptr<vector<GetHotTopicBroadcastResponseBodyDataDataImages>> images{};
  shared_ptr<long> inputToken{};
  shared_ptr<vector<string>> locations{};
  shared_ptr<vector<GetHotTopicBroadcastResponseBodyDataDataNews>> news{};
  shared_ptr<long> outputToken{};
  shared_ptr<GetHotTopicBroadcastResponseBodyDataDataSummary> summary{};
  shared_ptr<string> textSummary{};

  GetHotTopicBroadcastResponseBodyDataData() {}

  explicit GetHotTopicBroadcastResponseBodyDataData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customHotValue) {
      res["CustomHotValue"] = boost::any(*customHotValue);
    }
    if (customTextSummary) {
      res["CustomTextSummary"] = boost::any(*customTextSummary);
    }
    if (hotTopic) {
      res["HotTopic"] = boost::any(*hotTopic);
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (hotValue) {
      res["HotValue"] = boost::any(*hotValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Images"] = boost::any(temp1);
    }
    if (inputToken) {
      res["InputToken"] = boost::any(*inputToken);
    }
    if (locations) {
      res["Locations"] = boost::any(*locations);
    }
    if (news) {
      vector<boost::any> temp1;
      for(auto item1:*news){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["News"] = boost::any(temp1);
    }
    if (outputToken) {
      res["OutputToken"] = boost::any(*outputToken);
    }
    if (summary) {
      res["Summary"] = summary ? boost::any(summary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textSummary) {
      res["TextSummary"] = boost::any(*textSummary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomHotValue") != m.end() && !m["CustomHotValue"].empty()) {
      customHotValue = make_shared<double>(boost::any_cast<double>(m["CustomHotValue"]));
    }
    if (m.find("CustomTextSummary") != m.end() && !m["CustomTextSummary"].empty()) {
      customTextSummary = make_shared<string>(boost::any_cast<string>(m["CustomTextSummary"]));
    }
    if (m.find("HotTopic") != m.end() && !m["HotTopic"].empty()) {
      hotTopic = make_shared<string>(boost::any_cast<string>(m["HotTopic"]));
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("HotValue") != m.end() && !m["HotValue"].empty()) {
      hotValue = make_shared<double>(boost::any_cast<double>(m["HotValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<GetHotTopicBroadcastResponseBodyDataDataImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastResponseBodyDataDataImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<GetHotTopicBroadcastResponseBodyDataDataImages>>(expect1);
      }
    }
    if (m.find("InputToken") != m.end() && !m["InputToken"].empty()) {
      inputToken = make_shared<long>(boost::any_cast<long>(m["InputToken"]));
    }
    if (m.find("Locations") != m.end() && !m["Locations"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Locations"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Locations"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locations = make_shared<vector<string>>(toVec1);
    }
    if (m.find("News") != m.end() && !m["News"].empty()) {
      if (typeid(vector<boost::any>) == m["News"].type()) {
        vector<GetHotTopicBroadcastResponseBodyDataDataNews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["News"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastResponseBodyDataDataNews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        news = make_shared<vector<GetHotTopicBroadcastResponseBodyDataDataNews>>(expect1);
      }
    }
    if (m.find("OutputToken") != m.end() && !m["OutputToken"].empty()) {
      outputToken = make_shared<long>(boost::any_cast<long>(m["OutputToken"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Summary"].type()) {
        GetHotTopicBroadcastResponseBodyDataDataSummary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Summary"]));
        summary = make_shared<GetHotTopicBroadcastResponseBodyDataDataSummary>(model1);
      }
    }
    if (m.find("TextSummary") != m.end() && !m["TextSummary"].empty()) {
      textSummary = make_shared<string>(boost::any_cast<string>(m["TextSummary"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataData() = default;
};
class GetHotTopicBroadcastResponseBodyDataTotalTokenInfo : public Darabonba::Model {
public:
  shared_ptr<long> hotTopicCount{};
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> wordCount{};

  GetHotTopicBroadcastResponseBodyDataTotalTokenInfo() {}

  explicit GetHotTopicBroadcastResponseBodyDataTotalTokenInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotTopicCount) {
      res["HotTopicCount"] = boost::any(*hotTopicCount);
    }
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (wordCount) {
      res["WordCount"] = boost::any(*wordCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotTopicCount") != m.end() && !m["HotTopicCount"].empty()) {
      hotTopicCount = make_shared<long>(boost::any_cast<long>(m["HotTopicCount"]));
    }
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("WordCount") != m.end() && !m["WordCount"].empty()) {
      wordCount = make_shared<long>(boost::any_cast<long>(m["WordCount"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyDataTotalTokenInfo() = default;
};
class GetHotTopicBroadcastResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetHotTopicBroadcastResponseBodyDataData>> data{};
  shared_ptr<long> totalCount{};
  shared_ptr<GetHotTopicBroadcastResponseBodyDataTotalTokenInfo> totalTokenInfo{};

  GetHotTopicBroadcastResponseBodyData() {}

  explicit GetHotTopicBroadcastResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalTokenInfo) {
      res["TotalTokenInfo"] = totalTokenInfo ? boost::any(totalTokenInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetHotTopicBroadcastResponseBodyDataData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHotTopicBroadcastResponseBodyDataData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetHotTopicBroadcastResponseBodyDataData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalTokenInfo") != m.end() && !m["TotalTokenInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TotalTokenInfo"].type()) {
        GetHotTopicBroadcastResponseBodyDataTotalTokenInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TotalTokenInfo"]));
        totalTokenInfo = make_shared<GetHotTopicBroadcastResponseBodyDataTotalTokenInfo>(model1);
      }
    }
  }


  virtual ~GetHotTopicBroadcastResponseBodyData() = default;
};
class GetHotTopicBroadcastResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHotTopicBroadcastResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetHotTopicBroadcastResponseBody() {}

  explicit GetHotTopicBroadcastResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHotTopicBroadcastResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHotTopicBroadcastResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetHotTopicBroadcastResponseBody() = default;
};
class GetHotTopicBroadcastResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHotTopicBroadcastResponseBody> body{};

  GetHotTopicBroadcastResponse() {}

  explicit GetHotTopicBroadcastResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHotTopicBroadcastResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHotTopicBroadcastResponseBody>(model1);
      }
    }
  }


  virtual ~GetHotTopicBroadcastResponse() = default;
};
class GetInterveneGlobalReplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  GetInterveneGlobalReplyRequest() {}

  explicit GetInterveneGlobalReplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~GetInterveneGlobalReplyRequest() = default;
};
class GetInterveneGlobalReplyResponseBodyDataReplyMessagList : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> replyType{};

  GetInterveneGlobalReplyResponseBodyDataReplyMessagList() {}

  explicit GetInterveneGlobalReplyResponseBodyDataReplyMessagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (replyType) {
      res["ReplyType"] = boost::any(*replyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ReplyType") != m.end() && !m["ReplyType"].empty()) {
      replyType = make_shared<string>(boost::any_cast<string>(m["ReplyType"]));
    }
  }


  virtual ~GetInterveneGlobalReplyResponseBodyDataReplyMessagList() = default;
};
class GetInterveneGlobalReplyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInterveneGlobalReplyResponseBodyDataReplyMessagList>> replyMessagList{};

  GetInterveneGlobalReplyResponseBodyData() {}

  explicit GetInterveneGlobalReplyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (replyMessagList) {
      vector<boost::any> temp1;
      for(auto item1:*replyMessagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReplyMessagList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReplyMessagList") != m.end() && !m["ReplyMessagList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReplyMessagList"].type()) {
        vector<GetInterveneGlobalReplyResponseBodyDataReplyMessagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReplyMessagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInterveneGlobalReplyResponseBodyDataReplyMessagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        replyMessagList = make_shared<vector<GetInterveneGlobalReplyResponseBodyDataReplyMessagList>>(expect1);
      }
    }
  }


  virtual ~GetInterveneGlobalReplyResponseBodyData() = default;
};
class GetInterveneGlobalReplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInterveneGlobalReplyResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInterveneGlobalReplyResponseBody() {}

  explicit GetInterveneGlobalReplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInterveneGlobalReplyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInterveneGlobalReplyResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInterveneGlobalReplyResponseBody() = default;
};
class GetInterveneGlobalReplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterveneGlobalReplyResponseBody> body{};

  GetInterveneGlobalReplyResponse() {}

  explicit GetInterveneGlobalReplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterveneGlobalReplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterveneGlobalReplyResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterveneGlobalReplyResponse() = default;
};
class GetInterveneImportTaskInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  GetInterveneImportTaskInfoRequest() {}

  explicit GetInterveneImportTaskInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetInterveneImportTaskInfoRequest() = default;
};
class GetInterveneImportTaskInfoResponseBodyDataStatus : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<long> percentage{};
  shared_ptr<long> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  GetInterveneImportTaskInfoResponseBodyDataStatus() {}

  explicit GetInterveneImportTaskInfoResponseBodyDataStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~GetInterveneImportTaskInfoResponseBodyDataStatus() = default;
};
class GetInterveneImportTaskInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetInterveneImportTaskInfoResponseBodyDataStatus> status{};

  GetInterveneImportTaskInfoResponseBodyData() {}

  explicit GetInterveneImportTaskInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = status ? boost::any(status->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      if (typeid(map<string, boost::any>) == m["Status"].type()) {
        GetInterveneImportTaskInfoResponseBodyDataStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Status"]));
        status = make_shared<GetInterveneImportTaskInfoResponseBodyDataStatus>(model1);
      }
    }
  }


  virtual ~GetInterveneImportTaskInfoResponseBodyData() = default;
};
class GetInterveneImportTaskInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInterveneImportTaskInfoResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInterveneImportTaskInfoResponseBody() {}

  explicit GetInterveneImportTaskInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInterveneImportTaskInfoResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInterveneImportTaskInfoResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInterveneImportTaskInfoResponseBody() = default;
};
class GetInterveneImportTaskInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterveneImportTaskInfoResponseBody> body{};

  GetInterveneImportTaskInfoResponse() {}

  explicit GetInterveneImportTaskInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterveneImportTaskInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterveneImportTaskInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterveneImportTaskInfoResponse() = default;
};
class GetInterveneRuleDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> ruleId{};

  GetInterveneRuleDetailRequest() {}

  explicit GetInterveneRuleDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~GetInterveneRuleDetailRequest() = default;
};
class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig : public Darabonba::Model {
public:
  shared_ptr<long> answerType{};
  shared_ptr<string> message{};
  shared_ptr<string> namespace_{};

  GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig() {}

  explicit GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerType) {
      res["AnswerType"] = boost::any(*answerType);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerType") != m.end() && !m["AnswerType"].empty()) {
      answerType = make_shared<long>(boost::any_cast<long>(m["AnswerType"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig() = default;
};
class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig : public Darabonba::Model {
public:
  shared_ptr<long> effectType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig() {}

  explicit GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectType) {
      res["EffectType"] = boost::any(*effectType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectType") != m.end() && !m["EffectType"].empty()) {
      effectType = make_shared<long>(boost::any_cast<long>(m["EffectType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig() = default;
};
class GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail : public Darabonba::Model {
public:
  shared_ptr<vector<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig>> answerConfig{};
  shared_ptr<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig> effectConfig{};
  shared_ptr<long> interveneType{};
  shared_ptr<vector<string>> namespaceList{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail() {}

  explicit GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerConfig) {
      vector<boost::any> temp1;
      for(auto item1:*answerConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnswerConfig"] = boost::any(temp1);
    }
    if (effectConfig) {
      res["EffectConfig"] = effectConfig ? boost::any(effectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interveneType) {
      res["InterveneType"] = boost::any(*interveneType);
    }
    if (namespaceList) {
      res["NamespaceList"] = boost::any(*namespaceList);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerConfig") != m.end() && !m["AnswerConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AnswerConfig"].type()) {
        vector<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnswerConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        answerConfig = make_shared<vector<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailAnswerConfig>>(expect1);
      }
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EffectConfig"].type()) {
        GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EffectConfig"]));
        effectConfig = make_shared<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetailEffectConfig>(model1);
      }
    }
    if (m.find("InterveneType") != m.end() && !m["InterveneType"].empty()) {
      interveneType = make_shared<long>(boost::any_cast<long>(m["InterveneType"]));
    }
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NamespaceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail() = default;
};
class GetInterveneRuleDetailResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail> interveneRuleDetail{};

  GetInterveneRuleDetailResponseBodyData() {}

  explicit GetInterveneRuleDetailResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interveneRuleDetail) {
      res["InterveneRuleDetail"] = interveneRuleDetail ? boost::any(interveneRuleDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterveneRuleDetail") != m.end() && !m["InterveneRuleDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterveneRuleDetail"].type()) {
        GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterveneRuleDetail"]));
        interveneRuleDetail = make_shared<GetInterveneRuleDetailResponseBodyDataInterveneRuleDetail>(model1);
      }
    }
  }


  virtual ~GetInterveneRuleDetailResponseBodyData() = default;
};
class GetInterveneRuleDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInterveneRuleDetailResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInterveneRuleDetailResponseBody() {}

  explicit GetInterveneRuleDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInterveneRuleDetailResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInterveneRuleDetailResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInterveneRuleDetailResponseBody() = default;
};
class GetInterveneRuleDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterveneRuleDetailResponseBody> body{};

  GetInterveneRuleDetailResponse() {}

  explicit GetInterveneRuleDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterveneRuleDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterveneRuleDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterveneRuleDetailResponse() = default;
};
class GetInterveneTemplateFileUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  GetInterveneTemplateFileUrlRequest() {}

  explicit GetInterveneTemplateFileUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~GetInterveneTemplateFileUrlRequest() = default;
};
class GetInterveneTemplateFileUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};

  GetInterveneTemplateFileUrlResponseBodyData() {}

  explicit GetInterveneTemplateFileUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetInterveneTemplateFileUrlResponseBodyData() = default;
};
class GetInterveneTemplateFileUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInterveneTemplateFileUrlResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInterveneTemplateFileUrlResponseBody() {}

  explicit GetInterveneTemplateFileUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInterveneTemplateFileUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInterveneTemplateFileUrlResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInterveneTemplateFileUrlResponseBody() = default;
};
class GetInterveneTemplateFileUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInterveneTemplateFileUrlResponseBody> body{};

  GetInterveneTemplateFileUrlResponse() {}

  explicit GetInterveneTemplateFileUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInterveneTemplateFileUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInterveneTemplateFileUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetInterveneTemplateFileUrlResponse() = default;
};
class GetMaterialByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> id{};

  GetMaterialByIdRequest() {}

  explicit GetMaterialByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~GetMaterialByIdRequest() = default;
};
class GetMaterialByIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<vector<string>> docKeywords{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<long> id{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> publicUrl{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> thumbnailInBase64{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};
  shared_ptr<string> url{};

  GetMaterialByIdResponseBodyData() {}

  explicit GetMaterialByIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (docKeywords) {
      res["DocKeywords"] = boost::any(*docKeywords);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (thumbnailInBase64) {
      res["ThumbnailInBase64"] = boost::any(*thumbnailInBase64);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocKeywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocKeywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docKeywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("ThumbnailInBase64") != m.end() && !m["ThumbnailInBase64"].empty()) {
      thumbnailInBase64 = make_shared<string>(boost::any_cast<string>(m["ThumbnailInBase64"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetMaterialByIdResponseBodyData() = default;
};
class GetMaterialByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetMaterialByIdResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetMaterialByIdResponseBody() {}

  explicit GetMaterialByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMaterialByIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMaterialByIdResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMaterialByIdResponseBody() = default;
};
class GetMaterialByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMaterialByIdResponseBody> body{};

  GetMaterialByIdResponse() {}

  explicit GetMaterialByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMaterialByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMaterialByIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetMaterialByIdResponse() = default;
};
class GetPropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  GetPropertiesRequest() {}

  explicit GetPropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~GetPropertiesRequest() = default;
};
class GetPropertiesResponseBodyDataConsoleConfig : public Darabonba::Model {
public:
  shared_ptr<string> tipContent{};
  shared_ptr<string> title{};

  GetPropertiesResponseBodyDataConsoleConfig() {}

  explicit GetPropertiesResponseBodyDataConsoleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tipContent) {
      res["TipContent"] = boost::any(*tipContent);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TipContent") != m.end() && !m["TipContent"].empty()) {
      tipContent = make_shared<string>(boost::any_cast<string>(m["TipContent"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataConsoleConfig() = default;
};
class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles : public Darabonba::Model {
public:
  shared_ptr<bool> select{};
  shared_ptr<bool> stared{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles() {}

  explicit GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (stared) {
      res["Stared"] = boost::any(*stared);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<bool>(boost::any_cast<bool>(m["Select"]));
    }
    if (m.find("Stared") != m.end() && !m["Stared"].empty()) {
      stared = make_shared<bool>(boost::any_cast<bool>(m["Stared"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles() = default;
};
class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples : public Darabonba::Model {
public:
  shared_ptr<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles>> articles{};
  shared_ptr<string> prompt{};
  shared_ptr<string> text{};

  GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples() {}

  explicit GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamplesArticles>>(expect1);
      }
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples() = default;
};
class GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> name{};

  GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources() {}

  explicit GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources() = default;
};
class GetPropertiesResponseBodyDataIntelligentSearchConfig : public Darabonba::Model {
public:
  shared_ptr<string> productDescription{};
  shared_ptr<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples>> searchSamples{};
  shared_ptr<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources>> searchSources{};

  GetPropertiesResponseBodyDataIntelligentSearchConfig() {}

  explicit GetPropertiesResponseBodyDataIntelligentSearchConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (productDescription) {
      res["ProductDescription"] = boost::any(*productDescription);
    }
    if (searchSamples) {
      vector<boost::any> temp1;
      for(auto item1:*searchSamples){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSamples"] = boost::any(temp1);
    }
    if (searchSources) {
      vector<boost::any> temp1;
      for(auto item1:*searchSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProductDescription") != m.end() && !m["ProductDescription"].empty()) {
      productDescription = make_shared<string>(boost::any_cast<string>(m["ProductDescription"]));
    }
    if (m.find("SearchSamples") != m.end() && !m["SearchSamples"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSamples"].type()) {
        vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSamples"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSamples = make_shared<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSamples>>(expect1);
      }
    }
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSources"].type()) {
        vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSources = make_shared<vector<GetPropertiesResponseBodyDataIntelligentSearchConfigSearchSources>>(expect1);
      }
    }
  }


  virtual ~GetPropertiesResponseBodyDataIntelligentSearchConfig() = default;
};
class GetPropertiesResponseBodyDataSearchSources : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<string> value{};

  GetPropertiesResponseBodyDataSearchSources() {}

  explicit GetPropertiesResponseBodyDataSearchSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataSearchSources() = default;
};
class GetPropertiesResponseBodyDataUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userId{};
  shared_ptr<string> username{};

  GetPropertiesResponseBodyDataUserInfo() {}

  explicit GetPropertiesResponseBodyDataUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataUserInfo() = default;
};
class GetPropertiesResponseBodyDataWanxiangImageSizeConfig : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};

  GetPropertiesResponseBodyDataWanxiangImageSizeConfig() {}

  explicit GetPropertiesResponseBodyDataWanxiangImageSizeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataWanxiangImageSizeConfig() = default;
};
class GetPropertiesResponseBodyDataWanxiangImageStyleConfig : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> pic{};
  shared_ptr<string> value{};

  GetPropertiesResponseBodyDataWanxiangImageStyleConfig() {}

  explicit GetPropertiesResponseBodyDataWanxiangImageStyleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pic) {
      res["Pic"] = boost::any(*pic);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pic") != m.end() && !m["Pic"].empty()) {
      pic = make_shared<string>(boost::any_cast<string>(m["Pic"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetPropertiesResponseBodyDataWanxiangImageStyleConfig() = default;
};
class GetPropertiesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> chatConfig{};
  shared_ptr<GetPropertiesResponseBodyDataConsoleConfig> consoleConfig{};
  shared_ptr<map<string, boost::any>> generalConfigMap{};
  shared_ptr<GetPropertiesResponseBodyDataIntelligentSearchConfig> intelligentSearchConfig{};
  shared_ptr<vector<GetPropertiesResponseBodyDataSearchSources>> searchSources{};
  shared_ptr<bool> slrAuthorized{};
  shared_ptr<GetPropertiesResponseBodyDataUserInfo> userInfo{};
  shared_ptr<vector<GetPropertiesResponseBodyDataWanxiangImageSizeConfig>> wanxiangImageSizeConfig{};
  shared_ptr<vector<GetPropertiesResponseBodyDataWanxiangImageStyleConfig>> wanxiangImageStyleConfig{};

  GetPropertiesResponseBodyData() {}

  explicit GetPropertiesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatConfig) {
      res["ChatConfig"] = boost::any(*chatConfig);
    }
    if (consoleConfig) {
      res["ConsoleConfig"] = consoleConfig ? boost::any(consoleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (generalConfigMap) {
      res["GeneralConfigMap"] = boost::any(*generalConfigMap);
    }
    if (intelligentSearchConfig) {
      res["IntelligentSearchConfig"] = intelligentSearchConfig ? boost::any(intelligentSearchConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchSources) {
      vector<boost::any> temp1;
      for(auto item1:*searchSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSources"] = boost::any(temp1);
    }
    if (slrAuthorized) {
      res["SlrAuthorized"] = boost::any(*slrAuthorized);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (wanxiangImageSizeConfig) {
      vector<boost::any> temp1;
      for(auto item1:*wanxiangImageSizeConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WanxiangImageSizeConfig"] = boost::any(temp1);
    }
    if (wanxiangImageStyleConfig) {
      vector<boost::any> temp1;
      for(auto item1:*wanxiangImageStyleConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["WanxiangImageStyleConfig"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ChatConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      chatConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ConsoleConfig") != m.end() && !m["ConsoleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConsoleConfig"].type()) {
        GetPropertiesResponseBodyDataConsoleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConsoleConfig"]));
        consoleConfig = make_shared<GetPropertiesResponseBodyDataConsoleConfig>(model1);
      }
    }
    if (m.find("GeneralConfigMap") != m.end() && !m["GeneralConfigMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GeneralConfigMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      generalConfigMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("IntelligentSearchConfig") != m.end() && !m["IntelligentSearchConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IntelligentSearchConfig"].type()) {
        GetPropertiesResponseBodyDataIntelligentSearchConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IntelligentSearchConfig"]));
        intelligentSearchConfig = make_shared<GetPropertiesResponseBodyDataIntelligentSearchConfig>(model1);
      }
    }
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSources"].type()) {
        vector<GetPropertiesResponseBodyDataSearchSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataSearchSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSources = make_shared<vector<GetPropertiesResponseBodyDataSearchSources>>(expect1);
      }
    }
    if (m.find("SlrAuthorized") != m.end() && !m["SlrAuthorized"].empty()) {
      slrAuthorized = make_shared<bool>(boost::any_cast<bool>(m["SlrAuthorized"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        GetPropertiesResponseBodyDataUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<GetPropertiesResponseBodyDataUserInfo>(model1);
      }
    }
    if (m.find("WanxiangImageSizeConfig") != m.end() && !m["WanxiangImageSizeConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["WanxiangImageSizeConfig"].type()) {
        vector<GetPropertiesResponseBodyDataWanxiangImageSizeConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WanxiangImageSizeConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataWanxiangImageSizeConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wanxiangImageSizeConfig = make_shared<vector<GetPropertiesResponseBodyDataWanxiangImageSizeConfig>>(expect1);
      }
    }
    if (m.find("WanxiangImageStyleConfig") != m.end() && !m["WanxiangImageStyleConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["WanxiangImageStyleConfig"].type()) {
        vector<GetPropertiesResponseBodyDataWanxiangImageStyleConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["WanxiangImageStyleConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPropertiesResponseBodyDataWanxiangImageStyleConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wanxiangImageStyleConfig = make_shared<vector<GetPropertiesResponseBodyDataWanxiangImageStyleConfig>>(expect1);
      }
    }
  }


  virtual ~GetPropertiesResponseBodyData() = default;
};
class GetPropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetPropertiesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPropertiesResponseBody() {}

  explicit GetPropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPropertiesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPropertiesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPropertiesResponseBody() = default;
};
class GetPropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPropertiesResponseBody> body{};

  GetPropertiesResponse() {}

  explicit GetPropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~GetPropertiesResponse() = default;
};
class GetSmartClipTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  GetSmartClipTaskRequest() {}

  explicit GetSmartClipTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~GetSmartClipTaskRequest() = default;
};
class GetSmartClipTaskResponseBodyDataSubJobsFileAttr : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<string> fileLength{};
  shared_ptr<string> fileName{};
  shared_ptr<long> height{};
  shared_ptr<string> tmpUrl{};
  shared_ptr<long> width{};

  GetSmartClipTaskResponseBodyDataSubJobsFileAttr() {}

  explicit GetSmartClipTaskResponseBodyDataSubJobsFileAttr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileLength) {
      res["FileLength"] = boost::any(*fileLength);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (tmpUrl) {
      res["TmpUrl"] = boost::any(*tmpUrl);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("FileLength") != m.end() && !m["FileLength"].empty()) {
      fileLength = make_shared<string>(boost::any_cast<string>(m["FileLength"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("TmpUrl") != m.end() && !m["TmpUrl"].empty()) {
      tmpUrl = make_shared<string>(boost::any_cast<string>(m["TmpUrl"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~GetSmartClipTaskResponseBodyDataSubJobsFileAttr() = default;
};
class GetSmartClipTaskResponseBodyDataSubJobs : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<GetSmartClipTaskResponseBodyDataSubJobsFileAttr> fileAttr{};
  shared_ptr<string> fileKey{};
  shared_ptr<string> status{};
  shared_ptr<string> subJobId{};

  GetSmartClipTaskResponseBodyDataSubJobs() {}

  explicit GetSmartClipTaskResponseBodyDataSubJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (fileAttr) {
      res["FileAttr"] = fileAttr ? boost::any(fileAttr->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subJobId) {
      res["SubJobId"] = boost::any(*subJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FileAttr") != m.end() && !m["FileAttr"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileAttr"].type()) {
        GetSmartClipTaskResponseBodyDataSubJobsFileAttr model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileAttr"]));
        fileAttr = make_shared<GetSmartClipTaskResponseBodyDataSubJobsFileAttr>(model1);
      }
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubJobId") != m.end() && !m["SubJobId"].empty()) {
      subJobId = make_shared<string>(boost::any_cast<string>(m["SubJobId"]));
    }
  }


  virtual ~GetSmartClipTaskResponseBodyDataSubJobs() = default;
};
class GetSmartClipTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetSmartClipTaskResponseBodyDataSubJobs>> subJobs{};

  GetSmartClipTaskResponseBodyData() {}

  explicit GetSmartClipTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subJobs) {
      vector<boost::any> temp1;
      for(auto item1:*subJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubJobs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubJobs") != m.end() && !m["SubJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["SubJobs"].type()) {
        vector<GetSmartClipTaskResponseBodyDataSubJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSmartClipTaskResponseBodyDataSubJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subJobs = make_shared<vector<GetSmartClipTaskResponseBodyDataSubJobs>>(expect1);
      }
    }
  }


  virtual ~GetSmartClipTaskResponseBodyData() = default;
};
class GetSmartClipTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSmartClipTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSmartClipTaskResponseBody() {}

  explicit GetSmartClipTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSmartClipTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSmartClipTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSmartClipTaskResponseBody() = default;
};
class GetSmartClipTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSmartClipTaskResponseBody> body{};

  GetSmartClipTaskResponse() {}

  explicit GetSmartClipTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmartClipTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmartClipTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmartClipTaskResponse() = default;
};
class GetTopicByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> id{};

  GetTopicByIdRequest() {}

  explicit GetTopicByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetTopicByIdRequest() = default;
};
class GetTopicByIdResponseBodyDataStructureSummaryDocList : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  GetTopicByIdResponseBodyDataStructureSummaryDocList() {}

  explicit GetTopicByIdResponseBodyDataStructureSummaryDocList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetTopicByIdResponseBodyDataStructureSummaryDocList() = default;
};
class GetTopicByIdResponseBodyDataStructureSummary : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicByIdResponseBodyDataStructureSummaryDocList>> docList{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  GetTopicByIdResponseBodyDataStructureSummary() {}

  explicit GetTopicByIdResponseBodyDataStructureSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docList) {
      vector<boost::any> temp1;
      for(auto item1:*docList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DocList"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocList") != m.end() && !m["DocList"].empty()) {
      if (typeid(vector<boost::any>) == m["DocList"].type()) {
        vector<GetTopicByIdResponseBodyDataStructureSummaryDocList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DocList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicByIdResponseBodyDataStructureSummaryDocList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        docList = make_shared<vector<GetTopicByIdResponseBodyDataStructureSummaryDocList>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetTopicByIdResponseBodyDataStructureSummary() = default;
};
class GetTopicByIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> createUser{};
  shared_ptr<long> hotValue{};
  shared_ptr<string> id{};
  shared_ptr<string> status{};
  shared_ptr<vector<GetTopicByIdResponseBodyDataStructureSummary>> structureSummary{};
  shared_ptr<string> summary{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> version{};

  GetTopicByIdResponseBodyData() {}

  explicit GetTopicByIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (hotValue) {
      res["HotValue"] = boost::any(*hotValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureSummary) {
      vector<boost::any> temp1;
      for(auto item1:*structureSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StructureSummary"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("HotValue") != m.end() && !m["HotValue"].empty()) {
      hotValue = make_shared<long>(boost::any_cast<long>(m["HotValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureSummary") != m.end() && !m["StructureSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["StructureSummary"].type()) {
        vector<GetTopicByIdResponseBodyDataStructureSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StructureSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicByIdResponseBodyDataStructureSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        structureSummary = make_shared<vector<GetTopicByIdResponseBodyDataStructureSummary>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetTopicByIdResponseBodyData() = default;
};
class GetTopicByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTopicByIdResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTopicByIdResponseBody() {}

  explicit GetTopicByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicByIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicByIdResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTopicByIdResponseBody() = default;
};
class GetTopicByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTopicByIdResponseBody> body{};

  GetTopicByIdResponse() {}

  explicit GetTopicByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTopicByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTopicByIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTopicByIdResponse() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  GetTopicSelectionPerspectiveAnalysisTaskRequest() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskRequest() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints>> viewPoints{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudesViewPoints>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes>> attitudes{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitudes) {
      vector<boost::any> temp1;
      for(auto item1:*attitudes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attitudes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attitudes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attitudes = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResultAttitudes>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<vector<string>> imageUrls{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> topic{};
  shared_ptr<string> url{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews>> news{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints>> viewPoints{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (news) {
      vector<boost::any> temp1;
      for(auto item1:*news){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["News"] = boost::any(temp1);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("News") != m.end() && !m["News"].empty()) {
      if (typeid(vector<boost::any>) == m["News"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["News"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        news = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesNews>>(expect1);
      }
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudesViewPoints>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes>> attitudes{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitudes) {
      vector<boost::any> temp1;
      for(auto item1:*attitudes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attitudes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attitudes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attitudes = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResultAttitudes>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> ratio{};
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints>> viewPoints{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudesViewPoints>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes>> attitudes{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitudes) {
      vector<boost::any> temp1;
      for(auto item1:*attitudes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attitudes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attitudes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attitudes = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResultAttitudes>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList>> docList{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docList) {
      vector<boost::any> temp1;
      for(auto item1:*docList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DocList"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocList") != m.end() && !m["DocList"].empty()) {
      if (typeid(vector<boost::any>) == m["DocList"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DocList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        docList = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummariesDocList>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries>> summaries{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaries) {
      vector<boost::any> temp1;
      for(auto item1:*summaries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Summaries"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Summaries") != m.end() && !m["Summaries"].empty()) {
      if (typeid(vector<boost::any>) == m["Summaries"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Summaries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        summaries = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResultSummaries>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments>> comments{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints>> viewPoints{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Comments"] = boost::any(temp1);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      if (typeid(vector<boost::any>) == m["Comments"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesComments>>(expect1);
      }
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudesViewPoints>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes>> attitudes{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitudes) {
      vector<boost::any> temp1;
      for(auto item1:*attitudes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attitudes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attitudes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attitudes = make_shared<vector<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResultAttitudes>>(expect1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult> freshViewPointsResult{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult> hotViewPointsResult{};
  shared_ptr<string> status{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult> timedViewPointsResult{};
  shared_ptr<string> topic{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult> topicSummaryResult{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult> webReviewPointsResult{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (freshViewPointsResult) {
      res["FreshViewPointsResult"] = freshViewPointsResult ? boost::any(freshViewPointsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotViewPointsResult) {
      res["HotViewPointsResult"] = hotViewPointsResult ? boost::any(hotViewPointsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (timedViewPointsResult) {
      res["TimedViewPointsResult"] = timedViewPointsResult ? boost::any(timedViewPointsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSummaryResult) {
      res["TopicSummaryResult"] = topicSummaryResult ? boost::any(topicSummaryResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webReviewPointsResult) {
      res["WebReviewPointsResult"] = webReviewPointsResult ? boost::any(webReviewPointsResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FreshViewPointsResult") != m.end() && !m["FreshViewPointsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["FreshViewPointsResult"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FreshViewPointsResult"]));
        freshViewPointsResult = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataFreshViewPointsResult>(model1);
      }
    }
    if (m.find("HotViewPointsResult") != m.end() && !m["HotViewPointsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotViewPointsResult"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotViewPointsResult"]));
        hotViewPointsResult = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataHotViewPointsResult>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TimedViewPointsResult") != m.end() && !m["TimedViewPointsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimedViewPointsResult"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimedViewPointsResult"]));
        timedViewPointsResult = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTimedViewPointsResult>(model1);
      }
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSummaryResult") != m.end() && !m["TopicSummaryResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TopicSummaryResult"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TopicSummaryResult"]));
        topicSummaryResult = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataTopicSummaryResult>(model1);
      }
    }
    if (m.find("WebReviewPointsResult") != m.end() && !m["WebReviewPointsResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["WebReviewPointsResult"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WebReviewPointsResult"]));
        webReviewPointsResult = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyDataWebReviewPointsResult>(model1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTopicSelectionPerspectiveAnalysisTaskResponseBody() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponseBody() = default;
};
class GetTopicSelectionPerspectiveAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskResponseBody> body{};

  GetTopicSelectionPerspectiveAnalysisTaskResponse() {}

  explicit GetTopicSelectionPerspectiveAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTopicSelectionPerspectiveAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTopicSelectionPerspectiveAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTopicSelectionPerspectiveAnalysisTaskResponse() = default;
};
class ImportInterveneFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> docName{};
  shared_ptr<string> fileKey{};
  shared_ptr<string> fileUrl{};

  ImportInterveneFileRequest() {}

  explicit ImportInterveneFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~ImportInterveneFileRequest() = default;
};
class ImportInterveneFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failIdList{};
  shared_ptr<string> taskId{};

  ImportInterveneFileResponseBodyData() {}

  explicit ImportInterveneFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failIdList) {
      res["FailIdList"] = boost::any(*failIdList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailIdList") != m.end() && !m["FailIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ImportInterveneFileResponseBodyData() = default;
};
class ImportInterveneFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ImportInterveneFileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportInterveneFileResponseBody() {}

  explicit ImportInterveneFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportInterveneFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportInterveneFileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportInterveneFileResponseBody() = default;
};
class ImportInterveneFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportInterveneFileResponseBody> body{};

  ImportInterveneFileResponse() {}

  explicit ImportInterveneFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportInterveneFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportInterveneFileResponseBody>(model1);
      }
    }
  }


  virtual ~ImportInterveneFileResponse() = default;
};
class ImportInterveneFileAsyncRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> docName{};
  shared_ptr<string> fileKey{};
  shared_ptr<string> fileUrl{};

  ImportInterveneFileAsyncRequest() {}

  explicit ImportInterveneFileAsyncRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~ImportInterveneFileAsyncRequest() = default;
};
class ImportInterveneFileAsyncResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failIdList{};
  shared_ptr<string> taskId{};

  ImportInterveneFileAsyncResponseBodyData() {}

  explicit ImportInterveneFileAsyncResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failIdList) {
      res["FailIdList"] = boost::any(*failIdList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailIdList") != m.end() && !m["FailIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ImportInterveneFileAsyncResponseBodyData() = default;
};
class ImportInterveneFileAsyncResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ImportInterveneFileAsyncResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ImportInterveneFileAsyncResponseBody() {}

  explicit ImportInterveneFileAsyncResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ImportInterveneFileAsyncResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ImportInterveneFileAsyncResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ImportInterveneFileAsyncResponseBody() = default;
};
class ImportInterveneFileAsyncResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportInterveneFileAsyncResponseBody> body{};

  ImportInterveneFileAsyncResponse() {}

  explicit ImportInterveneFileAsyncResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportInterveneFileAsyncResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportInterveneFileAsyncResponseBody>(model1);
      }
    }
  }


  virtual ~ImportInterveneFileAsyncResponse() = default;
};
class InsertInterveneGlobalReplyRequestReplyMessagList : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> replyType{};

  InsertInterveneGlobalReplyRequestReplyMessagList() {}

  explicit InsertInterveneGlobalReplyRequestReplyMessagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (replyType) {
      res["ReplyType"] = boost::any(*replyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ReplyType") != m.end() && !m["ReplyType"].empty()) {
      replyType = make_shared<string>(boost::any_cast<string>(m["ReplyType"]));
    }
  }


  virtual ~InsertInterveneGlobalReplyRequestReplyMessagList() = default;
};
class InsertInterveneGlobalReplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<InsertInterveneGlobalReplyRequestReplyMessagList>> replyMessagList{};

  InsertInterveneGlobalReplyRequest() {}

  explicit InsertInterveneGlobalReplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (replyMessagList) {
      vector<boost::any> temp1;
      for(auto item1:*replyMessagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReplyMessagList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ReplyMessagList") != m.end() && !m["ReplyMessagList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReplyMessagList"].type()) {
        vector<InsertInterveneGlobalReplyRequestReplyMessagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReplyMessagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertInterveneGlobalReplyRequestReplyMessagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        replyMessagList = make_shared<vector<InsertInterveneGlobalReplyRequestReplyMessagList>>(expect1);
      }
    }
  }


  virtual ~InsertInterveneGlobalReplyRequest() = default;
};
class InsertInterveneGlobalReplyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> replyMessagListShrink{};

  InsertInterveneGlobalReplyShrinkRequest() {}

  explicit InsertInterveneGlobalReplyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (replyMessagListShrink) {
      res["ReplyMessagList"] = boost::any(*replyMessagListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ReplyMessagList") != m.end() && !m["ReplyMessagList"].empty()) {
      replyMessagListShrink = make_shared<string>(boost::any_cast<string>(m["ReplyMessagList"]));
    }
  }


  virtual ~InsertInterveneGlobalReplyShrinkRequest() = default;
};
class InsertInterveneGlobalReplyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failIdList{};
  shared_ptr<string> taskId{};

  InsertInterveneGlobalReplyResponseBodyData() {}

  explicit InsertInterveneGlobalReplyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failIdList) {
      res["FailIdList"] = boost::any(*failIdList);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailIdList") != m.end() && !m["FailIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~InsertInterveneGlobalReplyResponseBodyData() = default;
};
class InsertInterveneGlobalReplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InsertInterveneGlobalReplyResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InsertInterveneGlobalReplyResponseBody() {}

  explicit InsertInterveneGlobalReplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertInterveneGlobalReplyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertInterveneGlobalReplyResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InsertInterveneGlobalReplyResponseBody() = default;
};
class InsertInterveneGlobalReplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertInterveneGlobalReplyResponseBody> body{};

  InsertInterveneGlobalReplyResponse() {}

  explicit InsertInterveneGlobalReplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertInterveneGlobalReplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertInterveneGlobalReplyResponseBody>(model1);
      }
    }
  }


  virtual ~InsertInterveneGlobalReplyResponse() = default;
};
class InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig : public Darabonba::Model {
public:
  shared_ptr<long> answerType{};
  shared_ptr<string> message{};
  shared_ptr<string> namespace_{};

  InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig() {}

  explicit InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerType) {
      res["AnswerType"] = boost::any(*answerType);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerType") != m.end() && !m["AnswerType"].empty()) {
      answerType = make_shared<long>(boost::any_cast<long>(m["AnswerType"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig() = default;
};
class InsertInterveneRuleRequestInterveneRuleConfigEffectConfig : public Darabonba::Model {
public:
  shared_ptr<long> effectType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  InsertInterveneRuleRequestInterveneRuleConfigEffectConfig() {}

  explicit InsertInterveneRuleRequestInterveneRuleConfigEffectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectType) {
      res["EffectType"] = boost::any(*effectType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectType") != m.end() && !m["EffectType"].empty()) {
      effectType = make_shared<long>(boost::any_cast<long>(m["EffectType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~InsertInterveneRuleRequestInterveneRuleConfigEffectConfig() = default;
};
class InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<long> operationType{};
  shared_ptr<string> query{};

  InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList() {}

  explicit InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<long>(boost::any_cast<long>(m["OperationType"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
  }


  virtual ~InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList() = default;
};
class InsertInterveneRuleRequestInterveneRuleConfig : public Darabonba::Model {
public:
  shared_ptr<vector<InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig>> answerConfig{};
  shared_ptr<InsertInterveneRuleRequestInterveneRuleConfigEffectConfig> effectConfig{};
  shared_ptr<vector<InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList>> interveneConfigList{};
  shared_ptr<long> interveneType{};
  shared_ptr<vector<string>> namespaceList{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  InsertInterveneRuleRequestInterveneRuleConfig() {}

  explicit InsertInterveneRuleRequestInterveneRuleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerConfig) {
      vector<boost::any> temp1;
      for(auto item1:*answerConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnswerConfig"] = boost::any(temp1);
    }
    if (effectConfig) {
      res["EffectConfig"] = effectConfig ? boost::any(effectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interveneConfigList) {
      vector<boost::any> temp1;
      for(auto item1:*interveneConfigList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterveneConfigList"] = boost::any(temp1);
    }
    if (interveneType) {
      res["InterveneType"] = boost::any(*interveneType);
    }
    if (namespaceList) {
      res["NamespaceList"] = boost::any(*namespaceList);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerConfig") != m.end() && !m["AnswerConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AnswerConfig"].type()) {
        vector<InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnswerConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        answerConfig = make_shared<vector<InsertInterveneRuleRequestInterveneRuleConfigAnswerConfig>>(expect1);
      }
    }
    if (m.find("EffectConfig") != m.end() && !m["EffectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EffectConfig"].type()) {
        InsertInterveneRuleRequestInterveneRuleConfigEffectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EffectConfig"]));
        effectConfig = make_shared<InsertInterveneRuleRequestInterveneRuleConfigEffectConfig>(model1);
      }
    }
    if (m.find("InterveneConfigList") != m.end() && !m["InterveneConfigList"].empty()) {
      if (typeid(vector<boost::any>) == m["InterveneConfigList"].type()) {
        vector<InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterveneConfigList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interveneConfigList = make_shared<vector<InsertInterveneRuleRequestInterveneRuleConfigInterveneConfigList>>(expect1);
      }
    }
    if (m.find("InterveneType") != m.end() && !m["InterveneType"].empty()) {
      interveneType = make_shared<long>(boost::any_cast<long>(m["InterveneType"]));
    }
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NamespaceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~InsertInterveneRuleRequestInterveneRuleConfig() = default;
};
class InsertInterveneRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<InsertInterveneRuleRequestInterveneRuleConfig> interveneRuleConfig{};

  InsertInterveneRuleRequest() {}

  explicit InsertInterveneRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (interveneRuleConfig) {
      res["InterveneRuleConfig"] = interveneRuleConfig ? boost::any(interveneRuleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("InterveneRuleConfig") != m.end() && !m["InterveneRuleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InterveneRuleConfig"].type()) {
        InsertInterveneRuleRequestInterveneRuleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InterveneRuleConfig"]));
        interveneRuleConfig = make_shared<InsertInterveneRuleRequestInterveneRuleConfig>(model1);
      }
    }
  }


  virtual ~InsertInterveneRuleRequest() = default;
};
class InsertInterveneRuleShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> interveneRuleConfigShrink{};

  InsertInterveneRuleShrinkRequest() {}

  explicit InsertInterveneRuleShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (interveneRuleConfigShrink) {
      res["InterveneRuleConfig"] = boost::any(*interveneRuleConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("InterveneRuleConfig") != m.end() && !m["InterveneRuleConfig"].empty()) {
      interveneRuleConfigShrink = make_shared<string>(boost::any_cast<string>(m["InterveneRuleConfig"]));
    }
  }


  virtual ~InsertInterveneRuleShrinkRequest() = default;
};
class InsertInterveneRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> ruleId{};

  InsertInterveneRuleResponseBodyData() {}

  explicit InsertInterveneRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~InsertInterveneRuleResponseBodyData() = default;
};
class InsertInterveneRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InsertInterveneRuleResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  InsertInterveneRuleResponseBody() {}

  explicit InsertInterveneRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InsertInterveneRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InsertInterveneRuleResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InsertInterveneRuleResponseBody() = default;
};
class InsertInterveneRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InsertInterveneRuleResponseBody> body{};

  InsertInterveneRuleResponse() {}

  explicit InsertInterveneRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InsertInterveneRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InsertInterveneRuleResponseBody>(model1);
      }
    }
  }


  virtual ~InsertInterveneRuleResponse() = default;
};
class ListAnalysisTagDetailByTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<long> current{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> size{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ListAnalysisTagDetailByTaskIdRequest() {}

  explicit ListAnalysisTagDetailByTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdRequest() = default;
};
class ListAnalysisTagDetailByTaskIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoriesShrink{};
  shared_ptr<long> current{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> size{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ListAnalysisTagDetailByTaskIdShrinkRequest() {}

  explicit ListAnalysisTagDetailByTaskIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoriesShrink) {
      res["Categories"] = boost::any(*categoriesShrink);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      categoriesShrink = make_shared<string>(boost::any_cast<string>(m["Categories"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdShrinkRequest() = default;
};
class ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags : public Darabonba::Model {
public:
  shared_ptr<string> summaryOverview{};
  shared_ptr<string> tagName{};
  shared_ptr<vector<string>> tags{};

  ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags() {}

  explicit ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryOverview) {
      res["SummaryOverview"] = boost::any(*summaryOverview);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryOverview") != m.end() && !m["SummaryOverview"].empty()) {
      summaryOverview = make_shared<string>(boost::any_cast<string>(m["SummaryOverview"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags() = default;
};
class ListAnalysisTagDetailByTaskIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags>> contentTags{};
  shared_ptr<long> id{};
  shared_ptr<string> tagTaskType{};
  shared_ptr<string> taskId{};

  ListAnalysisTagDetailByTaskIdResponseBodyData() {}

  explicit ListAnalysisTagDetailByTaskIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentTags) {
      vector<boost::any> temp1;
      for(auto item1:*contentTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContentTags"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (tagTaskType) {
      res["TagTaskType"] = boost::any(*tagTaskType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentTags") != m.end() && !m["ContentTags"].empty()) {
      if (typeid(vector<boost::any>) == m["ContentTags"].type()) {
        vector<ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContentTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentTags = make_shared<vector<ListAnalysisTagDetailByTaskIdResponseBodyDataContentTags>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TagTaskType") != m.end() && !m["TagTaskType"].empty()) {
      tagTaskType = make_shared<string>(boost::any_cast<string>(m["TagTaskType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdResponseBodyData() = default;
};
class ListAnalysisTagDetailByTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAnalysisTagDetailByTaskIdResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListAnalysisTagDetailByTaskIdResponseBody() {}

  explicit ListAnalysisTagDetailByTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAnalysisTagDetailByTaskIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAnalysisTagDetailByTaskIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAnalysisTagDetailByTaskIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdResponseBody() = default;
};
class ListAnalysisTagDetailByTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAnalysisTagDetailByTaskIdResponseBody> body{};

  ListAnalysisTagDetailByTaskIdResponse() {}

  explicit ListAnalysisTagDetailByTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAnalysisTagDetailByTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAnalysisTagDetailByTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListAnalysisTagDetailByTaskIdResponse() = default;
};
class ListAsyncTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> createTimeEnd{};
  shared_ptr<string> createTimeStart{};
  shared_ptr<long> current{};
  shared_ptr<long> size{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<vector<long>> taskStatusList{};
  shared_ptr<string> taskType{};
  shared_ptr<vector<string>> taskTypeList{};

  ListAsyncTasksRequest() {}

  explicit ListAsyncTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskStatusList) {
      res["TaskStatusList"] = boost::any(*taskStatusList);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskTypeList) {
      res["TaskTypeList"] = boost::any(*taskTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<string>(boost::any_cast<string>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<string>(boost::any_cast<string>(m["CreateTimeStart"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskStatusList") != m.end() && !m["TaskStatusList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TaskStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      taskStatusList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskTypeList") != m.end() && !m["TaskTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAsyncTasksRequest() = default;
};
class ListAsyncTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> createTimeEnd{};
  shared_ptr<string> createTimeStart{};
  shared_ptr<long> current{};
  shared_ptr<long> size{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskName{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> taskStatusListShrink{};
  shared_ptr<string> taskType{};
  shared_ptr<string> taskTypeListShrink{};

  ListAsyncTasksShrinkRequest() {}

  explicit ListAsyncTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskStatusListShrink) {
      res["TaskStatusList"] = boost::any(*taskStatusListShrink);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (taskTypeListShrink) {
      res["TaskTypeList"] = boost::any(*taskTypeListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<string>(boost::any_cast<string>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<string>(boost::any_cast<string>(m["CreateTimeStart"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskStatusList") != m.end() && !m["TaskStatusList"].empty()) {
      taskStatusListShrink = make_shared<string>(boost::any_cast<string>(m["TaskStatusList"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TaskTypeList") != m.end() && !m["TaskTypeList"].empty()) {
      taskTypeListShrink = make_shared<string>(boost::any_cast<string>(m["TaskTypeList"]));
    }
  }


  virtual ~ListAsyncTasksShrinkRequest() = default;
};
class ListAsyncTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskDefinition{};
  shared_ptr<string> taskEndTime{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<string> taskExecuteTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskInnerErrorMessage{};
  shared_ptr<string> taskIntermediateResult{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskParam{};
  shared_ptr<string> taskProgressMessage{};
  shared_ptr<string> taskResult{};
  shared_ptr<string> taskRetryCount{};
  shared_ptr<string> taskStartTime{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> taskType{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};

  ListAsyncTasksResponseBodyData() {}

  explicit ListAsyncTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskDefinition) {
      res["TaskDefinition"] = boost::any(*taskDefinition);
    }
    if (taskEndTime) {
      res["TaskEndTime"] = boost::any(*taskEndTime);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskExecuteTime) {
      res["TaskExecuteTime"] = boost::any(*taskExecuteTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskInnerErrorMessage) {
      res["TaskInnerErrorMessage"] = boost::any(*taskInnerErrorMessage);
    }
    if (taskIntermediateResult) {
      res["TaskIntermediateResult"] = boost::any(*taskIntermediateResult);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (taskProgressMessage) {
      res["TaskProgressMessage"] = boost::any(*taskProgressMessage);
    }
    if (taskResult) {
      res["TaskResult"] = boost::any(*taskResult);
    }
    if (taskRetryCount) {
      res["TaskRetryCount"] = boost::any(*taskRetryCount);
    }
    if (taskStartTime) {
      res["TaskStartTime"] = boost::any(*taskStartTime);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskDefinition") != m.end() && !m["TaskDefinition"].empty()) {
      taskDefinition = make_shared<string>(boost::any_cast<string>(m["TaskDefinition"]));
    }
    if (m.find("TaskEndTime") != m.end() && !m["TaskEndTime"].empty()) {
      taskEndTime = make_shared<string>(boost::any_cast<string>(m["TaskEndTime"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskExecuteTime") != m.end() && !m["TaskExecuteTime"].empty()) {
      taskExecuteTime = make_shared<string>(boost::any_cast<string>(m["TaskExecuteTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskInnerErrorMessage") != m.end() && !m["TaskInnerErrorMessage"].empty()) {
      taskInnerErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskInnerErrorMessage"]));
    }
    if (m.find("TaskIntermediateResult") != m.end() && !m["TaskIntermediateResult"].empty()) {
      taskIntermediateResult = make_shared<string>(boost::any_cast<string>(m["TaskIntermediateResult"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("TaskProgressMessage") != m.end() && !m["TaskProgressMessage"].empty()) {
      taskProgressMessage = make_shared<string>(boost::any_cast<string>(m["TaskProgressMessage"]));
    }
    if (m.find("TaskResult") != m.end() && !m["TaskResult"].empty()) {
      taskResult = make_shared<string>(boost::any_cast<string>(m["TaskResult"]));
    }
    if (m.find("TaskRetryCount") != m.end() && !m["TaskRetryCount"].empty()) {
      taskRetryCount = make_shared<string>(boost::any_cast<string>(m["TaskRetryCount"]));
    }
    if (m.find("TaskStartTime") != m.end() && !m["TaskStartTime"].empty()) {
      taskStartTime = make_shared<string>(boost::any_cast<string>(m["TaskStartTime"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
  }


  virtual ~ListAsyncTasksResponseBodyData() = default;
};
class ListAsyncTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<ListAsyncTasksResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListAsyncTasksResponseBody() {}

  explicit ListAsyncTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAsyncTasksResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAsyncTasksResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAsyncTasksResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListAsyncTasksResponseBody() = default;
};
class ListAsyncTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAsyncTasksResponseBody> body{};

  ListAsyncTasksResponse() {}

  explicit ListAsyncTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAsyncTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAsyncTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListAsyncTasksResponse() = default;
};
class ListBuildConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> regionId{};
  shared_ptr<string> type{};

  ListBuildConfigsRequest() {}

  explicit ListBuildConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListBuildConfigsRequest() = default;
};
class ListBuildConfigsResponseBodyDataKeywords : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> key{};

  ListBuildConfigsResponseBodyDataKeywords() {}

  explicit ListBuildConfigsResponseBodyDataKeywords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~ListBuildConfigsResponseBodyDataKeywords() = default;
};
class ListBuildConfigsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> buildIn{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<vector<ListBuildConfigsResponseBodyDataKeywords>> keywords{};
  shared_ptr<string> tag{};
  shared_ptr<string> tagDescription{};
  shared_ptr<string> type{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};

  ListBuildConfigsResponseBodyData() {}

  explicit ListBuildConfigsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (buildIn) {
      res["BuildIn"] = boost::any(*buildIn);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywords) {
      vector<boost::any> temp1;
      for(auto item1:*keywords){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Keywords"] = boost::any(temp1);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (tagDescription) {
      res["TagDescription"] = boost::any(*tagDescription);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BuildIn") != m.end() && !m["BuildIn"].empty()) {
      buildIn = make_shared<bool>(boost::any_cast<bool>(m["BuildIn"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<ListBuildConfigsResponseBodyDataKeywords> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Keywords"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBuildConfigsResponseBodyDataKeywords model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keywords = make_shared<vector<ListBuildConfigsResponseBodyDataKeywords>>(expect1);
      }
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TagDescription") != m.end() && !m["TagDescription"].empty()) {
      tagDescription = make_shared<string>(boost::any_cast<string>(m["TagDescription"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
  }


  virtual ~ListBuildConfigsResponseBodyData() = default;
};
class ListBuildConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListBuildConfigsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListBuildConfigsResponseBody() {}

  explicit ListBuildConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListBuildConfigsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBuildConfigsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListBuildConfigsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListBuildConfigsResponseBody() = default;
};
class ListBuildConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBuildConfigsResponseBody> body{};

  ListBuildConfigsResponse() {}

  explicit ListBuildConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBuildConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBuildConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBuildConfigsResponse() = default;
};
class ListCustomTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> commodityCode{};

  ListCustomTextRequest() {}

  explicit ListCustomTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
  }


  virtual ~ListCustomTextRequest() = default;
};
class ListCustomTextResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> id{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};

  ListCustomTextResponseBodyData() {}

  explicit ListCustomTextResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
  }


  virtual ~ListCustomTextResponseBodyData() = default;
};
class ListCustomTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListCustomTextResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCustomTextResponseBody() {}

  explicit ListCustomTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCustomTextResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomTextResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCustomTextResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCustomTextResponseBody() = default;
};
class ListCustomTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomTextResponseBody> body{};

  ListCustomTextResponse() {}

  explicit ListCustomTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomTextResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomTextResponse() = default;
};
class ListCustomViewPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> attitude{};
  shared_ptr<vector<string>> attitudes{};
  shared_ptr<string> customViewPointId{};
  shared_ptr<vector<string>> customViewPointIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicId{};

  ListCustomViewPointsRequest() {}

  explicit ListCustomViewPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudes) {
      res["Attitudes"] = boost::any(*attitudes);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    if (customViewPointIds) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Attitudes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Attitudes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      attitudes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomViewPointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomViewPointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customViewPointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~ListCustomViewPointsRequest() = default;
};
class ListCustomViewPointsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudesShrink{};
  shared_ptr<string> customViewPointId{};
  shared_ptr<string> customViewPointIdsShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicId{};

  ListCustomViewPointsShrinkRequest() {}

  explicit ListCustomViewPointsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudesShrink) {
      res["Attitudes"] = boost::any(*attitudesShrink);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    if (customViewPointIdsShrink) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIdsShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("Attitudes") != m.end() && !m["Attitudes"].empty()) {
      attitudesShrink = make_shared<string>(boost::any_cast<string>(m["Attitudes"]));
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      customViewPointIdsShrink = make_shared<string>(boost::any_cast<string>(m["CustomViewPointIds"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~ListCustomViewPointsShrinkRequest() = default;
};
class ListCustomViewPointsResponseBodyDataViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListCustomViewPointsResponseBodyDataViewPointsOutlines() {}

  explicit ListCustomViewPointsResponseBodyDataViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListCustomViewPointsResponseBodyDataViewPointsOutlines() = default;
};
class ListCustomViewPointsResponseBodyDataViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomViewPointsResponseBodyDataViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  ListCustomViewPointsResponseBodyDataViewPoints() {}

  explicit ListCustomViewPointsResponseBodyDataViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListCustomViewPointsResponseBodyDataViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomViewPointsResponseBodyDataViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListCustomViewPointsResponseBodyDataViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListCustomViewPointsResponseBodyDataViewPoints() = default;
};
class ListCustomViewPointsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> attitude{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> id{};
  shared_ptr<string> status{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<long> taskStatus{};
  shared_ptr<vector<ListCustomViewPointsResponseBodyDataViewPoints>> viewPoints{};

  ListCustomViewPointsResponseBodyData() {}

  explicit ListCustomViewPointsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<ListCustomViewPointsResponseBodyDataViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomViewPointsResponseBodyDataViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<ListCustomViewPointsResponseBodyDataViewPoints>>(expect1);
      }
    }
  }


  virtual ~ListCustomViewPointsResponseBodyData() = default;
};
class ListCustomViewPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListCustomViewPointsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListCustomViewPointsResponseBody() {}

  explicit ListCustomViewPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCustomViewPointsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomViewPointsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCustomViewPointsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomViewPointsResponseBody() = default;
};
class ListCustomViewPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomViewPointsResponseBody> body{};

  ListCustomViewPointsResponse() {}

  explicit ListCustomViewPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomViewPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomViewPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomViewPointsResponse() = default;
};
class ListDatasetDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> docType{};
  shared_ptr<vector<string>> excludeFields{};
  shared_ptr<vector<string>> includeFields{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<long> status{};
  shared_ptr<string> workspaceId{};

  ListDatasetDocumentsRequest() {}

  explicit ListDatasetDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (excludeFields) {
      res["ExcludeFields"] = boost::any(*excludeFields);
    }
    if (includeFields) {
      res["IncludeFields"] = boost::any(*includeFields);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExcludeFields") != m.end() && !m["ExcludeFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeFields") != m.end() && !m["IncludeFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListDatasetDocumentsRequest() = default;
};
class ListDatasetDocumentsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> docType{};
  shared_ptr<string> excludeFieldsShrink{};
  shared_ptr<string> includeFieldsShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<long> status{};
  shared_ptr<string> workspaceId{};

  ListDatasetDocumentsShrinkRequest() {}

  explicit ListDatasetDocumentsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (excludeFieldsShrink) {
      res["ExcludeFields"] = boost::any(*excludeFieldsShrink);
    }
    if (includeFieldsShrink) {
      res["IncludeFields"] = boost::any(*includeFieldsShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExcludeFields") != m.end() && !m["ExcludeFields"].empty()) {
      excludeFieldsShrink = make_shared<string>(boost::any_cast<string>(m["ExcludeFields"]));
    }
    if (m.find("IncludeFields") != m.end() && !m["IncludeFields"].empty()) {
      includeFieldsShrink = make_shared<string>(boost::any_cast<string>(m["IncludeFields"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListDatasetDocumentsShrinkRequest() = default;
};
class ListDatasetDocumentsResponseBodyDataMultimodalMedias : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  ListDatasetDocumentsResponseBodyDataMultimodalMedias() {}

  explicit ListDatasetDocumentsResponseBodyDataMultimodalMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~ListDatasetDocumentsResponseBodyDataMultimodalMedias() = default;
};
class ListDatasetDocumentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryUuid{};
  shared_ptr<string> content{};
  shared_ptr<bool> disableHandleMultimodalMedia{};
  shared_ptr<string> docId{};
  shared_ptr<string> docType{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> extend1{};
  shared_ptr<string> extend2{};
  shared_ptr<string> extend3{};
  shared_ptr<vector<ListDatasetDocumentsResponseBodyDataMultimodalMedias>> multimodalMedias{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> sourceFrom{};
  shared_ptr<long> status{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  ListDatasetDocumentsResponseBodyData() {}

  explicit ListDatasetDocumentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryUuid) {
      res["CategoryUuid"] = boost::any(*categoryUuid);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (disableHandleMultimodalMedia) {
      res["DisableHandleMultimodalMedia"] = boost::any(*disableHandleMultimodalMedia);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (extend2) {
      res["Extend2"] = boost::any(*extend2);
    }
    if (extend3) {
      res["Extend3"] = boost::any(*extend3);
    }
    if (multimodalMedias) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMedias){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMedias"] = boost::any(temp1);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (sourceFrom) {
      res["SourceFrom"] = boost::any(*sourceFrom);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryUuid") != m.end() && !m["CategoryUuid"].empty()) {
      categoryUuid = make_shared<string>(boost::any_cast<string>(m["CategoryUuid"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DisableHandleMultimodalMedia") != m.end() && !m["DisableHandleMultimodalMedia"].empty()) {
      disableHandleMultimodalMedia = make_shared<bool>(boost::any_cast<bool>(m["DisableHandleMultimodalMedia"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("Extend2") != m.end() && !m["Extend2"].empty()) {
      extend2 = make_shared<string>(boost::any_cast<string>(m["Extend2"]));
    }
    if (m.find("Extend3") != m.end() && !m["Extend3"].empty()) {
      extend3 = make_shared<string>(boost::any_cast<string>(m["Extend3"]));
    }
    if (m.find("MultimodalMedias") != m.end() && !m["MultimodalMedias"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMedias"].type()) {
        vector<ListDatasetDocumentsResponseBodyDataMultimodalMedias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMedias"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatasetDocumentsResponseBodyDataMultimodalMedias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMedias = make_shared<vector<ListDatasetDocumentsResponseBodyDataMultimodalMedias>>(expect1);
      }
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SourceFrom") != m.end() && !m["SourceFrom"].empty()) {
      sourceFrom = make_shared<string>(boost::any_cast<string>(m["SourceFrom"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListDatasetDocumentsResponseBodyData() = default;
};
class ListDatasetDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDatasetDocumentsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDatasetDocumentsResponseBody() {}

  explicit ListDatasetDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDatasetDocumentsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatasetDocumentsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDatasetDocumentsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatasetDocumentsResponseBody() = default;
};
class ListDatasetDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatasetDocumentsResponseBody> body{};

  ListDatasetDocumentsResponse() {}

  explicit ListDatasetDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatasetDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatasetDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatasetDocumentsResponse() = default;
};
class ListDatasetsRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<long> searchDatasetEnable{};
  shared_ptr<string> startTime{};
  shared_ptr<string> workspaceId{};

  ListDatasetsRequest() {}

  explicit ListDatasetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListDatasetsRequest() = default;
};
class ListDatasetsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<long> searchDatasetEnable{};

  ListDatasetsResponseBodyData() {}

  explicit ListDatasetsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
  }


  virtual ~ListDatasetsResponseBodyData() = default;
};
class ListDatasetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDatasetsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDatasetsResponseBody() {}

  explicit ListDatasetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDatasetsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDatasetsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDatasetsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDatasetsResponseBody() = default;
};
class ListDatasetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatasetsResponseBody> body{};

  ListDatasetsResponse() {}

  explicit ListDatasetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatasetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatasetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatasetsResponse() = default;
};
class ListDialoguesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> current{};
  shared_ptr<long> dialogueType{};
  shared_ptr<string> endTime{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};

  ListDialoguesRequest() {}

  explicit ListDialoguesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (dialogueType) {
      res["DialogueType"] = boost::any(*dialogueType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("DialogueType") != m.end() && !m["DialogueType"].empty()) {
      dialogueType = make_shared<long>(boost::any_cast<long>(m["DialogueType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListDialoguesRequest() = default;
};
class ListDialoguesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bot{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<long> dialogueType{};
  shared_ptr<string> taskId{};
  shared_ptr<string> user{};

  ListDialoguesResponseBodyData() {}

  explicit ListDialoguesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bot) {
      res["Bot"] = boost::any(*bot);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (dialogueType) {
      res["DialogueType"] = boost::any(*dialogueType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bot") != m.end() && !m["Bot"].empty()) {
      bot = make_shared<string>(boost::any_cast<string>(m["Bot"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DialogueType") != m.end() && !m["DialogueType"].empty()) {
      dialogueType = make_shared<long>(boost::any_cast<long>(m["DialogueType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~ListDialoguesResponseBodyData() = default;
};
class ListDialoguesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<ListDialoguesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListDialoguesResponseBody() {}

  explicit ListDialoguesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDialoguesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDialoguesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDialoguesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListDialoguesResponseBody() = default;
};
class ListDialoguesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDialoguesResponseBody> body{};

  ListDialoguesResponse() {}

  explicit ListDialoguesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDialoguesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDialoguesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDialoguesResponse() = default;
};
class ListDocsRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docName{};
  shared_ptr<string> docType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> skip{};
  shared_ptr<vector<long>> statuses{};
  shared_ptr<string> workspaceId{};

  ListDocsRequest() {}

  explicit ListDocsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (statuses) {
      res["Statuses"] = boost::any(*statuses);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<long>(boost::any_cast<long>(m["Skip"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Statuses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Statuses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      statuses = make_shared<vector<long>>(toVec1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListDocsRequest() = default;
};
class ListDocsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docName{};
  shared_ptr<string> docType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> skip{};
  shared_ptr<string> statusesShrink{};
  shared_ptr<string> workspaceId{};

  ListDocsShrinkRequest() {}

  explicit ListDocsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (skip) {
      res["Skip"] = boost::any(*skip);
    }
    if (statusesShrink) {
      res["Statuses"] = boost::any(*statusesShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Skip") != m.end() && !m["Skip"].empty()) {
      skip = make_shared<long>(boost::any_cast<long>(m["Skip"]));
    }
    if (m.find("Statuses") != m.end() && !m["Statuses"].empty()) {
      statusesShrink = make_shared<string>(boost::any_cast<string>(m["Statuses"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListDocsShrinkRequest() = default;
};
class ListDocsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> docId{};
  shared_ptr<string> docName{};
  shared_ptr<string> docType{};
  shared_ptr<long> status{};
  shared_ptr<string> statusMessage{};

  ListDocsResponseBodyData() {}

  explicit ListDocsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (statusMessage) {
      res["StatusMessage"] = boost::any(*statusMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("StatusMessage") != m.end() && !m["StatusMessage"].empty()) {
      statusMessage = make_shared<string>(boost::any_cast<string>(m["StatusMessage"]));
    }
  }


  virtual ~ListDocsResponseBodyData() = default;
};
class ListDocsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDocsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDocsResponseBody() {}

  explicit ListDocsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDocsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDocsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDocsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDocsResponseBody() = default;
};
class ListDocsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDocsResponseBody> body{};

  ListDocsResponse() {}

  explicit ListDocsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDocsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDocsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDocsResponse() = default;
};
class ListFreshViewPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};

  ListFreshViewPointsRequest() {}

  explicit ListFreshViewPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
  }


  virtual ~ListFreshViewPointsRequest() = default;
};
class ListFreshViewPointsResponseBodyDataOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListFreshViewPointsResponseBodyDataOutlines() {}

  explicit ListFreshViewPointsResponseBodyDataOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListFreshViewPointsResponseBodyDataOutlines() = default;
};
class ListFreshViewPointsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListFreshViewPointsResponseBodyDataOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  ListFreshViewPointsResponseBodyData() {}

  explicit ListFreshViewPointsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListFreshViewPointsResponseBodyDataOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFreshViewPointsResponseBodyDataOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListFreshViewPointsResponseBodyDataOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListFreshViewPointsResponseBodyData() = default;
};
class ListFreshViewPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListFreshViewPointsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListFreshViewPointsResponseBody() {}

  explicit ListFreshViewPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListFreshViewPointsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFreshViewPointsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListFreshViewPointsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFreshViewPointsResponseBody() = default;
};
class ListFreshViewPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFreshViewPointsResponseBody> body{};

  ListFreshViewPointsResponse() {}

  explicit ListFreshViewPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFreshViewPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFreshViewPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListFreshViewPointsResponse() = default;
};
class ListGeneratedContentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> contentDomain{};
  shared_ptr<long> current{};
  shared_ptr<string> endTime{};
  shared_ptr<string> query{};
  shared_ptr<long> size{};
  shared_ptr<string> startTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};

  ListGeneratedContentsRequest() {}

  explicit ListGeneratedContentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (contentDomain) {
      res["ContentDomain"] = boost::any(*contentDomain);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ContentDomain") != m.end() && !m["ContentDomain"].empty()) {
      contentDomain = make_shared<string>(boost::any_cast<string>(m["ContentDomain"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListGeneratedContentsRequest() = default;
};
class ListGeneratedContentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentDomain{};
  shared_ptr<string> contentText{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> keywordList{};
  shared_ptr<string> keywords{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};
  shared_ptr<string> uuid{};

  ListGeneratedContentsResponseBodyData() {}

  explicit ListGeneratedContentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentDomain) {
      res["ContentDomain"] = boost::any(*contentDomain);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywordList) {
      res["KeywordList"] = boost::any(*keywordList);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentDomain") != m.end() && !m["ContentDomain"].empty()) {
      contentDomain = make_shared<string>(boost::any_cast<string>(m["ContentDomain"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("KeywordList") != m.end() && !m["KeywordList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["KeywordList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["KeywordList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywordList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~ListGeneratedContentsResponseBodyData() = default;
};
class ListGeneratedContentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<ListGeneratedContentsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListGeneratedContentsResponseBody() {}

  explicit ListGeneratedContentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListGeneratedContentsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGeneratedContentsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListGeneratedContentsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListGeneratedContentsResponseBody() = default;
};
class ListGeneratedContentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGeneratedContentsResponseBody> body{};

  ListGeneratedContentsResponse() {}

  explicit ListGeneratedContentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGeneratedContentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGeneratedContentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListGeneratedContentsResponse() = default;
};
class ListHotNewsWithTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> current{};
  shared_ptr<string> newsType{};
  shared_ptr<vector<string>> newsTypes{};
  shared_ptr<long> size{};

  ListHotNewsWithTypeRequest() {}

  explicit ListHotNewsWithTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (newsType) {
      res["NewsType"] = boost::any(*newsType);
    }
    if (newsTypes) {
      res["NewsTypes"] = boost::any(*newsTypes);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("NewsType") != m.end() && !m["NewsType"].empty()) {
      newsType = make_shared<string>(boost::any_cast<string>(m["NewsType"]));
    }
    if (m.find("NewsTypes") != m.end() && !m["NewsTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NewsTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NewsTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      newsTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListHotNewsWithTypeRequest() = default;
};
class ListHotNewsWithTypeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> current{};
  shared_ptr<string> newsType{};
  shared_ptr<string> newsTypesShrink{};
  shared_ptr<long> size{};

  ListHotNewsWithTypeShrinkRequest() {}

  explicit ListHotNewsWithTypeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (newsType) {
      res["NewsType"] = boost::any(*newsType);
    }
    if (newsTypesShrink) {
      res["NewsTypes"] = boost::any(*newsTypesShrink);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("NewsType") != m.end() && !m["NewsType"].empty()) {
      newsType = make_shared<string>(boost::any_cast<string>(m["NewsType"]));
    }
    if (m.find("NewsTypes") != m.end() && !m["NewsTypes"].empty()) {
      newsTypesShrink = make_shared<string>(boost::any_cast<string>(m["NewsTypes"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListHotNewsWithTypeShrinkRequest() = default;
};
class ListHotNewsWithTypeResponseBodyDataNews : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docUuid{};
  shared_ptr<vector<string>> imageUrls{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> url{};

  ListHotNewsWithTypeResponseBodyDataNews() {}

  explicit ListHotNewsWithTypeResponseBodyDataNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListHotNewsWithTypeResponseBodyDataNews() = default;
};
class ListHotNewsWithTypeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHotNewsWithTypeResponseBodyDataNews>> news{};
  shared_ptr<string> newsType{};
  shared_ptr<string> newsTypeName{};
  shared_ptr<long> totalPages{};

  ListHotNewsWithTypeResponseBodyData() {}

  explicit ListHotNewsWithTypeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (news) {
      vector<boost::any> temp1;
      for(auto item1:*news){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["News"] = boost::any(temp1);
    }
    if (newsType) {
      res["NewsType"] = boost::any(*newsType);
    }
    if (newsTypeName) {
      res["NewsTypeName"] = boost::any(*newsTypeName);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("News") != m.end() && !m["News"].empty()) {
      if (typeid(vector<boost::any>) == m["News"].type()) {
        vector<ListHotNewsWithTypeResponseBodyDataNews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["News"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotNewsWithTypeResponseBodyDataNews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        news = make_shared<vector<ListHotNewsWithTypeResponseBodyDataNews>>(expect1);
      }
    }
    if (m.find("NewsType") != m.end() && !m["NewsType"].empty()) {
      newsType = make_shared<string>(boost::any_cast<string>(m["NewsType"]));
    }
    if (m.find("NewsTypeName") != m.end() && !m["NewsTypeName"].empty()) {
      newsTypeName = make_shared<string>(boost::any_cast<string>(m["NewsTypeName"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~ListHotNewsWithTypeResponseBodyData() = default;
};
class ListHotNewsWithTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListHotNewsWithTypeResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListHotNewsWithTypeResponseBody() {}

  explicit ListHotNewsWithTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListHotNewsWithTypeResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotNewsWithTypeResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListHotNewsWithTypeResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListHotNewsWithTypeResponseBody() = default;
};
class ListHotNewsWithTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHotNewsWithTypeResponseBody> body{};

  ListHotNewsWithTypeResponse() {}

  explicit ListHotNewsWithTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHotNewsWithTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHotNewsWithTypeResponseBody>(model1);
      }
    }
  }


  virtual ~ListHotNewsWithTypeResponse() = default;
};
class ListHotSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListHotSourcesRequest() {}

  explicit ListHotSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListHotSourcesRequest() = default;
};
class ListHotSourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> show{};
  shared_ptr<long> sort{};
  shared_ptr<string> source{};

  ListHotSourcesResponseBodyData() {}

  explicit ListHotSourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (show) {
      res["Show"] = boost::any(*show);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Show") != m.end() && !m["Show"].empty()) {
      show = make_shared<bool>(boost::any_cast<bool>(m["Show"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<long>(boost::any_cast<long>(m["Sort"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~ListHotSourcesResponseBodyData() = default;
};
class ListHotSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListHotSourcesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListHotSourcesResponseBody() {}

  explicit ListHotSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListHotSourcesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotSourcesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListHotSourcesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHotSourcesResponseBody() = default;
};
class ListHotSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHotSourcesResponseBody> body{};

  ListHotSourcesResponse() {}

  explicit ListHotSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHotSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHotSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListHotSourcesResponse() = default;
};
class ListHotTopicsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> topicIds{};
  shared_ptr<string> topicQuery{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> topicVersion{};
  shared_ptr<vector<string>> topics{};
  shared_ptr<bool> withNews{};

  ListHotTopicsRequest() {}

  explicit ListHotTopicsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topicIds) {
      res["TopicIds"] = boost::any(*topicIds);
    }
    if (topicQuery) {
      res["TopicQuery"] = boost::any(*topicQuery);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (topicVersion) {
      res["TopicVersion"] = boost::any(*topicVersion);
    }
    if (topics) {
      res["Topics"] = boost::any(*topics);
    }
    if (withNews) {
      res["WithNews"] = boost::any(*withNews);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TopicIds") != m.end() && !m["TopicIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TopicIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TopicIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topicIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TopicQuery") != m.end() && !m["TopicQuery"].empty()) {
      topicQuery = make_shared<string>(boost::any_cast<string>(m["TopicQuery"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("TopicVersion") != m.end() && !m["TopicVersion"].empty()) {
      topicVersion = make_shared<string>(boost::any_cast<string>(m["TopicVersion"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithNews") != m.end() && !m["WithNews"].empty()) {
      withNews = make_shared<bool>(boost::any_cast<bool>(m["WithNews"]));
    }
  }


  virtual ~ListHotTopicsRequest() = default;
};
class ListHotTopicsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topicIdsShrink{};
  shared_ptr<string> topicQuery{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> topicVersion{};
  shared_ptr<string> topicsShrink{};
  shared_ptr<bool> withNews{};

  ListHotTopicsShrinkRequest() {}

  explicit ListHotTopicsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topicIdsShrink) {
      res["TopicIds"] = boost::any(*topicIdsShrink);
    }
    if (topicQuery) {
      res["TopicQuery"] = boost::any(*topicQuery);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (topicVersion) {
      res["TopicVersion"] = boost::any(*topicVersion);
    }
    if (topicsShrink) {
      res["Topics"] = boost::any(*topicsShrink);
    }
    if (withNews) {
      res["WithNews"] = boost::any(*withNews);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("TopicIds") != m.end() && !m["TopicIds"].empty()) {
      topicIdsShrink = make_shared<string>(boost::any_cast<string>(m["TopicIds"]));
    }
    if (m.find("TopicQuery") != m.end() && !m["TopicQuery"].empty()) {
      topicQuery = make_shared<string>(boost::any_cast<string>(m["TopicQuery"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("TopicVersion") != m.end() && !m["TopicVersion"].empty()) {
      topicVersion = make_shared<string>(boost::any_cast<string>(m["TopicVersion"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      topicsShrink = make_shared<string>(boost::any_cast<string>(m["Topics"]));
    }
    if (m.find("WithNews") != m.end() && !m["WithNews"].empty()) {
      withNews = make_shared<bool>(boost::any_cast<bool>(m["WithNews"]));
    }
  }


  virtual ~ListHotTopicsShrinkRequest() = default;
};
class ListHotTopicsResponseBodyDataStructureSummaryDocList : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  ListHotTopicsResponseBodyDataStructureSummaryDocList() {}

  explicit ListHotTopicsResponseBodyDataStructureSummaryDocList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListHotTopicsResponseBodyDataStructureSummaryDocList() = default;
};
class ListHotTopicsResponseBodyDataStructureSummary : public Darabonba::Model {
public:
  shared_ptr<vector<ListHotTopicsResponseBodyDataStructureSummaryDocList>> docList{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  ListHotTopicsResponseBodyDataStructureSummary() {}

  explicit ListHotTopicsResponseBodyDataStructureSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docList) {
      vector<boost::any> temp1;
      for(auto item1:*docList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DocList"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocList") != m.end() && !m["DocList"].empty()) {
      if (typeid(vector<boost::any>) == m["DocList"].type()) {
        vector<ListHotTopicsResponseBodyDataStructureSummaryDocList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DocList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotTopicsResponseBodyDataStructureSummaryDocList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        docList = make_shared<vector<ListHotTopicsResponseBodyDataStructureSummaryDocList>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListHotTopicsResponseBodyDataStructureSummary() = default;
};
class ListHotTopicsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> createUser{};
  shared_ptr<long> hotValue{};
  shared_ptr<string> id{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListHotTopicsResponseBodyDataStructureSummary>> structureSummary{};
  shared_ptr<string> summary{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> version{};

  ListHotTopicsResponseBodyData() {}

  explicit ListHotTopicsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (hotValue) {
      res["HotValue"] = boost::any(*hotValue);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structureSummary) {
      vector<boost::any> temp1;
      for(auto item1:*structureSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StructureSummary"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("HotValue") != m.end() && !m["HotValue"].empty()) {
      hotValue = make_shared<long>(boost::any_cast<long>(m["HotValue"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructureSummary") != m.end() && !m["StructureSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["StructureSummary"].type()) {
        vector<ListHotTopicsResponseBodyDataStructureSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StructureSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotTopicsResponseBodyDataStructureSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        structureSummary = make_shared<vector<ListHotTopicsResponseBodyDataStructureSummary>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListHotTopicsResponseBodyData() = default;
};
class ListHotTopicsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListHotTopicsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListHotTopicsResponseBody() {}

  explicit ListHotTopicsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListHotTopicsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotTopicsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListHotTopicsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHotTopicsResponseBody() = default;
};
class ListHotTopicsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHotTopicsResponseBody> body{};

  ListHotTopicsResponse() {}

  explicit ListHotTopicsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHotTopicsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHotTopicsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHotTopicsResponse() = default;
};
class ListHotViewPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};

  ListHotViewPointsRequest() {}

  explicit ListHotViewPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
  }


  virtual ~ListHotViewPointsRequest() = default;
};
class ListHotViewPointsResponseBodyDataNews : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<vector<string>> imageUrls{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> title{};
  shared_ptr<string> topic{};
  shared_ptr<string> url{};

  ListHotViewPointsResponseBodyDataNews() {}

  explicit ListHotViewPointsResponseBodyDataNews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListHotViewPointsResponseBodyDataNews() = default;
};
class ListHotViewPointsResponseBodyDataViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListHotViewPointsResponseBodyDataViewPointsOutlines() {}

  explicit ListHotViewPointsResponseBodyDataViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListHotViewPointsResponseBodyDataViewPointsOutlines() = default;
};
class ListHotViewPointsResponseBodyDataViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<ListHotViewPointsResponseBodyDataViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  ListHotViewPointsResponseBodyDataViewPoints() {}

  explicit ListHotViewPointsResponseBodyDataViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListHotViewPointsResponseBodyDataViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotViewPointsResponseBodyDataViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListHotViewPointsResponseBodyDataViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListHotViewPointsResponseBodyDataViewPoints() = default;
};
class ListHotViewPointsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<vector<ListHotViewPointsResponseBodyDataNews>> news{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<ListHotViewPointsResponseBodyDataViewPoints>> viewPoints{};

  ListHotViewPointsResponseBodyData() {}

  explicit ListHotViewPointsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (news) {
      vector<boost::any> temp1;
      for(auto item1:*news){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["News"] = boost::any(temp1);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("News") != m.end() && !m["News"].empty()) {
      if (typeid(vector<boost::any>) == m["News"].type()) {
        vector<ListHotViewPointsResponseBodyDataNews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["News"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotViewPointsResponseBodyDataNews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        news = make_shared<vector<ListHotViewPointsResponseBodyDataNews>>(expect1);
      }
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<ListHotViewPointsResponseBodyDataViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotViewPointsResponseBodyDataViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<ListHotViewPointsResponseBodyDataViewPoints>>(expect1);
      }
    }
  }


  virtual ~ListHotViewPointsResponseBodyData() = default;
};
class ListHotViewPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListHotViewPointsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListHotViewPointsResponseBody() {}

  explicit ListHotViewPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListHotViewPointsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHotViewPointsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListHotViewPointsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHotViewPointsResponseBody() = default;
};
class ListHotViewPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHotViewPointsResponseBody> body{};

  ListHotViewPointsResponse() {}

  explicit ListHotViewPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHotViewPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHotViewPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListHotViewPointsResponse() = default;
};
class ListInterveneCntRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListInterveneCntRequest() {}

  explicit ListInterveneCntRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterveneCntRequest() = default;
};
class ListInterveneCntResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<boost::any>> cntList{};
  shared_ptr<long> pageCnt{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListInterveneCntResponseBodyData() {}

  explicit ListInterveneCntResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cntList) {
      res["CntList"] = boost::any(*cntList);
    }
    if (pageCnt) {
      res["PageCnt"] = boost::any(*pageCnt);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CntList") != m.end() && !m["CntList"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["CntList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CntList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      cntList = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("PageCnt") != m.end() && !m["PageCnt"].empty()) {
      pageCnt = make_shared<long>(boost::any_cast<long>(m["PageCnt"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterveneCntResponseBodyData() = default;
};
class ListInterveneCntResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInterveneCntResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListInterveneCntResponseBody() {}

  explicit ListInterveneCntResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInterveneCntResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInterveneCntResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInterveneCntResponseBody() = default;
};
class ListInterveneCntResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterveneCntResponseBody> body{};

  ListInterveneCntResponse() {}

  explicit ListInterveneCntResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterveneCntResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterveneCntResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterveneCntResponse() = default;
};
class ListInterveneImportTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListInterveneImportTasksRequest() {}

  explicit ListInterveneImportTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterveneImportTasksRequest() = default;
};
class ListInterveneImportTasksResponseBodyDataStatusList : public Darabonba::Model {
public:
  shared_ptr<string> msg{};
  shared_ptr<long> percentage{};
  shared_ptr<long> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ListInterveneImportTasksResponseBodyDataStatusList() {}

  explicit ListInterveneImportTasksResponseBodyDataStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (msg) {
      res["Msg"] = boost::any(*msg);
    }
    if (percentage) {
      res["Percentage"] = boost::any(*percentage);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Msg") != m.end() && !m["Msg"].empty()) {
      msg = make_shared<string>(boost::any_cast<string>(m["Msg"]));
    }
    if (m.find("Percentage") != m.end() && !m["Percentage"].empty()) {
      percentage = make_shared<long>(boost::any_cast<long>(m["Percentage"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListInterveneImportTasksResponseBodyDataStatusList() = default;
};
class ListInterveneImportTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListInterveneImportTasksResponseBodyDataStatusList>> statusList{};
  shared_ptr<long> totalSize{};

  ListInterveneImportTasksResponseBodyData() {}

  explicit ListInterveneImportTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (statusList) {
      vector<boost::any> temp1;
      for(auto item1:*statusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusList"] = boost::any(temp1);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<ListInterveneImportTasksResponseBodyDataStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterveneImportTasksResponseBodyDataStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusList = make_shared<vector<ListInterveneImportTasksResponseBodyDataStatusList>>(expect1);
      }
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListInterveneImportTasksResponseBodyData() = default;
};
class ListInterveneImportTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInterveneImportTasksResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListInterveneImportTasksResponseBody() {}

  explicit ListInterveneImportTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInterveneImportTasksResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInterveneImportTasksResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInterveneImportTasksResponseBody() = default;
};
class ListInterveneImportTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterveneImportTasksResponseBody> body{};

  ListInterveneImportTasksResponse() {}

  explicit ListInterveneImportTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterveneImportTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterveneImportTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterveneImportTasksResponse() = default;
};
class ListInterveneRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListInterveneRulesRequest() {}

  explicit ListInterveneRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterveneRulesRequest() = default;
};
class ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig : public Darabonba::Model {
public:
  shared_ptr<long> answerType{};
  shared_ptr<string> message{};
  shared_ptr<string> namespace_{};

  ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig() {}

  explicit ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerType) {
      res["AnswerType"] = boost::any(*answerType);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerType") != m.end() && !m["AnswerType"].empty()) {
      answerType = make_shared<long>(boost::any_cast<long>(m["AnswerType"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig() = default;
};
class ListInterveneRulesResponseBodyDataInterveneRuleList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig>> answerConfig{};
  shared_ptr<string> createTime{};
  shared_ptr<string> effectTime{};
  shared_ptr<long> interveneType{};
  shared_ptr<vector<string>> namespaceList{};
  shared_ptr<long> ruleId{};
  shared_ptr<string> ruleName{};

  ListInterveneRulesResponseBodyDataInterveneRuleList() {}

  explicit ListInterveneRulesResponseBodyDataInterveneRuleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerConfig) {
      vector<boost::any> temp1;
      for(auto item1:*answerConfig){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnswerConfig"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (effectTime) {
      res["EffectTime"] = boost::any(*effectTime);
    }
    if (interveneType) {
      res["InterveneType"] = boost::any(*interveneType);
    }
    if (namespaceList) {
      res["NamespaceList"] = boost::any(*namespaceList);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerConfig") != m.end() && !m["AnswerConfig"].empty()) {
      if (typeid(vector<boost::any>) == m["AnswerConfig"].type()) {
        vector<ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnswerConfig"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        answerConfig = make_shared<vector<ListInterveneRulesResponseBodyDataInterveneRuleListAnswerConfig>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("EffectTime") != m.end() && !m["EffectTime"].empty()) {
      effectTime = make_shared<string>(boost::any_cast<string>(m["EffectTime"]));
    }
    if (m.find("InterveneType") != m.end() && !m["InterveneType"].empty()) {
      interveneType = make_shared<long>(boost::any_cast<long>(m["InterveneType"]));
    }
    if (m.find("NamespaceList") != m.end() && !m["NamespaceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NamespaceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NamespaceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      namespaceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~ListInterveneRulesResponseBodyDataInterveneRuleList() = default;
};
class ListInterveneRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<ListInterveneRulesResponseBodyDataInterveneRuleList>> interveneRuleList{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListInterveneRulesResponseBodyData() {}

  explicit ListInterveneRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (interveneRuleList) {
      vector<boost::any> temp1;
      for(auto item1:*interveneRuleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterveneRuleList"] = boost::any(temp1);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InterveneRuleList") != m.end() && !m["InterveneRuleList"].empty()) {
      if (typeid(vector<boost::any>) == m["InterveneRuleList"].type()) {
        vector<ListInterveneRulesResponseBodyDataInterveneRuleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterveneRuleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInterveneRulesResponseBodyDataInterveneRuleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interveneRuleList = make_shared<vector<ListInterveneRulesResponseBodyDataInterveneRuleList>>(expect1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInterveneRulesResponseBodyData() = default;
};
class ListInterveneRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInterveneRulesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListInterveneRulesResponseBody() {}

  explicit ListInterveneRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInterveneRulesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInterveneRulesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInterveneRulesResponseBody() = default;
};
class ListInterveneRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInterveneRulesResponseBody> body{};

  ListInterveneRulesResponse() {}

  explicit ListInterveneRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInterveneRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInterveneRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInterveneRulesResponse() = default;
};
class ListIntervenesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> interveneType{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<long> ruleId{};

  ListIntervenesRequest() {}

  explicit ListIntervenesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (interveneType) {
      res["InterveneType"] = boost::any(*interveneType);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("InterveneType") != m.end() && !m["InterveneType"].empty()) {
      interveneType = make_shared<long>(boost::any_cast<long>(m["InterveneType"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<long>(boost::any_cast<long>(m["RuleId"]));
    }
  }


  virtual ~ListIntervenesRequest() = default;
};
class ListIntervenesResponseBodyDataInterveneList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> query{};

  ListIntervenesResponseBodyDataInterveneList() {}

  explicit ListIntervenesResponseBodyDataInterveneList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
  }


  virtual ~ListIntervenesResponseBodyDataInterveneList() = default;
};
class ListIntervenesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntervenesResponseBodyDataInterveneList>> interveneList{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalSize{};

  ListIntervenesResponseBodyData() {}

  explicit ListIntervenesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interveneList) {
      vector<boost::any> temp1;
      for(auto item1:*interveneList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InterveneList"] = boost::any(temp1);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalSize) {
      res["TotalSize"] = boost::any(*totalSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InterveneList") != m.end() && !m["InterveneList"].empty()) {
      if (typeid(vector<boost::any>) == m["InterveneList"].type()) {
        vector<ListIntervenesResponseBodyDataInterveneList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InterveneList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervenesResponseBodyDataInterveneList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interveneList = make_shared<vector<ListIntervenesResponseBodyDataInterveneList>>(expect1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalSize") != m.end() && !m["TotalSize"].empty()) {
      totalSize = make_shared<long>(boost::any_cast<long>(m["TotalSize"]));
    }
  }


  virtual ~ListIntervenesResponseBodyData() = default;
};
class ListIntervenesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListIntervenesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListIntervenesResponseBody() {}

  explicit ListIntervenesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListIntervenesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListIntervenesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListIntervenesResponseBody() = default;
};
class ListIntervenesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervenesResponseBody> body{};

  ListIntervenesResponse() {}

  explicit ListIntervenesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervenesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervenesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervenesResponse() = default;
};
class ListMaterialDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> createTimeEnd{};
  shared_ptr<string> createTimeStart{};
  shared_ptr<long> current{};
  shared_ptr<string> docType{};
  shared_ptr<vector<string>> docTypeList{};
  shared_ptr<bool> generatePublicUrl{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> query{};
  shared_ptr<long> shareAttr{};
  shared_ptr<long> size{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTimeEnd{};
  shared_ptr<string> updateTimeStart{};

  ListMaterialDocumentsRequest() {}

  explicit ListMaterialDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (docTypeList) {
      res["DocTypeList"] = boost::any(*docTypeList);
    }
    if (generatePublicUrl) {
      res["GeneratePublicUrl"] = boost::any(*generatePublicUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTimeEnd) {
      res["UpdateTimeEnd"] = boost::any(*updateTimeEnd);
    }
    if (updateTimeStart) {
      res["UpdateTimeStart"] = boost::any(*updateTimeStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<string>(boost::any_cast<string>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<string>(boost::any_cast<string>(m["CreateTimeStart"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("DocTypeList") != m.end() && !m["DocTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GeneratePublicUrl") != m.end() && !m["GeneratePublicUrl"].empty()) {
      generatePublicUrl = make_shared<bool>(boost::any_cast<bool>(m["GeneratePublicUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTimeEnd") != m.end() && !m["UpdateTimeEnd"].empty()) {
      updateTimeEnd = make_shared<string>(boost::any_cast<string>(m["UpdateTimeEnd"]));
    }
    if (m.find("UpdateTimeStart") != m.end() && !m["UpdateTimeStart"].empty()) {
      updateTimeStart = make_shared<string>(boost::any_cast<string>(m["UpdateTimeStart"]));
    }
  }


  virtual ~ListMaterialDocumentsRequest() = default;
};
class ListMaterialDocumentsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> createTimeEnd{};
  shared_ptr<string> createTimeStart{};
  shared_ptr<long> current{};
  shared_ptr<string> docType{};
  shared_ptr<string> docTypeListShrink{};
  shared_ptr<bool> generatePublicUrl{};
  shared_ptr<long> id{};
  shared_ptr<string> keywordsShrink{};
  shared_ptr<string> query{};
  shared_ptr<long> shareAttr{};
  shared_ptr<long> size{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTimeEnd{};
  shared_ptr<string> updateTimeStart{};

  ListMaterialDocumentsShrinkRequest() {}

  explicit ListMaterialDocumentsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTimeEnd) {
      res["CreateTimeEnd"] = boost::any(*createTimeEnd);
    }
    if (createTimeStart) {
      res["CreateTimeStart"] = boost::any(*createTimeStart);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (docTypeListShrink) {
      res["DocTypeList"] = boost::any(*docTypeListShrink);
    }
    if (generatePublicUrl) {
      res["GeneratePublicUrl"] = boost::any(*generatePublicUrl);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywordsShrink) {
      res["Keywords"] = boost::any(*keywordsShrink);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTimeEnd) {
      res["UpdateTimeEnd"] = boost::any(*updateTimeEnd);
    }
    if (updateTimeStart) {
      res["UpdateTimeStart"] = boost::any(*updateTimeStart);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTimeEnd") != m.end() && !m["CreateTimeEnd"].empty()) {
      createTimeEnd = make_shared<string>(boost::any_cast<string>(m["CreateTimeEnd"]));
    }
    if (m.find("CreateTimeStart") != m.end() && !m["CreateTimeStart"].empty()) {
      createTimeStart = make_shared<string>(boost::any_cast<string>(m["CreateTimeStart"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("DocTypeList") != m.end() && !m["DocTypeList"].empty()) {
      docTypeListShrink = make_shared<string>(boost::any_cast<string>(m["DocTypeList"]));
    }
    if (m.find("GeneratePublicUrl") != m.end() && !m["GeneratePublicUrl"].empty()) {
      generatePublicUrl = make_shared<bool>(boost::any_cast<bool>(m["GeneratePublicUrl"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywordsShrink = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTimeEnd") != m.end() && !m["UpdateTimeEnd"].empty()) {
      updateTimeEnd = make_shared<string>(boost::any_cast<string>(m["UpdateTimeEnd"]));
    }
    if (m.find("UpdateTimeStart") != m.end() && !m["UpdateTimeStart"].empty()) {
      updateTimeStart = make_shared<string>(boost::any_cast<string>(m["UpdateTimeStart"]));
    }
  }


  virtual ~ListMaterialDocumentsShrinkRequest() = default;
};
class ListMaterialDocumentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> createUserName{};
  shared_ptr<vector<string>> docKeywords{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<long> id{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> publicUrl{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> thumbnailInBase64{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};
  shared_ptr<string> updateUserName{};
  shared_ptr<string> url{};

  ListMaterialDocumentsResponseBodyData() {}

  explicit ListMaterialDocumentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (createUserName) {
      res["CreateUserName"] = boost::any(*createUserName);
    }
    if (docKeywords) {
      res["DocKeywords"] = boost::any(*docKeywords);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (publicUrl) {
      res["PublicUrl"] = boost::any(*publicUrl);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (thumbnailInBase64) {
      res["ThumbnailInBase64"] = boost::any(*thumbnailInBase64);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    if (updateUserName) {
      res["UpdateUserName"] = boost::any(*updateUserName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("CreateUserName") != m.end() && !m["CreateUserName"].empty()) {
      createUserName = make_shared<string>(boost::any_cast<string>(m["CreateUserName"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocKeywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocKeywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docKeywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("PublicUrl") != m.end() && !m["PublicUrl"].empty()) {
      publicUrl = make_shared<string>(boost::any_cast<string>(m["PublicUrl"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("ThumbnailInBase64") != m.end() && !m["ThumbnailInBase64"].empty()) {
      thumbnailInBase64 = make_shared<string>(boost::any_cast<string>(m["ThumbnailInBase64"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
    if (m.find("UpdateUserName") != m.end() && !m["UpdateUserName"].empty()) {
      updateUserName = make_shared<string>(boost::any_cast<string>(m["UpdateUserName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListMaterialDocumentsResponseBodyData() = default;
};
class ListMaterialDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<ListMaterialDocumentsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListMaterialDocumentsResponseBody() {}

  explicit ListMaterialDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMaterialDocumentsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMaterialDocumentsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMaterialDocumentsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListMaterialDocumentsResponseBody() = default;
};
class ListMaterialDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMaterialDocumentsResponseBody> body{};

  ListMaterialDocumentsResponse() {}

  explicit ListMaterialDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMaterialDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMaterialDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMaterialDocumentsResponse() = default;
};
class ListPlanningProposalRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customViewPointId{};
  shared_ptr<vector<string>> customViewPointIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> titles{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> topicVersion{};
  shared_ptr<string> viewPointType{};

  ListPlanningProposalRequest() {}

  explicit ListPlanningProposalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    if (customViewPointIds) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (titles) {
      res["Titles"] = boost::any(*titles);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (topicVersion) {
      res["TopicVersion"] = boost::any(*topicVersion);
    }
    if (viewPointType) {
      res["ViewPointType"] = boost::any(*viewPointType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomViewPointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomViewPointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customViewPointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Titles") != m.end() && !m["Titles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Titles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Titles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      titles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("TopicVersion") != m.end() && !m["TopicVersion"].empty()) {
      topicVersion = make_shared<string>(boost::any_cast<string>(m["TopicVersion"]));
    }
    if (m.find("ViewPointType") != m.end() && !m["ViewPointType"].empty()) {
      viewPointType = make_shared<string>(boost::any_cast<string>(m["ViewPointType"]));
    }
  }


  virtual ~ListPlanningProposalRequest() = default;
};
class ListPlanningProposalShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> customViewPointId{};
  shared_ptr<string> customViewPointIdsShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> titlesShrink{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> topicVersion{};
  shared_ptr<string> viewPointType{};

  ListPlanningProposalShrinkRequest() {}

  explicit ListPlanningProposalShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    if (customViewPointIdsShrink) {
      res["CustomViewPointIds"] = boost::any(*customViewPointIdsShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (titlesShrink) {
      res["Titles"] = boost::any(*titlesShrink);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (topicVersion) {
      res["TopicVersion"] = boost::any(*topicVersion);
    }
    if (viewPointType) {
      res["ViewPointType"] = boost::any(*viewPointType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
    if (m.find("CustomViewPointIds") != m.end() && !m["CustomViewPointIds"].empty()) {
      customViewPointIdsShrink = make_shared<string>(boost::any_cast<string>(m["CustomViewPointIds"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Titles") != m.end() && !m["Titles"].empty()) {
      titlesShrink = make_shared<string>(boost::any_cast<string>(m["Titles"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("TopicVersion") != m.end() && !m["TopicVersion"].empty()) {
      topicVersion = make_shared<string>(boost::any_cast<string>(m["TopicVersion"]));
    }
    if (m.find("ViewPointType") != m.end() && !m["ViewPointType"].empty()) {
      viewPointType = make_shared<string>(boost::any_cast<string>(m["ViewPointType"]));
    }
  }


  virtual ~ListPlanningProposalShrinkRequest() = default;
};
class ListPlanningProposalResponseBodyDataOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListPlanningProposalResponseBodyDataOutlines() {}

  explicit ListPlanningProposalResponseBodyDataOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListPlanningProposalResponseBodyDataOutlines() = default;
};
class ListPlanningProposalResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPlanningProposalResponseBodyDataOutlines>> outlines{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  ListPlanningProposalResponseBodyData() {}

  explicit ListPlanningProposalResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListPlanningProposalResponseBodyDataOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlanningProposalResponseBodyDataOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListPlanningProposalResponseBodyDataOutlines>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~ListPlanningProposalResponseBodyData() = default;
};
class ListPlanningProposalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListPlanningProposalResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListPlanningProposalResponseBody() {}

  explicit ListPlanningProposalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPlanningProposalResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPlanningProposalResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPlanningProposalResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPlanningProposalResponseBody() = default;
};
class ListPlanningProposalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPlanningProposalResponseBody> body{};

  ListPlanningProposalResponse() {}

  explicit ListPlanningProposalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPlanningProposalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPlanningProposalResponseBody>(model1);
      }
    }
  }


  virtual ~ListPlanningProposalResponse() = default;
};
class ListSearchTaskDialogueDatasRequest : public Darabonba::Model {
public:
  shared_ptr<bool> includeContent{};
  shared_ptr<string> multimodalSearchType{};
  shared_ptr<string> originalSessionId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> searchModel{};
  shared_ptr<string> searchModelDataValue{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ListSearchTaskDialogueDatasRequest() {}

  explicit ListSearchTaskDialogueDatasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (includeContent) {
      res["IncludeContent"] = boost::any(*includeContent);
    }
    if (multimodalSearchType) {
      res["MultimodalSearchType"] = boost::any(*multimodalSearchType);
    }
    if (originalSessionId) {
      res["OriginalSessionId"] = boost::any(*originalSessionId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (searchModel) {
      res["SearchModel"] = boost::any(*searchModel);
    }
    if (searchModelDataValue) {
      res["SearchModelDataValue"] = boost::any(*searchModelDataValue);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncludeContent") != m.end() && !m["IncludeContent"].empty()) {
      includeContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeContent"]));
    }
    if (m.find("MultimodalSearchType") != m.end() && !m["MultimodalSearchType"].empty()) {
      multimodalSearchType = make_shared<string>(boost::any_cast<string>(m["MultimodalSearchType"]));
    }
    if (m.find("OriginalSessionId") != m.end() && !m["OriginalSessionId"].empty()) {
      originalSessionId = make_shared<string>(boost::any_cast<string>(m["OriginalSessionId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("SearchModel") != m.end() && !m["SearchModel"].empty()) {
      searchModel = make_shared<string>(boost::any_cast<string>(m["SearchModel"]));
    }
    if (m.find("SearchModelDataValue") != m.end() && !m["SearchModelDataValue"].empty()) {
      searchModelDataValue = make_shared<string>(boost::any_cast<string>(m["SearchModelDataValue"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListSearchTaskDialogueDatasRequest() = default;
};
class ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias() {}

  explicit ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias() = default;
};
class ListSearchTaskDialogueDatasResponseBodyArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> categoryUuid{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docType{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> extend1{};
  shared_ptr<string> extend2{};
  shared_ptr<string> extend3{};
  shared_ptr<vector<ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias>> multimodalMedias{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  ListSearchTaskDialogueDatasResponseBodyArticles() {}

  explicit ListSearchTaskDialogueDatasResponseBodyArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (categoryUuid) {
      res["CategoryUuid"] = boost::any(*categoryUuid);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (extend2) {
      res["Extend2"] = boost::any(*extend2);
    }
    if (extend3) {
      res["Extend3"] = boost::any(*extend3);
    }
    if (multimodalMedias) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMedias){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMedias"] = boost::any(temp1);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("CategoryUuid") != m.end() && !m["CategoryUuid"].empty()) {
      categoryUuid = make_shared<string>(boost::any_cast<string>(m["CategoryUuid"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("Extend2") != m.end() && !m["Extend2"].empty()) {
      extend2 = make_shared<string>(boost::any_cast<string>(m["Extend2"]));
    }
    if (m.find("Extend3") != m.end() && !m["Extend3"].empty()) {
      extend3 = make_shared<string>(boost::any_cast<string>(m["Extend3"]));
    }
    if (m.find("MultimodalMedias") != m.end() && !m["MultimodalMedias"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMedias"].type()) {
        vector<ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMedias"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMedias = make_shared<vector<ListSearchTaskDialogueDatasResponseBodyArticlesMultimodalMedias>>(expect1);
      }
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponseBodyArticles() = default;
};
class ListSearchTaskDialogueDatasResponseBodyImages : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  ListSearchTaskDialogueDatasResponseBodyImages() {}

  explicit ListSearchTaskDialogueDatasResponseBodyImages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponseBodyImages() = default;
};
class ListSearchTaskDialogueDatasResponseBodyVideos : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  ListSearchTaskDialogueDatasResponseBodyVideos() {}

  explicit ListSearchTaskDialogueDatasResponseBodyVideos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponseBodyVideos() = default;
};
class ListSearchTaskDialogueDatasResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSearchTaskDialogueDatasResponseBodyArticles>> articles{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<ListSearchTaskDialogueDatasResponseBodyImages>> images{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> realtimeSearch{};
  shared_ptr<string> requestId{};
  shared_ptr<string> searchType{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListSearchTaskDialogueDatasResponseBodyVideos>> videos{};

  ListSearchTaskDialogueDatasResponseBody() {}

  explicit ListSearchTaskDialogueDatasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (images) {
      vector<boost::any> temp1;
      for(auto item1:*images){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Images"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (realtimeSearch) {
      res["RealtimeSearch"] = boost::any(*realtimeSearch);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (videos) {
      vector<boost::any> temp1;
      for(auto item1:*videos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Videos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<ListSearchTaskDialogueDatasResponseBodyArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTaskDialogueDatasResponseBodyArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<ListSearchTaskDialogueDatasResponseBodyArticles>>(expect1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Images") != m.end() && !m["Images"].empty()) {
      if (typeid(vector<boost::any>) == m["Images"].type()) {
        vector<ListSearchTaskDialogueDatasResponseBodyImages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Images"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTaskDialogueDatasResponseBodyImages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        images = make_shared<vector<ListSearchTaskDialogueDatasResponseBodyImages>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RealtimeSearch") != m.end() && !m["RealtimeSearch"].empty()) {
      realtimeSearch = make_shared<bool>(boost::any_cast<bool>(m["RealtimeSearch"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Videos") != m.end() && !m["Videos"].empty()) {
      if (typeid(vector<boost::any>) == m["Videos"].type()) {
        vector<ListSearchTaskDialogueDatasResponseBodyVideos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Videos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTaskDialogueDatasResponseBodyVideos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videos = make_shared<vector<ListSearchTaskDialogueDatasResponseBodyVideos>>(expect1);
      }
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponseBody() = default;
};
class ListSearchTaskDialogueDatasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchTaskDialogueDatasResponseBody> body{};

  ListSearchTaskDialogueDatasResponse() {}

  explicit ListSearchTaskDialogueDatasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchTaskDialogueDatasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchTaskDialogueDatasResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchTaskDialogueDatasResponse() = default;
};
class ListSearchTaskDialoguesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  ListSearchTaskDialoguesRequest() {}

  explicit ListSearchTaskDialoguesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListSearchTaskDialoguesRequest() = default;
};
class ListSearchTaskDialoguesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> dialogueType{};
  shared_ptr<string> goodText{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> rating{};
  shared_ptr<string> responseBodyStr{};
  shared_ptr<string> sessionId{};
  shared_ptr<vector<string>> tags{};
  shared_ptr<string> taskId{};
  shared_ptr<string> text{};

  ListSearchTaskDialoguesResponseBodyData() {}

  explicit ListSearchTaskDialoguesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dialogueType) {
      res["DialogueType"] = boost::any(*dialogueType);
    }
    if (goodText) {
      res["GoodText"] = boost::any(*goodText);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (rating) {
      res["Rating"] = boost::any(*rating);
    }
    if (responseBodyStr) {
      res["ResponseBodyStr"] = boost::any(*responseBodyStr);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DialogueType") != m.end() && !m["DialogueType"].empty()) {
      dialogueType = make_shared<long>(boost::any_cast<long>(m["DialogueType"]));
    }
    if (m.find("GoodText") != m.end() && !m["GoodText"].empty()) {
      goodText = make_shared<string>(boost::any_cast<string>(m["GoodText"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Rating") != m.end() && !m["Rating"].empty()) {
      rating = make_shared<string>(boost::any_cast<string>(m["Rating"]));
    }
    if (m.find("ResponseBodyStr") != m.end() && !m["ResponseBodyStr"].empty()) {
      responseBodyStr = make_shared<string>(boost::any_cast<string>(m["ResponseBodyStr"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~ListSearchTaskDialoguesResponseBodyData() = default;
};
class ListSearchTaskDialoguesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListSearchTaskDialoguesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSearchTaskDialoguesResponseBody() {}

  explicit ListSearchTaskDialoguesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSearchTaskDialoguesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTaskDialoguesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSearchTaskDialoguesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSearchTaskDialoguesResponseBody() = default;
};
class ListSearchTaskDialoguesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchTaskDialoguesResponseBody> body{};

  ListSearchTaskDialoguesResponse() {}

  explicit ListSearchTaskDialoguesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchTaskDialoguesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchTaskDialoguesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchTaskDialoguesResponse() = default;
};
class ListSearchTasksRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> dialogueTypes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> workspaceId{};

  ListSearchTasksRequest() {}

  explicit ListSearchTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueTypes) {
      res["DialogueTypes"] = boost::any(*dialogueTypes);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueTypes") != m.end() && !m["DialogueTypes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DialogueTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DialogueTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dialogueTypes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListSearchTasksRequest() = default;
};
class ListSearchTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dialogueTypesShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> workspaceId{};

  ListSearchTasksShrinkRequest() {}

  explicit ListSearchTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dialogueTypesShrink) {
      res["DialogueTypes"] = boost::any(*dialogueTypesShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DialogueTypes") != m.end() && !m["DialogueTypes"].empty()) {
      dialogueTypesShrink = make_shared<string>(boost::any_cast<string>(m["DialogueTypes"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ListSearchTasksShrinkRequest() = default;
};
class ListSearchTasksResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> dialogueType{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> username{};

  ListSearchTasksResponseBodyData() {}

  explicit ListSearchTasksResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dialogueType) {
      res["DialogueType"] = boost::any(*dialogueType);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DialogueType") != m.end() && !m["DialogueType"].empty()) {
      dialogueType = make_shared<long>(boost::any_cast<long>(m["DialogueType"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ListSearchTasksResponseBodyData() = default;
};
class ListSearchTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListSearchTasksResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListSearchTasksResponseBody() {}

  explicit ListSearchTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSearchTasksResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchTasksResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSearchTasksResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSearchTasksResponseBody() = default;
};
class ListSearchTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchTasksResponseBody> body{};

  ListSearchTasksResponse() {}

  explicit ListSearchTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchTasksResponse() = default;
};
class ListStyleLearningResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> current{};
  shared_ptr<long> size{};

  ListStyleLearningResultRequest() {}

  explicit ListStyleLearningResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~ListStyleLearningResultRequest() = default;
};
class ListStyleLearningResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aigcResult{};
  shared_ptr<long> id{};
  shared_ptr<string> rewriteResult{};
  shared_ptr<string> styleName{};
  shared_ptr<string> taskId{};

  ListStyleLearningResultResponseBodyData() {}

  explicit ListStyleLearningResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aigcResult) {
      res["AigcResult"] = boost::any(*aigcResult);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rewriteResult) {
      res["RewriteResult"] = boost::any(*rewriteResult);
    }
    if (styleName) {
      res["StyleName"] = boost::any(*styleName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AigcResult") != m.end() && !m["AigcResult"].empty()) {
      aigcResult = make_shared<string>(boost::any_cast<string>(m["AigcResult"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RewriteResult") != m.end() && !m["RewriteResult"].empty()) {
      rewriteResult = make_shared<string>(boost::any_cast<string>(m["RewriteResult"]));
    }
    if (m.find("StyleName") != m.end() && !m["StyleName"].empty()) {
      styleName = make_shared<string>(boost::any_cast<string>(m["StyleName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListStyleLearningResultResponseBodyData() = default;
};
class ListStyleLearningResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<ListStyleLearningResultResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  ListStyleLearningResultResponseBody() {}

  explicit ListStyleLearningResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListStyleLearningResultResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListStyleLearningResultResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListStyleLearningResultResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListStyleLearningResultResponseBody() = default;
};
class ListStyleLearningResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListStyleLearningResultResponseBody> body{};

  ListStyleLearningResultResponse() {}

  explicit ListStyleLearningResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListStyleLearningResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListStyleLearningResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListStyleLearningResultResponse() = default;
};
class ListTimedViewAttitudeRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};

  ListTimedViewAttitudeRequest() {}

  explicit ListTimedViewAttitudeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
  }


  virtual ~ListTimedViewAttitudeRequest() = default;
};
class ListTimedViewAttitudeResponseBodyDataViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListTimedViewAttitudeResponseBodyDataViewPointsOutlines() {}

  explicit ListTimedViewAttitudeResponseBodyDataViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListTimedViewAttitudeResponseBodyDataViewPointsOutlines() = default;
};
class ListTimedViewAttitudeResponseBodyDataViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<ListTimedViewAttitudeResponseBodyDataViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  ListTimedViewAttitudeResponseBodyDataViewPoints() {}

  explicit ListTimedViewAttitudeResponseBodyDataViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListTimedViewAttitudeResponseBodyDataViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimedViewAttitudeResponseBodyDataViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListTimedViewAttitudeResponseBodyDataViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListTimedViewAttitudeResponseBodyDataViewPoints() = default;
};
class ListTimedViewAttitudeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> ratio{};
  shared_ptr<string> source{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<vector<ListTimedViewAttitudeResponseBodyDataViewPoints>> viewPoints{};

  ListTimedViewAttitudeResponseBodyData() {}

  explicit ListTimedViewAttitudeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<ListTimedViewAttitudeResponseBodyDataViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimedViewAttitudeResponseBodyDataViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<ListTimedViewAttitudeResponseBodyDataViewPoints>>(expect1);
      }
    }
  }


  virtual ~ListTimedViewAttitudeResponseBodyData() = default;
};
class ListTimedViewAttitudeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListTimedViewAttitudeResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListTimedViewAttitudeResponseBody() {}

  explicit ListTimedViewAttitudeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListTimedViewAttitudeResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTimedViewAttitudeResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTimedViewAttitudeResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTimedViewAttitudeResponseBody() = default;
};
class ListTimedViewAttitudeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTimedViewAttitudeResponseBody> body{};

  ListTimedViewAttitudeResponse() {}

  explicit ListTimedViewAttitudeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTimedViewAttitudeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTimedViewAttitudeResponseBody>(model1);
      }
    }
  }


  virtual ~ListTimedViewAttitudeResponse() = default;
};
class ListTopicRecommendEventListRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListTopicRecommendEventListRequest() {}

  explicit ListTopicRecommendEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListTopicRecommendEventListRequest() = default;
};
class ListTopicRecommendEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListTopicRecommendEventListResponseBody() {}

  explicit ListTopicRecommendEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTopicRecommendEventListResponseBody() = default;
};
class ListTopicRecommendEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTopicRecommendEventListResponseBody> body{};

  ListTopicRecommendEventListResponse() {}

  explicit ListTopicRecommendEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTopicRecommendEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTopicRecommendEventListResponseBody>(model1);
      }
    }
  }


  virtual ~ListTopicRecommendEventListResponse() = default;
};
class ListTopicViewPointRecommendEventListRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> id{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};

  ListTopicViewPointRecommendEventListRequest() {}

  explicit ListTopicViewPointRecommendEventListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
  }


  virtual ~ListTopicViewPointRecommendEventListRequest() = default;
};
class ListTopicViewPointRecommendEventListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListTopicViewPointRecommendEventListResponseBody() {}

  explicit ListTopicViewPointRecommendEventListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTopicViewPointRecommendEventListResponseBody() = default;
};
class ListTopicViewPointRecommendEventListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTopicViewPointRecommendEventListResponseBody> body{};

  ListTopicViewPointRecommendEventListResponse() {}

  explicit ListTopicViewPointRecommendEventListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTopicViewPointRecommendEventListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTopicViewPointRecommendEventListResponseBody>(model1);
      }
    }
  }


  virtual ~ListTopicViewPointRecommendEventListResponse() = default;
};
class ListVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};

  ListVersionsRequest() {}

  explicit ListVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
  }


  virtual ~ListVersionsRequest() = default;
};
class ListVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> concurrentCount{};
  shared_ptr<string> endTime{};
  shared_ptr<long> instanceCount{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> orderId{};
  shared_ptr<string> productType{};
  shared_ptr<long> quota{};
  shared_ptr<string> startTime{};
  shared_ptr<long> useQuota{};
  shared_ptr<string> versionDetail{};
  shared_ptr<string> versionName{};
  shared_ptr<long> versionStatus{};

  ListVersionsResponseBodyData() {}

  explicit ListVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (concurrentCount) {
      res["ConcurrentCount"] = boost::any(*concurrentCount);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceCount) {
      res["InstanceCount"] = boost::any(*instanceCount);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (productType) {
      res["ProductType"] = boost::any(*productType);
    }
    if (quota) {
      res["Quota"] = boost::any(*quota);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (useQuota) {
      res["UseQuota"] = boost::any(*useQuota);
    }
    if (versionDetail) {
      res["VersionDetail"] = boost::any(*versionDetail);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    if (versionStatus) {
      res["VersionStatus"] = boost::any(*versionStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConcurrentCount") != m.end() && !m["ConcurrentCount"].empty()) {
      concurrentCount = make_shared<long>(boost::any_cast<long>(m["ConcurrentCount"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceCount") != m.end() && !m["InstanceCount"].empty()) {
      instanceCount = make_shared<long>(boost::any_cast<long>(m["InstanceCount"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<long>(boost::any_cast<long>(m["OrderId"]));
    }
    if (m.find("ProductType") != m.end() && !m["ProductType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["ProductType"]));
    }
    if (m.find("Quota") != m.end() && !m["Quota"].empty()) {
      quota = make_shared<long>(boost::any_cast<long>(m["Quota"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("UseQuota") != m.end() && !m["UseQuota"].empty()) {
      useQuota = make_shared<long>(boost::any_cast<long>(m["UseQuota"]));
    }
    if (m.find("VersionDetail") != m.end() && !m["VersionDetail"].empty()) {
      versionDetail = make_shared<string>(boost::any_cast<string>(m["VersionDetail"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
    if (m.find("VersionStatus") != m.end() && !m["VersionStatus"].empty()) {
      versionStatus = make_shared<long>(boost::any_cast<long>(m["VersionStatus"]));
    }
  }


  virtual ~ListVersionsResponseBodyData() = default;
};
class ListVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListVersionsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListVersionsResponseBody() {}

  explicit ListVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListVersionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVersionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListVersionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListVersionsResponseBody() = default;
};
class ListVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVersionsResponseBody> body{};

  ListVersionsResponse() {}

  explicit ListVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVersionsResponse() = default;
};
class ListWebReviewPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicSource{};

  ListWebReviewPointsRequest() {}

  explicit ListWebReviewPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
  }


  virtual ~ListWebReviewPointsRequest() = default;
};
class ListWebReviewPointsResponseBodyDataComments : public Darabonba::Model {
public:
  shared_ptr<string> source{};
  shared_ptr<string> text{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<string> username{};

  ListWebReviewPointsResponseBodyDataComments() {}

  explicit ListWebReviewPointsResponseBodyDataComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ListWebReviewPointsResponseBodyDataComments() = default;
};
class ListWebReviewPointsResponseBodyDataViewPointsOutlines : public Darabonba::Model {
public:
  shared_ptr<string> outline{};
  shared_ptr<string> summary{};

  ListWebReviewPointsResponseBodyDataViewPointsOutlines() {}

  explicit ListWebReviewPointsResponseBodyDataViewPointsOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListWebReviewPointsResponseBodyDataViewPointsOutlines() = default;
};
class ListWebReviewPointsResponseBodyDataViewPoints : public Darabonba::Model {
public:
  shared_ptr<vector<ListWebReviewPointsResponseBodyDataViewPointsOutlines>> outlines{};
  shared_ptr<string> point{};
  shared_ptr<string> summary{};

  ListWebReviewPointsResponseBodyDataViewPoints() {}

  explicit ListWebReviewPointsResponseBodyDataViewPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (point) {
      res["Point"] = boost::any(*point);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<ListWebReviewPointsResponseBodyDataViewPointsOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWebReviewPointsResponseBodyDataViewPointsOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<ListWebReviewPointsResponseBodyDataViewPointsOutlines>>(expect1);
      }
    }
    if (m.find("Point") != m.end() && !m["Point"].empty()) {
      point = make_shared<string>(boost::any_cast<string>(m["Point"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~ListWebReviewPointsResponseBodyDataViewPoints() = default;
};
class ListWebReviewPointsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> attitude{};
  shared_ptr<string> attitudeType{};
  shared_ptr<vector<ListWebReviewPointsResponseBodyDataComments>> comments{};
  shared_ptr<string> ratio{};
  shared_ptr<vector<ListWebReviewPointsResponseBodyDataViewPoints>> viewPoints{};

  ListWebReviewPointsResponseBodyData() {}

  explicit ListWebReviewPointsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (attitudeType) {
      res["AttitudeType"] = boost::any(*attitudeType);
    }
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Comments"] = boost::any(temp1);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (viewPoints) {
      vector<boost::any> temp1;
      for(auto item1:*viewPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewPoints"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("AttitudeType") != m.end() && !m["AttitudeType"].empty()) {
      attitudeType = make_shared<string>(boost::any_cast<string>(m["AttitudeType"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      if (typeid(vector<boost::any>) == m["Comments"].type()) {
        vector<ListWebReviewPointsResponseBodyDataComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWebReviewPointsResponseBodyDataComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<ListWebReviewPointsResponseBodyDataComments>>(expect1);
      }
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<string>(boost::any_cast<string>(m["Ratio"]));
    }
    if (m.find("ViewPoints") != m.end() && !m["ViewPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewPoints"].type()) {
        vector<ListWebReviewPointsResponseBodyDataViewPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWebReviewPointsResponseBodyDataViewPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewPoints = make_shared<vector<ListWebReviewPointsResponseBodyDataViewPoints>>(expect1);
      }
    }
  }


  virtual ~ListWebReviewPointsResponseBodyData() = default;
};
class ListWebReviewPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListWebReviewPointsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> message{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListWebReviewPointsResponseBody() {}

  explicit ListWebReviewPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListWebReviewPointsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWebReviewPointsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListWebReviewPointsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListWebReviewPointsResponseBody() = default;
};
class ListWebReviewPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWebReviewPointsResponseBody> body{};

  ListWebReviewPointsResponse() {}

  explicit ListWebReviewPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWebReviewPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWebReviewPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListWebReviewPointsResponse() = default;
};
class QueryAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskId{};

  QueryAsyncTaskRequest() {}

  explicit QueryAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~QueryAsyncTaskRequest() = default;
};
class QueryAsyncTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskErrorMessage{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskIntermediateResult{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskParam{};
  shared_ptr<string> taskProgressMessage{};
  shared_ptr<string> taskResult{};
  shared_ptr<string> taskRetryCount{};
  shared_ptr<long> taskStatus{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> updateUser{};

  QueryAsyncTaskResponseBodyData() {}

  explicit QueryAsyncTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskErrorMessage) {
      res["TaskErrorMessage"] = boost::any(*taskErrorMessage);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIntermediateResult) {
      res["TaskIntermediateResult"] = boost::any(*taskIntermediateResult);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    if (taskProgressMessage) {
      res["TaskProgressMessage"] = boost::any(*taskProgressMessage);
    }
    if (taskResult) {
      res["TaskResult"] = boost::any(*taskResult);
    }
    if (taskRetryCount) {
      res["TaskRetryCount"] = boost::any(*taskRetryCount);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (updateUser) {
      res["UpdateUser"] = boost::any(*updateUser);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskErrorMessage") != m.end() && !m["TaskErrorMessage"].empty()) {
      taskErrorMessage = make_shared<string>(boost::any_cast<string>(m["TaskErrorMessage"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskIntermediateResult") != m.end() && !m["TaskIntermediateResult"].empty()) {
      taskIntermediateResult = make_shared<string>(boost::any_cast<string>(m["TaskIntermediateResult"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
    if (m.find("TaskProgressMessage") != m.end() && !m["TaskProgressMessage"].empty()) {
      taskProgressMessage = make_shared<string>(boost::any_cast<string>(m["TaskProgressMessage"]));
    }
    if (m.find("TaskResult") != m.end() && !m["TaskResult"].empty()) {
      taskResult = make_shared<string>(boost::any_cast<string>(m["TaskResult"]));
    }
    if (m.find("TaskRetryCount") != m.end() && !m["TaskRetryCount"].empty()) {
      taskRetryCount = make_shared<string>(boost::any_cast<string>(m["TaskRetryCount"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<long>(boost::any_cast<long>(m["TaskStatus"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("UpdateUser") != m.end() && !m["UpdateUser"].empty()) {
      updateUser = make_shared<string>(boost::any_cast<string>(m["UpdateUser"]));
    }
  }


  virtual ~QueryAsyncTaskResponseBodyData() = default;
};
class QueryAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<QueryAsyncTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  QueryAsyncTaskResponseBody() {}

  explicit QueryAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        QueryAsyncTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<QueryAsyncTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryAsyncTaskResponseBody() = default;
};
class QueryAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryAsyncTaskResponseBody> body{};

  QueryAsyncTaskResponse() {}

  explicit QueryAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~QueryAsyncTaskResponse() = default;
};
class RunAbbreviationContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> workspaceId{};

  RunAbbreviationContentRequest() {}

  explicit RunAbbreviationContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunAbbreviationContentRequest() = default;
};
class RunAbbreviationContentResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunAbbreviationContentResponseBodyHeader() {}

  explicit RunAbbreviationContentResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunAbbreviationContentResponseBodyHeader() = default;
};
class RunAbbreviationContentResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunAbbreviationContentResponseBodyPayloadOutput() {}

  explicit RunAbbreviationContentResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunAbbreviationContentResponseBodyPayloadOutput() = default;
};
class RunAbbreviationContentResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunAbbreviationContentResponseBodyPayloadUsage() {}

  explicit RunAbbreviationContentResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunAbbreviationContentResponseBodyPayloadUsage() = default;
};
class RunAbbreviationContentResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunAbbreviationContentResponseBodyPayloadOutput> output{};
  shared_ptr<RunAbbreviationContentResponseBodyPayloadUsage> usage{};

  RunAbbreviationContentResponseBodyPayload() {}

  explicit RunAbbreviationContentResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunAbbreviationContentResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunAbbreviationContentResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunAbbreviationContentResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunAbbreviationContentResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunAbbreviationContentResponseBodyPayload() = default;
};
class RunAbbreviationContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunAbbreviationContentResponseBodyHeader> header{};
  shared_ptr<RunAbbreviationContentResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunAbbreviationContentResponseBody() {}

  explicit RunAbbreviationContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunAbbreviationContentResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunAbbreviationContentResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunAbbreviationContentResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunAbbreviationContentResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunAbbreviationContentResponseBody() = default;
};
class RunAbbreviationContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunAbbreviationContentResponseBody> body{};

  RunAbbreviationContentResponse() {}

  explicit RunAbbreviationContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunAbbreviationContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunAbbreviationContentResponseBody>(model1);
      }
    }
  }


  virtual ~RunAbbreviationContentResponse() = default;
};
class RunBookIntroductionRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> keyPointPrompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> summaryPrompt{};
  shared_ptr<string> workspaceId{};

  RunBookIntroductionRequest() {}

  explicit RunBookIntroductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (keyPointPrompt) {
      res["KeyPointPrompt"] = boost::any(*keyPointPrompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("KeyPointPrompt") != m.end() && !m["KeyPointPrompt"].empty()) {
      keyPointPrompt = make_shared<string>(boost::any_cast<string>(m["KeyPointPrompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunBookIntroductionRequest() = default;
};
class RunBookIntroductionResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunBookIntroductionResponseBodyHeader() {}

  explicit RunBookIntroductionResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunBookIntroductionResponseBodyHeader() = default;
};
class RunBookIntroductionResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> keyPoint{};
  shared_ptr<string> summary{};

  RunBookIntroductionResponseBodyPayloadOutput() {}

  explicit RunBookIntroductionResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPoint) {
      res["KeyPoint"] = boost::any(*keyPoint);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPoint") != m.end() && !m["KeyPoint"].empty()) {
      keyPoint = make_shared<string>(boost::any_cast<string>(m["KeyPoint"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~RunBookIntroductionResponseBodyPayloadOutput() = default;
};
class RunBookIntroductionResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunBookIntroductionResponseBodyPayloadUsage() {}

  explicit RunBookIntroductionResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunBookIntroductionResponseBodyPayloadUsage() = default;
};
class RunBookIntroductionResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunBookIntroductionResponseBodyPayloadOutput> output{};
  shared_ptr<RunBookIntroductionResponseBodyPayloadUsage> usage{};

  RunBookIntroductionResponseBodyPayload() {}

  explicit RunBookIntroductionResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunBookIntroductionResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunBookIntroductionResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunBookIntroductionResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunBookIntroductionResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunBookIntroductionResponseBodyPayload() = default;
};
class RunBookIntroductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunBookIntroductionResponseBodyHeader> header{};
  shared_ptr<RunBookIntroductionResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunBookIntroductionResponseBody() {}

  explicit RunBookIntroductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunBookIntroductionResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunBookIntroductionResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunBookIntroductionResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunBookIntroductionResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunBookIntroductionResponseBody() = default;
};
class RunBookIntroductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunBookIntroductionResponseBody> body{};

  RunBookIntroductionResponse() {}

  explicit RunBookIntroductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunBookIntroductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunBookIntroductionResponseBody>(model1);
      }
    }
  }


  virtual ~RunBookIntroductionResponse() = default;
};
class RunBookSmartCardRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunBookSmartCardRequest() {}

  explicit RunBookSmartCardRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunBookSmartCardRequest() = default;
};
class RunBookSmartCardResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunBookSmartCardResponseBodyHeader() {}

  explicit RunBookSmartCardResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunBookSmartCardResponseBodyHeader() = default;
};
class RunBookSmartCardResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<string>> tags{};

  RunBookSmartCardResponseBodyPayloadOutput() {}

  explicit RunBookSmartCardResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunBookSmartCardResponseBodyPayloadOutput() = default;
};
class RunBookSmartCardResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunBookSmartCardResponseBodyPayloadUsage() {}

  explicit RunBookSmartCardResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunBookSmartCardResponseBodyPayloadUsage() = default;
};
class RunBookSmartCardResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunBookSmartCardResponseBodyPayloadOutput> output{};
  shared_ptr<RunBookSmartCardResponseBodyPayloadUsage> usage{};

  RunBookSmartCardResponseBodyPayload() {}

  explicit RunBookSmartCardResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunBookSmartCardResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunBookSmartCardResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunBookSmartCardResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunBookSmartCardResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunBookSmartCardResponseBodyPayload() = default;
};
class RunBookSmartCardResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunBookSmartCardResponseBodyHeader> header{};
  shared_ptr<RunBookSmartCardResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunBookSmartCardResponseBody() {}

  explicit RunBookSmartCardResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunBookSmartCardResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunBookSmartCardResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunBookSmartCardResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunBookSmartCardResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunBookSmartCardResponseBody() = default;
};
class RunBookSmartCardResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunBookSmartCardResponseBody> body{};

  RunBookSmartCardResponse() {}

  explicit RunBookSmartCardResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunBookSmartCardResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunBookSmartCardResponseBody>(model1);
      }
    }
  }


  virtual ~RunBookSmartCardResponse() = default;
};
class RunCommentGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowEmoji{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> length{};
  shared_ptr<map<string, boost::any>> lengthRange{};
  shared_ptr<string> numComments{};
  shared_ptr<map<string, boost::any>> sentiment{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> sourceMaterial{};
  shared_ptr<string> style{};
  shared_ptr<map<string, boost::any>> type{};
  shared_ptr<string> workspaceId{};

  RunCommentGenerationRequest() {}

  explicit RunCommentGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowEmoji) {
      res["AllowEmoji"] = boost::any(*allowEmoji);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (lengthRange) {
      res["LengthRange"] = boost::any(*lengthRange);
    }
    if (numComments) {
      res["NumComments"] = boost::any(*numComments);
    }
    if (sentiment) {
      res["Sentiment"] = boost::any(*sentiment);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sourceMaterial) {
      res["SourceMaterial"] = boost::any(*sourceMaterial);
    }
    if (style) {
      res["Style"] = boost::any(*style);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowEmoji") != m.end() && !m["AllowEmoji"].empty()) {
      allowEmoji = make_shared<bool>(boost::any_cast<bool>(m["AllowEmoji"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("LengthRange") != m.end() && !m["LengthRange"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["LengthRange"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      lengthRange = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("NumComments") != m.end() && !m["NumComments"].empty()) {
      numComments = make_shared<string>(boost::any_cast<string>(m["NumComments"]));
    }
    if (m.find("Sentiment") != m.end() && !m["Sentiment"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Sentiment"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sentiment = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SourceMaterial") != m.end() && !m["SourceMaterial"].empty()) {
      sourceMaterial = make_shared<string>(boost::any_cast<string>(m["SourceMaterial"]));
    }
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Type"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      type = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunCommentGenerationRequest() = default;
};
class RunCommentGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> allowEmoji{};
  shared_ptr<string> extraInfo{};
  shared_ptr<string> length{};
  shared_ptr<string> lengthRangeShrink{};
  shared_ptr<string> numComments{};
  shared_ptr<string> sentimentShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> sourceMaterial{};
  shared_ptr<string> style{};
  shared_ptr<string> typeShrink{};
  shared_ptr<string> workspaceId{};

  RunCommentGenerationShrinkRequest() {}

  explicit RunCommentGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowEmoji) {
      res["AllowEmoji"] = boost::any(*allowEmoji);
    }
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (lengthRangeShrink) {
      res["LengthRange"] = boost::any(*lengthRangeShrink);
    }
    if (numComments) {
      res["NumComments"] = boost::any(*numComments);
    }
    if (sentimentShrink) {
      res["Sentiment"] = boost::any(*sentimentShrink);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sourceMaterial) {
      res["SourceMaterial"] = boost::any(*sourceMaterial);
    }
    if (style) {
      res["Style"] = boost::any(*style);
    }
    if (typeShrink) {
      res["Type"] = boost::any(*typeShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowEmoji") != m.end() && !m["AllowEmoji"].empty()) {
      allowEmoji = make_shared<bool>(boost::any_cast<bool>(m["AllowEmoji"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("LengthRange") != m.end() && !m["LengthRange"].empty()) {
      lengthRangeShrink = make_shared<string>(boost::any_cast<string>(m["LengthRange"]));
    }
    if (m.find("NumComments") != m.end() && !m["NumComments"].empty()) {
      numComments = make_shared<string>(boost::any_cast<string>(m["NumComments"]));
    }
    if (m.find("Sentiment") != m.end() && !m["Sentiment"].empty()) {
      sentimentShrink = make_shared<string>(boost::any_cast<string>(m["Sentiment"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SourceMaterial") != m.end() && !m["SourceMaterial"].empty()) {
      sourceMaterial = make_shared<string>(boost::any_cast<string>(m["SourceMaterial"]));
    }
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      typeShrink = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunCommentGenerationShrinkRequest() = default;
};
class RunCommentGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunCommentGenerationResponseBodyHeader() {}

  explicit RunCommentGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunCommentGenerationResponseBodyHeader() = default;
};
class RunCommentGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunCommentGenerationResponseBodyPayloadOutput() {}

  explicit RunCommentGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunCommentGenerationResponseBodyPayloadOutput() = default;
};
class RunCommentGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunCommentGenerationResponseBodyPayloadUsage() {}

  explicit RunCommentGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunCommentGenerationResponseBodyPayloadUsage() = default;
};
class RunCommentGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunCommentGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunCommentGenerationResponseBodyPayloadUsage> usage{};

  RunCommentGenerationResponseBodyPayload() {}

  explicit RunCommentGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunCommentGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunCommentGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunCommentGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunCommentGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunCommentGenerationResponseBodyPayload() = default;
};
class RunCommentGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunCommentGenerationResponseBodyHeader> header{};
  shared_ptr<RunCommentGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunCommentGenerationResponseBody() {}

  explicit RunCommentGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunCommentGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunCommentGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunCommentGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunCommentGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunCommentGenerationResponseBody() = default;
};
class RunCommentGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunCommentGenerationResponseBody> body{};

  RunCommentGenerationResponse() {}

  explicit RunCommentGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCommentGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCommentGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunCommentGenerationResponse() = default;
};
class RunContinueContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> workspaceId{};

  RunContinueContentRequest() {}

  explicit RunContinueContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunContinueContentRequest() = default;
};
class RunContinueContentResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunContinueContentResponseBodyHeader() {}

  explicit RunContinueContentResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunContinueContentResponseBodyHeader() = default;
};
class RunContinueContentResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunContinueContentResponseBodyPayloadOutput() {}

  explicit RunContinueContentResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunContinueContentResponseBodyPayloadOutput() = default;
};
class RunContinueContentResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunContinueContentResponseBodyPayloadUsage() {}

  explicit RunContinueContentResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunContinueContentResponseBodyPayloadUsage() = default;
};
class RunContinueContentResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunContinueContentResponseBodyPayloadOutput> output{};
  shared_ptr<RunContinueContentResponseBodyPayloadUsage> usage{};

  RunContinueContentResponseBodyPayload() {}

  explicit RunContinueContentResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunContinueContentResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunContinueContentResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunContinueContentResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunContinueContentResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunContinueContentResponseBodyPayload() = default;
};
class RunContinueContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunContinueContentResponseBodyHeader> header{};
  shared_ptr<RunContinueContentResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunContinueContentResponseBody() {}

  explicit RunContinueContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunContinueContentResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunContinueContentResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunContinueContentResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunContinueContentResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunContinueContentResponseBody() = default;
};
class RunContinueContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunContinueContentResponseBody> body{};

  RunContinueContentResponse() {}

  explicit RunContinueContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunContinueContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunContinueContentResponseBody>(model1);
      }
    }
  }


  virtual ~RunContinueContentResponse() = default;
};
class RunCustomHotTopicAnalysisRequest : public Darabonba::Model {
public:
  shared_ptr<string> askUser{};
  shared_ptr<bool> forceAnalysisExistsTopic{};
  shared_ptr<string> prompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> userBack{};
  shared_ptr<string> workspaceId{};

  RunCustomHotTopicAnalysisRequest() {}

  explicit RunCustomHotTopicAnalysisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (askUser) {
      res["AskUser"] = boost::any(*askUser);
    }
    if (forceAnalysisExistsTopic) {
      res["ForceAnalysisExistsTopic"] = boost::any(*forceAnalysisExistsTopic);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (userBack) {
      res["UserBack"] = boost::any(*userBack);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AskUser") != m.end() && !m["AskUser"].empty()) {
      askUser = make_shared<string>(boost::any_cast<string>(m["AskUser"]));
    }
    if (m.find("ForceAnalysisExistsTopic") != m.end() && !m["ForceAnalysisExistsTopic"].empty()) {
      forceAnalysisExistsTopic = make_shared<bool>(boost::any_cast<bool>(m["ForceAnalysisExistsTopic"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("UserBack") != m.end() && !m["UserBack"].empty()) {
      userBack = make_shared<string>(boost::any_cast<string>(m["UserBack"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisRequest() = default;
};
class RunCustomHotTopicAnalysisResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunCustomHotTopicAnalysisResponseBodyHeader() {}

  explicit RunCustomHotTopicAnalysisResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBodyHeader() = default;
};
class RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles() {}

  explicit RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles() = default;
};
class RunCustomHotTopicAnalysisResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles>> articles{};
  shared_ptr<vector<string>> askUser{};
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> attitude{};
  shared_ptr<string> searchQuery{};
  shared_ptr<string> text{};
  shared_ptr<string> topicId{};

  RunCustomHotTopicAnalysisResponseBodyPayloadOutput() {}

  explicit RunCustomHotTopicAnalysisResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (askUser) {
      res["AskUser"] = boost::any(*askUser);
    }
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (searchQuery) {
      res["SearchQuery"] = boost::any(*searchQuery);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunCustomHotTopicAnalysisResponseBodyPayloadOutputArticles>>(expect1);
      }
    }
    if (m.find("AskUser") != m.end() && !m["AskUser"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AskUser"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AskUser"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      askUser = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("SearchQuery") != m.end() && !m["SearchQuery"].empty()) {
      searchQuery = make_shared<string>(boost::any_cast<string>(m["SearchQuery"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBodyPayloadOutput() = default;
};
class RunCustomHotTopicAnalysisResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunCustomHotTopicAnalysisResponseBodyPayloadUsage() {}

  explicit RunCustomHotTopicAnalysisResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBodyPayloadUsage() = default;
};
class RunCustomHotTopicAnalysisResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunCustomHotTopicAnalysisResponseBodyPayloadOutput> output{};
  shared_ptr<RunCustomHotTopicAnalysisResponseBodyPayloadUsage> usage{};

  RunCustomHotTopicAnalysisResponseBodyPayload() {}

  explicit RunCustomHotTopicAnalysisResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunCustomHotTopicAnalysisResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunCustomHotTopicAnalysisResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunCustomHotTopicAnalysisResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunCustomHotTopicAnalysisResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBodyPayload() = default;
};
class RunCustomHotTopicAnalysisResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunCustomHotTopicAnalysisResponseBodyHeader> header{};
  shared_ptr<RunCustomHotTopicAnalysisResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunCustomHotTopicAnalysisResponseBody() {}

  explicit RunCustomHotTopicAnalysisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunCustomHotTopicAnalysisResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunCustomHotTopicAnalysisResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunCustomHotTopicAnalysisResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunCustomHotTopicAnalysisResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponseBody() = default;
};
class RunCustomHotTopicAnalysisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunCustomHotTopicAnalysisResponseBody> body{};

  RunCustomHotTopicAnalysisResponse() {}

  explicit RunCustomHotTopicAnalysisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCustomHotTopicAnalysisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCustomHotTopicAnalysisResponseBody>(model1);
      }
    }
  }


  virtual ~RunCustomHotTopicAnalysisResponse() = default;
};
class RunCustomHotTopicViewPointAnalysisRequest : public Darabonba::Model {
public:
  shared_ptr<string> askUser{};
  shared_ptr<string> prompt{};
  shared_ptr<string> searchQuery{};
  shared_ptr<bool> skipAskUser{};
  shared_ptr<string> topic{};
  shared_ptr<string> topicId{};
  shared_ptr<string> topicSource{};
  shared_ptr<string> topicVersion{};
  shared_ptr<string> userBack{};
  shared_ptr<string> workspaceId{};

  RunCustomHotTopicViewPointAnalysisRequest() {}

  explicit RunCustomHotTopicViewPointAnalysisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (askUser) {
      res["AskUser"] = boost::any(*askUser);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (searchQuery) {
      res["SearchQuery"] = boost::any(*searchQuery);
    }
    if (skipAskUser) {
      res["SkipAskUser"] = boost::any(*skipAskUser);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    if (topicSource) {
      res["TopicSource"] = boost::any(*topicSource);
    }
    if (topicVersion) {
      res["TopicVersion"] = boost::any(*topicVersion);
    }
    if (userBack) {
      res["UserBack"] = boost::any(*userBack);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AskUser") != m.end() && !m["AskUser"].empty()) {
      askUser = make_shared<string>(boost::any_cast<string>(m["AskUser"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("SearchQuery") != m.end() && !m["SearchQuery"].empty()) {
      searchQuery = make_shared<string>(boost::any_cast<string>(m["SearchQuery"]));
    }
    if (m.find("SkipAskUser") != m.end() && !m["SkipAskUser"].empty()) {
      skipAskUser = make_shared<bool>(boost::any_cast<bool>(m["SkipAskUser"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
    if (m.find("TopicSource") != m.end() && !m["TopicSource"].empty()) {
      topicSource = make_shared<string>(boost::any_cast<string>(m["TopicSource"]));
    }
    if (m.find("TopicVersion") != m.end() && !m["TopicVersion"].empty()) {
      topicVersion = make_shared<string>(boost::any_cast<string>(m["TopicVersion"]));
    }
    if (m.find("UserBack") != m.end() && !m["UserBack"].empty()) {
      userBack = make_shared<string>(boost::any_cast<string>(m["UserBack"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisRequest() = default;
};
class RunCustomHotTopicViewPointAnalysisResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunCustomHotTopicViewPointAnalysisResponseBodyHeader() {}

  explicit RunCustomHotTopicViewPointAnalysisResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponseBodyHeader() = default;
};
class RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<string>> askUser{};
  shared_ptr<string> asyncTaskId{};
  shared_ptr<string> attitude{};
  shared_ptr<string> customViewPointId{};
  shared_ptr<string> text{};
  shared_ptr<string> topicId{};

  RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput() {}

  explicit RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (askUser) {
      res["AskUser"] = boost::any(*askUser);
    }
    if (asyncTaskId) {
      res["AsyncTaskId"] = boost::any(*asyncTaskId);
    }
    if (attitude) {
      res["Attitude"] = boost::any(*attitude);
    }
    if (customViewPointId) {
      res["CustomViewPointId"] = boost::any(*customViewPointId);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (topicId) {
      res["TopicId"] = boost::any(*topicId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AskUser") != m.end() && !m["AskUser"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AskUser"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AskUser"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      askUser = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AsyncTaskId") != m.end() && !m["AsyncTaskId"].empty()) {
      asyncTaskId = make_shared<string>(boost::any_cast<string>(m["AsyncTaskId"]));
    }
    if (m.find("Attitude") != m.end() && !m["Attitude"].empty()) {
      attitude = make_shared<string>(boost::any_cast<string>(m["Attitude"]));
    }
    if (m.find("CustomViewPointId") != m.end() && !m["CustomViewPointId"].empty()) {
      customViewPointId = make_shared<string>(boost::any_cast<string>(m["CustomViewPointId"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("TopicId") != m.end() && !m["TopicId"].empty()) {
      topicId = make_shared<string>(boost::any_cast<string>(m["TopicId"]));
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput() = default;
};
class RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage() {}

  explicit RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage() = default;
};
class RunCustomHotTopicViewPointAnalysisResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput> output{};
  shared_ptr<RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage> usage{};

  RunCustomHotTopicViewPointAnalysisResponseBodyPayload() {}

  explicit RunCustomHotTopicViewPointAnalysisResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunCustomHotTopicViewPointAnalysisResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunCustomHotTopicViewPointAnalysisResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponseBodyPayload() = default;
};
class RunCustomHotTopicViewPointAnalysisResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunCustomHotTopicViewPointAnalysisResponseBodyHeader> header{};
  shared_ptr<RunCustomHotTopicViewPointAnalysisResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunCustomHotTopicViewPointAnalysisResponseBody() {}

  explicit RunCustomHotTopicViewPointAnalysisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunCustomHotTopicViewPointAnalysisResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunCustomHotTopicViewPointAnalysisResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunCustomHotTopicViewPointAnalysisResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunCustomHotTopicViewPointAnalysisResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponseBody() = default;
};
class RunCustomHotTopicViewPointAnalysisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunCustomHotTopicViewPointAnalysisResponseBody> body{};

  RunCustomHotTopicViewPointAnalysisResponse() {}

  explicit RunCustomHotTopicViewPointAnalysisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunCustomHotTopicViewPointAnalysisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunCustomHotTopicViewPointAnalysisResponseBody>(model1);
      }
    }
  }


  virtual ~RunCustomHotTopicViewPointAnalysisResponse() = default;
};
class RunDocBrainmapRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cleanCache{};
  shared_ptr<string> docId{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<string> prompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> wordNumber{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> referenceContent{};

  RunDocBrainmapRequest() {}

  explicit RunDocBrainmapRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanCache) {
      res["CleanCache"] = boost::any(*cleanCache);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (wordNumber) {
      res["WordNumber"] = boost::any(*wordNumber);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (referenceContent) {
      res["referenceContent"] = boost::any(*referenceContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CleanCache") != m.end() && !m["CleanCache"].empty()) {
      cleanCache = make_shared<bool>(boost::any_cast<bool>(m["CleanCache"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WordNumber") != m.end() && !m["WordNumber"].empty()) {
      wordNumber = make_shared<long>(boost::any_cast<long>(m["WordNumber"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("referenceContent") != m.end() && !m["referenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["referenceContent"]));
    }
  }


  virtual ~RunDocBrainmapRequest() = default;
};
class RunDocBrainmapResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocBrainmapResponseBodyHeader() {}

  explicit RunDocBrainmapResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocBrainmapResponseBodyHeader() = default;
};
class RunDocBrainmapResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  RunDocBrainmapResponseBodyPayloadOutput() {}

  explicit RunDocBrainmapResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~RunDocBrainmapResponseBodyPayloadOutput() = default;
};
class RunDocBrainmapResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocBrainmapResponseBodyPayloadUsage() {}

  explicit RunDocBrainmapResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocBrainmapResponseBodyPayloadUsage() = default;
};
class RunDocBrainmapResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocBrainmapResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocBrainmapResponseBodyPayloadUsage> usage{};

  RunDocBrainmapResponseBodyPayload() {}

  explicit RunDocBrainmapResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocBrainmapResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocBrainmapResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocBrainmapResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocBrainmapResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocBrainmapResponseBodyPayload() = default;
};
class RunDocBrainmapResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocBrainmapResponseBodyHeader> header{};
  shared_ptr<RunDocBrainmapResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocBrainmapResponseBody() {}

  explicit RunDocBrainmapResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocBrainmapResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocBrainmapResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocBrainmapResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocBrainmapResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocBrainmapResponseBody() = default;
};
class RunDocBrainmapResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocBrainmapResponseBody> body{};

  RunDocBrainmapResponse() {}

  explicit RunDocBrainmapResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocBrainmapResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocBrainmapResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocBrainmapResponse() = default;
};
class RunDocIntroductionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cleanCache{};
  shared_ptr<string> docId{};
  shared_ptr<string> introductionPrompt{};
  shared_ptr<string> keyPointPrompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> summaryPrompt{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> referenceContent{};

  RunDocIntroductionRequest() {}

  explicit RunDocIntroductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanCache) {
      res["CleanCache"] = boost::any(*cleanCache);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (introductionPrompt) {
      res["IntroductionPrompt"] = boost::any(*introductionPrompt);
    }
    if (keyPointPrompt) {
      res["KeyPointPrompt"] = boost::any(*keyPointPrompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (referenceContent) {
      res["referenceContent"] = boost::any(*referenceContent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CleanCache") != m.end() && !m["CleanCache"].empty()) {
      cleanCache = make_shared<bool>(boost::any_cast<bool>(m["CleanCache"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("IntroductionPrompt") != m.end() && !m["IntroductionPrompt"].empty()) {
      introductionPrompt = make_shared<string>(boost::any_cast<string>(m["IntroductionPrompt"]));
    }
    if (m.find("KeyPointPrompt") != m.end() && !m["KeyPointPrompt"].empty()) {
      keyPointPrompt = make_shared<string>(boost::any_cast<string>(m["KeyPointPrompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("referenceContent") != m.end() && !m["referenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["referenceContent"]));
    }
  }


  virtual ~RunDocIntroductionRequest() = default;
};
class RunDocIntroductionResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocIntroductionResponseBodyHeader() {}

  explicit RunDocIntroductionResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocIntroductionResponseBodyHeader() = default;
};
class RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> height{};
  shared_ptr<long> pageId{};
  shared_ptr<long> width{};
  shared_ptr<long> x{};
  shared_ptr<long> y{};

  RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks() {}

  explicit RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (pageId) {
      res["PageId"] = boost::any(*pageId);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PageId") != m.end() && !m["PageId"].empty()) {
      pageId = make_shared<long>(boost::any_cast<long>(m["PageId"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
  }


  virtual ~RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks() = default;
};
class RunDocIntroductionResponseBodyPayloadOutputIntroductions : public Darabonba::Model {
public:
  shared_ptr<vector<RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks>> blocks{};
  shared_ptr<long> startPageId{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};

  RunDocIntroductionResponseBodyPayloadOutputIntroductions() {}

  explicit RunDocIntroductionResponseBodyPayloadOutputIntroductions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blocks) {
      vector<boost::any> temp1;
      for(auto item1:*blocks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Blocks"] = boost::any(temp1);
    }
    if (startPageId) {
      res["StartPageId"] = boost::any(*startPageId);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Blocks") != m.end() && !m["Blocks"].empty()) {
      if (typeid(vector<boost::any>) == m["Blocks"].type()) {
        vector<RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Blocks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blocks = make_shared<vector<RunDocIntroductionResponseBodyPayloadOutputIntroductionsBlocks>>(expect1);
      }
    }
    if (m.find("StartPageId") != m.end() && !m["StartPageId"].empty()) {
      startPageId = make_shared<long>(boost::any_cast<long>(m["StartPageId"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~RunDocIntroductionResponseBodyPayloadOutputIntroductions() = default;
};
class RunDocIntroductionResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunDocIntroductionResponseBodyPayloadOutputIntroductions>> introductions{};
  shared_ptr<string> keyPoint{};
  shared_ptr<string> summary{};

  RunDocIntroductionResponseBodyPayloadOutput() {}

  explicit RunDocIntroductionResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (introductions) {
      vector<boost::any> temp1;
      for(auto item1:*introductions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Introductions"] = boost::any(temp1);
    }
    if (keyPoint) {
      res["KeyPoint"] = boost::any(*keyPoint);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Introductions") != m.end() && !m["Introductions"].empty()) {
      if (typeid(vector<boost::any>) == m["Introductions"].type()) {
        vector<RunDocIntroductionResponseBodyPayloadOutputIntroductions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Introductions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocIntroductionResponseBodyPayloadOutputIntroductions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        introductions = make_shared<vector<RunDocIntroductionResponseBodyPayloadOutputIntroductions>>(expect1);
      }
    }
    if (m.find("KeyPoint") != m.end() && !m["KeyPoint"].empty()) {
      keyPoint = make_shared<string>(boost::any_cast<string>(m["KeyPoint"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~RunDocIntroductionResponseBodyPayloadOutput() = default;
};
class RunDocIntroductionResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocIntroductionResponseBodyPayloadUsage() {}

  explicit RunDocIntroductionResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocIntroductionResponseBodyPayloadUsage() = default;
};
class RunDocIntroductionResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocIntroductionResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocIntroductionResponseBodyPayloadUsage> usage{};

  RunDocIntroductionResponseBodyPayload() {}

  explicit RunDocIntroductionResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocIntroductionResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocIntroductionResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocIntroductionResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocIntroductionResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocIntroductionResponseBodyPayload() = default;
};
class RunDocIntroductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocIntroductionResponseBodyHeader> header{};
  shared_ptr<RunDocIntroductionResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocIntroductionResponseBody() {}

  explicit RunDocIntroductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocIntroductionResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocIntroductionResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocIntroductionResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocIntroductionResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocIntroductionResponseBody() = default;
};
class RunDocIntroductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocIntroductionResponseBody> body{};

  RunDocIntroductionResponse() {}

  explicit RunDocIntroductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocIntroductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocIntroductionResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocIntroductionResponse() = default;
};
class RunDocQaRequestConversationContexts : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> role{};

  RunDocQaRequestConversationContexts() {}

  explicit RunDocQaRequestConversationContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~RunDocQaRequestConversationContexts() = default;
};
class RunDocQaRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categoryIds{};
  shared_ptr<vector<RunDocQaRequestConversationContexts>> conversationContexts{};
  shared_ptr<vector<string>> docIds{};
  shared_ptr<string> query{};
  shared_ptr<string> referenceContent{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunDocQaRequest() {}

  explicit RunDocQaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryIds) {
      res["CategoryIds"] = boost::any(*categoryIds);
    }
    if (conversationContexts) {
      vector<boost::any> temp1;
      for(auto item1:*conversationContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConversationContexts"] = boost::any(temp1);
    }
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (referenceContent) {
      res["ReferenceContent"] = boost::any(*referenceContent);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryIds") != m.end() && !m["CategoryIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CategoryIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CategoryIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categoryIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ConversationContexts") != m.end() && !m["ConversationContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ConversationContexts"].type()) {
        vector<RunDocQaRequestConversationContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConversationContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocQaRequestConversationContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conversationContexts = make_shared<vector<RunDocQaRequestConversationContexts>>(expect1);
      }
    }
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("ReferenceContent") != m.end() && !m["ReferenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["ReferenceContent"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunDocQaRequest() = default;
};
class RunDocQaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryIdsShrink{};
  shared_ptr<string> conversationContextsShrink{};
  shared_ptr<string> docIdsShrink{};
  shared_ptr<string> query{};
  shared_ptr<string> referenceContent{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunDocQaShrinkRequest() {}

  explicit RunDocQaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryIdsShrink) {
      res["CategoryIds"] = boost::any(*categoryIdsShrink);
    }
    if (conversationContextsShrink) {
      res["ConversationContexts"] = boost::any(*conversationContextsShrink);
    }
    if (docIdsShrink) {
      res["DocIds"] = boost::any(*docIdsShrink);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (referenceContent) {
      res["ReferenceContent"] = boost::any(*referenceContent);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryIds") != m.end() && !m["CategoryIds"].empty()) {
      categoryIdsShrink = make_shared<string>(boost::any_cast<string>(m["CategoryIds"]));
    }
    if (m.find("ConversationContexts") != m.end() && !m["ConversationContexts"].empty()) {
      conversationContextsShrink = make_shared<string>(boost::any_cast<string>(m["ConversationContexts"]));
    }
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      docIdsShrink = make_shared<string>(boost::any_cast<string>(m["DocIds"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("ReferenceContent") != m.end() && !m["ReferenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["ReferenceContent"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunDocQaShrinkRequest() = default;
};
class RunDocQaResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocQaResponseBodyHeader() {}

  explicit RunDocQaResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocQaResponseBodyHeader() = default;
};
class RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> to{};

  RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos() {}

  explicit RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
  }


  virtual ~RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos() = default;
};
class RunDocQaResponseBodyPayloadOutputMediaUrlList : public Darabonba::Model {
public:
  shared_ptr<vector<RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos>> clipInfos{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaType{};

  RunDocQaResponseBodyPayloadOutputMediaUrlList() {}

  explicit RunDocQaResponseBodyPayloadOutputMediaUrlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfos"] = boost::any(temp1);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClipInfos") != m.end() && !m["ClipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfos"].type()) {
        vector<RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfos = make_shared<vector<RunDocQaResponseBodyPayloadOutputMediaUrlListClipInfos>>(expect1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunDocQaResponseBodyPayloadOutputMediaUrlList() = default;
};
class RunDocQaResponseBodyPayloadOutputRecommends : public Darabonba::Model {
public:
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunDocQaResponseBodyPayloadOutputRecommends() {}

  explicit RunDocQaResponseBodyPayloadOutputRecommends(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunDocQaResponseBodyPayloadOutputRecommends() = default;
};
class RunDocQaResponseBodyPayloadOutputReferences : public Darabonba::Model {
public:
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> sourceDocId{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunDocQaResponseBodyPayloadOutputReferences() {}

  explicit RunDocQaResponseBodyPayloadOutputReferences(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (sourceDocId) {
      res["SourceDocId"] = boost::any(*sourceDocId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("SourceDocId") != m.end() && !m["SourceDocId"].empty()) {
      sourceDocId = make_shared<string>(boost::any_cast<string>(m["SourceDocId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunDocQaResponseBodyPayloadOutputReferences() = default;
};
class RunDocQaResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> interveneContent{};
  shared_ptr<bool> isReject{};
  shared_ptr<vector<RunDocQaResponseBodyPayloadOutputMediaUrlList>> mediaUrlList{};
  shared_ptr<vector<RunDocQaResponseBodyPayloadOutputRecommends>> recommends{};
  shared_ptr<vector<RunDocQaResponseBodyPayloadOutputReferences>> references{};

  RunDocQaResponseBodyPayloadOutput() {}

  explicit RunDocQaResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (interveneContent) {
      res["InterveneContent"] = boost::any(*interveneContent);
    }
    if (isReject) {
      res["IsReject"] = boost::any(*isReject);
    }
    if (mediaUrlList) {
      vector<boost::any> temp1;
      for(auto item1:*mediaUrlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MediaUrlList"] = boost::any(temp1);
    }
    if (recommends) {
      vector<boost::any> temp1;
      for(auto item1:*recommends){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Recommends"] = boost::any(temp1);
    }
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["References"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("InterveneContent") != m.end() && !m["InterveneContent"].empty()) {
      interveneContent = make_shared<string>(boost::any_cast<string>(m["InterveneContent"]));
    }
    if (m.find("IsReject") != m.end() && !m["IsReject"].empty()) {
      isReject = make_shared<bool>(boost::any_cast<bool>(m["IsReject"]));
    }
    if (m.find("MediaUrlList") != m.end() && !m["MediaUrlList"].empty()) {
      if (typeid(vector<boost::any>) == m["MediaUrlList"].type()) {
        vector<RunDocQaResponseBodyPayloadOutputMediaUrlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MediaUrlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocQaResponseBodyPayloadOutputMediaUrlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mediaUrlList = make_shared<vector<RunDocQaResponseBodyPayloadOutputMediaUrlList>>(expect1);
      }
    }
    if (m.find("Recommends") != m.end() && !m["Recommends"].empty()) {
      if (typeid(vector<boost::any>) == m["Recommends"].type()) {
        vector<RunDocQaResponseBodyPayloadOutputRecommends> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Recommends"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocQaResponseBodyPayloadOutputRecommends model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recommends = make_shared<vector<RunDocQaResponseBodyPayloadOutputRecommends>>(expect1);
      }
    }
    if (m.find("References") != m.end() && !m["References"].empty()) {
      if (typeid(vector<boost::any>) == m["References"].type()) {
        vector<RunDocQaResponseBodyPayloadOutputReferences> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["References"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunDocQaResponseBodyPayloadOutputReferences model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<RunDocQaResponseBodyPayloadOutputReferences>>(expect1);
      }
    }
  }


  virtual ~RunDocQaResponseBodyPayloadOutput() = default;
};
class RunDocQaResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocQaResponseBodyPayloadUsage() {}

  explicit RunDocQaResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocQaResponseBodyPayloadUsage() = default;
};
class RunDocQaResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocQaResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocQaResponseBodyPayloadUsage> usage{};

  RunDocQaResponseBodyPayload() {}

  explicit RunDocQaResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocQaResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocQaResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocQaResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocQaResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocQaResponseBodyPayload() = default;
};
class RunDocQaResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocQaResponseBodyHeader> header{};
  shared_ptr<RunDocQaResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocQaResponseBody() {}

  explicit RunDocQaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocQaResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocQaResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocQaResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocQaResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocQaResponseBody() = default;
};
class RunDocQaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocQaResponseBody> body{};

  RunDocQaResponse() {}

  explicit RunDocQaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocQaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocQaResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocQaResponse() = default;
};
class RunDocSmartCardRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunDocSmartCardRequest() {}

  explicit RunDocSmartCardRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunDocSmartCardRequest() = default;
};
class RunDocSmartCardResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocSmartCardResponseBodyHeader() {}

  explicit RunDocSmartCardResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocSmartCardResponseBodyHeader() = default;
};
class RunDocSmartCardResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<string>> tags{};

  RunDocSmartCardResponseBodyPayloadOutput() {}

  explicit RunDocSmartCardResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tags"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tags = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunDocSmartCardResponseBodyPayloadOutput() = default;
};
class RunDocSmartCardResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocSmartCardResponseBodyPayloadUsage() {}

  explicit RunDocSmartCardResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocSmartCardResponseBodyPayloadUsage() = default;
};
class RunDocSmartCardResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocSmartCardResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocSmartCardResponseBodyPayloadUsage> usage{};

  RunDocSmartCardResponseBodyPayload() {}

  explicit RunDocSmartCardResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocSmartCardResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocSmartCardResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocSmartCardResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocSmartCardResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocSmartCardResponseBodyPayload() = default;
};
class RunDocSmartCardResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocSmartCardResponseBodyHeader> header{};
  shared_ptr<RunDocSmartCardResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocSmartCardResponseBody() {}

  explicit RunDocSmartCardResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocSmartCardResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocSmartCardResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocSmartCardResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocSmartCardResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocSmartCardResponseBody() = default;
};
class RunDocSmartCardResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocSmartCardResponseBody> body{};

  RunDocSmartCardResponse() {}

  explicit RunDocSmartCardResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocSmartCardResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocSmartCardResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocSmartCardResponse() = default;
};
class RunDocSummaryRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cleanCache{};
  shared_ptr<string> docId{};
  shared_ptr<string> query{};
  shared_ptr<string> recommendContent{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunDocSummaryRequest() {}

  explicit RunDocSummaryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanCache) {
      res["CleanCache"] = boost::any(*cleanCache);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (recommendContent) {
      res["RecommendContent"] = boost::any(*recommendContent);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CleanCache") != m.end() && !m["CleanCache"].empty()) {
      cleanCache = make_shared<bool>(boost::any_cast<bool>(m["CleanCache"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("RecommendContent") != m.end() && !m["RecommendContent"].empty()) {
      recommendContent = make_shared<string>(boost::any_cast<string>(m["RecommendContent"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunDocSummaryRequest() = default;
};
class RunDocSummaryResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocSummaryResponseBodyHeader() {}

  explicit RunDocSummaryResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocSummaryResponseBodyHeader() = default;
};
class RunDocSummaryResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  RunDocSummaryResponseBodyPayloadOutput() {}

  explicit RunDocSummaryResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~RunDocSummaryResponseBodyPayloadOutput() = default;
};
class RunDocSummaryResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocSummaryResponseBodyPayloadUsage() {}

  explicit RunDocSummaryResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocSummaryResponseBodyPayloadUsage() = default;
};
class RunDocSummaryResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocSummaryResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocSummaryResponseBodyPayloadUsage> usage{};

  RunDocSummaryResponseBodyPayload() {}

  explicit RunDocSummaryResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocSummaryResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocSummaryResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocSummaryResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocSummaryResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocSummaryResponseBodyPayload() = default;
};
class RunDocSummaryResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocSummaryResponseBodyHeader> header{};
  shared_ptr<RunDocSummaryResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocSummaryResponseBody() {}

  explicit RunDocSummaryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocSummaryResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocSummaryResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocSummaryResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocSummaryResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocSummaryResponseBody() = default;
};
class RunDocSummaryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocSummaryResponseBody> body{};

  RunDocSummaryResponse() {}

  explicit RunDocSummaryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocSummaryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocSummaryResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocSummaryResponse() = default;
};
class RunDocTranslationRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cleanCache{};
  shared_ptr<string> docId{};
  shared_ptr<string> recommendContent{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> transType{};
  shared_ptr<string> workspaceId{};

  RunDocTranslationRequest() {}

  explicit RunDocTranslationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cleanCache) {
      res["CleanCache"] = boost::any(*cleanCache);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (recommendContent) {
      res["RecommendContent"] = boost::any(*recommendContent);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (transType) {
      res["TransType"] = boost::any(*transType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CleanCache") != m.end() && !m["CleanCache"].empty()) {
      cleanCache = make_shared<bool>(boost::any_cast<bool>(m["CleanCache"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("RecommendContent") != m.end() && !m["RecommendContent"].empty()) {
      recommendContent = make_shared<string>(boost::any_cast<string>(m["RecommendContent"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TransType") != m.end() && !m["TransType"].empty()) {
      transType = make_shared<string>(boost::any_cast<string>(m["TransType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunDocTranslationRequest() = default;
};
class RunDocTranslationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocTranslationResponseBodyHeader() {}

  explicit RunDocTranslationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocTranslationResponseBodyHeader() = default;
};
class RunDocTranslationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  RunDocTranslationResponseBodyPayloadOutput() {}

  explicit RunDocTranslationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~RunDocTranslationResponseBodyPayloadOutput() = default;
};
class RunDocTranslationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocTranslationResponseBodyPayloadUsage() {}

  explicit RunDocTranslationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocTranslationResponseBodyPayloadUsage() = default;
};
class RunDocTranslationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocTranslationResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocTranslationResponseBodyPayloadUsage> usage{};

  RunDocTranslationResponseBodyPayload() {}

  explicit RunDocTranslationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocTranslationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocTranslationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocTranslationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocTranslationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocTranslationResponseBodyPayload() = default;
};
class RunDocTranslationResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunDocTranslationResponseBodyHeader> header{};
  shared_ptr<RunDocTranslationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocTranslationResponseBody() {}

  explicit RunDocTranslationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocTranslationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocTranslationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocTranslationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocTranslationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocTranslationResponseBody() = default;
};
class RunDocTranslationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocTranslationResponseBody> body{};

  RunDocTranslationResponse() {}

  explicit RunDocTranslationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocTranslationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocTranslationResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocTranslationResponse() = default;
};
class RunDocWashingRequest : public Darabonba::Model {
public:
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceContent{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> topic{};
  shared_ptr<long> wordNumber{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> writingTypeName{};
  shared_ptr<string> writingTypeRefDoc{};

  RunDocWashingRequest() {}

  explicit RunDocWashingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceContent) {
      res["ReferenceContent"] = boost::any(*referenceContent);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (wordNumber) {
      res["WordNumber"] = boost::any(*wordNumber);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (writingTypeName) {
      res["WritingTypeName"] = boost::any(*writingTypeName);
    }
    if (writingTypeRefDoc) {
      res["WritingTypeRefDoc"] = boost::any(*writingTypeRefDoc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceContent") != m.end() && !m["ReferenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["ReferenceContent"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("WordNumber") != m.end() && !m["WordNumber"].empty()) {
      wordNumber = make_shared<long>(boost::any_cast<long>(m["WordNumber"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("WritingTypeName") != m.end() && !m["WritingTypeName"].empty()) {
      writingTypeName = make_shared<string>(boost::any_cast<string>(m["WritingTypeName"]));
    }
    if (m.find("WritingTypeRefDoc") != m.end() && !m["WritingTypeRefDoc"].empty()) {
      writingTypeRefDoc = make_shared<string>(boost::any_cast<string>(m["WritingTypeRefDoc"]));
    }
  }


  virtual ~RunDocWashingRequest() = default;
};
class RunDocWashingResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunDocWashingResponseBodyHeader() {}

  explicit RunDocWashingResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunDocWashingResponseBodyHeader() = default;
};
class RunDocWashingResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunDocWashingResponseBodyPayloadOutput() {}

  explicit RunDocWashingResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunDocWashingResponseBodyPayloadOutput() = default;
};
class RunDocWashingResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunDocWashingResponseBodyPayloadUsage() {}

  explicit RunDocWashingResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunDocWashingResponseBodyPayloadUsage() = default;
};
class RunDocWashingResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunDocWashingResponseBodyPayloadOutput> output{};
  shared_ptr<RunDocWashingResponseBodyPayloadUsage> usage{};

  RunDocWashingResponseBodyPayload() {}

  explicit RunDocWashingResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunDocWashingResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunDocWashingResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunDocWashingResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunDocWashingResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunDocWashingResponseBodyPayload() = default;
};
class RunDocWashingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunDocWashingResponseBodyHeader> header{};
  shared_ptr<RunDocWashingResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunDocWashingResponseBody() {}

  explicit RunDocWashingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunDocWashingResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunDocWashingResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunDocWashingResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunDocWashingResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunDocWashingResponseBody() = default;
};
class RunDocWashingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunDocWashingResponseBody> body{};

  RunDocWashingResponse() {}

  explicit RunDocWashingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunDocWashingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunDocWashingResponseBody>(model1);
      }
    }
  }


  virtual ~RunDocWashingResponse() = default;
};
class RunExpandContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> workspaceId{};

  RunExpandContentRequest() {}

  explicit RunExpandContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunExpandContentRequest() = default;
};
class RunExpandContentResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunExpandContentResponseBodyHeader() {}

  explicit RunExpandContentResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunExpandContentResponseBodyHeader() = default;
};
class RunExpandContentResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunExpandContentResponseBodyPayloadOutput() {}

  explicit RunExpandContentResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunExpandContentResponseBodyPayloadOutput() = default;
};
class RunExpandContentResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunExpandContentResponseBodyPayloadUsage() {}

  explicit RunExpandContentResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunExpandContentResponseBodyPayloadUsage() = default;
};
class RunExpandContentResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunExpandContentResponseBodyPayloadOutput> output{};
  shared_ptr<RunExpandContentResponseBodyPayloadUsage> usage{};

  RunExpandContentResponseBodyPayload() {}

  explicit RunExpandContentResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunExpandContentResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunExpandContentResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunExpandContentResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunExpandContentResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunExpandContentResponseBodyPayload() = default;
};
class RunExpandContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunExpandContentResponseBodyHeader> header{};
  shared_ptr<RunExpandContentResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunExpandContentResponseBody() {}

  explicit RunExpandContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunExpandContentResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunExpandContentResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunExpandContentResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunExpandContentResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunExpandContentResponseBody() = default;
};
class RunExpandContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunExpandContentResponseBody> body{};

  RunExpandContentResponse() {}

  explicit RunExpandContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunExpandContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunExpandContentResponseBody>(model1);
      }
    }
  }


  virtual ~RunExpandContentResponse() = default;
};
class RunGenerateQuestionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> referenceContent{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunGenerateQuestionsRequest() {}

  explicit RunGenerateQuestionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (referenceContent) {
      res["ReferenceContent"] = boost::any(*referenceContent);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("ReferenceContent") != m.end() && !m["ReferenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["ReferenceContent"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunGenerateQuestionsRequest() = default;
};
class RunGenerateQuestionsResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunGenerateQuestionsResponseBodyHeader() {}

  explicit RunGenerateQuestionsResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunGenerateQuestionsResponseBodyHeader() = default;
};
class RunGenerateQuestionsResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  RunGenerateQuestionsResponseBodyPayloadOutput() {}

  explicit RunGenerateQuestionsResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~RunGenerateQuestionsResponseBodyPayloadOutput() = default;
};
class RunGenerateQuestionsResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunGenerateQuestionsResponseBodyPayloadUsage() {}

  explicit RunGenerateQuestionsResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunGenerateQuestionsResponseBodyPayloadUsage() = default;
};
class RunGenerateQuestionsResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunGenerateQuestionsResponseBodyPayloadOutput> output{};
  shared_ptr<RunGenerateQuestionsResponseBodyPayloadUsage> usage{};

  RunGenerateQuestionsResponseBodyPayload() {}

  explicit RunGenerateQuestionsResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunGenerateQuestionsResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunGenerateQuestionsResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunGenerateQuestionsResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunGenerateQuestionsResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunGenerateQuestionsResponseBodyPayload() = default;
};
class RunGenerateQuestionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunGenerateQuestionsResponseBodyHeader> header{};
  shared_ptr<RunGenerateQuestionsResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunGenerateQuestionsResponseBody() {}

  explicit RunGenerateQuestionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunGenerateQuestionsResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunGenerateQuestionsResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunGenerateQuestionsResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunGenerateQuestionsResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunGenerateQuestionsResponseBody() = default;
};
class RunGenerateQuestionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunGenerateQuestionsResponseBody> body{};

  RunGenerateQuestionsResponse() {}

  explicit RunGenerateQuestionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunGenerateQuestionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunGenerateQuestionsResponseBody>(model1);
      }
    }
  }


  virtual ~RunGenerateQuestionsResponse() = default;
};
class RunHotwordRequest : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceContent{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> workspaceId{};

  RunHotwordRequest() {}

  explicit RunHotwordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceContent) {
      res["ReferenceContent"] = boost::any(*referenceContent);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceContent") != m.end() && !m["ReferenceContent"].empty()) {
      referenceContent = make_shared<string>(boost::any_cast<string>(m["ReferenceContent"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunHotwordRequest() = default;
};
class RunHotwordResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunHotwordResponseBodyHeader() {}

  explicit RunHotwordResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunHotwordResponseBodyHeader() = default;
};
class RunHotwordResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> content{};

  RunHotwordResponseBodyPayloadOutput() {}

  explicit RunHotwordResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~RunHotwordResponseBodyPayloadOutput() = default;
};
class RunHotwordResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunHotwordResponseBodyPayloadUsage() {}

  explicit RunHotwordResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunHotwordResponseBodyPayloadUsage() = default;
};
class RunHotwordResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunHotwordResponseBodyPayloadOutput> output{};
  shared_ptr<RunHotwordResponseBodyPayloadUsage> usage{};

  RunHotwordResponseBodyPayload() {}

  explicit RunHotwordResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunHotwordResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunHotwordResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunHotwordResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunHotwordResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunHotwordResponseBodyPayload() = default;
};
class RunHotwordResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunHotwordResponseBodyHeader> header{};
  shared_ptr<RunHotwordResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunHotwordResponseBody() {}

  explicit RunHotwordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunHotwordResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunHotwordResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunHotwordResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunHotwordResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunHotwordResponseBody() = default;
};
class RunHotwordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunHotwordResponseBody> body{};

  RunHotwordResponse() {}

  explicit RunHotwordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunHotwordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunHotwordResponseBody>(model1);
      }
    }
  }


  virtual ~RunHotwordResponse() = default;
};
class RunKeywordsExtractionGenerationRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contents{};

  RunKeywordsExtractionGenerationRequestReferenceData() {}

  explicit RunKeywordsExtractionGenerationRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contents = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunKeywordsExtractionGenerationRequestReferenceData() = default;
};
class RunKeywordsExtractionGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<RunKeywordsExtractionGenerationRequestReferenceData> referenceData{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunKeywordsExtractionGenerationRequest() {}

  explicit RunKeywordsExtractionGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunKeywordsExtractionGenerationRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunKeywordsExtractionGenerationRequestReferenceData>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationRequest() = default;
};
class RunKeywordsExtractionGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunKeywordsExtractionGenerationShrinkRequest() {}

  explicit RunKeywordsExtractionGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationShrinkRequest() = default;
};
class RunKeywordsExtractionGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunKeywordsExtractionGenerationResponseBodyHeader() {}

  explicit RunKeywordsExtractionGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponseBodyHeader() = default;
};
class RunKeywordsExtractionGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunKeywordsExtractionGenerationResponseBodyPayloadOutput() {}

  explicit RunKeywordsExtractionGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponseBodyPayloadOutput() = default;
};
class RunKeywordsExtractionGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunKeywordsExtractionGenerationResponseBodyPayloadUsage() {}

  explicit RunKeywordsExtractionGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponseBodyPayloadUsage() = default;
};
class RunKeywordsExtractionGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunKeywordsExtractionGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunKeywordsExtractionGenerationResponseBodyPayloadUsage> usage{};

  RunKeywordsExtractionGenerationResponseBodyPayload() {}

  explicit RunKeywordsExtractionGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunKeywordsExtractionGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunKeywordsExtractionGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunKeywordsExtractionGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunKeywordsExtractionGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponseBodyPayload() = default;
};
class RunKeywordsExtractionGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunKeywordsExtractionGenerationResponseBodyHeader> header{};
  shared_ptr<RunKeywordsExtractionGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunKeywordsExtractionGenerationResponseBody() {}

  explicit RunKeywordsExtractionGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunKeywordsExtractionGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunKeywordsExtractionGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunKeywordsExtractionGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunKeywordsExtractionGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponseBody() = default;
};
class RunKeywordsExtractionGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunKeywordsExtractionGenerationResponseBody> body{};

  RunKeywordsExtractionGenerationResponse() {}

  explicit RunKeywordsExtractionGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunKeywordsExtractionGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunKeywordsExtractionGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunKeywordsExtractionGenerationResponse() = default;
};
class RunMultiDocIntroductionRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> docIds{};
  shared_ptr<string> keyPointPrompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> summaryPrompt{};
  shared_ptr<string> workspaceId{};

  RunMultiDocIntroductionRequest() {}

  explicit RunMultiDocIntroductionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (keyPointPrompt) {
      res["KeyPointPrompt"] = boost::any(*keyPointPrompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("KeyPointPrompt") != m.end() && !m["KeyPointPrompt"].empty()) {
      keyPointPrompt = make_shared<string>(boost::any_cast<string>(m["KeyPointPrompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunMultiDocIntroductionRequest() = default;
};
class RunMultiDocIntroductionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> docIdsShrink{};
  shared_ptr<string> keyPointPrompt{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> summaryPrompt{};
  shared_ptr<string> workspaceId{};

  RunMultiDocIntroductionShrinkRequest() {}

  explicit RunMultiDocIntroductionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIdsShrink) {
      res["DocIds"] = boost::any(*docIdsShrink);
    }
    if (keyPointPrompt) {
      res["KeyPointPrompt"] = boost::any(*keyPointPrompt);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      docIdsShrink = make_shared<string>(boost::any_cast<string>(m["DocIds"]));
    }
    if (m.find("KeyPointPrompt") != m.end() && !m["KeyPointPrompt"].empty()) {
      keyPointPrompt = make_shared<string>(boost::any_cast<string>(m["KeyPointPrompt"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunMultiDocIntroductionShrinkRequest() = default;
};
class RunMultiDocIntroductionResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunMultiDocIntroductionResponseBodyHeader() {}

  explicit RunMultiDocIntroductionResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunMultiDocIntroductionResponseBodyHeader() = default;
};
class RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints : public Darabonba::Model {
public:
  shared_ptr<string> keyPoint{};
  shared_ptr<string> source{};

  RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints() {}

  explicit RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPoint) {
      res["KeyPoint"] = boost::any(*keyPoint);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPoint") != m.end() && !m["KeyPoint"].empty()) {
      keyPoint = make_shared<string>(boost::any_cast<string>(m["KeyPoint"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints() = default;
};
class RunMultiDocIntroductionResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints>> keyPoints{};
  shared_ptr<string> summary{};

  RunMultiDocIntroductionResponseBodyPayloadOutput() {}

  explicit RunMultiDocIntroductionResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyPoints) {
      vector<boost::any> temp1;
      for(auto item1:*keyPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["KeyPoints"] = boost::any(temp1);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyPoints") != m.end() && !m["KeyPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["KeyPoints"].type()) {
        vector<RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["KeyPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        keyPoints = make_shared<vector<RunMultiDocIntroductionResponseBodyPayloadOutputKeyPoints>>(expect1);
      }
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
  }


  virtual ~RunMultiDocIntroductionResponseBodyPayloadOutput() = default;
};
class RunMultiDocIntroductionResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunMultiDocIntroductionResponseBodyPayloadUsage() {}

  explicit RunMultiDocIntroductionResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunMultiDocIntroductionResponseBodyPayloadUsage() = default;
};
class RunMultiDocIntroductionResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunMultiDocIntroductionResponseBodyPayloadOutput> output{};
  shared_ptr<RunMultiDocIntroductionResponseBodyPayloadUsage> usage{};

  RunMultiDocIntroductionResponseBodyPayload() {}

  explicit RunMultiDocIntroductionResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunMultiDocIntroductionResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunMultiDocIntroductionResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunMultiDocIntroductionResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunMultiDocIntroductionResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunMultiDocIntroductionResponseBodyPayload() = default;
};
class RunMultiDocIntroductionResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunMultiDocIntroductionResponseBodyHeader> header{};
  shared_ptr<RunMultiDocIntroductionResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunMultiDocIntroductionResponseBody() {}

  explicit RunMultiDocIntroductionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunMultiDocIntroductionResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunMultiDocIntroductionResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunMultiDocIntroductionResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunMultiDocIntroductionResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunMultiDocIntroductionResponseBody() = default;
};
class RunMultiDocIntroductionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunMultiDocIntroductionResponseBody> body{};

  RunMultiDocIntroductionResponse() {}

  explicit RunMultiDocIntroductionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunMultiDocIntroductionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunMultiDocIntroductionResponseBody>(model1);
      }
    }
  }


  virtual ~RunMultiDocIntroductionResponse() = default;
};
class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> chunks{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<double> score{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult() {}

  explicit RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chunks) {
      res["Chunks"] = boost::any(*chunks);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chunks") != m.end() && !m["Chunks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Chunks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Chunks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      chunks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult() = default;
};
class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult>> searchResult{};

  RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult() {}

  explicit RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResultSearchResult>>(expect1);
      }
    }
  }


  virtual ~RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult() = default;
};
class RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection : public Darabonba::Model {
public:
  shared_ptr<string> originalSessionId{};
  shared_ptr<string> searchModel{};
  shared_ptr<string> searchModelDataValue{};
  shared_ptr<string> selectionType{};
  shared_ptr<string> sessionId{};
  shared_ptr<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult> textSearchResult{};

  RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection() {}

  explicit RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalSessionId) {
      res["OriginalSessionId"] = boost::any(*originalSessionId);
    }
    if (searchModel) {
      res["SearchModel"] = boost::any(*searchModel);
    }
    if (searchModelDataValue) {
      res["SearchModelDataValue"] = boost::any(*searchModelDataValue);
    }
    if (selectionType) {
      res["SelectionType"] = boost::any(*selectionType);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (textSearchResult) {
      res["TextSearchResult"] = textSearchResult ? boost::any(textSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalSessionId") != m.end() && !m["OriginalSessionId"].empty()) {
      originalSessionId = make_shared<string>(boost::any_cast<string>(m["OriginalSessionId"]));
    }
    if (m.find("SearchModel") != m.end() && !m["SearchModel"].empty()) {
      searchModel = make_shared<string>(boost::any_cast<string>(m["SearchModel"]));
    }
    if (m.find("SearchModelDataValue") != m.end() && !m["SearchModelDataValue"].empty()) {
      searchModelDataValue = make_shared<string>(boost::any_cast<string>(m["SearchModelDataValue"]));
    }
    if (m.find("SelectionType") != m.end() && !m["SelectionType"].empty()) {
      selectionType = make_shared<string>(boost::any_cast<string>(m["SelectionType"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TextSearchResult") != m.end() && !m["TextSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextSearchResult"].type()) {
        RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextSearchResult"]));
        textSearchResult = make_shared<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelectionTextSearchResult>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection() = default;
};
class RunSearchGenerationRequestAgentContextBizContext : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection> multimodalMediaSelection{};
  shared_ptr<bool> skipCurrentSupplement{};

  RunSearchGenerationRequestAgentContextBizContext() {}

  explicit RunSearchGenerationRequestAgentContextBizContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (multimodalMediaSelection) {
      res["MultimodalMediaSelection"] = multimodalMediaSelection ? boost::any(multimodalMediaSelection->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skipCurrentSupplement) {
      res["SkipCurrentSupplement"] = boost::any(*skipCurrentSupplement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MultimodalMediaSelection") != m.end() && !m["MultimodalMediaSelection"].empty()) {
      if (typeid(map<string, boost::any>) == m["MultimodalMediaSelection"].type()) {
        RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MultimodalMediaSelection"]));
        multimodalMediaSelection = make_shared<RunSearchGenerationRequestAgentContextBizContextMultimodalMediaSelection>(model1);
      }
    }
    if (m.find("SkipCurrentSupplement") != m.end() && !m["SkipCurrentSupplement"].empty()) {
      skipCurrentSupplement = make_shared<bool>(boost::any_cast<bool>(m["SkipCurrentSupplement"]));
    }
  }


  virtual ~RunSearchGenerationRequestAgentContextBizContext() = default;
};
class RunSearchGenerationRequestAgentContext : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationRequestAgentContextBizContext> bizContext{};

  RunSearchGenerationRequestAgentContext() {}

  explicit RunSearchGenerationRequestAgentContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizContext) {
      res["BizContext"] = bizContext ? boost::any(bizContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizContext") != m.end() && !m["BizContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizContext"].type()) {
        RunSearchGenerationRequestAgentContextBizContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizContext"]));
        bizContext = make_shared<RunSearchGenerationRequestAgentContextBizContext>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationRequestAgentContext() = default;
};
class RunSearchGenerationRequestChatConfigSearchParamSearchSources : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datasetName{};

  RunSearchGenerationRequestChatConfigSearchParamSearchSources() {}

  explicit RunSearchGenerationRequestChatConfigSearchParamSearchSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
  }


  virtual ~RunSearchGenerationRequestChatConfigSearchParamSearchSources() = default;
};
class RunSearchGenerationRequestChatConfigSearchParam : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<vector<string>> multimodalSearchTypes{};
  shared_ptr<vector<RunSearchGenerationRequestChatConfigSearchParamSearchSources>> searchSources{};
  shared_ptr<long> startTime{};

  RunSearchGenerationRequestChatConfigSearchParam() {}

  explicit RunSearchGenerationRequestChatConfigSearchParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (multimodalSearchTypes) {
      res["MultimodalSearchTypes"] = boost::any(*multimodalSearchTypes);
    }
    if (searchSources) {
      vector<boost::any> temp1;
      for(auto item1:*searchSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSources"] = boost::any(temp1);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("MultimodalSearchTypes") != m.end() && !m["MultimodalSearchTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MultimodalSearchTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MultimodalSearchTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      multimodalSearchTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSources"].type()) {
        vector<RunSearchGenerationRequestChatConfigSearchParamSearchSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationRequestChatConfigSearchParamSearchSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSources = make_shared<vector<RunSearchGenerationRequestChatConfigSearchParamSearchSources>>(expect1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~RunSearchGenerationRequestChatConfigSearchParam() = default;
};
class RunSearchGenerationRequestChatConfig : public Darabonba::Model {
public:
  shared_ptr<string> generateLevel{};
  shared_ptr<string> generateTechnology{};
  shared_ptr<vector<string>> searchModels{};
  shared_ptr<RunSearchGenerationRequestChatConfigSearchParam> searchParam{};

  RunSearchGenerationRequestChatConfig() {}

  explicit RunSearchGenerationRequestChatConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateLevel) {
      res["GenerateLevel"] = boost::any(*generateLevel);
    }
    if (generateTechnology) {
      res["GenerateTechnology"] = boost::any(*generateTechnology);
    }
    if (searchModels) {
      res["SearchModels"] = boost::any(*searchModels);
    }
    if (searchParam) {
      res["SearchParam"] = searchParam ? boost::any(searchParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateLevel") != m.end() && !m["GenerateLevel"].empty()) {
      generateLevel = make_shared<string>(boost::any_cast<string>(m["GenerateLevel"]));
    }
    if (m.find("GenerateTechnology") != m.end() && !m["GenerateTechnology"].empty()) {
      generateTechnology = make_shared<string>(boost::any_cast<string>(m["GenerateTechnology"]));
    }
    if (m.find("SearchModels") != m.end() && !m["SearchModels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SearchModels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SearchModels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searchModels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchParam") != m.end() && !m["SearchParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchParam"].type()) {
        RunSearchGenerationRequestChatConfigSearchParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchParam"]));
        searchParam = make_shared<RunSearchGenerationRequestChatConfigSearchParam>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationRequestChatConfig() = default;
};
class RunSearchGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationRequestAgentContext> agentContext{};
  shared_ptr<RunSearchGenerationRequestChatConfig> chatConfig{};
  shared_ptr<string> modelId{};
  shared_ptr<string> originalSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunSearchGenerationRequest() {}

  explicit RunSearchGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentContext) {
      res["AgentContext"] = agentContext ? boost::any(agentContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (chatConfig) {
      res["ChatConfig"] = chatConfig ? boost::any(chatConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (originalSessionId) {
      res["OriginalSessionId"] = boost::any(*originalSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentContext") != m.end() && !m["AgentContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentContext"].type()) {
        RunSearchGenerationRequestAgentContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentContext"]));
        agentContext = make_shared<RunSearchGenerationRequestAgentContext>(model1);
      }
    }
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChatConfig"].type()) {
        RunSearchGenerationRequestChatConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChatConfig"]));
        chatConfig = make_shared<RunSearchGenerationRequestChatConfig>(model1);
      }
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("OriginalSessionId") != m.end() && !m["OriginalSessionId"].empty()) {
      originalSessionId = make_shared<string>(boost::any_cast<string>(m["OriginalSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunSearchGenerationRequest() = default;
};
class RunSearchGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentContextShrink{};
  shared_ptr<string> chatConfigShrink{};
  shared_ptr<string> modelId{};
  shared_ptr<string> originalSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunSearchGenerationShrinkRequest() {}

  explicit RunSearchGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentContextShrink) {
      res["AgentContext"] = boost::any(*agentContextShrink);
    }
    if (chatConfigShrink) {
      res["ChatConfig"] = boost::any(*chatConfigShrink);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (originalSessionId) {
      res["OriginalSessionId"] = boost::any(*originalSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentContext") != m.end() && !m["AgentContext"].empty()) {
      agentContextShrink = make_shared<string>(boost::any_cast<string>(m["AgentContext"]));
    }
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      chatConfigShrink = make_shared<string>(boost::any_cast<string>(m["ChatConfig"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("OriginalSessionId") != m.end() && !m["OriginalSessionId"].empty()) {
      originalSessionId = make_shared<string>(boost::any_cast<string>(m["OriginalSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunSearchGenerationShrinkRequest() = default;
};
class RunSearchGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> originSessionId{};
  shared_ptr<long> responseTime{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunSearchGenerationResponseBodyHeader() {}

  explicit RunSearchGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (responseTime) {
      res["ResponseTime"] = boost::any(*responseTime);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("ResponseTime") != m.end() && !m["ResponseTime"].empty()) {
      responseTime = make_shared<long>(boost::any_cast<long>(m["ResponseTime"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyHeader() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle> article{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResultArticle>(model1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult>> searchResult{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResultSearchResult>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias>> multimodalMedias{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (multimodalMedias) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMedias){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMedias"] = boost::any(temp1);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("MultimodalMedias") != m.end() && !m["MultimodalMedias"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMedias"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMedias"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMedias = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResultMultimodalMedias>>(expect1);
      }
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult>> searchResult{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResultSearchResult>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<string> text{};
  shared_ptr<double> to{};
  shared_ptr<string> type{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle> article{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos>> clipInfos{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfos"] = boost::any(temp1);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultArticle>(model1);
      }
    }
    if (m.find("ClipInfos") != m.end() && !m["ClipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfos"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfos = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResultClipInfos>>(expect1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult>> searchResult{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResultSearchResult>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult> imageSearchResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult> textSearchResult{};
  shared_ptr<string> topic{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult> videoSearchResult{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageSearchResult) {
      res["ImageSearchResult"] = imageSearchResult ? boost::any(imageSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textSearchResult) {
      res["TextSearchResult"] = textSearchResult ? boost::any(textSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (videoSearchResult) {
      res["VideoSearchResult"] = videoSearchResult ? boost::any(videoSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageSearchResult") != m.end() && !m["ImageSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageSearchResult"]));
        imageSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsImageSearchResult>(model1);
      }
    }
    if (m.find("TextSearchResult") != m.end() && !m["TextSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextSearchResult"]));
        textSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsTextSearchResult>(model1);
      }
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("VideoSearchResult") != m.end() && !m["VideoSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSearchResult"]));
        videoSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopicsVideoSearchResult>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics>> clusterTopics{};
  shared_ptr<bool> generateFinished{};
  shared_ptr<string> textGenerate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTopics) {
      vector<boost::any> temp1;
      for(auto item1:*clusterTopics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClusterTopics"] = boost::any(temp1);
    }
    if (generateFinished) {
      res["GenerateFinished"] = boost::any(*generateFinished);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTopics") != m.end() && !m["ClusterTopics"].empty()) {
      if (typeid(vector<boost::any>) == m["ClusterTopics"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClusterTopics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusterTopics = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResultClusterTopics>>(expect1);
      }
    }
    if (m.find("GenerateFinished") != m.end() && !m["GenerateFinished"].empty()) {
      generateFinished = make_shared<bool>(boost::any_cast<bool>(m["GenerateFinished"]));
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias : public Darabonba::Model {
public:
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle> article{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaListArticle>(model1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<string> docUuid{};
  shared_ptr<long> end{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList>> multimodalMediaList{};
  shared_ptr<long> start{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (multimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMediaList"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("MultimodalMediaList") != m.end() && !m["MultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaListMultimodalMediaList>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> chunks{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> excerpt{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias>> multimodalMedias{};
  shared_ptr<string> pubTime{};
  shared_ptr<double> score{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<bool> select{};
  shared_ptr<string> summary{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList>> textGenerateMultimodalMediaList{};
  shared_ptr<string> title{};
  shared_ptr<long> traceabilityId{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chunks) {
      res["Chunks"] = boost::any(*chunks);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (excerpt) {
      res["Excerpt"] = boost::any(*excerpt);
    }
    if (multimodalMedias) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMedias){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMedias"] = boost::any(temp1);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textGenerateMultimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*textGenerateMultimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextGenerateMultimodalMediaList"] = boost::any(temp1);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (traceabilityId) {
      res["TraceabilityId"] = boost::any(*traceabilityId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chunks") != m.end() && !m["Chunks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Chunks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Chunks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      chunks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Excerpt") != m.end() && !m["Excerpt"].empty()) {
      excerpt = make_shared<string>(boost::any_cast<string>(m["Excerpt"]));
    }
    if (m.find("MultimodalMedias") != m.end() && !m["MultimodalMedias"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMedias"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMedias"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMedias = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultMultimodalMedias>>(expect1);
      }
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<bool>(boost::any_cast<bool>(m["Select"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextGenerateMultimodalMediaList") != m.end() && !m["TextGenerateMultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["TextGenerateMultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextGenerateMultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textGenerateMultimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResultTextGenerateMultimodalMediaList>>(expect1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TraceabilityId") != m.end() && !m["TraceabilityId"].empty()) {
      traceabilityId = make_shared<long>(boost::any_cast<long>(m["TraceabilityId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult : public Darabonba::Model {
public:
  shared_ptr<bool> generateFinished{};
  shared_ptr<string> generateLevel{};
  shared_ptr<string> reasonTextGenerate{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult>> searchResult{};
  shared_ptr<string> textGenerate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateFinished) {
      res["GenerateFinished"] = boost::any(*generateFinished);
    }
    if (generateLevel) {
      res["GenerateLevel"] = boost::any(*generateLevel);
    }
    if (reasonTextGenerate) {
      res["ReasonTextGenerate"] = boost::any(*reasonTextGenerate);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateFinished") != m.end() && !m["GenerateFinished"].empty()) {
      generateFinished = make_shared<bool>(boost::any_cast<bool>(m["GenerateFinished"]));
    }
    if (m.find("GenerateLevel") != m.end() && !m["GenerateLevel"].empty()) {
      generateLevel = make_shared<string>(boost::any_cast<string>(m["GenerateLevel"]));
    }
    if (m.find("ReasonTextGenerate") != m.end() && !m["ReasonTextGenerate"].empty()) {
      reasonTextGenerate = make_shared<string>(boost::any_cast<string>(m["ReasonTextGenerate"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResultSearchResult>>(expect1);
      }
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle> article{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResultArticle>(model1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult>> searchResult{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResultSearchResult>>(expect1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<double> score{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<bool> select{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<bool>(boost::any_cast<bool>(m["Select"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent : public Darabonba::Model {
public:
  shared_ptr<vector<string>> causeList{};
  shared_ptr<vector<string>> processList{};
  shared_ptr<vector<string>> resultList{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (causeList) {
      res["CauseList"] = boost::any(*causeList);
    }
    if (processList) {
      res["ProcessList"] = boost::any(*processList);
    }
    if (resultList) {
      res["ResultList"] = boost::any(*resultList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CauseList") != m.end() && !m["CauseList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CauseList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CauseList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      causeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProcessList") != m.end() && !m["ProcessList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProcessList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProcessList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      processList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResultList") != m.end() && !m["ResultList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResultList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResultList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resultList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent> event{};
  shared_ptr<string> location{};
  shared_ptr<string> people{};
  shared_ptr<string> time{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = event ? boost::any(event->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (people) {
      res["People"] = boost::any(*people);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      if (typeid(map<string, boost::any>) == m["Event"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Event"]));
        event = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementListEvent>(model1);
      }
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("People") != m.end() && !m["People"].empty()) {
      people = make_shared<string>(boost::any_cast<string>(m["People"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle> article{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList>> newsElementList{};
  shared_ptr<string> textGenerate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (newsElementList) {
      vector<boost::any> temp1;
      for(auto item1:*newsElementList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NewsElementList"] = boost::any(temp1);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListArticle>(model1);
      }
    }
    if (m.find("NewsElementList") != m.end() && !m["NewsElementList"].empty()) {
      if (typeid(vector<boost::any>) == m["NewsElementList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NewsElementList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newsElementList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleListNewsElementList>>(expect1);
      }
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult : public Darabonba::Model {
public:
  shared_ptr<bool> generateFinished{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList>> newsElementArticleList{};
  shared_ptr<string> textGenerate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateFinished) {
      res["GenerateFinished"] = boost::any(*generateFinished);
    }
    if (newsElementArticleList) {
      vector<boost::any> temp1;
      for(auto item1:*newsElementArticleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NewsElementArticleList"] = boost::any(temp1);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateFinished") != m.end() && !m["GenerateFinished"].empty()) {
      generateFinished = make_shared<bool>(boost::any_cast<bool>(m["GenerateFinished"]));
    }
    if (m.find("NewsElementArticleList") != m.end() && !m["NewsElementArticleList"].empty()) {
      if (typeid(vector<boost::any>) == m["NewsElementArticleList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NewsElementArticleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newsElementArticleList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResultNewsElementArticleList>>(expect1);
      }
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};
  shared_ptr<long> z{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (z) {
      res["Z"] = boost::any(*z);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
    if (m.find("Z") != m.end() && !m["Z"].empty()) {
      z = make_shared<long>(boost::any_cast<long>(m["Z"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};
  shared_ptr<long> z{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (z) {
      res["Z"] = boost::any(*z);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
    if (m.find("Z") != m.end() && !m["Z"].empty()) {
      z = make_shared<long>(boost::any_cast<long>(m["Z"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate> generateCoordinate{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate> newsCoordinate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateCoordinate) {
      res["GenerateCoordinate"] = generateCoordinate ? boost::any(generateCoordinate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (newsCoordinate) {
      res["NewsCoordinate"] = newsCoordinate ? boost::any(newsCoordinate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateCoordinate") != m.end() && !m["GenerateCoordinate"].empty()) {
      if (typeid(map<string, boost::any>) == m["GenerateCoordinate"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GenerateCoordinate"]));
        generateCoordinate = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesGenerateCoordinate>(model1);
      }
    }
    if (m.find("NewsCoordinate") != m.end() && !m["NewsCoordinate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NewsCoordinate"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NewsCoordinate"]));
        newsCoordinate = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinatesNewsCoordinate>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates>> coordinates{};
  shared_ptr<double> duplicate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coordinates) {
      vector<boost::any> temp1;
      for(auto item1:*coordinates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Coordinates"] = boost::any(temp1);
    }
    if (duplicate) {
      res["Duplicate"] = boost::any(*duplicate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coordinates") != m.end() && !m["Coordinates"].empty()) {
      if (typeid(vector<boost::any>) == m["Coordinates"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Coordinates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coordinates = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceabilityCoordinates>>(expect1);
      }
    }
    if (m.find("Duplicate") != m.end() && !m["Duplicate"].empty()) {
      duplicate = make_shared<double>(boost::any_cast<double>(m["Duplicate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<string> text{};
  shared_ptr<double> to{};
  shared_ptr<string> type{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle> article{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos>> clipInfos{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfos"] = boost::any(temp1);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultArticle>(model1);
      }
    }
    if (m.find("ClipInfos") != m.end() && !m["ClipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfos"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfos = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResultClipInfos>>(expect1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<string> searchQuery{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult>> searchResult{};
  shared_ptr<string> searchType{};
  shared_ptr<long> size{};
  shared_ptr<string> timelineDateStr{};
  shared_ptr<long> total{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (searchQuery) {
      res["SearchQuery"] = boost::any(*searchQuery);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (searchType) {
      res["SearchType"] = boost::any(*searchType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (timelineDateStr) {
      res["TimelineDateStr"] = boost::any(*timelineDateStr);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("SearchQuery") != m.end() && !m["SearchQuery"].empty()) {
      searchQuery = make_shared<string>(boost::any_cast<string>(m["SearchQuery"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultListSearchResult>>(expect1);
      }
    }
    if (m.find("SearchType") != m.end() && !m["SearchType"].empty()) {
      searchType = make_shared<string>(boost::any_cast<string>(m["SearchType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TimelineDateStr") != m.end() && !m["TimelineDateStr"].empty()) {
      timelineDateStr = make_shared<string>(boost::any_cast<string>(m["TimelineDateStr"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> chunks{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<double> score{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<bool> select{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<long> traceabilityId{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chunks) {
      res["Chunks"] = boost::any(*chunks);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (traceabilityId) {
      res["TraceabilityId"] = boost::any(*traceabilityId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chunks") != m.end() && !m["Chunks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Chunks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Chunks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      chunks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<bool>(boost::any_cast<bool>(m["Select"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TraceabilityId") != m.end() && !m["TraceabilityId"].empty()) {
      traceabilityId = make_shared<long>(boost::any_cast<long>(m["TraceabilityId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle> article{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaListArticle>(model1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList>> multimodalMediaList{};
  shared_ptr<long> start{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (multimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMediaList"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("MultimodalMediaList") != m.end() && !m["MultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaListMultimodalMediaList>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult : public Darabonba::Model {
public:
  shared_ptr<bool> generateFinished{};
  shared_ptr<string> generateLevel{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability> generateTraceability{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList>> multimodalSearchResultList{};
  shared_ptr<string> reasonTextGenerate{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList>> referenceList{};
  shared_ptr<string> textGenerate{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList>> textGenerateMultimodalMediaList{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateFinished) {
      res["GenerateFinished"] = boost::any(*generateFinished);
    }
    if (generateLevel) {
      res["GenerateLevel"] = boost::any(*generateLevel);
    }
    if (generateTraceability) {
      res["GenerateTraceability"] = generateTraceability ? boost::any(generateTraceability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (multimodalSearchResultList) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalSearchResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalSearchResultList"] = boost::any(temp1);
    }
    if (reasonTextGenerate) {
      res["ReasonTextGenerate"] = boost::any(*reasonTextGenerate);
    }
    if (referenceList) {
      vector<boost::any> temp1;
      for(auto item1:*referenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceList"] = boost::any(temp1);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    if (textGenerateMultimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*textGenerateMultimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextGenerateMultimodalMediaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateFinished") != m.end() && !m["GenerateFinished"].empty()) {
      generateFinished = make_shared<bool>(boost::any_cast<bool>(m["GenerateFinished"]));
    }
    if (m.find("GenerateLevel") != m.end() && !m["GenerateLevel"].empty()) {
      generateLevel = make_shared<string>(boost::any_cast<string>(m["GenerateLevel"]));
    }
    if (m.find("GenerateTraceability") != m.end() && !m["GenerateTraceability"].empty()) {
      if (typeid(map<string, boost::any>) == m["GenerateTraceability"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GenerateTraceability"]));
        generateTraceability = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultGenerateTraceability>(model1);
      }
    }
    if (m.find("MultimodalSearchResultList") != m.end() && !m["MultimodalSearchResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalSearchResultList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalSearchResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalSearchResultList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultMultimodalSearchResultList>>(expect1);
      }
    }
    if (m.find("ReasonTextGenerate") != m.end() && !m["ReasonTextGenerate"].empty()) {
      reasonTextGenerate = make_shared<string>(boost::any_cast<string>(m["ReasonTextGenerate"]));
    }
    if (m.find("ReferenceList") != m.end() && !m["ReferenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultReferenceList>>(expect1);
      }
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
    if (m.find("TextGenerateMultimodalMediaList") != m.end() && !m["TextGenerateMultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["TextGenerateMultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextGenerateMultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textGenerateMultimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResultTextGenerateMultimodalMediaList>>(expect1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult>> searchResult{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResultSearchResult>>(expect1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};
  shared_ptr<long> z{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (z) {
      res["Z"] = boost::any(*z);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
    if (m.find("Z") != m.end() && !m["Z"].empty()) {
      z = make_shared<long>(boost::any_cast<long>(m["Z"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};
  shared_ptr<long> z{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    if (z) {
      res["Z"] = boost::any(*z);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
    if (m.find("Z") != m.end() && !m["Z"].empty()) {
      z = make_shared<long>(boost::any_cast<long>(m["Z"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate> generateCoordinate{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate> newsCoordinate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateCoordinate) {
      res["GenerateCoordinate"] = generateCoordinate ? boost::any(generateCoordinate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (newsCoordinate) {
      res["NewsCoordinate"] = newsCoordinate ? boost::any(newsCoordinate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateCoordinate") != m.end() && !m["GenerateCoordinate"].empty()) {
      if (typeid(map<string, boost::any>) == m["GenerateCoordinate"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GenerateCoordinate"]));
        generateCoordinate = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesGenerateCoordinate>(model1);
      }
    }
    if (m.find("NewsCoordinate") != m.end() && !m["NewsCoordinate"].empty()) {
      if (typeid(map<string, boost::any>) == m["NewsCoordinate"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NewsCoordinate"]));
        newsCoordinate = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinatesNewsCoordinate>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates>> coordinates{};
  shared_ptr<double> duplicate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coordinates) {
      vector<boost::any> temp1;
      for(auto item1:*coordinates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Coordinates"] = boost::any(temp1);
    }
    if (duplicate) {
      res["Duplicate"] = boost::any(*duplicate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Coordinates") != m.end() && !m["Coordinates"].empty()) {
      if (typeid(vector<boost::any>) == m["Coordinates"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Coordinates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coordinates = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceabilityCoordinates>>(expect1);
      }
    }
    if (m.find("Duplicate") != m.end() && !m["Duplicate"].empty()) {
      duplicate = make_shared<double>(boost::any_cast<double>(m["Duplicate"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<string> text{};
  shared_ptr<double> to{};
  shared_ptr<string> type{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle> article{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos>> clipInfos{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfos"] = boost::any(temp1);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultArticle>(model1);
      }
    }
    if (m.find("ClipInfos") != m.end() && !m["ClipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfos"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfos = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResultClipInfos>>(expect1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult>> searchResult{};
  shared_ptr<string> timelineDateStr{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    if (timelineDateStr) {
      res["TimelineDateStr"] = boost::any(*timelineDateStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultListSearchResult>>(expect1);
      }
    }
    if (m.find("TimelineDateStr") != m.end() && !m["TimelineDateStr"].empty()) {
      timelineDateStr = make_shared<string>(boost::any_cast<string>(m["TimelineDateStr"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> chunks{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<double> score{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> searchSourceType{};
  shared_ptr<bool> select{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<long> traceabilityId{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chunks) {
      res["Chunks"] = boost::any(*chunks);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (searchSourceType) {
      res["SearchSourceType"] = boost::any(*searchSourceType);
    }
    if (select) {
      res["Select"] = boost::any(*select);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (traceabilityId) {
      res["TraceabilityId"] = boost::any(*traceabilityId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chunks") != m.end() && !m["Chunks"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Chunks"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Chunks"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      chunks = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("SearchSourceType") != m.end() && !m["SearchSourceType"].empty()) {
      searchSourceType = make_shared<string>(boost::any_cast<string>(m["SearchSourceType"]));
    }
    if (m.find("Select") != m.end() && !m["Select"].empty()) {
      select = make_shared<bool>(boost::any_cast<bool>(m["Select"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TraceabilityId") != m.end() && !m["TraceabilityId"].empty()) {
      traceabilityId = make_shared<long>(boost::any_cast<long>(m["TraceabilityId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle> article{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};
  shared_ptr<string> mediaType{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaListArticle>(model1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList : public Darabonba::Model {
public:
  shared_ptr<long> end{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList>> multimodalMediaList{};
  shared_ptr<long> start{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (multimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalMediaList"] = boost::any(temp1);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("MultimodalMediaList") != m.end() && !m["MultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaListMultimodalMediaList>>(expect1);
      }
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult : public Darabonba::Model {
public:
  shared_ptr<bool> generateFinished{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability> generateTraceability{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList>> multimodalSearchResultList{};
  shared_ptr<string> reasonTextGenerate{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList>> referenceList{};
  shared_ptr<string> textGenerate{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList>> textGenerateMultimodalMediaList{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (generateFinished) {
      res["GenerateFinished"] = boost::any(*generateFinished);
    }
    if (generateTraceability) {
      res["GenerateTraceability"] = generateTraceability ? boost::any(generateTraceability->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (multimodalSearchResultList) {
      vector<boost::any> temp1;
      for(auto item1:*multimodalSearchResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MultimodalSearchResultList"] = boost::any(temp1);
    }
    if (reasonTextGenerate) {
      res["ReasonTextGenerate"] = boost::any(*reasonTextGenerate);
    }
    if (referenceList) {
      vector<boost::any> temp1;
      for(auto item1:*referenceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReferenceList"] = boost::any(temp1);
    }
    if (textGenerate) {
      res["TextGenerate"] = boost::any(*textGenerate);
    }
    if (textGenerateMultimodalMediaList) {
      vector<boost::any> temp1;
      for(auto item1:*textGenerateMultimodalMediaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TextGenerateMultimodalMediaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenerateFinished") != m.end() && !m["GenerateFinished"].empty()) {
      generateFinished = make_shared<bool>(boost::any_cast<bool>(m["GenerateFinished"]));
    }
    if (m.find("GenerateTraceability") != m.end() && !m["GenerateTraceability"].empty()) {
      if (typeid(map<string, boost::any>) == m["GenerateTraceability"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GenerateTraceability"]));
        generateTraceability = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultGenerateTraceability>(model1);
      }
    }
    if (m.find("MultimodalSearchResultList") != m.end() && !m["MultimodalSearchResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["MultimodalSearchResultList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MultimodalSearchResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        multimodalSearchResultList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultMultimodalSearchResultList>>(expect1);
      }
    }
    if (m.find("ReasonTextGenerate") != m.end() && !m["ReasonTextGenerate"].empty()) {
      reasonTextGenerate = make_shared<string>(boost::any_cast<string>(m["ReasonTextGenerate"]));
    }
    if (m.find("ReferenceList") != m.end() && !m["ReferenceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReferenceList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReferenceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        referenceList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultReferenceList>>(expect1);
      }
    }
    if (m.find("TextGenerate") != m.end() && !m["TextGenerate"].empty()) {
      textGenerate = make_shared<string>(boost::any_cast<string>(m["TextGenerate"]));
    }
    if (m.find("TextGenerateMultimodalMediaList") != m.end() && !m["TextGenerateMultimodalMediaList"].empty()) {
      if (typeid(vector<boost::any>) == m["TextGenerateMultimodalMediaList"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TextGenerateMultimodalMediaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        textGenerateMultimodalMediaList = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResultTextGenerateMultimodalMediaList>>(expect1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos : public Darabonba::Model {
public:
  shared_ptr<double> from{};
  shared_ptr<double> score{};
  shared_ptr<string> text{};
  shared_ptr<double> to{};
  shared_ptr<string> type{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<double>(boost::any_cast<double>(m["From"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<double>(boost::any_cast<double>(m["To"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle> article{};
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos>> clipInfos{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> mediaId{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (article) {
      res["Article"] = article ? boost::any(article->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clipInfos) {
      vector<boost::any> temp1;
      for(auto item1:*clipInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClipInfos"] = boost::any(temp1);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (mediaId) {
      res["MediaId"] = boost::any(*mediaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Article") != m.end() && !m["Article"].empty()) {
      if (typeid(map<string, boost::any>) == m["Article"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Article"]));
        article = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultArticle>(model1);
      }
    }
    if (m.find("ClipInfos") != m.end() && !m["ClipInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ClipInfos"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClipInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clipInfos = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResultClipInfos>>(expect1);
      }
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("MediaId") != m.end() && !m["MediaId"].empty()) {
      mediaId = make_shared<string>(boost::any_cast<string>(m["MediaId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult>> searchResult{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchResult) {
      vector<boost::any> temp1;
      for(auto item1:*searchResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchResult") != m.end() && !m["SearchResult"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchResult"].type()) {
        vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchResult = make_shared<vector<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResultSearchResult>>(expect1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult> clusterTopicResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult> excerptResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult> imageSearchResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult> newsElementResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult> textGenerateResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult> textSearchResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult> timelineResult{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult> videoSearchResult{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterTopicResult) {
      res["ClusterTopicResult"] = clusterTopicResult ? boost::any(clusterTopicResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (excerptResult) {
      res["ExcerptResult"] = excerptResult ? boost::any(excerptResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageSearchResult) {
      res["ImageSearchResult"] = imageSearchResult ? boost::any(imageSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (newsElementResult) {
      res["NewsElementResult"] = newsElementResult ? boost::any(newsElementResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textGenerateResult) {
      res["TextGenerateResult"] = textGenerateResult ? boost::any(textGenerateResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (textSearchResult) {
      res["TextSearchResult"] = textSearchResult ? boost::any(textSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timelineResult) {
      res["TimelineResult"] = timelineResult ? boost::any(timelineResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (videoSearchResult) {
      res["VideoSearchResult"] = videoSearchResult ? boost::any(videoSearchResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterTopicResult") != m.end() && !m["ClusterTopicResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClusterTopicResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClusterTopicResult"]));
        clusterTopicResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentClusterTopicResult>(model1);
      }
    }
    if (m.find("ExcerptResult") != m.end() && !m["ExcerptResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExcerptResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExcerptResult"]));
        excerptResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentExcerptResult>(model1);
      }
    }
    if (m.find("ImageSearchResult") != m.end() && !m["ImageSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageSearchResult"]));
        imageSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentImageSearchResult>(model1);
      }
    }
    if (m.find("NewsElementResult") != m.end() && !m["NewsElementResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["NewsElementResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NewsElementResult"]));
        newsElementResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentNewsElementResult>(model1);
      }
    }
    if (m.find("TextGenerateResult") != m.end() && !m["TextGenerateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextGenerateResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextGenerateResult"]));
        textGenerateResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextGenerateResult>(model1);
      }
    }
    if (m.find("TextSearchResult") != m.end() && !m["TextSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TextSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TextSearchResult"]));
        textSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTextSearchResult>(model1);
      }
    }
    if (m.find("TimelineResult") != m.end() && !m["TimelineResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimelineResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimelineResult"]));
        timelineResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentTimelineResult>(model1);
      }
    }
    if (m.find("VideoSearchResult") != m.end() && !m["VideoSearchResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["VideoSearchResult"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VideoSearchResult"]));
        videoSearchResult = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContentVideoSearchResult>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate : public Darabonba::Model {
public:
  shared_ptr<double> firstTokenTime{};
  shared_ptr<double> outputAvgTime{};
  shared_ptr<double> searchTime{};
  shared_ptr<double> time{};
  shared_ptr<long> totalTokens{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (firstTokenTime) {
      res["FirstTokenTime"] = boost::any(*firstTokenTime);
    }
    if (outputAvgTime) {
      res["OutputAvgTime"] = boost::any(*outputAvgTime);
    }
    if (searchTime) {
      res["SearchTime"] = boost::any(*searchTime);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FirstTokenTime") != m.end() && !m["FirstTokenTime"].empty()) {
      firstTokenTime = make_shared<double>(boost::any_cast<double>(m["FirstTokenTime"]));
    }
    if (m.find("OutputAvgTime") != m.end() && !m["OutputAvgTime"].empty()) {
      outputAvgTime = make_shared<double>(boost::any_cast<double>(m["OutputAvgTime"]));
    }
    if (m.find("SearchTime") != m.end() && !m["SearchTime"].empty()) {
      searchTime = make_shared<double>(boost::any_cast<double>(m["SearchTime"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<double>(boost::any_cast<double>(m["Time"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext : public Darabonba::Model {
public:
  shared_ptr<string> currentStep{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent> generatedContent{};
  shared_ptr<string> modelId{};
  shared_ptr<string> nextStep{};
  shared_ptr<vector<string>> recommendSearchQueryList{};
  shared_ptr<vector<string>> searchKeywords{};
  shared_ptr<vector<string>> searchQueryList{};
  shared_ptr<string> supplementDataType{};
  shared_ptr<bool> supplementEnable{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate> tokenCalculate{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentStep) {
      res["CurrentStep"] = boost::any(*currentStep);
    }
    if (generatedContent) {
      res["GeneratedContent"] = generatedContent ? boost::any(generatedContent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (nextStep) {
      res["NextStep"] = boost::any(*nextStep);
    }
    if (recommendSearchQueryList) {
      res["RecommendSearchQueryList"] = boost::any(*recommendSearchQueryList);
    }
    if (searchKeywords) {
      res["SearchKeywords"] = boost::any(*searchKeywords);
    }
    if (searchQueryList) {
      res["SearchQueryList"] = boost::any(*searchQueryList);
    }
    if (supplementDataType) {
      res["SupplementDataType"] = boost::any(*supplementDataType);
    }
    if (supplementEnable) {
      res["SupplementEnable"] = boost::any(*supplementEnable);
    }
    if (tokenCalculate) {
      res["TokenCalculate"] = tokenCalculate ? boost::any(tokenCalculate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CurrentStep") != m.end() && !m["CurrentStep"].empty()) {
      currentStep = make_shared<string>(boost::any_cast<string>(m["CurrentStep"]));
    }
    if (m.find("GeneratedContent") != m.end() && !m["GeneratedContent"].empty()) {
      if (typeid(map<string, boost::any>) == m["GeneratedContent"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GeneratedContent"]));
        generatedContent = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextGeneratedContent>(model1);
      }
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("NextStep") != m.end() && !m["NextStep"].empty()) {
      nextStep = make_shared<string>(boost::any_cast<string>(m["NextStep"]));
    }
    if (m.find("RecommendSearchQueryList") != m.end() && !m["RecommendSearchQueryList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecommendSearchQueryList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecommendSearchQueryList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recommendSearchQueryList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchKeywords") != m.end() && !m["SearchKeywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SearchKeywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SearchKeywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searchKeywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchQueryList") != m.end() && !m["SearchQueryList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SearchQueryList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SearchQueryList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searchQueryList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SupplementDataType") != m.end() && !m["SupplementDataType"].empty()) {
      supplementDataType = make_shared<string>(boost::any_cast<string>(m["SupplementDataType"]));
    }
    if (m.find("SupplementEnable") != m.end() && !m["SupplementEnable"].empty()) {
      supplementEnable = make_shared<bool>(boost::any_cast<bool>(m["SupplementEnable"]));
    }
    if (m.find("TokenCalculate") != m.end() && !m["TokenCalculate"].empty()) {
      if (typeid(map<string, boost::any>) == m["TokenCalculate"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TokenCalculate"]));
        tokenCalculate = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContextTokenCalculate>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext() = default;
};
class RunSearchGenerationResponseBodyPayloadOutputAgentContext : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext> bizContext{};

  RunSearchGenerationResponseBodyPayloadOutputAgentContext() {}

  explicit RunSearchGenerationResponseBodyPayloadOutputAgentContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizContext) {
      res["BizContext"] = bizContext ? boost::any(bizContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizContext") != m.end() && !m["BizContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizContext"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizContext"]));
        bizContext = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContextBizContext>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutputAgentContext() = default;
};
class RunSearchGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutputAgentContext> agentContext{};

  RunSearchGenerationResponseBodyPayloadOutput() {}

  explicit RunSearchGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentContext) {
      res["AgentContext"] = agentContext ? boost::any(agentContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentContext") != m.end() && !m["AgentContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["AgentContext"].type()) {
        RunSearchGenerationResponseBodyPayloadOutputAgentContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AgentContext"]));
        agentContext = make_shared<RunSearchGenerationResponseBodyPayloadOutputAgentContext>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadOutput() = default;
};
class RunSearchGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunSearchGenerationResponseBodyPayloadUsage() {}

  explicit RunSearchGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayloadUsage() = default;
};
class RunSearchGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunSearchGenerationResponseBodyPayloadUsage> usage{};

  RunSearchGenerationResponseBodyPayload() {}

  explicit RunSearchGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunSearchGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunSearchGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunSearchGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunSearchGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponseBodyPayload() = default;
};
class RunSearchGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunSearchGenerationResponseBodyHeader> header{};
  shared_ptr<RunSearchGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunSearchGenerationResponseBody() {}

  explicit RunSearchGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunSearchGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunSearchGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunSearchGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunSearchGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunSearchGenerationResponseBody() = default;
};
class RunSearchGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunSearchGenerationResponseBody> body{};

  RunSearchGenerationResponse() {}

  explicit RunSearchGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunSearchGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunSearchGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunSearchGenerationResponse() = default;
};
class RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> name{};

  RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources() {}

  explicit RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources() = default;
};
class RunSearchSimilarArticlesRequestChatConfigSearchParam : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources>> searchSources{};

  RunSearchSimilarArticlesRequestChatConfigSearchParam() {}

  explicit RunSearchSimilarArticlesRequestChatConfigSearchParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchSources) {
      vector<boost::any> temp1;
      for(auto item1:*searchSources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSources"].type()) {
        vector<RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSources = make_shared<vector<RunSearchSimilarArticlesRequestChatConfigSearchParamSearchSources>>(expect1);
      }
    }
  }


  virtual ~RunSearchSimilarArticlesRequestChatConfigSearchParam() = default;
};
class RunSearchSimilarArticlesRequestChatConfig : public Darabonba::Model {
public:
  shared_ptr<RunSearchSimilarArticlesRequestChatConfigSearchParam> searchParam{};

  RunSearchSimilarArticlesRequestChatConfig() {}

  explicit RunSearchSimilarArticlesRequestChatConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchParam) {
      res["SearchParam"] = searchParam ? boost::any(searchParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchParam") != m.end() && !m["SearchParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchParam"].type()) {
        RunSearchSimilarArticlesRequestChatConfigSearchParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchParam"]));
        searchParam = make_shared<RunSearchSimilarArticlesRequestChatConfigSearchParam>(model1);
      }
    }
  }


  virtual ~RunSearchSimilarArticlesRequestChatConfig() = default;
};
class RunSearchSimilarArticlesRequest : public Darabonba::Model {
public:
  shared_ptr<RunSearchSimilarArticlesRequestChatConfig> chatConfig{};
  shared_ptr<string> docType{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  RunSearchSimilarArticlesRequest() {}

  explicit RunSearchSimilarArticlesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatConfig) {
      res["ChatConfig"] = chatConfig ? boost::any(chatConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChatConfig"].type()) {
        RunSearchSimilarArticlesRequestChatConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChatConfig"]));
        chatConfig = make_shared<RunSearchSimilarArticlesRequestChatConfig>(model1);
      }
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunSearchSimilarArticlesRequest() = default;
};
class RunSearchSimilarArticlesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> chatConfigShrink{};
  shared_ptr<string> docType{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};
  shared_ptr<string> workspaceId{};

  RunSearchSimilarArticlesShrinkRequest() {}

  explicit RunSearchSimilarArticlesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chatConfigShrink) {
      res["ChatConfig"] = boost::any(*chatConfigShrink);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChatConfig") != m.end() && !m["ChatConfig"].empty()) {
      chatConfigShrink = make_shared<string>(boost::any_cast<string>(m["ChatConfig"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunSearchSimilarArticlesShrinkRequest() = default;
};
class RunSearchSimilarArticlesResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};

  RunSearchSimilarArticlesResponseBodyHeader() {}

  explicit RunSearchSimilarArticlesResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBodyHeader() = default;
};
class RunSearchSimilarArticlesResponseBodyPayloadOutputArticles : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunSearchSimilarArticlesResponseBodyPayloadOutputArticles() {}

  explicit RunSearchSimilarArticlesResponseBodyPayloadOutputArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBodyPayloadOutputArticles() = default;
};
class RunSearchSimilarArticlesResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunSearchSimilarArticlesResponseBodyPayloadOutputArticles>> articles{};
  shared_ptr<string> text{};

  RunSearchSimilarArticlesResponseBodyPayloadOutput() {}

  explicit RunSearchSimilarArticlesResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunSearchSimilarArticlesResponseBodyPayloadOutputArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunSearchSimilarArticlesResponseBodyPayloadOutputArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunSearchSimilarArticlesResponseBodyPayloadOutputArticles>>(expect1);
      }
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBodyPayloadOutput() = default;
};
class RunSearchSimilarArticlesResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunSearchSimilarArticlesResponseBodyPayloadUsage() {}

  explicit RunSearchSimilarArticlesResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBodyPayloadUsage() = default;
};
class RunSearchSimilarArticlesResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunSearchSimilarArticlesResponseBodyPayloadOutput> output{};
  shared_ptr<RunSearchSimilarArticlesResponseBodyPayloadUsage> usage{};

  RunSearchSimilarArticlesResponseBodyPayload() {}

  explicit RunSearchSimilarArticlesResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunSearchSimilarArticlesResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunSearchSimilarArticlesResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunSearchSimilarArticlesResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunSearchSimilarArticlesResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBodyPayload() = default;
};
class RunSearchSimilarArticlesResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunSearchSimilarArticlesResponseBodyHeader> header{};
  shared_ptr<RunSearchSimilarArticlesResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunSearchSimilarArticlesResponseBody() {}

  explicit RunSearchSimilarArticlesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunSearchSimilarArticlesResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunSearchSimilarArticlesResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunSearchSimilarArticlesResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunSearchSimilarArticlesResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunSearchSimilarArticlesResponseBody() = default;
};
class RunSearchSimilarArticlesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunSearchSimilarArticlesResponseBody> body{};

  RunSearchSimilarArticlesResponse() {}

  explicit RunSearchSimilarArticlesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunSearchSimilarArticlesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunSearchSimilarArticlesResponseBody>(model1);
      }
    }
  }


  virtual ~RunSearchSimilarArticlesResponse() = default;
};
class RunStepByStepWritingRequestReferenceDataArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> mediaUrl{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunStepByStepWritingRequestReferenceDataArticles() {}

  explicit RunStepByStepWritingRequestReferenceDataArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (mediaUrl) {
      res["MediaUrl"] = boost::any(*mediaUrl);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("MediaUrl") != m.end() && !m["MediaUrl"].empty()) {
      mediaUrl = make_shared<string>(boost::any_cast<string>(m["MediaUrl"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunStepByStepWritingRequestReferenceDataArticles() = default;
};
class RunStepByStepWritingRequestReferenceDataOutlinesArticles : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunStepByStepWritingRequestReferenceDataOutlinesArticles() {}

  explicit RunStepByStepWritingRequestReferenceDataOutlinesArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunStepByStepWritingRequestReferenceDataOutlinesArticles() = default;
};
class RunStepByStepWritingRequestReferenceDataOutlines : public Darabonba::Model {
public:
  shared_ptr<vector<RunStepByStepWritingRequestReferenceDataOutlinesArticles>> articles{};
  shared_ptr<string> outline{};

  RunStepByStepWritingRequestReferenceDataOutlines() {}

  explicit RunStepByStepWritingRequestReferenceDataOutlines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (outline) {
      res["Outline"] = boost::any(*outline);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunStepByStepWritingRequestReferenceDataOutlinesArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunStepByStepWritingRequestReferenceDataOutlinesArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunStepByStepWritingRequestReferenceDataOutlinesArticles>>(expect1);
      }
    }
    if (m.find("Outline") != m.end() && !m["Outline"].empty()) {
      outline = make_shared<string>(boost::any_cast<string>(m["Outline"]));
    }
  }


  virtual ~RunStepByStepWritingRequestReferenceDataOutlines() = default;
};
class RunStepByStepWritingRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<RunStepByStepWritingRequestReferenceDataArticles>> articles{};
  shared_ptr<vector<string>> miniDoc{};
  shared_ptr<vector<RunStepByStepWritingRequestReferenceDataOutlines>> outlines{};
  shared_ptr<vector<string>> summarization{};

  RunStepByStepWritingRequestReferenceData() {}

  explicit RunStepByStepWritingRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (miniDoc) {
      res["MiniDoc"] = boost::any(*miniDoc);
    }
    if (outlines) {
      vector<boost::any> temp1;
      for(auto item1:*outlines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outlines"] = boost::any(temp1);
    }
    if (summarization) {
      res["Summarization"] = boost::any(*summarization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunStepByStepWritingRequestReferenceDataArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunStepByStepWritingRequestReferenceDataArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunStepByStepWritingRequestReferenceDataArticles>>(expect1);
      }
    }
    if (m.find("MiniDoc") != m.end() && !m["MiniDoc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MiniDoc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MiniDoc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      miniDoc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Outlines") != m.end() && !m["Outlines"].empty()) {
      if (typeid(vector<boost::any>) == m["Outlines"].type()) {
        vector<RunStepByStepWritingRequestReferenceDataOutlines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outlines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunStepByStepWritingRequestReferenceDataOutlines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outlines = make_shared<vector<RunStepByStepWritingRequestReferenceDataOutlines>>(expect1);
      }
    }
    if (m.find("Summarization") != m.end() && !m["Summarization"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Summarization"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Summarization"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      summarization = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunStepByStepWritingRequestReferenceData() = default;
};
class RunStepByStepWritingRequestWritingConfigPromptTag : public Darabonba::Model {
public:
  shared_ptr<string> necessaryTips{};
  shared_ptr<string> position{};
  shared_ptr<string> reverseWords{};
  shared_ptr<string> theme{};

  RunStepByStepWritingRequestWritingConfigPromptTag() {}

  explicit RunStepByStepWritingRequestWritingConfigPromptTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (necessaryTips) {
      res["NecessaryTips"] = boost::any(*necessaryTips);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (reverseWords) {
      res["ReverseWords"] = boost::any(*reverseWords);
    }
    if (theme) {
      res["Theme"] = boost::any(*theme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NecessaryTips") != m.end() && !m["NecessaryTips"].empty()) {
      necessaryTips = make_shared<string>(boost::any_cast<string>(m["NecessaryTips"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("ReverseWords") != m.end() && !m["ReverseWords"].empty()) {
      reverseWords = make_shared<string>(boost::any_cast<string>(m["ReverseWords"]));
    }
    if (m.find("Theme") != m.end() && !m["Theme"].empty()) {
      theme = make_shared<string>(boost::any_cast<string>(m["Theme"]));
    }
  }


  virtual ~RunStepByStepWritingRequestWritingConfigPromptTag() = default;
};
class RunStepByStepWritingRequestWritingConfigTags : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> tag{};

  RunStepByStepWritingRequestWritingConfigTags() {}

  explicit RunStepByStepWritingRequestWritingConfigTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~RunStepByStepWritingRequestWritingConfigTags() = default;
};
class RunStepByStepWritingRequestWritingConfig : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<RunStepByStepWritingRequestWritingConfigPromptTag> promptTag{};
  shared_ptr<string> scene{};
  shared_ptr<string> step{};
  shared_ptr<string> summaryReturnType{};
  shared_ptr<vector<RunStepByStepWritingRequestWritingConfigTags>> tags{};
  shared_ptr<bool> useSearch{};

  RunStepByStepWritingRequestWritingConfig() {}

  explicit RunStepByStepWritingRequestWritingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (promptTag) {
      res["PromptTag"] = promptTag ? boost::any(promptTag->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scene) {
      res["Scene"] = boost::any(*scene);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    if (summaryReturnType) {
      res["SummaryReturnType"] = boost::any(*summaryReturnType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (useSearch) {
      res["UseSearch"] = boost::any(*useSearch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PromptTag") != m.end() && !m["PromptTag"].empty()) {
      if (typeid(map<string, boost::any>) == m["PromptTag"].type()) {
        RunStepByStepWritingRequestWritingConfigPromptTag model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PromptTag"]));
        promptTag = make_shared<RunStepByStepWritingRequestWritingConfigPromptTag>(model1);
      }
    }
    if (m.find("Scene") != m.end() && !m["Scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["Scene"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<string>(boost::any_cast<string>(m["Step"]));
    }
    if (m.find("SummaryReturnType") != m.end() && !m["SummaryReturnType"].empty()) {
      summaryReturnType = make_shared<string>(boost::any_cast<string>(m["SummaryReturnType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<RunStepByStepWritingRequestWritingConfigTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunStepByStepWritingRequestWritingConfigTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<RunStepByStepWritingRequestWritingConfigTags>>(expect1);
      }
    }
    if (m.find("UseSearch") != m.end() && !m["UseSearch"].empty()) {
      useSearch = make_shared<bool>(boost::any_cast<bool>(m["UseSearch"]));
    }
  }


  virtual ~RunStepByStepWritingRequestWritingConfig() = default;
};
class RunStepByStepWritingRequest : public Darabonba::Model {
public:
  shared_ptr<string> originSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<RunStepByStepWritingRequestReferenceData> referenceData{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};
  shared_ptr<RunStepByStepWritingRequestWritingConfig> writingConfig{};

  RunStepByStepWritingRequest() {}

  explicit RunStepByStepWritingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (writingConfig) {
      res["WritingConfig"] = writingConfig ? boost::any(writingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunStepByStepWritingRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunStepByStepWritingRequestReferenceData>(model1);
      }
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("WritingConfig") != m.end() && !m["WritingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WritingConfig"].type()) {
        RunStepByStepWritingRequestWritingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WritingConfig"]));
        writingConfig = make_shared<RunStepByStepWritingRequestWritingConfig>(model1);
      }
    }
  }


  virtual ~RunStepByStepWritingRequest() = default;
};
class RunStepByStepWritingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> originSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> writingConfigShrink{};

  RunStepByStepWritingShrinkRequest() {}

  explicit RunStepByStepWritingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (writingConfigShrink) {
      res["WritingConfig"] = boost::any(*writingConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("WritingConfig") != m.end() && !m["WritingConfig"].empty()) {
      writingConfigShrink = make_shared<string>(boost::any_cast<string>(m["WritingConfig"]));
    }
  }


  virtual ~RunStepByStepWritingShrinkRequest() = default;
};
class RunStepByStepWritingResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunStepByStepWritingResponseBodyHeader() {}

  explicit RunStepByStepWritingResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunStepByStepWritingResponseBodyHeader() = default;
};
class RunStepByStepWritingResponseBodyPayloadOutputArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> mediaUrl{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunStepByStepWritingResponseBodyPayloadOutputArticles() {}

  explicit RunStepByStepWritingResponseBodyPayloadOutputArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (mediaUrl) {
      res["MediaUrl"] = boost::any(*mediaUrl);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("MediaUrl") != m.end() && !m["MediaUrl"].empty()) {
      mediaUrl = make_shared<string>(boost::any_cast<string>(m["MediaUrl"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunStepByStepWritingResponseBodyPayloadOutputArticles() = default;
};
class RunStepByStepWritingResponseBodyPayloadOutputExtraOutput : public Darabonba::Model {
public:
  shared_ptr<vector<string>> summarization{};

  RunStepByStepWritingResponseBodyPayloadOutputExtraOutput() {}

  explicit RunStepByStepWritingResponseBodyPayloadOutputExtraOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summarization) {
      res["summarization"] = boost::any(*summarization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("summarization") != m.end() && !m["summarization"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["summarization"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["summarization"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      summarization = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunStepByStepWritingResponseBodyPayloadOutputExtraOutput() = default;
};
class RunStepByStepWritingResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunStepByStepWritingResponseBodyPayloadOutputArticles>> articles{};
  shared_ptr<RunStepByStepWritingResponseBodyPayloadOutputExtraOutput> extraOutput{};
  shared_ptr<vector<string>> miniDoc{};
  shared_ptr<string> searchQuery{};
  shared_ptr<string> text{};

  RunStepByStepWritingResponseBodyPayloadOutput() {}

  explicit RunStepByStepWritingResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (extraOutput) {
      res["ExtraOutput"] = extraOutput ? boost::any(extraOutput->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (miniDoc) {
      res["MiniDoc"] = boost::any(*miniDoc);
    }
    if (searchQuery) {
      res["SearchQuery"] = boost::any(*searchQuery);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunStepByStepWritingResponseBodyPayloadOutputArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunStepByStepWritingResponseBodyPayloadOutputArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunStepByStepWritingResponseBodyPayloadOutputArticles>>(expect1);
      }
    }
    if (m.find("ExtraOutput") != m.end() && !m["ExtraOutput"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraOutput"].type()) {
        RunStepByStepWritingResponseBodyPayloadOutputExtraOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraOutput"]));
        extraOutput = make_shared<RunStepByStepWritingResponseBodyPayloadOutputExtraOutput>(model1);
      }
    }
    if (m.find("MiniDoc") != m.end() && !m["MiniDoc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MiniDoc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MiniDoc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      miniDoc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchQuery") != m.end() && !m["SearchQuery"].empty()) {
      searchQuery = make_shared<string>(boost::any_cast<string>(m["SearchQuery"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunStepByStepWritingResponseBodyPayloadOutput() = default;
};
class RunStepByStepWritingResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunStepByStepWritingResponseBodyPayloadUsage() {}

  explicit RunStepByStepWritingResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunStepByStepWritingResponseBodyPayloadUsage() = default;
};
class RunStepByStepWritingResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunStepByStepWritingResponseBodyPayloadOutput> output{};
  shared_ptr<RunStepByStepWritingResponseBodyPayloadUsage> usage{};

  RunStepByStepWritingResponseBodyPayload() {}

  explicit RunStepByStepWritingResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunStepByStepWritingResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunStepByStepWritingResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunStepByStepWritingResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunStepByStepWritingResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunStepByStepWritingResponseBodyPayload() = default;
};
class RunStepByStepWritingResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunStepByStepWritingResponseBodyHeader> header{};
  shared_ptr<RunStepByStepWritingResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunStepByStepWritingResponseBody() {}

  explicit RunStepByStepWritingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunStepByStepWritingResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunStepByStepWritingResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunStepByStepWritingResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunStepByStepWritingResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunStepByStepWritingResponseBody() = default;
};
class RunStepByStepWritingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunStepByStepWritingResponseBody> body{};

  RunStepByStepWritingResponse() {}

  explicit RunStepByStepWritingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunStepByStepWritingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunStepByStepWritingResponseBody>(model1);
      }
    }
  }


  virtual ~RunStepByStepWritingResponse() = default;
};
class RunStyleFeatureAnalysisRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contents{};
  shared_ptr<vector<long>> materialIds{};
  shared_ptr<string> workspaceId{};

  RunStyleFeatureAnalysisRequest() {}

  explicit RunStyleFeatureAnalysisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    if (materialIds) {
      res["MaterialIds"] = boost::any(*materialIds);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contents = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["MaterialIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaterialIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      materialIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisRequest() = default;
};
class RunStyleFeatureAnalysisShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> materialIdsShrink{};
  shared_ptr<string> workspaceId{};

  RunStyleFeatureAnalysisShrinkRequest() {}

  explicit RunStyleFeatureAnalysisShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (materialIdsShrink) {
      res["MaterialIds"] = boost::any(*materialIdsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("MaterialIds") != m.end() && !m["MaterialIds"].empty()) {
      materialIdsShrink = make_shared<string>(boost::any_cast<string>(m["MaterialIds"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisShrinkRequest() = default;
};
class RunStyleFeatureAnalysisResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunStyleFeatureAnalysisResponseBodyHeader() {}

  explicit RunStyleFeatureAnalysisResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisResponseBodyHeader() = default;
};
class RunStyleFeatureAnalysisResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunStyleFeatureAnalysisResponseBodyPayloadOutput() {}

  explicit RunStyleFeatureAnalysisResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisResponseBodyPayloadOutput() = default;
};
class RunStyleFeatureAnalysisResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunStyleFeatureAnalysisResponseBodyPayloadUsage() {}

  explicit RunStyleFeatureAnalysisResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisResponseBodyPayloadUsage() = default;
};
class RunStyleFeatureAnalysisResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunStyleFeatureAnalysisResponseBodyPayloadOutput> output{};
  shared_ptr<RunStyleFeatureAnalysisResponseBodyPayloadUsage> usage{};

  RunStyleFeatureAnalysisResponseBodyPayload() {}

  explicit RunStyleFeatureAnalysisResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunStyleFeatureAnalysisResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunStyleFeatureAnalysisResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunStyleFeatureAnalysisResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunStyleFeatureAnalysisResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunStyleFeatureAnalysisResponseBodyPayload() = default;
};
class RunStyleFeatureAnalysisResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunStyleFeatureAnalysisResponseBodyHeader> header{};
  shared_ptr<RunStyleFeatureAnalysisResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunStyleFeatureAnalysisResponseBody() {}

  explicit RunStyleFeatureAnalysisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunStyleFeatureAnalysisResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunStyleFeatureAnalysisResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunStyleFeatureAnalysisResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunStyleFeatureAnalysisResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunStyleFeatureAnalysisResponseBody() = default;
};
class RunStyleFeatureAnalysisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunStyleFeatureAnalysisResponseBody> body{};

  RunStyleFeatureAnalysisResponse() {}

  explicit RunStyleFeatureAnalysisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunStyleFeatureAnalysisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunStyleFeatureAnalysisResponseBody>(model1);
      }
    }
  }


  virtual ~RunStyleFeatureAnalysisResponse() = default;
};
class RunSummaryGenerateRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> prompt{};
  shared_ptr<string> workspaceId{};

  RunSummaryGenerateRequest() {}

  explicit RunSummaryGenerateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunSummaryGenerateRequest() = default;
};
class RunSummaryGenerateResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> eventInfo{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunSummaryGenerateResponseBodyHeader() {}

  explicit RunSummaryGenerateResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventInfo) {
      res["EventInfo"] = boost::any(*eventInfo);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventInfo") != m.end() && !m["EventInfo"].empty()) {
      eventInfo = make_shared<string>(boost::any_cast<string>(m["EventInfo"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunSummaryGenerateResponseBodyHeader() = default;
};
class RunSummaryGenerateResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunSummaryGenerateResponseBodyPayloadOutput() {}

  explicit RunSummaryGenerateResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunSummaryGenerateResponseBodyPayloadOutput() = default;
};
class RunSummaryGenerateResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunSummaryGenerateResponseBodyPayloadUsage() {}

  explicit RunSummaryGenerateResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunSummaryGenerateResponseBodyPayloadUsage() = default;
};
class RunSummaryGenerateResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunSummaryGenerateResponseBodyPayloadOutput> output{};
  shared_ptr<RunSummaryGenerateResponseBodyPayloadUsage> usage{};

  RunSummaryGenerateResponseBodyPayload() {}

  explicit RunSummaryGenerateResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunSummaryGenerateResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunSummaryGenerateResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunSummaryGenerateResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunSummaryGenerateResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunSummaryGenerateResponseBodyPayload() = default;
};
class RunSummaryGenerateResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunSummaryGenerateResponseBodyHeader> header{};
  shared_ptr<RunSummaryGenerateResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunSummaryGenerateResponseBody() {}

  explicit RunSummaryGenerateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunSummaryGenerateResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunSummaryGenerateResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunSummaryGenerateResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunSummaryGenerateResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunSummaryGenerateResponseBody() = default;
};
class RunSummaryGenerateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunSummaryGenerateResponseBody> body{};

  RunSummaryGenerateResponse() {}

  explicit RunSummaryGenerateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunSummaryGenerateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunSummaryGenerateResponseBody>(model1);
      }
    }
  }


  virtual ~RunSummaryGenerateResponse() = default;
};
class RunTextPolishingRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> workspaceId{};

  RunTextPolishingRequest() {}

  explicit RunTextPolishingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunTextPolishingRequest() = default;
};
class RunTextPolishingResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunTextPolishingResponseBodyHeader() {}

  explicit RunTextPolishingResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunTextPolishingResponseBodyHeader() = default;
};
class RunTextPolishingResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunTextPolishingResponseBodyPayloadOutput() {}

  explicit RunTextPolishingResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunTextPolishingResponseBodyPayloadOutput() = default;
};
class RunTextPolishingResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunTextPolishingResponseBodyPayloadUsage() {}

  explicit RunTextPolishingResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunTextPolishingResponseBodyPayloadUsage() = default;
};
class RunTextPolishingResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunTextPolishingResponseBodyPayloadOutput> output{};
  shared_ptr<RunTextPolishingResponseBodyPayloadUsage> usage{};

  RunTextPolishingResponseBodyPayload() {}

  explicit RunTextPolishingResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunTextPolishingResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunTextPolishingResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunTextPolishingResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunTextPolishingResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunTextPolishingResponseBodyPayload() = default;
};
class RunTextPolishingResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunTextPolishingResponseBodyHeader> header{};
  shared_ptr<RunTextPolishingResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunTextPolishingResponseBody() {}

  explicit RunTextPolishingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunTextPolishingResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunTextPolishingResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunTextPolishingResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunTextPolishingResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunTextPolishingResponseBody() = default;
};
class RunTextPolishingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunTextPolishingResponseBody> body{};

  RunTextPolishingResponse() {}

  explicit RunTextPolishingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunTextPolishingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunTextPolishingResponseBody>(model1);
      }
    }
  }


  virtual ~RunTextPolishingResponse() = default;
};
class RunTitleGenerationRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contents{};

  RunTitleGenerationRequestReferenceData() {}

  explicit RunTitleGenerationRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contents = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunTitleGenerationRequestReferenceData() = default;
};
class RunTitleGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> deduplicatedTitles{};
  shared_ptr<RunTitleGenerationRequestReferenceData> referenceData{};
  shared_ptr<string> taskId{};
  shared_ptr<string> titleCount{};
  shared_ptr<string> workspaceId{};

  RunTitleGenerationRequest() {}

  explicit RunTitleGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deduplicatedTitles) {
      res["DeduplicatedTitles"] = boost::any(*deduplicatedTitles);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (titleCount) {
      res["TitleCount"] = boost::any(*titleCount);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeduplicatedTitles") != m.end() && !m["DeduplicatedTitles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DeduplicatedTitles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DeduplicatedTitles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      deduplicatedTitles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunTitleGenerationRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunTitleGenerationRequestReferenceData>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TitleCount") != m.end() && !m["TitleCount"].empty()) {
      titleCount = make_shared<string>(boost::any_cast<string>(m["TitleCount"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunTitleGenerationRequest() = default;
};
class RunTitleGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deduplicatedTitlesShrink{};
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> taskId{};
  shared_ptr<string> titleCount{};
  shared_ptr<string> workspaceId{};

  RunTitleGenerationShrinkRequest() {}

  explicit RunTitleGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deduplicatedTitlesShrink) {
      res["DeduplicatedTitles"] = boost::any(*deduplicatedTitlesShrink);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (titleCount) {
      res["TitleCount"] = boost::any(*titleCount);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeduplicatedTitles") != m.end() && !m["DeduplicatedTitles"].empty()) {
      deduplicatedTitlesShrink = make_shared<string>(boost::any_cast<string>(m["DeduplicatedTitles"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TitleCount") != m.end() && !m["TitleCount"].empty()) {
      titleCount = make_shared<string>(boost::any_cast<string>(m["TitleCount"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunTitleGenerationShrinkRequest() = default;
};
class RunTitleGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunTitleGenerationResponseBodyHeader() {}

  explicit RunTitleGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunTitleGenerationResponseBodyHeader() = default;
};
class RunTitleGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunTitleGenerationResponseBodyPayloadOutput() {}

  explicit RunTitleGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunTitleGenerationResponseBodyPayloadOutput() = default;
};
class RunTitleGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunTitleGenerationResponseBodyPayloadUsage() {}

  explicit RunTitleGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunTitleGenerationResponseBodyPayloadUsage() = default;
};
class RunTitleGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunTitleGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunTitleGenerationResponseBodyPayloadUsage> usage{};

  RunTitleGenerationResponseBodyPayload() {}

  explicit RunTitleGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunTitleGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunTitleGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunTitleGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunTitleGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunTitleGenerationResponseBodyPayload() = default;
};
class RunTitleGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RunTitleGenerationResponseBodyHeader> header{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<RunTitleGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RunTitleGenerationResponseBody() {}

  explicit RunTitleGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunTitleGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunTitleGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunTitleGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunTitleGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RunTitleGenerationResponseBody() = default;
};
class RunTitleGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunTitleGenerationResponseBody> body{};

  RunTitleGenerationResponse() {}

  explicit RunTitleGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunTitleGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunTitleGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunTitleGenerationResponse() = default;
};
class RunTranslateGenerationRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contents{};

  RunTranslateGenerationRequestReferenceData() {}

  explicit RunTranslateGenerationRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contents = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunTranslateGenerationRequestReferenceData() = default;
};
class RunTranslateGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<string> prompt{};
  shared_ptr<RunTranslateGenerationRequestReferenceData> referenceData{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunTranslateGenerationRequest() {}

  explicit RunTranslateGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunTranslateGenerationRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunTranslateGenerationRequestReferenceData>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunTranslateGenerationRequest() = default;
};
class RunTranslateGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunTranslateGenerationShrinkRequest() {}

  explicit RunTranslateGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunTranslateGenerationShrinkRequest() = default;
};
class RunTranslateGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunTranslateGenerationResponseBodyHeader() {}

  explicit RunTranslateGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunTranslateGenerationResponseBodyHeader() = default;
};
class RunTranslateGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunTranslateGenerationResponseBodyPayloadOutput() {}

  explicit RunTranslateGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunTranslateGenerationResponseBodyPayloadOutput() = default;
};
class RunTranslateGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunTranslateGenerationResponseBodyPayloadUsage() {}

  explicit RunTranslateGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunTranslateGenerationResponseBodyPayloadUsage() = default;
};
class RunTranslateGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunTranslateGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunTranslateGenerationResponseBodyPayloadUsage> usage{};

  RunTranslateGenerationResponseBodyPayload() {}

  explicit RunTranslateGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunTranslateGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunTranslateGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunTranslateGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunTranslateGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunTranslateGenerationResponseBodyPayload() = default;
};
class RunTranslateGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunTranslateGenerationResponseBodyHeader> header{};
  shared_ptr<RunTranslateGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunTranslateGenerationResponseBody() {}

  explicit RunTranslateGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunTranslateGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunTranslateGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunTranslateGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunTranslateGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunTranslateGenerationResponseBody() = default;
};
class RunTranslateGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunTranslateGenerationResponseBody> body{};

  RunTranslateGenerationResponse() {}

  explicit RunTranslateGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunTranslateGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunTranslateGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunTranslateGenerationResponse() = default;
};
class RunWriteToneGenerationRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> contents{};

  RunWriteToneGenerationRequestReferenceData() {}

  explicit RunWriteToneGenerationRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Contents"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      contents = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunWriteToneGenerationRequestReferenceData() = default;
};
class RunWriteToneGenerationRequest : public Darabonba::Model {
public:
  shared_ptr<string> prompt{};
  shared_ptr<RunWriteToneGenerationRequestReferenceData> referenceData{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunWriteToneGenerationRequest() {}

  explicit RunWriteToneGenerationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunWriteToneGenerationRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunWriteToneGenerationRequestReferenceData>(model1);
      }
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunWriteToneGenerationRequest() = default;
};
class RunWriteToneGenerationShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};

  RunWriteToneGenerationShrinkRequest() {}

  explicit RunWriteToneGenerationShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~RunWriteToneGenerationShrinkRequest() = default;
};
class RunWriteToneGenerationResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunWriteToneGenerationResponseBodyHeader() {}

  explicit RunWriteToneGenerationResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunWriteToneGenerationResponseBodyHeader() = default;
};
class RunWriteToneGenerationResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<string> text{};

  RunWriteToneGenerationResponseBodyPayloadOutput() {}

  explicit RunWriteToneGenerationResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunWriteToneGenerationResponseBodyPayloadOutput() = default;
};
class RunWriteToneGenerationResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<long> totalTokens{};

  RunWriteToneGenerationResponseBodyPayloadUsage() {}

  explicit RunWriteToneGenerationResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunWriteToneGenerationResponseBodyPayloadUsage() = default;
};
class RunWriteToneGenerationResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunWriteToneGenerationResponseBodyPayloadOutput> output{};
  shared_ptr<RunWriteToneGenerationResponseBodyPayloadUsage> usage{};

  RunWriteToneGenerationResponseBodyPayload() {}

  explicit RunWriteToneGenerationResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunWriteToneGenerationResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunWriteToneGenerationResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunWriteToneGenerationResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunWriteToneGenerationResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunWriteToneGenerationResponseBodyPayload() = default;
};
class RunWriteToneGenerationResponseBody : public Darabonba::Model {
public:
  shared_ptr<RunWriteToneGenerationResponseBodyHeader> header{};
  shared_ptr<RunWriteToneGenerationResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunWriteToneGenerationResponseBody() {}

  explicit RunWriteToneGenerationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunWriteToneGenerationResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunWriteToneGenerationResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunWriteToneGenerationResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunWriteToneGenerationResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunWriteToneGenerationResponseBody() = default;
};
class RunWriteToneGenerationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunWriteToneGenerationResponseBody> body{};

  RunWriteToneGenerationResponse() {}

  explicit RunWriteToneGenerationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunWriteToneGenerationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunWriteToneGenerationResponseBody>(model1);
      }
    }
  }


  virtual ~RunWriteToneGenerationResponse() = default;
};
class RunWritingRequestReferenceDataArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunWritingRequestReferenceDataArticles() {}

  explicit RunWritingRequestReferenceDataArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunWritingRequestReferenceDataArticles() = default;
};
class RunWritingRequestReferenceData : public Darabonba::Model {
public:
  shared_ptr<vector<RunWritingRequestReferenceDataArticles>> articles{};

  RunWritingRequestReferenceData() {}

  explicit RunWritingRequestReferenceData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunWritingRequestReferenceDataArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunWritingRequestReferenceDataArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunWritingRequestReferenceDataArticles>>(expect1);
      }
    }
  }


  virtual ~RunWritingRequestReferenceData() = default;
};
class RunWritingRequestWritingConfigPromptTag : public Darabonba::Model {
public:
  shared_ptr<string> necessaryTips{};
  shared_ptr<string> position{};
  shared_ptr<string> reverseWords{};
  shared_ptr<string> theme{};

  RunWritingRequestWritingConfigPromptTag() {}

  explicit RunWritingRequestWritingConfigPromptTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (necessaryTips) {
      res["NecessaryTips"] = boost::any(*necessaryTips);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (reverseWords) {
      res["ReverseWords"] = boost::any(*reverseWords);
    }
    if (theme) {
      res["Theme"] = boost::any(*theme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NecessaryTips") != m.end() && !m["NecessaryTips"].empty()) {
      necessaryTips = make_shared<string>(boost::any_cast<string>(m["NecessaryTips"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<string>(boost::any_cast<string>(m["Position"]));
    }
    if (m.find("ReverseWords") != m.end() && !m["ReverseWords"].empty()) {
      reverseWords = make_shared<string>(boost::any_cast<string>(m["ReverseWords"]));
    }
    if (m.find("Theme") != m.end() && !m["Theme"].empty()) {
      theme = make_shared<string>(boost::any_cast<string>(m["Theme"]));
    }
  }


  virtual ~RunWritingRequestWritingConfigPromptTag() = default;
};
class RunWritingRequestWritingConfigTags : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<string> tag{};

  RunWritingRequestWritingConfigTags() {}

  explicit RunWritingRequestWritingConfigTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~RunWritingRequestWritingConfigTags() = default;
};
class RunWritingRequestWritingConfig : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<RunWritingRequestWritingConfigPromptTag> promptTag{};
  shared_ptr<vector<RunWritingRequestWritingConfigTags>> tags{};
  shared_ptr<bool> useSearch{};

  RunWritingRequestWritingConfig() {}

  explicit RunWritingRequestWritingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (promptTag) {
      res["PromptTag"] = promptTag ? boost::any(promptTag->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (useSearch) {
      res["UseSearch"] = boost::any(*useSearch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PromptTag") != m.end() && !m["PromptTag"].empty()) {
      if (typeid(map<string, boost::any>) == m["PromptTag"].type()) {
        RunWritingRequestWritingConfigPromptTag model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PromptTag"]));
        promptTag = make_shared<RunWritingRequestWritingConfigPromptTag>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<RunWritingRequestWritingConfigTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunWritingRequestWritingConfigTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<RunWritingRequestWritingConfigTags>>(expect1);
      }
    }
    if (m.find("UseSearch") != m.end() && !m["UseSearch"].empty()) {
      useSearch = make_shared<bool>(boost::any_cast<bool>(m["UseSearch"]));
    }
  }


  virtual ~RunWritingRequestWritingConfig() = default;
};
class RunWritingRequest : public Darabonba::Model {
public:
  shared_ptr<string> originSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<RunWritingRequestReferenceData> referenceData{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};
  shared_ptr<RunWritingRequestWritingConfig> writingConfig{};

  RunWritingRequest() {}

  explicit RunWritingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceData) {
      res["ReferenceData"] = referenceData ? boost::any(referenceData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (writingConfig) {
      res["WritingConfig"] = writingConfig ? boost::any(writingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceData"].type()) {
        RunWritingRequestReferenceData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceData"]));
        referenceData = make_shared<RunWritingRequestReferenceData>(model1);
      }
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("WritingConfig") != m.end() && !m["WritingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WritingConfig"].type()) {
        RunWritingRequestWritingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WritingConfig"]));
        writingConfig = make_shared<RunWritingRequestWritingConfig>(model1);
      }
    }
  }


  virtual ~RunWritingRequest() = default;
};
class RunWritingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> originSessionId{};
  shared_ptr<string> prompt{};
  shared_ptr<string> referenceDataShrink{};
  shared_ptr<string> sessionId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> workspaceId{};
  shared_ptr<string> writingConfigShrink{};

  RunWritingShrinkRequest() {}

  explicit RunWritingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (referenceDataShrink) {
      res["ReferenceData"] = boost::any(*referenceDataShrink);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    if (writingConfigShrink) {
      res["WritingConfig"] = boost::any(*writingConfigShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("ReferenceData") != m.end() && !m["ReferenceData"].empty()) {
      referenceDataShrink = make_shared<string>(boost::any_cast<string>(m["ReferenceData"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
    if (m.find("WritingConfig") != m.end() && !m["WritingConfig"].empty()) {
      writingConfigShrink = make_shared<string>(boost::any_cast<string>(m["WritingConfig"]));
    }
  }


  virtual ~RunWritingShrinkRequest() = default;
};
class RunWritingResponseBodyHeader : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> event{};
  shared_ptr<string> originSessionId{};
  shared_ptr<string> sessionId{};
  shared_ptr<long> statusCode{};
  shared_ptr<string> taskId{};
  shared_ptr<string> traceId{};

  RunWritingResponseBodyHeader() {}

  explicit RunWritingResponseBodyHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (originSessionId) {
      res["OriginSessionId"] = boost::any(*originSessionId);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("OriginSessionId") != m.end() && !m["OriginSessionId"].empty()) {
      originSessionId = make_shared<string>(boost::any_cast<string>(m["OriginSessionId"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<string>(boost::any_cast<string>(m["SessionId"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["StatusCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~RunWritingResponseBodyHeader() = default;
};
class RunWritingResponseBodyPayloadOutputArticles : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  RunWritingResponseBodyPayloadOutputArticles() {}

  explicit RunWritingResponseBodyPayloadOutputArticles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~RunWritingResponseBodyPayloadOutputArticles() = default;
};
class RunWritingResponseBodyPayloadOutput : public Darabonba::Model {
public:
  shared_ptr<vector<RunWritingResponseBodyPayloadOutputArticles>> articles{};
  shared_ptr<vector<string>> miniDoc{};
  shared_ptr<string> searchQuery{};
  shared_ptr<string> text{};

  RunWritingResponseBodyPayloadOutput() {}

  explicit RunWritingResponseBodyPayloadOutput(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (articles) {
      vector<boost::any> temp1;
      for(auto item1:*articles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Articles"] = boost::any(temp1);
    }
    if (miniDoc) {
      res["MiniDoc"] = boost::any(*miniDoc);
    }
    if (searchQuery) {
      res["SearchQuery"] = boost::any(*searchQuery);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Articles") != m.end() && !m["Articles"].empty()) {
      if (typeid(vector<boost::any>) == m["Articles"].type()) {
        vector<RunWritingResponseBodyPayloadOutputArticles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Articles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RunWritingResponseBodyPayloadOutputArticles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        articles = make_shared<vector<RunWritingResponseBodyPayloadOutputArticles>>(expect1);
      }
    }
    if (m.find("MiniDoc") != m.end() && !m["MiniDoc"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MiniDoc"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MiniDoc"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      miniDoc = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchQuery") != m.end() && !m["SearchQuery"].empty()) {
      searchQuery = make_shared<string>(boost::any_cast<string>(m["SearchQuery"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~RunWritingResponseBodyPayloadOutput() = default;
};
class RunWritingResponseBodyPayloadUsage : public Darabonba::Model {
public:
  shared_ptr<long> inputTokens{};
  shared_ptr<long> outputTokens{};
  shared_ptr<map<string, long>> tokenMap{};
  shared_ptr<long> totalTokens{};

  RunWritingResponseBodyPayloadUsage() {}

  explicit RunWritingResponseBodyPayloadUsage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputTokens) {
      res["InputTokens"] = boost::any(*inputTokens);
    }
    if (outputTokens) {
      res["OutputTokens"] = boost::any(*outputTokens);
    }
    if (tokenMap) {
      res["TokenMap"] = boost::any(*tokenMap);
    }
    if (totalTokens) {
      res["TotalTokens"] = boost::any(*totalTokens);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputTokens") != m.end() && !m["InputTokens"].empty()) {
      inputTokens = make_shared<long>(boost::any_cast<long>(m["InputTokens"]));
    }
    if (m.find("OutputTokens") != m.end() && !m["OutputTokens"].empty()) {
      outputTokens = make_shared<long>(boost::any_cast<long>(m["OutputTokens"]));
    }
    if (m.find("TokenMap") != m.end() && !m["TokenMap"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["TokenMap"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tokenMap = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("TotalTokens") != m.end() && !m["TotalTokens"].empty()) {
      totalTokens = make_shared<long>(boost::any_cast<long>(m["TotalTokens"]));
    }
  }


  virtual ~RunWritingResponseBodyPayloadUsage() = default;
};
class RunWritingResponseBodyPayload : public Darabonba::Model {
public:
  shared_ptr<RunWritingResponseBodyPayloadOutput> output{};
  shared_ptr<RunWritingResponseBodyPayloadUsage> usage{};

  RunWritingResponseBodyPayload() {}

  explicit RunWritingResponseBodyPayload(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = output ? boost::any(output->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (usage) {
      res["Usage"] = usage ? boost::any(usage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      if (typeid(map<string, boost::any>) == m["Output"].type()) {
        RunWritingResponseBodyPayloadOutput model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Output"]));
        output = make_shared<RunWritingResponseBodyPayloadOutput>(model1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      if (typeid(map<string, boost::any>) == m["Usage"].type()) {
        RunWritingResponseBodyPayloadUsage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Usage"]));
        usage = make_shared<RunWritingResponseBodyPayloadUsage>(model1);
      }
    }
  }


  virtual ~RunWritingResponseBodyPayload() = default;
};
class RunWritingResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> end{};
  shared_ptr<RunWritingResponseBodyHeader> header{};
  shared_ptr<RunWritingResponseBodyPayload> payload{};
  shared_ptr<string> requestId{};

  RunWritingResponseBody() {}

  explicit RunWritingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (header) {
      res["Header"] = header ? boost::any(header->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (payload) {
      res["Payload"] = payload ? boost::any(payload->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<bool>(boost::any_cast<bool>(m["End"]));
    }
    if (m.find("Header") != m.end() && !m["Header"].empty()) {
      if (typeid(map<string, boost::any>) == m["Header"].type()) {
        RunWritingResponseBodyHeader model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Header"]));
        header = make_shared<RunWritingResponseBodyHeader>(model1);
      }
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      if (typeid(map<string, boost::any>) == m["Payload"].type()) {
        RunWritingResponseBodyPayload model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Payload"]));
        payload = make_shared<RunWritingResponseBodyPayload>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RunWritingResponseBody() = default;
};
class RunWritingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunWritingResponseBody> body{};

  RunWritingResponse() {}

  explicit RunWritingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunWritingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunWritingResponseBody>(model1);
      }
    }
  }


  virtual ~RunWritingResponse() = default;
};
class SaveCustomTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> content{};
  shared_ptr<string> title{};

  SaveCustomTextRequest() {}

  explicit SaveCustomTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SaveCustomTextRequest() = default;
};
class SaveCustomTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveCustomTextResponseBody() {}

  explicit SaveCustomTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveCustomTextResponseBody() = default;
};
class SaveCustomTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveCustomTextResponseBody> body{};

  SaveCustomTextResponse() {}

  explicit SaveCustomTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveCustomTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveCustomTextResponseBody>(model1);
      }
    }
  }


  virtual ~SaveCustomTextResponse() = default;
};
class SaveDataSourceOrderConfigRequestUserConfigDataSourceList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<long> number{};
  shared_ptr<string> type{};

  SaveDataSourceOrderConfigRequestUserConfigDataSourceList() {}

  explicit SaveDataSourceOrderConfigRequestUserConfigDataSourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SaveDataSourceOrderConfigRequestUserConfigDataSourceList() = default;
};
class SaveDataSourceOrderConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> productCode{};
  shared_ptr<vector<SaveDataSourceOrderConfigRequestUserConfigDataSourceList>> userConfigDataSourceList{};

  SaveDataSourceOrderConfigRequest() {}

  explicit SaveDataSourceOrderConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (userConfigDataSourceList) {
      vector<boost::any> temp1;
      for(auto item1:*userConfigDataSourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserConfigDataSourceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("UserConfigDataSourceList") != m.end() && !m["UserConfigDataSourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserConfigDataSourceList"].type()) {
        vector<SaveDataSourceOrderConfigRequestUserConfigDataSourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserConfigDataSourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SaveDataSourceOrderConfigRequestUserConfigDataSourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userConfigDataSourceList = make_shared<vector<SaveDataSourceOrderConfigRequestUserConfigDataSourceList>>(expect1);
      }
    }
  }


  virtual ~SaveDataSourceOrderConfigRequest() = default;
};
class SaveDataSourceOrderConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> productCode{};
  shared_ptr<string> userConfigDataSourceListShrink{};

  SaveDataSourceOrderConfigShrinkRequest() {}

  explicit SaveDataSourceOrderConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (productCode) {
      res["ProductCode"] = boost::any(*productCode);
    }
    if (userConfigDataSourceListShrink) {
      res["UserConfigDataSourceList"] = boost::any(*userConfigDataSourceListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("ProductCode") != m.end() && !m["ProductCode"].empty()) {
      productCode = make_shared<string>(boost::any_cast<string>(m["ProductCode"]));
    }
    if (m.find("UserConfigDataSourceList") != m.end() && !m["UserConfigDataSourceList"].empty()) {
      userConfigDataSourceListShrink = make_shared<string>(boost::any_cast<string>(m["UserConfigDataSourceList"]));
    }
  }


  virtual ~SaveDataSourceOrderConfigShrinkRequest() = default;
};
class SaveDataSourceOrderConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveDataSourceOrderConfigResponseBody() {}

  explicit SaveDataSourceOrderConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveDataSourceOrderConfigResponseBody() = default;
};
class SaveDataSourceOrderConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveDataSourceOrderConfigResponseBody> body{};

  SaveDataSourceOrderConfigResponse() {}

  explicit SaveDataSourceOrderConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveDataSourceOrderConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveDataSourceOrderConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SaveDataSourceOrderConfigResponse() = default;
};
class SaveMaterialDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> author{};
  shared_ptr<bool> bothSavePrivateAndShare{};
  shared_ptr<vector<string>> docKeywords{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<string> pubTime{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  SaveMaterialDocumentRequest() {}

  explicit SaveMaterialDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (bothSavePrivateAndShare) {
      res["BothSavePrivateAndShare"] = boost::any(*bothSavePrivateAndShare);
    }
    if (docKeywords) {
      res["DocKeywords"] = boost::any(*docKeywords);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("BothSavePrivateAndShare") != m.end() && !m["BothSavePrivateAndShare"].empty()) {
      bothSavePrivateAndShare = make_shared<bool>(boost::any_cast<bool>(m["BothSavePrivateAndShare"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocKeywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocKeywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docKeywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SaveMaterialDocumentRequest() = default;
};
class SaveMaterialDocumentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> author{};
  shared_ptr<bool> bothSavePrivateAndShare{};
  shared_ptr<string> docKeywordsShrink{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<string> pubTime{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  SaveMaterialDocumentShrinkRequest() {}

  explicit SaveMaterialDocumentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (bothSavePrivateAndShare) {
      res["BothSavePrivateAndShare"] = boost::any(*bothSavePrivateAndShare);
    }
    if (docKeywordsShrink) {
      res["DocKeywords"] = boost::any(*docKeywordsShrink);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("BothSavePrivateAndShare") != m.end() && !m["BothSavePrivateAndShare"].empty()) {
      bothSavePrivateAndShare = make_shared<bool>(boost::any_cast<bool>(m["BothSavePrivateAndShare"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      docKeywordsShrink = make_shared<string>(boost::any_cast<string>(m["DocKeywords"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SaveMaterialDocumentShrinkRequest() = default;
};
class SaveMaterialDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveMaterialDocumentResponseBody() {}

  explicit SaveMaterialDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveMaterialDocumentResponseBody() = default;
};
class SaveMaterialDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveMaterialDocumentResponseBody> body{};

  SaveMaterialDocumentResponse() {}

  explicit SaveMaterialDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveMaterialDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveMaterialDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~SaveMaterialDocumentResponse() = default;
};
class SaveStyleLearningResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> aigcResult{};
  shared_ptr<vector<long>> customTextIdList{};
  shared_ptr<vector<long>> materialIdList{};
  shared_ptr<string> rewriteResult{};
  shared_ptr<string> styleName{};
  shared_ptr<string> taskId{};

  SaveStyleLearningResultRequest() {}

  explicit SaveStyleLearningResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (aigcResult) {
      res["AigcResult"] = boost::any(*aigcResult);
    }
    if (customTextIdList) {
      res["CustomTextIdList"] = boost::any(*customTextIdList);
    }
    if (materialIdList) {
      res["MaterialIdList"] = boost::any(*materialIdList);
    }
    if (rewriteResult) {
      res["RewriteResult"] = boost::any(*rewriteResult);
    }
    if (styleName) {
      res["StyleName"] = boost::any(*styleName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AigcResult") != m.end() && !m["AigcResult"].empty()) {
      aigcResult = make_shared<string>(boost::any_cast<string>(m["AigcResult"]));
    }
    if (m.find("CustomTextIdList") != m.end() && !m["CustomTextIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["CustomTextIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomTextIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      customTextIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("MaterialIdList") != m.end() && !m["MaterialIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["MaterialIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaterialIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      materialIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RewriteResult") != m.end() && !m["RewriteResult"].empty()) {
      rewriteResult = make_shared<string>(boost::any_cast<string>(m["RewriteResult"]));
    }
    if (m.find("StyleName") != m.end() && !m["StyleName"].empty()) {
      styleName = make_shared<string>(boost::any_cast<string>(m["StyleName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SaveStyleLearningResultRequest() = default;
};
class SaveStyleLearningResultShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> aigcResult{};
  shared_ptr<string> customTextIdListShrink{};
  shared_ptr<string> materialIdListShrink{};
  shared_ptr<string> rewriteResult{};
  shared_ptr<string> styleName{};
  shared_ptr<string> taskId{};

  SaveStyleLearningResultShrinkRequest() {}

  explicit SaveStyleLearningResultShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (aigcResult) {
      res["AigcResult"] = boost::any(*aigcResult);
    }
    if (customTextIdListShrink) {
      res["CustomTextIdList"] = boost::any(*customTextIdListShrink);
    }
    if (materialIdListShrink) {
      res["MaterialIdList"] = boost::any(*materialIdListShrink);
    }
    if (rewriteResult) {
      res["RewriteResult"] = boost::any(*rewriteResult);
    }
    if (styleName) {
      res["StyleName"] = boost::any(*styleName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("AigcResult") != m.end() && !m["AigcResult"].empty()) {
      aigcResult = make_shared<string>(boost::any_cast<string>(m["AigcResult"]));
    }
    if (m.find("CustomTextIdList") != m.end() && !m["CustomTextIdList"].empty()) {
      customTextIdListShrink = make_shared<string>(boost::any_cast<string>(m["CustomTextIdList"]));
    }
    if (m.find("MaterialIdList") != m.end() && !m["MaterialIdList"].empty()) {
      materialIdListShrink = make_shared<string>(boost::any_cast<string>(m["MaterialIdList"]));
    }
    if (m.find("RewriteResult") != m.end() && !m["RewriteResult"].empty()) {
      rewriteResult = make_shared<string>(boost::any_cast<string>(m["RewriteResult"]));
    }
    if (m.find("StyleName") != m.end() && !m["StyleName"].empty()) {
      styleName = make_shared<string>(boost::any_cast<string>(m["StyleName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SaveStyleLearningResultShrinkRequest() = default;
};
class SaveStyleLearningResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SaveStyleLearningResultResponseBody() {}

  explicit SaveStyleLearningResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SaveStyleLearningResultResponseBody() = default;
};
class SaveStyleLearningResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveStyleLearningResultResponseBody> body{};

  SaveStyleLearningResultResponse() {}

  explicit SaveStyleLearningResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveStyleLearningResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveStyleLearningResultResponseBody>(model1);
      }
    }
  }


  virtual ~SaveStyleLearningResultResponse() = default;
};
class SearchDatasetDocumentsRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> extend1{};
  shared_ptr<bool> includeContent{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> workspaceId{};

  SearchDatasetDocumentsRequest() {}

  explicit SearchDatasetDocumentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (includeContent) {
      res["IncludeContent"] = boost::any(*includeContent);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("IncludeContent") != m.end() && !m["IncludeContent"].empty()) {
      includeContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeContent"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SearchDatasetDocumentsRequest() = default;
};
class SearchDatasetDocumentsResponseBodyDataDocuments : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> sourceFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  SearchDatasetDocumentsResponseBodyDataDocuments() {}

  explicit SearchDatasetDocumentsResponseBodyDataDocuments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (sourceFrom) {
      res["SourceFrom"] = boost::any(*sourceFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SourceFrom") != m.end() && !m["SourceFrom"].empty()) {
      sourceFrom = make_shared<string>(boost::any_cast<string>(m["SourceFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SearchDatasetDocumentsResponseBodyDataDocuments() = default;
};
class SearchDatasetDocumentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<SearchDatasetDocumentsResponseBodyDataDocuments>> documents{};

  SearchDatasetDocumentsResponseBodyData() {}

  explicit SearchDatasetDocumentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documents) {
      vector<boost::any> temp1;
      for(auto item1:*documents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Documents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      if (typeid(vector<boost::any>) == m["Documents"].type()) {
        vector<SearchDatasetDocumentsResponseBodyDataDocuments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Documents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchDatasetDocumentsResponseBodyDataDocuments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        documents = make_shared<vector<SearchDatasetDocumentsResponseBodyDataDocuments>>(expect1);
      }
    }
  }


  virtual ~SearchDatasetDocumentsResponseBodyData() = default;
};
class SearchDatasetDocumentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SearchDatasetDocumentsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SearchDatasetDocumentsResponseBody() {}

  explicit SearchDatasetDocumentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SearchDatasetDocumentsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SearchDatasetDocumentsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SearchDatasetDocumentsResponseBody() = default;
};
class SearchDatasetDocumentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchDatasetDocumentsResponseBody> body{};

  SearchDatasetDocumentsResponse() {}

  explicit SearchDatasetDocumentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchDatasetDocumentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchDatasetDocumentsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchDatasetDocumentsResponse() = default;
};
class SearchNewsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<bool> filterNotNull{};
  shared_ptr<bool> includeContent{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<vector<string>> searchSources{};

  SearchNewsRequest() {}

  explicit SearchNewsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (filterNotNull) {
      res["FilterNotNull"] = boost::any(*filterNotNull);
    }
    if (includeContent) {
      res["IncludeContent"] = boost::any(*includeContent);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (searchSources) {
      res["SearchSources"] = boost::any(*searchSources);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("FilterNotNull") != m.end() && !m["FilterNotNull"].empty()) {
      filterNotNull = make_shared<bool>(boost::any_cast<bool>(m["FilterNotNull"]));
    }
    if (m.find("IncludeContent") != m.end() && !m["IncludeContent"].empty()) {
      includeContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeContent"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SearchSources"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SearchSources"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      searchSources = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SearchNewsRequest() = default;
};
class SearchNewsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<bool> filterNotNull{};
  shared_ptr<bool> includeContent{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> searchSourcesShrink{};

  SearchNewsShrinkRequest() {}

  explicit SearchNewsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (filterNotNull) {
      res["FilterNotNull"] = boost::any(*filterNotNull);
    }
    if (includeContent) {
      res["IncludeContent"] = boost::any(*includeContent);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (searchSourcesShrink) {
      res["SearchSources"] = boost::any(*searchSourcesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("FilterNotNull") != m.end() && !m["FilterNotNull"].empty()) {
      filterNotNull = make_shared<bool>(boost::any_cast<bool>(m["FilterNotNull"]));
    }
    if (m.find("IncludeContent") != m.end() && !m["IncludeContent"].empty()) {
      includeContent = make_shared<bool>(boost::any_cast<bool>(m["IncludeContent"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("SearchSources") != m.end() && !m["SearchSources"].empty()) {
      searchSourcesShrink = make_shared<string>(boost::any_cast<string>(m["SearchSources"]));
    }
  }


  virtual ~SearchNewsShrinkRequest() = default;
};
class SearchNewsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> docUuid{};
  shared_ptr<vector<string>> imageUrls{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> searchSource{};
  shared_ptr<string> searchSourceName{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> tag{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};
  shared_ptr<string> url{};

  SearchNewsResponseBodyData() {}

  explicit SearchNewsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (imageUrls) {
      res["ImageUrls"] = boost::any(*imageUrls);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (searchSource) {
      res["SearchSource"] = boost::any(*searchSource);
    }
    if (searchSourceName) {
      res["SearchSourceName"] = boost::any(*searchSourceName);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("ImageUrls") != m.end() && !m["ImageUrls"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ImageUrls"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ImageUrls"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      imageUrls = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("SearchSource") != m.end() && !m["SearchSource"].empty()) {
      searchSource = make_shared<string>(boost::any_cast<string>(m["SearchSource"]));
    }
    if (m.find("SearchSourceName") != m.end() && !m["SearchSourceName"].empty()) {
      searchSourceName = make_shared<string>(boost::any_cast<string>(m["SearchSourceName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SearchNewsResponseBodyData() = default;
};
class SearchNewsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<SearchNewsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<bool> success{};
  shared_ptr<long> total{};

  SearchNewsResponseBody() {}

  explicit SearchNewsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<SearchNewsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchNewsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<SearchNewsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~SearchNewsResponseBody() = default;
};
class SearchNewsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchNewsResponseBody> body{};

  SearchNewsResponse() {}

  explicit SearchNewsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchNewsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchNewsResponseBody>(model1);
      }
    }
  }


  virtual ~SearchNewsResponse() = default;
};
class SubmitAsyncTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> taskCode{};
  shared_ptr<string> taskExecuteTime{};
  shared_ptr<string> taskName{};
  shared_ptr<string> taskParam{};

  SubmitAsyncTaskRequest() {}

  explicit SubmitAsyncTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (taskCode) {
      res["TaskCode"] = boost::any(*taskCode);
    }
    if (taskExecuteTime) {
      res["TaskExecuteTime"] = boost::any(*taskExecuteTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    if (taskParam) {
      res["TaskParam"] = boost::any(*taskParam);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("TaskCode") != m.end() && !m["TaskCode"].empty()) {
      taskCode = make_shared<string>(boost::any_cast<string>(m["TaskCode"]));
    }
    if (m.find("TaskExecuteTime") != m.end() && !m["TaskExecuteTime"].empty()) {
      taskExecuteTime = make_shared<string>(boost::any_cast<string>(m["TaskExecuteTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
    if (m.find("TaskParam") != m.end() && !m["TaskParam"].empty()) {
      taskParam = make_shared<string>(boost::any_cast<string>(m["TaskParam"]));
    }
  }


  virtual ~SubmitAsyncTaskRequest() = default;
};
class SubmitAsyncTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<boost::any> taskIntermediateResult{};
  shared_ptr<string> taskName{};

  SubmitAsyncTaskResponseBodyData() {}

  explicit SubmitAsyncTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskIntermediateResult) {
      res["TaskIntermediateResult"] = boost::any(*taskIntermediateResult);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskIntermediateResult") != m.end() && !m["TaskIntermediateResult"].empty()) {
      taskIntermediateResult = make_shared<boost::any>(boost::any_cast<boost::any>(m["TaskIntermediateResult"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~SubmitAsyncTaskResponseBodyData() = default;
};
class SubmitAsyncTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitAsyncTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitAsyncTaskResponseBody() {}

  explicit SubmitAsyncTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitAsyncTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitAsyncTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitAsyncTaskResponseBody() = default;
};
class SubmitAsyncTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitAsyncTaskResponseBody> body{};

  SubmitAsyncTaskResponse() {}

  explicit SubmitAsyncTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAsyncTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAsyncTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAsyncTaskResponse() = default;
};
class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig : public Darabonba::Model {
public:
  shared_ptr<long> summaryImageCount{};
  shared_ptr<string> summaryModel{};
  shared_ptr<string> summaryPrompt{};

  SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig() {}

  explicit SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (summaryImageCount) {
      res["SummaryImageCount"] = boost::any(*summaryImageCount);
    }
    if (summaryModel) {
      res["SummaryModel"] = boost::any(*summaryModel);
    }
    if (summaryPrompt) {
      res["SummaryPrompt"] = boost::any(*summaryPrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SummaryImageCount") != m.end() && !m["SummaryImageCount"].empty()) {
      summaryImageCount = make_shared<long>(boost::any_cast<long>(m["SummaryImageCount"]));
    }
    if (m.find("SummaryModel") != m.end() && !m["SummaryModel"].empty()) {
      summaryModel = make_shared<string>(boost::any_cast<string>(m["SummaryModel"]));
    }
    if (m.find("SummaryPrompt") != m.end() && !m["SummaryPrompt"].empty()) {
      summaryPrompt = make_shared<string>(boost::any_cast<string>(m["SummaryPrompt"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig() = default;
};
class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> dimensionName{};
  shared_ptr<long> weight{};

  SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights() {}

  explicit SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (dimensionName) {
      res["DimensionName"] = boost::any(*dimensionName);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("DimensionName") != m.end() && !m["DimensionName"].empty()) {
      dimensionName = make_shared<string>(boost::any_cast<string>(m["DimensionName"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights() = default;
};
class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<vector<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights>> customHotValueWeights{};
  shared_ptr<long> topicCount{};

  SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig() {}

  explicit SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (customHotValueWeights) {
      vector<boost::any> temp1;
      for(auto item1:*customHotValueWeights){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomHotValueWeights"] = boost::any(temp1);
    }
    if (topicCount) {
      res["TopicCount"] = boost::any(*topicCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomHotValueWeights") != m.end() && !m["CustomHotValueWeights"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomHotValueWeights"].type()) {
        vector<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomHotValueWeights"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customHotValueWeights = make_shared<vector<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfigCustomHotValueWeights>>(expect1);
      }
    }
    if (m.find("TopicCount") != m.end() && !m["TopicCount"].empty()) {
      topicCount = make_shared<long>(boost::any_cast<long>(m["TopicCount"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig() = default;
};
class SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig> stepForCustomSummaryStyleConfig{};
  shared_ptr<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig> stepForNewsBroadcastContentConfig{};

  SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig() {}

  explicit SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stepForCustomSummaryStyleConfig) {
      res["StepForCustomSummaryStyleConfig"] = stepForCustomSummaryStyleConfig ? boost::any(stepForCustomSummaryStyleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stepForNewsBroadcastContentConfig) {
      res["StepForNewsBroadcastContentConfig"] = stepForNewsBroadcastContentConfig ? boost::any(stepForNewsBroadcastContentConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StepForCustomSummaryStyleConfig") != m.end() && !m["StepForCustomSummaryStyleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StepForCustomSummaryStyleConfig"].type()) {
        SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StepForCustomSummaryStyleConfig"]));
        stepForCustomSummaryStyleConfig = make_shared<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForCustomSummaryStyleConfig>(model1);
      }
    }
    if (m.find("StepForNewsBroadcastContentConfig") != m.end() && !m["StepForNewsBroadcastContentConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StepForNewsBroadcastContentConfig"].type()) {
        SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StepForNewsBroadcastContentConfig"]));
        stepForNewsBroadcastContentConfig = make_shared<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfigStepForNewsBroadcastContentConfig>(model1);
      }
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig() = default;
};
class SubmitCustomHotTopicBroadcastJobRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig> hotTopicBroadcastConfig{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<vector<string>> topics{};
  shared_ptr<string> workspaceId{};

  SubmitCustomHotTopicBroadcastJobRequest() {}

  explicit SubmitCustomHotTopicBroadcastJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotTopicBroadcastConfig) {
      res["HotTopicBroadcastConfig"] = hotTopicBroadcastConfig ? boost::any(hotTopicBroadcastConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (topics) {
      res["Topics"] = boost::any(*topics);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotTopicBroadcastConfig") != m.end() && !m["HotTopicBroadcastConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["HotTopicBroadcastConfig"].type()) {
        SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HotTopicBroadcastConfig"]));
        hotTopicBroadcastConfig = make_shared<SubmitCustomHotTopicBroadcastJobRequestHotTopicBroadcastConfig>(model1);
      }
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Topics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Topics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      topics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobRequest() = default;
};
class SubmitCustomHotTopicBroadcastJobShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> hotTopicBroadcastConfigShrink{};
  shared_ptr<string> hotTopicVersion{};
  shared_ptr<string> topicsShrink{};
  shared_ptr<string> workspaceId{};

  SubmitCustomHotTopicBroadcastJobShrinkRequest() {}

  explicit SubmitCustomHotTopicBroadcastJobShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hotTopicBroadcastConfigShrink) {
      res["HotTopicBroadcastConfig"] = boost::any(*hotTopicBroadcastConfigShrink);
    }
    if (hotTopicVersion) {
      res["HotTopicVersion"] = boost::any(*hotTopicVersion);
    }
    if (topicsShrink) {
      res["Topics"] = boost::any(*topicsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HotTopicBroadcastConfig") != m.end() && !m["HotTopicBroadcastConfig"].empty()) {
      hotTopicBroadcastConfigShrink = make_shared<string>(boost::any_cast<string>(m["HotTopicBroadcastConfig"]));
    }
    if (m.find("HotTopicVersion") != m.end() && !m["HotTopicVersion"].empty()) {
      hotTopicVersion = make_shared<string>(boost::any_cast<string>(m["HotTopicVersion"]));
    }
    if (m.find("Topics") != m.end() && !m["Topics"].empty()) {
      topicsShrink = make_shared<string>(boost::any_cast<string>(m["Topics"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobShrinkRequest() = default;
};
class SubmitCustomHotTopicBroadcastJobResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  SubmitCustomHotTopicBroadcastJobResponseBodyData() {}

  explicit SubmitCustomHotTopicBroadcastJobResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobResponseBodyData() = default;
};
class SubmitCustomHotTopicBroadcastJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitCustomHotTopicBroadcastJobResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitCustomHotTopicBroadcastJobResponseBody() {}

  explicit SubmitCustomHotTopicBroadcastJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCustomHotTopicBroadcastJobResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCustomHotTopicBroadcastJobResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobResponseBody() = default;
};
class SubmitCustomHotTopicBroadcastJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCustomHotTopicBroadcastJobResponseBody> body{};

  SubmitCustomHotTopicBroadcastJobResponse() {}

  explicit SubmitCustomHotTopicBroadcastJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCustomHotTopicBroadcastJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCustomHotTopicBroadcastJobResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCustomHotTopicBroadcastJobResponse() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<string> content{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments>> documents{};
  shared_ptr<string> prompt{};
  shared_ptr<string> topic{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documents) {
      vector<boost::any> temp1;
      for(auto item1:*documents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Documents"] = boost::any(temp1);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      if (typeid(vector<boost::any>) == m["Documents"].type()) {
        vector<SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Documents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        documents = make_shared<vector<SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequestDocuments>>(expect1);
      }
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> documentsShrink{};
  shared_ptr<string> prompt{};
  shared_ptr<string> topic{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskShrinkRequest() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documentsShrink) {
      res["Documents"] = boost::any(*documentsShrink);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      documentsShrink = make_shared<string>(boost::any_cast<string>(m["Documents"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskShrinkRequest() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody() = default;
};
class SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody> body{};

  SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse() {}

  explicit SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse() = default;
};
class SubmitDocClusterTaskRequestDocuments : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> docId{};
  shared_ptr<string> title{};

  SubmitDocClusterTaskRequestDocuments() {}

  explicit SubmitDocClusterTaskRequestDocuments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~SubmitDocClusterTaskRequestDocuments() = default;
};
class SubmitDocClusterTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<SubmitDocClusterTaskRequestDocuments>> documents{};
  shared_ptr<long> summaryLength{};
  shared_ptr<long> titleLength{};
  shared_ptr<long> topicCount{};

  SubmitDocClusterTaskRequest() {}

  explicit SubmitDocClusterTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documents) {
      vector<boost::any> temp1;
      for(auto item1:*documents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Documents"] = boost::any(temp1);
    }
    if (summaryLength) {
      res["SummaryLength"] = boost::any(*summaryLength);
    }
    if (titleLength) {
      res["TitleLength"] = boost::any(*titleLength);
    }
    if (topicCount) {
      res["TopicCount"] = boost::any(*topicCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      if (typeid(vector<boost::any>) == m["Documents"].type()) {
        vector<SubmitDocClusterTaskRequestDocuments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Documents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitDocClusterTaskRequestDocuments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        documents = make_shared<vector<SubmitDocClusterTaskRequestDocuments>>(expect1);
      }
    }
    if (m.find("SummaryLength") != m.end() && !m["SummaryLength"].empty()) {
      summaryLength = make_shared<long>(boost::any_cast<long>(m["SummaryLength"]));
    }
    if (m.find("TitleLength") != m.end() && !m["TitleLength"].empty()) {
      titleLength = make_shared<long>(boost::any_cast<long>(m["TitleLength"]));
    }
    if (m.find("TopicCount") != m.end() && !m["TopicCount"].empty()) {
      topicCount = make_shared<long>(boost::any_cast<long>(m["TopicCount"]));
    }
  }


  virtual ~SubmitDocClusterTaskRequest() = default;
};
class SubmitDocClusterTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> documentsShrink{};
  shared_ptr<long> summaryLength{};
  shared_ptr<long> titleLength{};
  shared_ptr<long> topicCount{};

  SubmitDocClusterTaskShrinkRequest() {}

  explicit SubmitDocClusterTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documentsShrink) {
      res["Documents"] = boost::any(*documentsShrink);
    }
    if (summaryLength) {
      res["SummaryLength"] = boost::any(*summaryLength);
    }
    if (titleLength) {
      res["TitleLength"] = boost::any(*titleLength);
    }
    if (topicCount) {
      res["TopicCount"] = boost::any(*topicCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      documentsShrink = make_shared<string>(boost::any_cast<string>(m["Documents"]));
    }
    if (m.find("SummaryLength") != m.end() && !m["SummaryLength"].empty()) {
      summaryLength = make_shared<long>(boost::any_cast<long>(m["SummaryLength"]));
    }
    if (m.find("TitleLength") != m.end() && !m["TitleLength"].empty()) {
      titleLength = make_shared<long>(boost::any_cast<long>(m["TitleLength"]));
    }
    if (m.find("TopicCount") != m.end() && !m["TopicCount"].empty()) {
      topicCount = make_shared<long>(boost::any_cast<long>(m["TopicCount"]));
    }
  }


  virtual ~SubmitDocClusterTaskShrinkRequest() = default;
};
class SubmitDocClusterTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  SubmitDocClusterTaskResponseBodyData() {}

  explicit SubmitDocClusterTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitDocClusterTaskResponseBodyData() = default;
};
class SubmitDocClusterTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitDocClusterTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitDocClusterTaskResponseBody() {}

  explicit SubmitDocClusterTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitDocClusterTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitDocClusterTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitDocClusterTaskResponseBody() = default;
};
class SubmitDocClusterTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitDocClusterTaskResponseBody> body{};

  SubmitDocClusterTaskResponse() {}

  explicit SubmitDocClusterTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitDocClusterTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitDocClusterTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitDocClusterTaskResponse() = default;
};
class SubmitEnterpriseVocAnalysisTaskRequestContentTags : public Darabonba::Model {
public:
  shared_ptr<string> tagDefinePrompt{};
  shared_ptr<string> tagName{};
  shared_ptr<string> tagTaskType{};
  shared_ptr<string> tagValueDefinePrompt{};

  SubmitEnterpriseVocAnalysisTaskRequestContentTags() {}

  explicit SubmitEnterpriseVocAnalysisTaskRequestContentTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagDefinePrompt) {
      res["TagDefinePrompt"] = boost::any(*tagDefinePrompt);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagTaskType) {
      res["TagTaskType"] = boost::any(*tagTaskType);
    }
    if (tagValueDefinePrompt) {
      res["TagValueDefinePrompt"] = boost::any(*tagValueDefinePrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagDefinePrompt") != m.end() && !m["TagDefinePrompt"].empty()) {
      tagDefinePrompt = make_shared<string>(boost::any_cast<string>(m["TagDefinePrompt"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagTaskType") != m.end() && !m["TagTaskType"].empty()) {
      tagTaskType = make_shared<string>(boost::any_cast<string>(m["TagTaskType"]));
    }
    if (m.find("TagValueDefinePrompt") != m.end() && !m["TagValueDefinePrompt"].empty()) {
      tagValueDefinePrompt = make_shared<string>(boost::any_cast<string>(m["TagValueDefinePrompt"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskRequestContentTags() = default;
};
class SubmitEnterpriseVocAnalysisTaskRequestContents : public Darabonba::Model {
public:
  shared_ptr<string> extraInfo{};
  shared_ptr<string> text{};

  SubmitEnterpriseVocAnalysisTaskRequestContents() {}

  explicit SubmitEnterpriseVocAnalysisTaskRequestContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extraInfo) {
      res["ExtraInfo"] = boost::any(*extraInfo);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      extraInfo = make_shared<string>(boost::any_cast<string>(m["ExtraInfo"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskRequestContents() = default;
};
class SubmitEnterpriseVocAnalysisTaskRequestFilterTags : public Darabonba::Model {
public:
  shared_ptr<string> tagDefinePrompt{};
  shared_ptr<string> tagName{};
  shared_ptr<string> tagType{};
  shared_ptr<string> tagValueDefinePrompt{};

  SubmitEnterpriseVocAnalysisTaskRequestFilterTags() {}

  explicit SubmitEnterpriseVocAnalysisTaskRequestFilterTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagDefinePrompt) {
      res["TagDefinePrompt"] = boost::any(*tagDefinePrompt);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    if (tagType) {
      res["TagType"] = boost::any(*tagType);
    }
    if (tagValueDefinePrompt) {
      res["TagValueDefinePrompt"] = boost::any(*tagValueDefinePrompt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagDefinePrompt") != m.end() && !m["TagDefinePrompt"].empty()) {
      tagDefinePrompt = make_shared<string>(boost::any_cast<string>(m["TagDefinePrompt"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
    if (m.find("TagType") != m.end() && !m["TagType"].empty()) {
      tagType = make_shared<string>(boost::any_cast<string>(m["TagType"]));
    }
    if (m.find("TagValueDefinePrompt") != m.end() && !m["TagValueDefinePrompt"].empty()) {
      tagValueDefinePrompt = make_shared<string>(boost::any_cast<string>(m["TagValueDefinePrompt"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskRequestFilterTags() = default;
};
class SubmitEnterpriseVocAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiKey{};
  shared_ptr<vector<SubmitEnterpriseVocAnalysisTaskRequestContentTags>> contentTags{};
  shared_ptr<vector<SubmitEnterpriseVocAnalysisTaskRequestContents>> contents{};
  shared_ptr<string> fileKey{};
  shared_ptr<vector<SubmitEnterpriseVocAnalysisTaskRequestFilterTags>> filterTags{};
  shared_ptr<string> materialType{};
  shared_ptr<string> modelId{};
  shared_ptr<string> positiveSample{};
  shared_ptr<string> positiveSampleFileKey{};
  shared_ptr<string> taskType{};
  shared_ptr<string> workspaceId{};

  SubmitEnterpriseVocAnalysisTaskRequest() {}

  explicit SubmitEnterpriseVocAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiKey) {
      res["ApiKey"] = boost::any(*apiKey);
    }
    if (contentTags) {
      vector<boost::any> temp1;
      for(auto item1:*contentTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContentTags"] = boost::any(temp1);
    }
    if (contents) {
      vector<boost::any> temp1;
      for(auto item1:*contents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Contents"] = boost::any(temp1);
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (filterTags) {
      vector<boost::any> temp1;
      for(auto item1:*filterTags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilterTags"] = boost::any(temp1);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (positiveSample) {
      res["PositiveSample"] = boost::any(*positiveSample);
    }
    if (positiveSampleFileKey) {
      res["PositiveSampleFileKey"] = boost::any(*positiveSampleFileKey);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiKey") != m.end() && !m["ApiKey"].empty()) {
      apiKey = make_shared<string>(boost::any_cast<string>(m["ApiKey"]));
    }
    if (m.find("ContentTags") != m.end() && !m["ContentTags"].empty()) {
      if (typeid(vector<boost::any>) == m["ContentTags"].type()) {
        vector<SubmitEnterpriseVocAnalysisTaskRequestContentTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContentTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEnterpriseVocAnalysisTaskRequestContentTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contentTags = make_shared<vector<SubmitEnterpriseVocAnalysisTaskRequestContentTags>>(expect1);
      }
    }
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      if (typeid(vector<boost::any>) == m["Contents"].type()) {
        vector<SubmitEnterpriseVocAnalysisTaskRequestContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Contents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEnterpriseVocAnalysisTaskRequestContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contents = make_shared<vector<SubmitEnterpriseVocAnalysisTaskRequestContents>>(expect1);
      }
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FilterTags") != m.end() && !m["FilterTags"].empty()) {
      if (typeid(vector<boost::any>) == m["FilterTags"].type()) {
        vector<SubmitEnterpriseVocAnalysisTaskRequestFilterTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilterTags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitEnterpriseVocAnalysisTaskRequestFilterTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filterTags = make_shared<vector<SubmitEnterpriseVocAnalysisTaskRequestFilterTags>>(expect1);
      }
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("PositiveSample") != m.end() && !m["PositiveSample"].empty()) {
      positiveSample = make_shared<string>(boost::any_cast<string>(m["PositiveSample"]));
    }
    if (m.find("PositiveSampleFileKey") != m.end() && !m["PositiveSampleFileKey"].empty()) {
      positiveSampleFileKey = make_shared<string>(boost::any_cast<string>(m["PositiveSampleFileKey"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskRequest() = default;
};
class SubmitEnterpriseVocAnalysisTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiKey{};
  shared_ptr<string> contentTagsShrink{};
  shared_ptr<string> contentsShrink{};
  shared_ptr<string> fileKey{};
  shared_ptr<string> filterTagsShrink{};
  shared_ptr<string> materialType{};
  shared_ptr<string> modelId{};
  shared_ptr<string> positiveSample{};
  shared_ptr<string> positiveSampleFileKey{};
  shared_ptr<string> taskType{};
  shared_ptr<string> workspaceId{};

  SubmitEnterpriseVocAnalysisTaskShrinkRequest() {}

  explicit SubmitEnterpriseVocAnalysisTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiKey) {
      res["ApiKey"] = boost::any(*apiKey);
    }
    if (contentTagsShrink) {
      res["ContentTags"] = boost::any(*contentTagsShrink);
    }
    if (contentsShrink) {
      res["Contents"] = boost::any(*contentsShrink);
    }
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (filterTagsShrink) {
      res["FilterTags"] = boost::any(*filterTagsShrink);
    }
    if (materialType) {
      res["MaterialType"] = boost::any(*materialType);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (positiveSample) {
      res["PositiveSample"] = boost::any(*positiveSample);
    }
    if (positiveSampleFileKey) {
      res["PositiveSampleFileKey"] = boost::any(*positiveSampleFileKey);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiKey") != m.end() && !m["ApiKey"].empty()) {
      apiKey = make_shared<string>(boost::any_cast<string>(m["ApiKey"]));
    }
    if (m.find("ContentTags") != m.end() && !m["ContentTags"].empty()) {
      contentTagsShrink = make_shared<string>(boost::any_cast<string>(m["ContentTags"]));
    }
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contentsShrink = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("FilterTags") != m.end() && !m["FilterTags"].empty()) {
      filterTagsShrink = make_shared<string>(boost::any_cast<string>(m["FilterTags"]));
    }
    if (m.find("MaterialType") != m.end() && !m["MaterialType"].empty()) {
      materialType = make_shared<string>(boost::any_cast<string>(m["MaterialType"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("PositiveSample") != m.end() && !m["PositiveSample"].empty()) {
      positiveSample = make_shared<string>(boost::any_cast<string>(m["PositiveSample"]));
    }
    if (m.find("PositiveSampleFileKey") != m.end() && !m["PositiveSampleFileKey"].empty()) {
      positiveSampleFileKey = make_shared<string>(boost::any_cast<string>(m["PositiveSampleFileKey"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskShrinkRequest() = default;
};
class SubmitEnterpriseVocAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  SubmitEnterpriseVocAnalysisTaskResponseBodyData() {}

  explicit SubmitEnterpriseVocAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskResponseBodyData() = default;
};
class SubmitEnterpriseVocAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitEnterpriseVocAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitEnterpriseVocAnalysisTaskResponseBody() {}

  explicit SubmitEnterpriseVocAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitEnterpriseVocAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitEnterpriseVocAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskResponseBody() = default;
};
class SubmitEnterpriseVocAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitEnterpriseVocAnalysisTaskResponseBody> body{};

  SubmitEnterpriseVocAnalysisTaskResponse() {}

  explicit SubmitEnterpriseVocAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitEnterpriseVocAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitEnterpriseVocAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitEnterpriseVocAnalysisTaskResponse() = default;
};
class SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig : public Darabonba::Model {
public:
  shared_ptr<string> style{};
  shared_ptr<double> volume{};

  SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (style) {
      res["Style"] = boost::any(*style);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<double>(boost::any_cast<double>(m["Volume"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig() = default;
};
class SubmitSmartClipTaskRequestEditingConfigMediaConfig : public Darabonba::Model {
public:
  shared_ptr<double> volume{};

  SubmitSmartClipTaskRequestEditingConfigMediaConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfigMediaConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<double>(boost::any_cast<double>(m["Volume"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfigMediaConfig() = default;
};
class SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig : public Darabonba::Model {
public:
  shared_ptr<string> alignment{};
  shared_ptr<string> font{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontSize{};
  shared_ptr<string> spacing{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alignment) {
      res["Alignment"] = boost::any(*alignment);
    }
    if (font) {
      res["Font"] = boost::any(*font);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (spacing) {
      res["Spacing"] = boost::any(*spacing);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alignment") != m.end() && !m["Alignment"].empty()) {
      alignment = make_shared<string>(boost::any_cast<string>(m["Alignment"]));
    }
    if (m.find("Font") != m.end() && !m["Font"].empty()) {
      font = make_shared<string>(boost::any_cast<string>(m["Font"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<string>(boost::any_cast<string>(m["FontSize"]));
    }
    if (m.find("Spacing") != m.end() && !m["Spacing"].empty()) {
      spacing = make_shared<string>(boost::any_cast<string>(m["Spacing"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["Y"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig() = default;
};
class SubmitSmartClipTaskRequestEditingConfigSpeechConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig> asrConfig{};
  shared_ptr<double> speechRate{};
  shared_ptr<string> style{};
  shared_ptr<string> voice{};
  shared_ptr<double> volume{};

  SubmitSmartClipTaskRequestEditingConfigSpeechConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfigSpeechConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (asrConfig) {
      res["AsrConfig"] = asrConfig ? boost::any(asrConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speechRate) {
      res["SpeechRate"] = boost::any(*speechRate);
    }
    if (style) {
      res["Style"] = boost::any(*style);
    }
    if (voice) {
      res["Voice"] = boost::any(*voice);
    }
    if (volume) {
      res["Volume"] = boost::any(*volume);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AsrConfig") != m.end() && !m["AsrConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AsrConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AsrConfig"]));
        asrConfig = make_shared<SubmitSmartClipTaskRequestEditingConfigSpeechConfigAsrConfig>(model1);
      }
    }
    if (m.find("SpeechRate") != m.end() && !m["SpeechRate"].empty()) {
      speechRate = make_shared<double>(boost::any_cast<double>(m["SpeechRate"]));
    }
    if (m.find("Style") != m.end() && !m["Style"].empty()) {
      style = make_shared<string>(boost::any_cast<string>(m["Style"]));
    }
    if (m.find("Voice") != m.end() && !m["Voice"].empty()) {
      voice = make_shared<string>(boost::any_cast<string>(m["Voice"]));
    }
    if (m.find("Volume") != m.end() && !m["Volume"].empty()) {
      volume = make_shared<double>(boost::any_cast<double>(m["Volume"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfigSpeechConfig() = default;
};
class SubmitSmartClipTaskRequestEditingConfigTitleConfig : public Darabonba::Model {
public:
  shared_ptr<string> alignment{};
  shared_ptr<double> timelineIn{};
  shared_ptr<double> timelineOut{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  SubmitSmartClipTaskRequestEditingConfigTitleConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfigTitleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alignment) {
      res["Alignment"] = boost::any(*alignment);
    }
    if (timelineIn) {
      res["TimelineIn"] = boost::any(*timelineIn);
    }
    if (timelineOut) {
      res["TimelineOut"] = boost::any(*timelineOut);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alignment") != m.end() && !m["Alignment"].empty()) {
      alignment = make_shared<string>(boost::any_cast<string>(m["Alignment"]));
    }
    if (m.find("TimelineIn") != m.end() && !m["TimelineIn"].empty()) {
      timelineIn = make_shared<double>(boost::any_cast<double>(m["TimelineIn"]));
    }
    if (m.find("TimelineOut") != m.end() && !m["TimelineOut"].empty()) {
      timelineOut = make_shared<double>(boost::any_cast<double>(m["TimelineOut"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["Y"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfigTitleConfig() = default;
};
class SubmitSmartClipTaskRequestEditingConfig : public Darabonba::Model {
public:
  shared_ptr<SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig> backgroundMusicConfig{};
  shared_ptr<SubmitSmartClipTaskRequestEditingConfigMediaConfig> mediaConfig{};
  shared_ptr<SubmitSmartClipTaskRequestEditingConfigSpeechConfig> speechConfig{};
  shared_ptr<SubmitSmartClipTaskRequestEditingConfigTitleConfig> titleConfig{};

  SubmitSmartClipTaskRequestEditingConfig() {}

  explicit SubmitSmartClipTaskRequestEditingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundMusicConfig) {
      res["BackgroundMusicConfig"] = backgroundMusicConfig ? boost::any(backgroundMusicConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mediaConfig) {
      res["MediaConfig"] = mediaConfig ? boost::any(mediaConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speechConfig) {
      res["SpeechConfig"] = speechConfig ? boost::any(speechConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (titleConfig) {
      res["TitleConfig"] = titleConfig ? boost::any(titleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundMusicConfig") != m.end() && !m["BackgroundMusicConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackgroundMusicConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackgroundMusicConfig"]));
        backgroundMusicConfig = make_shared<SubmitSmartClipTaskRequestEditingConfigBackgroundMusicConfig>(model1);
      }
    }
    if (m.find("MediaConfig") != m.end() && !m["MediaConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MediaConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfigMediaConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MediaConfig"]));
        mediaConfig = make_shared<SubmitSmartClipTaskRequestEditingConfigMediaConfig>(model1);
      }
    }
    if (m.find("SpeechConfig") != m.end() && !m["SpeechConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpeechConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfigSpeechConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpeechConfig"]));
        speechConfig = make_shared<SubmitSmartClipTaskRequestEditingConfigSpeechConfig>(model1);
      }
    }
    if (m.find("TitleConfig") != m.end() && !m["TitleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["TitleConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfigTitleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TitleConfig"]));
        titleConfig = make_shared<SubmitSmartClipTaskRequestEditingConfigTitleConfig>(model1);
      }
    }
  }


  virtual ~SubmitSmartClipTaskRequestEditingConfig() = default;
};
class SubmitSmartClipTaskRequestInputConfigBackgroundMusics : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  SubmitSmartClipTaskRequestInputConfigBackgroundMusics() {}

  explicit SubmitSmartClipTaskRequestInputConfigBackgroundMusics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestInputConfigBackgroundMusics() = default;
};
class SubmitSmartClipTaskRequestInputConfigStickersStickerId : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  SubmitSmartClipTaskRequestInputConfigStickersStickerId() {}

  explicit SubmitSmartClipTaskRequestInputConfigStickersStickerId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestInputConfigStickersStickerId() = default;
};
class SubmitSmartClipTaskRequestInputConfigStickers : public Darabonba::Model {
public:
  shared_ptr<double> height{};
  shared_ptr<SubmitSmartClipTaskRequestInputConfigStickersStickerId> stickerId{};
  shared_ptr<double> width{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  SubmitSmartClipTaskRequestInputConfigStickers() {}

  explicit SubmitSmartClipTaskRequestInputConfigStickers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (stickerId) {
      res["StickerId"] = stickerId ? boost::any(stickerId->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("StickerId") != m.end() && !m["StickerId"].empty()) {
      if (typeid(map<string, boost::any>) == m["StickerId"].type()) {
        SubmitSmartClipTaskRequestInputConfigStickersStickerId model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StickerId"]));
        stickerId = make_shared<SubmitSmartClipTaskRequestInputConfigStickersStickerId>(model1);
      }
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["Y"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestInputConfigStickers() = default;
};
class SubmitSmartClipTaskRequestInputConfigVideoIds : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  SubmitSmartClipTaskRequestInputConfigVideoIds() {}

  explicit SubmitSmartClipTaskRequestInputConfigVideoIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestInputConfigVideoIds() = default;
};
class SubmitSmartClipTaskRequestInputConfig : public Darabonba::Model {
public:
  shared_ptr<vector<SubmitSmartClipTaskRequestInputConfigBackgroundMusics>> backgroundMusics{};
  shared_ptr<vector<string>> speechTexts{};
  shared_ptr<vector<SubmitSmartClipTaskRequestInputConfigStickers>> stickers{};
  shared_ptr<vector<string>> titles{};
  shared_ptr<vector<SubmitSmartClipTaskRequestInputConfigVideoIds>> videoIds{};

  SubmitSmartClipTaskRequestInputConfig() {}

  explicit SubmitSmartClipTaskRequestInputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backgroundMusics) {
      vector<boost::any> temp1;
      for(auto item1:*backgroundMusics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackgroundMusics"] = boost::any(temp1);
    }
    if (speechTexts) {
      res["SpeechTexts"] = boost::any(*speechTexts);
    }
    if (stickers) {
      vector<boost::any> temp1;
      for(auto item1:*stickers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stickers"] = boost::any(temp1);
    }
    if (titles) {
      res["Titles"] = boost::any(*titles);
    }
    if (videoIds) {
      vector<boost::any> temp1;
      for(auto item1:*videoIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoIds"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackgroundMusics") != m.end() && !m["BackgroundMusics"].empty()) {
      if (typeid(vector<boost::any>) == m["BackgroundMusics"].type()) {
        vector<SubmitSmartClipTaskRequestInputConfigBackgroundMusics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackgroundMusics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSmartClipTaskRequestInputConfigBackgroundMusics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backgroundMusics = make_shared<vector<SubmitSmartClipTaskRequestInputConfigBackgroundMusics>>(expect1);
      }
    }
    if (m.find("SpeechTexts") != m.end() && !m["SpeechTexts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpeechTexts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpeechTexts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      speechTexts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Stickers") != m.end() && !m["Stickers"].empty()) {
      if (typeid(vector<boost::any>) == m["Stickers"].type()) {
        vector<SubmitSmartClipTaskRequestInputConfigStickers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stickers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSmartClipTaskRequestInputConfigStickers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stickers = make_shared<vector<SubmitSmartClipTaskRequestInputConfigStickers>>(expect1);
      }
    }
    if (m.find("Titles") != m.end() && !m["Titles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Titles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Titles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      titles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VideoIds") != m.end() && !m["VideoIds"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoIds"].type()) {
        vector<SubmitSmartClipTaskRequestInputConfigVideoIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitSmartClipTaskRequestInputConfigVideoIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoIds = make_shared<vector<SubmitSmartClipTaskRequestInputConfigVideoIds>>(expect1);
      }
    }
  }


  virtual ~SubmitSmartClipTaskRequestInputConfig() = default;
};
class SubmitSmartClipTaskRequestOutputConfig : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> fileName{};
  shared_ptr<long> height{};
  shared_ptr<long> maxDuration{};
  shared_ptr<bool> saveToGeneratedContent{};
  shared_ptr<long> width{};

  SubmitSmartClipTaskRequestOutputConfig() {}

  explicit SubmitSmartClipTaskRequestOutputConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (maxDuration) {
      res["MaxDuration"] = boost::any(*maxDuration);
    }
    if (saveToGeneratedContent) {
      res["SaveToGeneratedContent"] = boost::any(*saveToGeneratedContent);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("MaxDuration") != m.end() && !m["MaxDuration"].empty()) {
      maxDuration = make_shared<long>(boost::any_cast<long>(m["MaxDuration"]));
    }
    if (m.find("SaveToGeneratedContent") != m.end() && !m["SaveToGeneratedContent"].empty()) {
      saveToGeneratedContent = make_shared<bool>(boost::any_cast<bool>(m["SaveToGeneratedContent"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequestOutputConfig() = default;
};
class SubmitSmartClipTaskRequest : public Darabonba::Model {
public:
  shared_ptr<SubmitSmartClipTaskRequestEditingConfig> editingConfig{};
  shared_ptr<string> extendParam{};
  shared_ptr<SubmitSmartClipTaskRequestInputConfig> inputConfig{};
  shared_ptr<SubmitSmartClipTaskRequestOutputConfig> outputConfig{};
  shared_ptr<string> workspaceId{};

  SubmitSmartClipTaskRequest() {}

  explicit SubmitSmartClipTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingConfig) {
      res["EditingConfig"] = editingConfig ? boost::any(editingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (extendParam) {
      res["ExtendParam"] = boost::any(*extendParam);
    }
    if (inputConfig) {
      res["InputConfig"] = inputConfig ? boost::any(inputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outputConfig) {
      res["OutputConfig"] = outputConfig ? boost::any(outputConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EditingConfig"].type()) {
        SubmitSmartClipTaskRequestEditingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EditingConfig"]));
        editingConfig = make_shared<SubmitSmartClipTaskRequestEditingConfig>(model1);
      }
    }
    if (m.find("ExtendParam") != m.end() && !m["ExtendParam"].empty()) {
      extendParam = make_shared<string>(boost::any_cast<string>(m["ExtendParam"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["InputConfig"].type()) {
        SubmitSmartClipTaskRequestInputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InputConfig"]));
        inputConfig = make_shared<SubmitSmartClipTaskRequestInputConfig>(model1);
      }
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutputConfig"].type()) {
        SubmitSmartClipTaskRequestOutputConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutputConfig"]));
        outputConfig = make_shared<SubmitSmartClipTaskRequestOutputConfig>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitSmartClipTaskRequest() = default;
};
class SubmitSmartClipTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> editingConfigShrink{};
  shared_ptr<string> extendParam{};
  shared_ptr<string> inputConfigShrink{};
  shared_ptr<string> outputConfigShrink{};
  shared_ptr<string> workspaceId{};

  SubmitSmartClipTaskShrinkRequest() {}

  explicit SubmitSmartClipTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (editingConfigShrink) {
      res["EditingConfig"] = boost::any(*editingConfigShrink);
    }
    if (extendParam) {
      res["ExtendParam"] = boost::any(*extendParam);
    }
    if (inputConfigShrink) {
      res["InputConfig"] = boost::any(*inputConfigShrink);
    }
    if (outputConfigShrink) {
      res["OutputConfig"] = boost::any(*outputConfigShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EditingConfig") != m.end() && !m["EditingConfig"].empty()) {
      editingConfigShrink = make_shared<string>(boost::any_cast<string>(m["EditingConfig"]));
    }
    if (m.find("ExtendParam") != m.end() && !m["ExtendParam"].empty()) {
      extendParam = make_shared<string>(boost::any_cast<string>(m["ExtendParam"]));
    }
    if (m.find("InputConfig") != m.end() && !m["InputConfig"].empty()) {
      inputConfigShrink = make_shared<string>(boost::any_cast<string>(m["InputConfig"]));
    }
    if (m.find("OutputConfig") != m.end() && !m["OutputConfig"].empty()) {
      outputConfigShrink = make_shared<string>(boost::any_cast<string>(m["OutputConfig"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~SubmitSmartClipTaskShrinkRequest() = default;
};
class SubmitSmartClipTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};

  SubmitSmartClipTaskResponseBodyData() {}

  explicit SubmitSmartClipTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~SubmitSmartClipTaskResponseBodyData() = default;
};
class SubmitSmartClipTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitSmartClipTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitSmartClipTaskResponseBody() {}

  explicit SubmitSmartClipTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitSmartClipTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitSmartClipTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitSmartClipTaskResponseBody() = default;
};
class SubmitSmartClipTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitSmartClipTaskResponseBody> body{};

  SubmitSmartClipTaskResponse() {}

  explicit SubmitSmartClipTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitSmartClipTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitSmartClipTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitSmartClipTaskResponse() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments : public Darabonba::Model {
public:
  shared_ptr<string> text{};
  shared_ptr<string> username{};

  SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments : public Darabonba::Model {
public:
  shared_ptr<string> author{};
  shared_ptr<vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments>> comments{};
  shared_ptr<string> content{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (comments) {
      vector<boost::any> temp1;
      for(auto item1:*comments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Comments"] = boost::any(temp1);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("Comments") != m.end() && !m["Comments"].empty()) {
      if (typeid(vector<boost::any>) == m["Comments"].type()) {
        vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Comments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        comments = make_shared<vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocumentsComments>>(expect1);
      }
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments>> documents{};
  shared_ptr<vector<string>> perspectiveTypes{};
  shared_ptr<string> topic{};

  SubmitTopicSelectionPerspectiveAnalysisTaskRequest() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documents) {
      vector<boost::any> temp1;
      for(auto item1:*documents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Documents"] = boost::any(temp1);
    }
    if (perspectiveTypes) {
      res["PerspectiveTypes"] = boost::any(*perspectiveTypes);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      if (typeid(vector<boost::any>) == m["Documents"].type()) {
        vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Documents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        documents = make_shared<vector<SubmitTopicSelectionPerspectiveAnalysisTaskRequestDocuments>>(expect1);
      }
    }
    if (m.find("PerspectiveTypes") != m.end() && !m["PerspectiveTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PerspectiveTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PerspectiveTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      perspectiveTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskRequest() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> documentsShrink{};
  shared_ptr<string> perspectiveTypesShrink{};
  shared_ptr<string> topic{};

  SubmitTopicSelectionPerspectiveAnalysisTaskShrinkRequest() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (documentsShrink) {
      res["Documents"] = boost::any(*documentsShrink);
    }
    if (perspectiveTypesShrink) {
      res["PerspectiveTypes"] = boost::any(*perspectiveTypesShrink);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Documents") != m.end() && !m["Documents"].empty()) {
      documentsShrink = make_shared<string>(boost::any_cast<string>(m["Documents"]));
    }
    if (m.find("PerspectiveTypes") != m.end() && !m["PerspectiveTypes"].empty()) {
      perspectiveTypesShrink = make_shared<string>(boost::any_cast<string>(m["PerspectiveTypes"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskShrinkRequest() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SubmitTopicSelectionPerspectiveAnalysisTaskResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody() = default;
};
class SubmitTopicSelectionPerspectiveAnalysisTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody> body{};

  SubmitTopicSelectionPerspectiveAnalysisTaskResponse() {}

  explicit SubmitTopicSelectionPerspectiveAnalysisTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitTopicSelectionPerspectiveAnalysisTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitTopicSelectionPerspectiveAnalysisTaskResponse() = default;
};
class UpdateCustomTextRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> commodityCode{};
  shared_ptr<string> content{};
  shared_ptr<long> id{};
  shared_ptr<string> title{};

  UpdateCustomTextRequest() {}

  explicit UpdateCustomTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateCustomTextRequest() = default;
};
class UpdateCustomTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateCustomTextResponseBody() {}

  explicit UpdateCustomTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateCustomTextResponseBody() = default;
};
class UpdateCustomTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomTextResponseBody> body{};

  UpdateCustomTextResponse() {}

  explicit UpdateCustomTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomTextResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomTextResponse() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueFormat{};
  shared_ptr<string> valueType{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueFormat) {
      res["ValueFormat"] = boost::any(*valueFormat);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueFormat") != m.end() && !m["ValueFormat"].empty()) {
      valueFormat = make_shared<string>(boost::any_cast<string>(m["ValueFormat"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<long> connectTimeout{};
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>> headers{};
  shared_ptr<string> method{};
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>> params{};
  shared_ptr<bool> pathParamsEnable{};
  shared_ptr<long> socketTimeout{};
  shared_ptr<string> url{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["Body"] = boost::any(*body);
    }
    if (connectTimeout) {
      res["ConnectTimeout"] = boost::any(*connectTimeout);
    }
    if (headers) {
      vector<boost::any> temp1;
      for(auto item1:*headers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Headers"] = boost::any(temp1);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (params) {
      vector<boost::any> temp1;
      for(auto item1:*params){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Params"] = boost::any(temp1);
    }
    if (pathParamsEnable) {
      res["PathParamsEnable"] = boost::any(*pathParamsEnable);
    }
    if (socketTimeout) {
      res["SocketTimeout"] = boost::any(*socketTimeout);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Body") != m.end() && !m["Body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["Body"]));
    }
    if (m.find("ConnectTimeout") != m.end() && !m["ConnectTimeout"].empty()) {
      connectTimeout = make_shared<long>(boost::any_cast<long>(m["ConnectTimeout"]));
    }
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(vector<boost::any>) == m["Headers"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Headers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        headers = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigHeaders>>(expect1);
      }
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Params"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        params = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfigParams>>(expect1);
      }
    }
    if (m.find("PathParamsEnable") != m.end() && !m["PathParamsEnable"].empty()) {
      pathParamsEnable = make_shared<bool>(boost::any_cast<bool>(m["PathParamsEnable"]));
    }
    if (m.find("SocketTimeout") != m.end() && !m["SocketTimeout"].empty()) {
      socketTimeout = make_shared<long>(boost::any_cast<long>(m["SocketTimeout"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>> jqNodes{};
  shared_ptr<string> key{};
  shared_ptr<string> path{};
  shared_ptr<string> type{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodesJqNodes>>(expect1);
      }
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>> jqNodes{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jqNodes) {
      vector<boost::any> temp1;
      for(auto item1:*jqNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["JqNodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JqNodes") != m.end() && !m["JqNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["JqNodes"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["JqNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        jqNodes = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfigJqNodes>>(expect1);
      }
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig() = default;
};
class UpdateDatasetRequestDatasetConfigSearchSourceConfigs : public Darabonba::Model {
public:
  shared_ptr<string> demoQuery{};
  shared_ptr<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig> searchSourceRequestConfig{};
  shared_ptr<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig> searchSourceResponseConfig{};
  shared_ptr<long> size{};

  UpdateDatasetRequestDatasetConfigSearchSourceConfigs() {}

  explicit UpdateDatasetRequestDatasetConfigSearchSourceConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoQuery) {
      res["DemoQuery"] = boost::any(*demoQuery);
    }
    if (searchSourceRequestConfig) {
      res["SearchSourceRequestConfig"] = searchSourceRequestConfig ? boost::any(searchSourceRequestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (searchSourceResponseConfig) {
      res["SearchSourceResponseConfig"] = searchSourceResponseConfig ? boost::any(searchSourceResponseConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoQuery") != m.end() && !m["DemoQuery"].empty()) {
      demoQuery = make_shared<string>(boost::any_cast<string>(m["DemoQuery"]));
    }
    if (m.find("SearchSourceRequestConfig") != m.end() && !m["SearchSourceRequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceRequestConfig"].type()) {
        UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceRequestConfig"]));
        searchSourceRequestConfig = make_shared<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceRequestConfig>(model1);
      }
    }
    if (m.find("SearchSourceResponseConfig") != m.end() && !m["SearchSourceResponseConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchSourceResponseConfig"].type()) {
        UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchSourceResponseConfig"]));
        searchSourceResponseConfig = make_shared<UpdateDatasetRequestDatasetConfigSearchSourceConfigsSearchSourceResponseConfig>(model1);
      }
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfigSearchSourceConfigs() = default;
};
class UpdateDatasetRequestDatasetConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigs>> searchSourceConfigs{};

  UpdateDatasetRequestDatasetConfig() {}

  explicit UpdateDatasetRequestDatasetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (searchSourceConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*searchSourceConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SearchSourceConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SearchSourceConfigs") != m.end() && !m["SearchSourceConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SearchSourceConfigs"].type()) {
        vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SearchSourceConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetRequestDatasetConfigSearchSourceConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        searchSourceConfigs = make_shared<vector<UpdateDatasetRequestDatasetConfigSearchSourceConfigs>>(expect1);
      }
    }
  }


  virtual ~UpdateDatasetRequestDatasetConfig() = default;
};
class UpdateDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateDatasetRequestDatasetConfig> datasetConfig{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<long> searchDatasetEnable{};
  shared_ptr<string> workspaceId{};

  UpdateDatasetRequest() {}

  explicit UpdateDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetConfig) {
      res["DatasetConfig"] = datasetConfig ? boost::any(datasetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetConfig") != m.end() && !m["DatasetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatasetConfig"].type()) {
        UpdateDatasetRequestDatasetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatasetConfig"]));
        datasetConfig = make_shared<UpdateDatasetRequestDatasetConfig>(model1);
      }
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateDatasetRequest() = default;
};
class UpdateDatasetShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetConfigShrink{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<long> searchDatasetEnable{};
  shared_ptr<string> workspaceId{};

  UpdateDatasetShrinkRequest() {}

  explicit UpdateDatasetShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetConfigShrink) {
      res["DatasetConfig"] = boost::any(*datasetConfigShrink);
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetConfig") != m.end() && !m["DatasetConfig"].empty()) {
      datasetConfigShrink = make_shared<string>(boost::any_cast<string>(m["DatasetConfig"]));
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateDatasetShrinkRequest() = default;
};
class UpdateDatasetResponseBodyDataNewsArticleResultsData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> source{};
  shared_ptr<string> summary{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  UpdateDatasetResponseBodyDataNewsArticleResultsData() {}

  explicit UpdateDatasetResponseBodyDataNewsArticleResultsData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateDatasetResponseBodyDataNewsArticleResultsData() = default;
};
class UpdateDatasetResponseBodyDataNewsArticleResults : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> current{};
  shared_ptr<vector<UpdateDatasetResponseBodyDataNewsArticleResultsData>> data{};
  shared_ptr<string> message{};
  shared_ptr<long> size{};
  shared_ptr<long> total{};

  UpdateDatasetResponseBodyDataNewsArticleResults() {}

  explicit UpdateDatasetResponseBodyDataNewsArticleResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<UpdateDatasetResponseBodyDataNewsArticleResultsData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetResponseBodyDataNewsArticleResultsData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<UpdateDatasetResponseBodyDataNewsArticleResultsData>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~UpdateDatasetResponseBodyDataNewsArticleResults() = default;
};
class UpdateDatasetResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> createUser{};
  shared_ptr<string> datasetDescription{};
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<vector<UpdateDatasetResponseBodyDataNewsArticleResults>> newsArticleResults{};
  shared_ptr<long> searchDatasetEnable{};

  UpdateDatasetResponseBodyData() {}

  explicit UpdateDatasetResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (createUser) {
      res["CreateUser"] = boost::any(*createUser);
    }
    if (datasetDescription) {
      res["DatasetDescription"] = boost::any(*datasetDescription);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (newsArticleResults) {
      vector<boost::any> temp1;
      for(auto item1:*newsArticleResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NewsArticleResults"] = boost::any(temp1);
    }
    if (searchDatasetEnable) {
      res["SearchDatasetEnable"] = boost::any(*searchDatasetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CreateUser") != m.end() && !m["CreateUser"].empty()) {
      createUser = make_shared<string>(boost::any_cast<string>(m["CreateUser"]));
    }
    if (m.find("DatasetDescription") != m.end() && !m["DatasetDescription"].empty()) {
      datasetDescription = make_shared<string>(boost::any_cast<string>(m["DatasetDescription"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("NewsArticleResults") != m.end() && !m["NewsArticleResults"].empty()) {
      if (typeid(vector<boost::any>) == m["NewsArticleResults"].type()) {
        vector<UpdateDatasetResponseBodyDataNewsArticleResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NewsArticleResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDatasetResponseBodyDataNewsArticleResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        newsArticleResults = make_shared<vector<UpdateDatasetResponseBodyDataNewsArticleResults>>(expect1);
      }
    }
    if (m.find("SearchDatasetEnable") != m.end() && !m["SearchDatasetEnable"].empty()) {
      searchDatasetEnable = make_shared<long>(boost::any_cast<long>(m["SearchDatasetEnable"]));
    }
  }


  virtual ~UpdateDatasetResponseBodyData() = default;
};
class UpdateDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateDatasetResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDatasetResponseBody() {}

  explicit UpdateDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateDatasetResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateDatasetResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDatasetResponseBody() = default;
};
class UpdateDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDatasetResponseBody> body{};

  UpdateDatasetResponse() {}

  explicit UpdateDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDatasetResponse() = default;
};
class UpdateDatasetDocumentRequestDocument : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> title{};

  UpdateDatasetDocumentRequestDocument() {}

  explicit UpdateDatasetDocumentRequestDocument(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateDatasetDocumentRequestDocument() = default;
};
class UpdateDatasetDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<UpdateDatasetDocumentRequestDocument> document{};
  shared_ptr<string> workspaceId{};

  UpdateDatasetDocumentRequest() {}

  explicit UpdateDatasetDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (document) {
      res["Document"] = document ? boost::any(document->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Document") != m.end() && !m["Document"].empty()) {
      if (typeid(map<string, boost::any>) == m["Document"].type()) {
        UpdateDatasetDocumentRequestDocument model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Document"]));
        document = make_shared<UpdateDatasetDocumentRequestDocument>(model1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateDatasetDocumentRequest() = default;
};
class UpdateDatasetDocumentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> documentShrink{};
  shared_ptr<string> workspaceId{};

  UpdateDatasetDocumentShrinkRequest() {}

  explicit UpdateDatasetDocumentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (documentShrink) {
      res["Document"] = boost::any(*documentShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<long>(boost::any_cast<long>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Document") != m.end() && !m["Document"].empty()) {
      documentShrink = make_shared<string>(boost::any_cast<string>(m["Document"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UpdateDatasetDocumentShrinkRequest() = default;
};
class UpdateDatasetDocumentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> docId{};
  shared_ptr<string> docUuid{};
  shared_ptr<string> title{};

  UpdateDatasetDocumentResponseBodyData() {}

  explicit UpdateDatasetDocumentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docId) {
      res["DocId"] = boost::any(*docId);
    }
    if (docUuid) {
      res["DocUuid"] = boost::any(*docUuid);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocId") != m.end() && !m["DocId"].empty()) {
      docId = make_shared<string>(boost::any_cast<string>(m["DocId"]));
    }
    if (m.find("DocUuid") != m.end() && !m["DocUuid"].empty()) {
      docUuid = make_shared<string>(boost::any_cast<string>(m["DocUuid"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateDatasetDocumentResponseBodyData() = default;
};
class UpdateDatasetDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UpdateDatasetDocumentResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDatasetDocumentResponseBody() {}

  explicit UpdateDatasetDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UpdateDatasetDocumentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UpdateDatasetDocumentResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDatasetDocumentResponseBody() = default;
};
class UpdateDatasetDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDatasetDocumentResponseBody> body{};

  UpdateDatasetDocumentResponse() {}

  explicit UpdateDatasetDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDatasetDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDatasetDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDatasetDocumentResponse() = default;
};
class UpdateGeneratedContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> contentText{};
  shared_ptr<long> id{};
  shared_ptr<vector<string>> keywords{};
  shared_ptr<string> prompt{};
  shared_ptr<string> title{};

  UpdateGeneratedContentRequest() {}

  explicit UpdateGeneratedContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateGeneratedContentRequest() = default;
};
class UpdateGeneratedContentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> content{};
  shared_ptr<string> contentText{};
  shared_ptr<long> id{};
  shared_ptr<string> keywordsShrink{};
  shared_ptr<string> prompt{};
  shared_ptr<string> title{};

  UpdateGeneratedContentShrinkRequest() {}

  explicit UpdateGeneratedContentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentText) {
      res["ContentText"] = boost::any(*contentText);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (keywordsShrink) {
      res["Keywords"] = boost::any(*keywordsShrink);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentText") != m.end() && !m["ContentText"].empty()) {
      contentText = make_shared<string>(boost::any_cast<string>(m["ContentText"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywordsShrink = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateGeneratedContentShrinkRequest() = default;
};
class UpdateGeneratedContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateGeneratedContentResponseBody() {}

  explicit UpdateGeneratedContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGeneratedContentResponseBody() = default;
};
class UpdateGeneratedContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGeneratedContentResponseBody> body{};

  UpdateGeneratedContentResponse() {}

  explicit UpdateGeneratedContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGeneratedContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGeneratedContentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGeneratedContentResponse() = default;
};
class UpdateMaterialDocumentRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> author{};
  shared_ptr<vector<string>> docKeywords{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<long> id{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  UpdateMaterialDocumentRequest() {}

  explicit UpdateMaterialDocumentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (docKeywords) {
      res["DocKeywords"] = boost::any(*docKeywords);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocKeywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocKeywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docKeywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateMaterialDocumentRequest() = default;
};
class UpdateMaterialDocumentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentKey{};
  shared_ptr<string> author{};
  shared_ptr<string> docKeywordsShrink{};
  shared_ptr<string> docType{};
  shared_ptr<string> externalUrl{};
  shared_ptr<string> htmlContent{};
  shared_ptr<long> id{};
  shared_ptr<string> pubTime{};
  shared_ptr<string> regionId{};
  shared_ptr<long> shareAttr{};
  shared_ptr<string> srcFrom{};
  shared_ptr<string> summary{};
  shared_ptr<string> textContent{};
  shared_ptr<string> title{};
  shared_ptr<string> url{};

  UpdateMaterialDocumentShrinkRequest() {}

  explicit UpdateMaterialDocumentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentKey) {
      res["AgentKey"] = boost::any(*agentKey);
    }
    if (author) {
      res["Author"] = boost::any(*author);
    }
    if (docKeywordsShrink) {
      res["DocKeywords"] = boost::any(*docKeywordsShrink);
    }
    if (docType) {
      res["DocType"] = boost::any(*docType);
    }
    if (externalUrl) {
      res["ExternalUrl"] = boost::any(*externalUrl);
    }
    if (htmlContent) {
      res["HtmlContent"] = boost::any(*htmlContent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (pubTime) {
      res["PubTime"] = boost::any(*pubTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (shareAttr) {
      res["ShareAttr"] = boost::any(*shareAttr);
    }
    if (srcFrom) {
      res["SrcFrom"] = boost::any(*srcFrom);
    }
    if (summary) {
      res["Summary"] = boost::any(*summary);
    }
    if (textContent) {
      res["TextContent"] = boost::any(*textContent);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentKey") != m.end() && !m["AgentKey"].empty()) {
      agentKey = make_shared<string>(boost::any_cast<string>(m["AgentKey"]));
    }
    if (m.find("Author") != m.end() && !m["Author"].empty()) {
      author = make_shared<string>(boost::any_cast<string>(m["Author"]));
    }
    if (m.find("DocKeywords") != m.end() && !m["DocKeywords"].empty()) {
      docKeywordsShrink = make_shared<string>(boost::any_cast<string>(m["DocKeywords"]));
    }
    if (m.find("DocType") != m.end() && !m["DocType"].empty()) {
      docType = make_shared<string>(boost::any_cast<string>(m["DocType"]));
    }
    if (m.find("ExternalUrl") != m.end() && !m["ExternalUrl"].empty()) {
      externalUrl = make_shared<string>(boost::any_cast<string>(m["ExternalUrl"]));
    }
    if (m.find("HtmlContent") != m.end() && !m["HtmlContent"].empty()) {
      htmlContent = make_shared<string>(boost::any_cast<string>(m["HtmlContent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PubTime") != m.end() && !m["PubTime"].empty()) {
      pubTime = make_shared<string>(boost::any_cast<string>(m["PubTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ShareAttr") != m.end() && !m["ShareAttr"].empty()) {
      shareAttr = make_shared<long>(boost::any_cast<long>(m["ShareAttr"]));
    }
    if (m.find("SrcFrom") != m.end() && !m["SrcFrom"].empty()) {
      srcFrom = make_shared<string>(boost::any_cast<string>(m["SrcFrom"]));
    }
    if (m.find("Summary") != m.end() && !m["Summary"].empty()) {
      summary = make_shared<string>(boost::any_cast<string>(m["Summary"]));
    }
    if (m.find("TextContent") != m.end() && !m["TextContent"].empty()) {
      textContent = make_shared<string>(boost::any_cast<string>(m["TextContent"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~UpdateMaterialDocumentShrinkRequest() = default;
};
class UpdateMaterialDocumentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateMaterialDocumentResponseBody() {}

  explicit UpdateMaterialDocumentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateMaterialDocumentResponseBody() = default;
};
class UpdateMaterialDocumentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMaterialDocumentResponseBody> body{};

  UpdateMaterialDocumentResponse() {}

  explicit UpdateMaterialDocumentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMaterialDocumentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMaterialDocumentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMaterialDocumentResponse() = default;
};
class UploadBookRequestDocs : public Darabonba::Model {
public:
  shared_ptr<string> docName{};
  shared_ptr<string> fileUrl{};

  UploadBookRequestDocs() {}

  explicit UploadBookRequestDocs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~UploadBookRequestDocs() = default;
};
class UploadBookRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<vector<UploadBookRequestDocs>> docs{};
  shared_ptr<string> workspaceId{};

  UploadBookRequest() {}

  explicit UploadBookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docs) {
      vector<boost::any> temp1;
      for(auto item1:*docs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Docs"] = boost::any(temp1);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Docs") != m.end() && !m["Docs"].empty()) {
      if (typeid(vector<boost::any>) == m["Docs"].type()) {
        vector<UploadBookRequestDocs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Docs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UploadBookRequestDocs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        docs = make_shared<vector<UploadBookRequestDocs>>(expect1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadBookRequest() = default;
};
class UploadBookShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docsShrink{};
  shared_ptr<string> workspaceId{};

  UploadBookShrinkRequest() {}

  explicit UploadBookShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docsShrink) {
      res["Docs"] = boost::any(*docsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Docs") != m.end() && !m["Docs"].empty()) {
      docsShrink = make_shared<string>(boost::any_cast<string>(m["Docs"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadBookShrinkRequest() = default;
};
class UploadBookResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> docIds{};
  shared_ptr<vector<string>> existedIds{};

  UploadBookResponseBodyData() {}

  explicit UploadBookResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (existedIds) {
      res["ExistedIds"] = boost::any(*existedIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExistedIds") != m.end() && !m["ExistedIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExistedIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExistedIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      existedIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UploadBookResponseBodyData() = default;
};
class UploadBookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UploadBookResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UploadBookResponseBody() {}

  explicit UploadBookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UploadBookResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UploadBookResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadBookResponseBody() = default;
};
class UploadBookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadBookResponseBody> body{};

  UploadBookResponse() {}

  explicit UploadBookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadBookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadBookResponseBody>(model1);
      }
    }
  }


  virtual ~UploadBookResponse() = default;
};
class UploadDocRequestDocs : public Darabonba::Model {
public:
  shared_ptr<string> docName{};
  shared_ptr<string> fileUrl{};

  UploadDocRequestDocs() {}

  explicit UploadDocRequestDocs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docName) {
      res["DocName"] = boost::any(*docName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocName") != m.end() && !m["DocName"].empty()) {
      docName = make_shared<string>(boost::any_cast<string>(m["DocName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~UploadDocRequestDocs() = default;
};
class UploadDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<vector<UploadDocRequestDocs>> docs{};
  shared_ptr<string> workspaceId{};

  UploadDocRequest() {}

  explicit UploadDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docs) {
      vector<boost::any> temp1;
      for(auto item1:*docs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Docs"] = boost::any(temp1);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Docs") != m.end() && !m["Docs"].empty()) {
      if (typeid(vector<boost::any>) == m["Docs"].type()) {
        vector<UploadDocRequestDocs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Docs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UploadDocRequestDocs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        docs = make_shared<vector<UploadDocRequestDocs>>(expect1);
      }
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadDocRequest() = default;
};
class UploadDocShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> categoryId{};
  shared_ptr<string> docsShrink{};
  shared_ptr<string> workspaceId{};

  UploadDocShrinkRequest() {}

  explicit UploadDocShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryId) {
      res["CategoryId"] = boost::any(*categoryId);
    }
    if (docsShrink) {
      res["Docs"] = boost::any(*docsShrink);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryId") != m.end() && !m["CategoryId"].empty()) {
      categoryId = make_shared<string>(boost::any_cast<string>(m["CategoryId"]));
    }
    if (m.find("Docs") != m.end() && !m["Docs"].empty()) {
      docsShrink = make_shared<string>(boost::any_cast<string>(m["Docs"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~UploadDocShrinkRequest() = default;
};
class UploadDocResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> docIds{};
  shared_ptr<vector<string>> existedIds{};

  UploadDocResponseBodyData() {}

  explicit UploadDocResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (docIds) {
      res["DocIds"] = boost::any(*docIds);
    }
    if (existedIds) {
      res["ExistedIds"] = boost::any(*existedIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocIds") != m.end() && !m["DocIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DocIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DocIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      docIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExistedIds") != m.end() && !m["ExistedIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExistedIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExistedIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      existedIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UploadDocResponseBodyData() = default;
};
class UploadDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UploadDocResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UploadDocResponseBody() {}

  explicit UploadDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UploadDocResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UploadDocResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UploadDocResponseBody() = default;
};
class UploadDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UploadDocResponseBody> body{};

  UploadDocResponse() {}

  explicit UploadDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UploadDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UploadDocResponseBody>(model1);
      }
    }
  }


  virtual ~UploadDocResponse() = default;
};
class ValidateUploadTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileKey{};
  shared_ptr<string> taskType{};
  shared_ptr<string> templateType{};
  shared_ptr<string> workspaceId{};

  ValidateUploadTemplateRequest() {}

  explicit ValidateUploadTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (templateType) {
      res["TemplateType"] = boost::any(*templateType);
    }
    if (workspaceId) {
      res["WorkspaceId"] = boost::any(*workspaceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("TemplateType") != m.end() && !m["TemplateType"].empty()) {
      templateType = make_shared<string>(boost::any_cast<string>(m["TemplateType"]));
    }
    if (m.find("WorkspaceId") != m.end() && !m["WorkspaceId"].empty()) {
      workspaceId = make_shared<string>(boost::any_cast<string>(m["WorkspaceId"]));
    }
  }


  virtual ~ValidateUploadTemplateRequest() = default;
};
class ValidateUploadTemplateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> commentCount{};
  shared_ptr<long> dialogueCount{};
  shared_ptr<long> totalCount{};

  ValidateUploadTemplateResponseBodyData() {}

  explicit ValidateUploadTemplateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commentCount) {
      res["CommentCount"] = boost::any(*commentCount);
    }
    if (dialogueCount) {
      res["DialogueCount"] = boost::any(*dialogueCount);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommentCount") != m.end() && !m["CommentCount"].empty()) {
      commentCount = make_shared<long>(boost::any_cast<long>(m["CommentCount"]));
    }
    if (m.find("DialogueCount") != m.end() && !m["DialogueCount"].empty()) {
      dialogueCount = make_shared<long>(boost::any_cast<long>(m["DialogueCount"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ValidateUploadTemplateResponseBodyData() = default;
};
class ValidateUploadTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ValidateUploadTemplateResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ValidateUploadTemplateResponseBody() {}

  explicit ValidateUploadTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ValidateUploadTemplateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ValidateUploadTemplateResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ValidateUploadTemplateResponseBody() = default;
};
class ValidateUploadTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateUploadTemplateResponseBody> body{};

  ValidateUploadTemplateResponse() {}

  explicit ValidateUploadTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateUploadTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateUploadTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateUploadTemplateResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddDatasetDocumentResponse addDatasetDocumentWithOptions(shared_ptr<AddDatasetDocumentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDatasetDocumentResponse addDatasetDocument(shared_ptr<AddDatasetDocumentRequest> request);
  CancelAsyncTaskResponse cancelAsyncTaskWithOptions(shared_ptr<CancelAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelAsyncTaskResponse cancelAsyncTask(shared_ptr<CancelAsyncTaskRequest> request);
  ClearIntervenesResponse clearIntervenesWithOptions(shared_ptr<ClearIntervenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearIntervenesResponse clearIntervenes(shared_ptr<ClearIntervenesRequest> request);
  CreateDatasetResponse createDatasetWithOptions(shared_ptr<CreateDatasetRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatasetResponse createDataset(shared_ptr<CreateDatasetRequest> request);
  CreateGeneratedContentResponse createGeneratedContentWithOptions(shared_ptr<CreateGeneratedContentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGeneratedContentResponse createGeneratedContent(shared_ptr<CreateGeneratedContentRequest> request);
  CreateTokenResponse createTokenWithOptions(shared_ptr<CreateTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTokenResponse createToken(shared_ptr<CreateTokenRequest> request);
  DeleteCustomTextResponse deleteCustomTextWithOptions(shared_ptr<DeleteCustomTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTextResponse deleteCustomText(shared_ptr<DeleteCustomTextRequest> request);
  DeleteCustomTopicByTopicResponse deleteCustomTopicByTopicWithOptions(shared_ptr<DeleteCustomTopicByTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTopicByTopicResponse deleteCustomTopicByTopic(shared_ptr<DeleteCustomTopicByTopicRequest> request);
  DeleteCustomTopicViewPointByIdResponse deleteCustomTopicViewPointByIdWithOptions(shared_ptr<DeleteCustomTopicViewPointByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomTopicViewPointByIdResponse deleteCustomTopicViewPointById(shared_ptr<DeleteCustomTopicViewPointByIdRequest> request);
  DeleteDatasetResponse deleteDatasetWithOptions(shared_ptr<DeleteDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatasetResponse deleteDataset(shared_ptr<DeleteDatasetRequest> request);
  DeleteDatasetDocumentResponse deleteDatasetDocumentWithOptions(shared_ptr<DeleteDatasetDocumentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatasetDocumentResponse deleteDatasetDocument(shared_ptr<DeleteDatasetDocumentRequest> request);
  DeleteDocsResponse deleteDocsWithOptions(shared_ptr<DeleteDocsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDocsResponse deleteDocs(shared_ptr<DeleteDocsRequest> request);
  DeleteGeneratedContentResponse deleteGeneratedContentWithOptions(shared_ptr<DeleteGeneratedContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGeneratedContentResponse deleteGeneratedContent(shared_ptr<DeleteGeneratedContentRequest> request);
  DeleteInterveneRuleResponse deleteInterveneRuleWithOptions(shared_ptr<DeleteInterveneRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInterveneRuleResponse deleteInterveneRule(shared_ptr<DeleteInterveneRuleRequest> request);
  DeleteMaterialByIdResponse deleteMaterialByIdWithOptions(shared_ptr<DeleteMaterialByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMaterialByIdResponse deleteMaterialById(shared_ptr<DeleteMaterialByIdRequest> request);
  DocumentExtractionResponse documentExtractionWithOptions(shared_ptr<DocumentExtractionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DocumentExtractionResponse documentExtraction(shared_ptr<DocumentExtractionRequest> request);
  ExportAnalysisTagDetailByTaskIdResponse exportAnalysisTagDetailByTaskIdWithOptions(shared_ptr<ExportAnalysisTagDetailByTaskIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportAnalysisTagDetailByTaskIdResponse exportAnalysisTagDetailByTaskId(shared_ptr<ExportAnalysisTagDetailByTaskIdRequest> request);
  ExportGeneratedContentResponse exportGeneratedContentWithOptions(shared_ptr<ExportGeneratedContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportGeneratedContentResponse exportGeneratedContent(shared_ptr<ExportGeneratedContentRequest> request);
  ExportHotTopicPlanningProposalsResponse exportHotTopicPlanningProposalsWithOptions(shared_ptr<ExportHotTopicPlanningProposalsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportHotTopicPlanningProposalsResponse exportHotTopicPlanningProposals(shared_ptr<ExportHotTopicPlanningProposalsRequest> request);
  ExportIntervenesResponse exportIntervenesWithOptions(shared_ptr<ExportIntervenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportIntervenesResponse exportIntervenes(shared_ptr<ExportIntervenesRequest> request);
  FeedbackDialogueResponse feedbackDialogueWithOptions(shared_ptr<FeedbackDialogueRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FeedbackDialogueResponse feedbackDialogue(shared_ptr<FeedbackDialogueRequest> request);
  FetchImageTaskResponse fetchImageTaskWithOptions(shared_ptr<FetchImageTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FetchImageTaskResponse fetchImageTask(shared_ptr<FetchImageTaskRequest> request);
  GenerateFileUrlByKeyResponse generateFileUrlByKeyWithOptions(shared_ptr<GenerateFileUrlByKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateFileUrlByKeyResponse generateFileUrlByKey(shared_ptr<GenerateFileUrlByKeyRequest> request);
  GenerateImageTaskResponse generateImageTaskWithOptions(shared_ptr<GenerateImageTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateImageTaskResponse generateImageTask(shared_ptr<GenerateImageTaskRequest> request);
  GenerateUploadConfigResponse generateUploadConfigWithOptions(shared_ptr<GenerateUploadConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateUploadConfigResponse generateUploadConfig(shared_ptr<GenerateUploadConfigRequest> request);
  GenerateViewPointResponse generateViewPointWithOptions(shared_ptr<GenerateViewPointRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateViewPointResponse generateViewPoint(shared_ptr<GenerateViewPointRequest> request);
  GetCategoriesByTaskIdResponse getCategoriesByTaskIdWithOptions(shared_ptr<GetCategoriesByTaskIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCategoriesByTaskIdResponse getCategoriesByTaskId(shared_ptr<GetCategoriesByTaskIdRequest> request);
  GetCustomHotTopicBroadcastJobResponse getCustomHotTopicBroadcastJobWithOptions(shared_ptr<GetCustomHotTopicBroadcastJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomHotTopicBroadcastJobResponse getCustomHotTopicBroadcastJob(shared_ptr<GetCustomHotTopicBroadcastJobRequest> request);
  GetCustomTextResponse getCustomTextWithOptions(shared_ptr<GetCustomTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTextResponse getCustomText(shared_ptr<GetCustomTextRequest> request);
  GetCustomTopicSelectionPerspectiveAnalysisTaskResponse getCustomTopicSelectionPerspectiveAnalysisTaskWithOptions(shared_ptr<GetCustomTopicSelectionPerspectiveAnalysisTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCustomTopicSelectionPerspectiveAnalysisTaskResponse getCustomTopicSelectionPerspectiveAnalysisTask(shared_ptr<GetCustomTopicSelectionPerspectiveAnalysisTaskRequest> request);
  GetDataSourceOrderConfigResponse getDataSourceOrderConfigWithOptions(shared_ptr<GetDataSourceOrderConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataSourceOrderConfigResponse getDataSourceOrderConfig(shared_ptr<GetDataSourceOrderConfigRequest> request);
  GetDatasetResponse getDatasetWithOptions(shared_ptr<GetDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatasetResponse getDataset(shared_ptr<GetDatasetRequest> request);
  GetDatasetDocumentResponse getDatasetDocumentWithOptions(shared_ptr<GetDatasetDocumentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatasetDocumentResponse getDatasetDocument(shared_ptr<GetDatasetDocumentRequest> request);
  GetDocClusterTaskResponse getDocClusterTaskWithOptions(shared_ptr<GetDocClusterTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDocClusterTaskResponse getDocClusterTask(shared_ptr<GetDocClusterTaskRequest> request);
  GetDocInfoResponse getDocInfoWithOptions(shared_ptr<GetDocInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDocInfoResponse getDocInfo(shared_ptr<GetDocInfoRequest> request);
  GetEnterpriseVocAnalysisTaskResponse getEnterpriseVocAnalysisTaskWithOptions(shared_ptr<GetEnterpriseVocAnalysisTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEnterpriseVocAnalysisTaskResponse getEnterpriseVocAnalysisTask(shared_ptr<GetEnterpriseVocAnalysisTaskRequest> request);
  GetGeneratedContentResponse getGeneratedContentWithOptions(shared_ptr<GetGeneratedContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGeneratedContentResponse getGeneratedContent(shared_ptr<GetGeneratedContentRequest> request);
  GetHotTopicBroadcastResponse getHotTopicBroadcastWithOptions(shared_ptr<GetHotTopicBroadcastRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHotTopicBroadcastResponse getHotTopicBroadcast(shared_ptr<GetHotTopicBroadcastRequest> request);
  GetInterveneGlobalReplyResponse getInterveneGlobalReplyWithOptions(shared_ptr<GetInterveneGlobalReplyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterveneGlobalReplyResponse getInterveneGlobalReply(shared_ptr<GetInterveneGlobalReplyRequest> request);
  GetInterveneImportTaskInfoResponse getInterveneImportTaskInfoWithOptions(shared_ptr<GetInterveneImportTaskInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterveneImportTaskInfoResponse getInterveneImportTaskInfo(shared_ptr<GetInterveneImportTaskInfoRequest> request);
  GetInterveneRuleDetailResponse getInterveneRuleDetailWithOptions(shared_ptr<GetInterveneRuleDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterveneRuleDetailResponse getInterveneRuleDetail(shared_ptr<GetInterveneRuleDetailRequest> request);
  GetInterveneTemplateFileUrlResponse getInterveneTemplateFileUrlWithOptions(shared_ptr<GetInterveneTemplateFileUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInterveneTemplateFileUrlResponse getInterveneTemplateFileUrl(shared_ptr<GetInterveneTemplateFileUrlRequest> request);
  GetMaterialByIdResponse getMaterialByIdWithOptions(shared_ptr<GetMaterialByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMaterialByIdResponse getMaterialById(shared_ptr<GetMaterialByIdRequest> request);
  GetPropertiesResponse getPropertiesWithOptions(shared_ptr<GetPropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPropertiesResponse getProperties(shared_ptr<GetPropertiesRequest> request);
  GetSmartClipTaskResponse getSmartClipTaskWithOptions(shared_ptr<GetSmartClipTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmartClipTaskResponse getSmartClipTask(shared_ptr<GetSmartClipTaskRequest> request);
  GetTopicByIdResponse getTopicByIdWithOptions(shared_ptr<GetTopicByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicByIdResponse getTopicById(shared_ptr<GetTopicByIdRequest> request);
  GetTopicSelectionPerspectiveAnalysisTaskResponse getTopicSelectionPerspectiveAnalysisTaskWithOptions(shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTopicSelectionPerspectiveAnalysisTaskResponse getTopicSelectionPerspectiveAnalysisTask(shared_ptr<GetTopicSelectionPerspectiveAnalysisTaskRequest> request);
  ImportInterveneFileResponse importInterveneFileWithOptions(shared_ptr<ImportInterveneFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportInterveneFileResponse importInterveneFile(shared_ptr<ImportInterveneFileRequest> request);
  ImportInterveneFileAsyncResponse importInterveneFileAsyncWithOptions(shared_ptr<ImportInterveneFileAsyncRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportInterveneFileAsyncResponse importInterveneFileAsync(shared_ptr<ImportInterveneFileAsyncRequest> request);
  InsertInterveneGlobalReplyResponse insertInterveneGlobalReplyWithOptions(shared_ptr<InsertInterveneGlobalReplyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertInterveneGlobalReplyResponse insertInterveneGlobalReply(shared_ptr<InsertInterveneGlobalReplyRequest> request);
  InsertInterveneRuleResponse insertInterveneRuleWithOptions(shared_ptr<InsertInterveneRuleRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InsertInterveneRuleResponse insertInterveneRule(shared_ptr<InsertInterveneRuleRequest> request);
  ListAnalysisTagDetailByTaskIdResponse listAnalysisTagDetailByTaskIdWithOptions(shared_ptr<ListAnalysisTagDetailByTaskIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAnalysisTagDetailByTaskIdResponse listAnalysisTagDetailByTaskId(shared_ptr<ListAnalysisTagDetailByTaskIdRequest> request);
  ListAsyncTasksResponse listAsyncTasksWithOptions(shared_ptr<ListAsyncTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAsyncTasksResponse listAsyncTasks(shared_ptr<ListAsyncTasksRequest> request);
  ListBuildConfigsResponse listBuildConfigsWithOptions(shared_ptr<ListBuildConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBuildConfigsResponse listBuildConfigs(shared_ptr<ListBuildConfigsRequest> request);
  ListCustomTextResponse listCustomTextWithOptions(shared_ptr<ListCustomTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomTextResponse listCustomText(shared_ptr<ListCustomTextRequest> request);
  ListCustomViewPointsResponse listCustomViewPointsWithOptions(shared_ptr<ListCustomViewPointsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomViewPointsResponse listCustomViewPoints(shared_ptr<ListCustomViewPointsRequest> request);
  ListDatasetDocumentsResponse listDatasetDocumentsWithOptions(shared_ptr<ListDatasetDocumentsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatasetDocumentsResponse listDatasetDocuments(shared_ptr<ListDatasetDocumentsRequest> request);
  ListDatasetsResponse listDatasetsWithOptions(shared_ptr<ListDatasetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatasetsResponse listDatasets(shared_ptr<ListDatasetsRequest> request);
  ListDialoguesResponse listDialoguesWithOptions(shared_ptr<ListDialoguesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDialoguesResponse listDialogues(shared_ptr<ListDialoguesRequest> request);
  ListDocsResponse listDocsWithOptions(shared_ptr<ListDocsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDocsResponse listDocs(shared_ptr<ListDocsRequest> request);
  ListFreshViewPointsResponse listFreshViewPointsWithOptions(shared_ptr<ListFreshViewPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFreshViewPointsResponse listFreshViewPoints(shared_ptr<ListFreshViewPointsRequest> request);
  ListGeneratedContentsResponse listGeneratedContentsWithOptions(shared_ptr<ListGeneratedContentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGeneratedContentsResponse listGeneratedContents(shared_ptr<ListGeneratedContentsRequest> request);
  ListHotNewsWithTypeResponse listHotNewsWithTypeWithOptions(shared_ptr<ListHotNewsWithTypeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHotNewsWithTypeResponse listHotNewsWithType(shared_ptr<ListHotNewsWithTypeRequest> request);
  ListHotSourcesResponse listHotSourcesWithOptions(shared_ptr<ListHotSourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHotSourcesResponse listHotSources(shared_ptr<ListHotSourcesRequest> request);
  ListHotTopicsResponse listHotTopicsWithOptions(shared_ptr<ListHotTopicsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHotTopicsResponse listHotTopics(shared_ptr<ListHotTopicsRequest> request);
  ListHotViewPointsResponse listHotViewPointsWithOptions(shared_ptr<ListHotViewPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHotViewPointsResponse listHotViewPoints(shared_ptr<ListHotViewPointsRequest> request);
  ListInterveneCntResponse listInterveneCntWithOptions(shared_ptr<ListInterveneCntRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterveneCntResponse listInterveneCnt(shared_ptr<ListInterveneCntRequest> request);
  ListInterveneImportTasksResponse listInterveneImportTasksWithOptions(shared_ptr<ListInterveneImportTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterveneImportTasksResponse listInterveneImportTasks(shared_ptr<ListInterveneImportTasksRequest> request);
  ListInterveneRulesResponse listInterveneRulesWithOptions(shared_ptr<ListInterveneRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInterveneRulesResponse listInterveneRules(shared_ptr<ListInterveneRulesRequest> request);
  ListIntervenesResponse listIntervenesWithOptions(shared_ptr<ListIntervenesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervenesResponse listIntervenes(shared_ptr<ListIntervenesRequest> request);
  ListMaterialDocumentsResponse listMaterialDocumentsWithOptions(shared_ptr<ListMaterialDocumentsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMaterialDocumentsResponse listMaterialDocuments(shared_ptr<ListMaterialDocumentsRequest> request);
  ListPlanningProposalResponse listPlanningProposalWithOptions(shared_ptr<ListPlanningProposalRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPlanningProposalResponse listPlanningProposal(shared_ptr<ListPlanningProposalRequest> request);
  ListSearchTaskDialogueDatasResponse listSearchTaskDialogueDatasWithOptions(shared_ptr<ListSearchTaskDialogueDatasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchTaskDialogueDatasResponse listSearchTaskDialogueDatas(shared_ptr<ListSearchTaskDialogueDatasRequest> request);
  ListSearchTaskDialoguesResponse listSearchTaskDialoguesWithOptions(shared_ptr<ListSearchTaskDialoguesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchTaskDialoguesResponse listSearchTaskDialogues(shared_ptr<ListSearchTaskDialoguesRequest> request);
  ListSearchTasksResponse listSearchTasksWithOptions(shared_ptr<ListSearchTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchTasksResponse listSearchTasks(shared_ptr<ListSearchTasksRequest> request);
  ListStyleLearningResultResponse listStyleLearningResultWithOptions(shared_ptr<ListStyleLearningResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListStyleLearningResultResponse listStyleLearningResult(shared_ptr<ListStyleLearningResultRequest> request);
  ListTimedViewAttitudeResponse listTimedViewAttitudeWithOptions(shared_ptr<ListTimedViewAttitudeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTimedViewAttitudeResponse listTimedViewAttitude(shared_ptr<ListTimedViewAttitudeRequest> request);
  ListTopicRecommendEventListResponse listTopicRecommendEventListWithOptions(shared_ptr<ListTopicRecommendEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTopicRecommendEventListResponse listTopicRecommendEventList(shared_ptr<ListTopicRecommendEventListRequest> request);
  ListTopicViewPointRecommendEventListResponse listTopicViewPointRecommendEventListWithOptions(shared_ptr<ListTopicViewPointRecommendEventListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTopicViewPointRecommendEventListResponse listTopicViewPointRecommendEventList(shared_ptr<ListTopicViewPointRecommendEventListRequest> request);
  ListVersionsResponse listVersionsWithOptions(shared_ptr<ListVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVersionsResponse listVersions(shared_ptr<ListVersionsRequest> request);
  ListWebReviewPointsResponse listWebReviewPointsWithOptions(shared_ptr<ListWebReviewPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWebReviewPointsResponse listWebReviewPoints(shared_ptr<ListWebReviewPointsRequest> request);
  QueryAsyncTaskResponse queryAsyncTaskWithOptions(shared_ptr<QueryAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryAsyncTaskResponse queryAsyncTask(shared_ptr<QueryAsyncTaskRequest> request);
  RunAbbreviationContentResponse runAbbreviationContentWithOptions(shared_ptr<RunAbbreviationContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunAbbreviationContentResponse runAbbreviationContent(shared_ptr<RunAbbreviationContentRequest> request);
  RunBookIntroductionResponse runBookIntroductionWithOptions(shared_ptr<RunBookIntroductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunBookIntroductionResponse runBookIntroduction(shared_ptr<RunBookIntroductionRequest> request);
  RunBookSmartCardResponse runBookSmartCardWithOptions(shared_ptr<RunBookSmartCardRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunBookSmartCardResponse runBookSmartCard(shared_ptr<RunBookSmartCardRequest> request);
  RunCommentGenerationResponse runCommentGenerationWithOptions(shared_ptr<RunCommentGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCommentGenerationResponse runCommentGeneration(shared_ptr<RunCommentGenerationRequest> request);
  RunContinueContentResponse runContinueContentWithOptions(shared_ptr<RunContinueContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunContinueContentResponse runContinueContent(shared_ptr<RunContinueContentRequest> request);
  RunCustomHotTopicAnalysisResponse runCustomHotTopicAnalysisWithOptions(shared_ptr<RunCustomHotTopicAnalysisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCustomHotTopicAnalysisResponse runCustomHotTopicAnalysis(shared_ptr<RunCustomHotTopicAnalysisRequest> request);
  RunCustomHotTopicViewPointAnalysisResponse runCustomHotTopicViewPointAnalysisWithOptions(shared_ptr<RunCustomHotTopicViewPointAnalysisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunCustomHotTopicViewPointAnalysisResponse runCustomHotTopicViewPointAnalysis(shared_ptr<RunCustomHotTopicViewPointAnalysisRequest> request);
  RunDocBrainmapResponse runDocBrainmapWithOptions(shared_ptr<RunDocBrainmapRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocBrainmapResponse runDocBrainmap(shared_ptr<RunDocBrainmapRequest> request);
  RunDocIntroductionResponse runDocIntroductionWithOptions(shared_ptr<RunDocIntroductionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocIntroductionResponse runDocIntroduction(shared_ptr<RunDocIntroductionRequest> request);
  RunDocQaResponse runDocQaWithOptions(shared_ptr<RunDocQaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocQaResponse runDocQa(shared_ptr<RunDocQaRequest> request);
  RunDocSmartCardResponse runDocSmartCardWithOptions(shared_ptr<RunDocSmartCardRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocSmartCardResponse runDocSmartCard(shared_ptr<RunDocSmartCardRequest> request);
  RunDocSummaryResponse runDocSummaryWithOptions(shared_ptr<RunDocSummaryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocSummaryResponse runDocSummary(shared_ptr<RunDocSummaryRequest> request);
  RunDocTranslationResponse runDocTranslationWithOptions(shared_ptr<RunDocTranslationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocTranslationResponse runDocTranslation(shared_ptr<RunDocTranslationRequest> request);
  RunDocWashingResponse runDocWashingWithOptions(shared_ptr<RunDocWashingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunDocWashingResponse runDocWashing(shared_ptr<RunDocWashingRequest> request);
  RunExpandContentResponse runExpandContentWithOptions(shared_ptr<RunExpandContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunExpandContentResponse runExpandContent(shared_ptr<RunExpandContentRequest> request);
  RunGenerateQuestionsResponse runGenerateQuestionsWithOptions(shared_ptr<RunGenerateQuestionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunGenerateQuestionsResponse runGenerateQuestions(shared_ptr<RunGenerateQuestionsRequest> request);
  RunHotwordResponse runHotwordWithOptions(shared_ptr<RunHotwordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunHotwordResponse runHotword(shared_ptr<RunHotwordRequest> request);
  RunKeywordsExtractionGenerationResponse runKeywordsExtractionGenerationWithOptions(shared_ptr<RunKeywordsExtractionGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunKeywordsExtractionGenerationResponse runKeywordsExtractionGeneration(shared_ptr<RunKeywordsExtractionGenerationRequest> request);
  RunMultiDocIntroductionResponse runMultiDocIntroductionWithOptions(shared_ptr<RunMultiDocIntroductionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunMultiDocIntroductionResponse runMultiDocIntroduction(shared_ptr<RunMultiDocIntroductionRequest> request);
  RunSearchGenerationResponse runSearchGenerationWithOptions(shared_ptr<RunSearchGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSearchGenerationResponse runSearchGeneration(shared_ptr<RunSearchGenerationRequest> request);
  RunSearchSimilarArticlesResponse runSearchSimilarArticlesWithOptions(shared_ptr<RunSearchSimilarArticlesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSearchSimilarArticlesResponse runSearchSimilarArticles(shared_ptr<RunSearchSimilarArticlesRequest> request);
  RunStepByStepWritingResponse runStepByStepWritingWithOptions(shared_ptr<RunStepByStepWritingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunStepByStepWritingResponse runStepByStepWriting(shared_ptr<RunStepByStepWritingRequest> request);
  RunStyleFeatureAnalysisResponse runStyleFeatureAnalysisWithOptions(shared_ptr<RunStyleFeatureAnalysisRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunStyleFeatureAnalysisResponse runStyleFeatureAnalysis(shared_ptr<RunStyleFeatureAnalysisRequest> request);
  RunSummaryGenerateResponse runSummaryGenerateWithOptions(shared_ptr<RunSummaryGenerateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSummaryGenerateResponse runSummaryGenerate(shared_ptr<RunSummaryGenerateRequest> request);
  RunTextPolishingResponse runTextPolishingWithOptions(shared_ptr<RunTextPolishingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunTextPolishingResponse runTextPolishing(shared_ptr<RunTextPolishingRequest> request);
  RunTitleGenerationResponse runTitleGenerationWithOptions(shared_ptr<RunTitleGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunTitleGenerationResponse runTitleGeneration(shared_ptr<RunTitleGenerationRequest> request);
  RunTranslateGenerationResponse runTranslateGenerationWithOptions(shared_ptr<RunTranslateGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunTranslateGenerationResponse runTranslateGeneration(shared_ptr<RunTranslateGenerationRequest> request);
  RunWriteToneGenerationResponse runWriteToneGenerationWithOptions(shared_ptr<RunWriteToneGenerationRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunWriteToneGenerationResponse runWriteToneGeneration(shared_ptr<RunWriteToneGenerationRequest> request);
  RunWritingResponse runWritingWithOptions(shared_ptr<RunWritingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunWritingResponse runWriting(shared_ptr<RunWritingRequest> request);
  SaveCustomTextResponse saveCustomTextWithOptions(shared_ptr<SaveCustomTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveCustomTextResponse saveCustomText(shared_ptr<SaveCustomTextRequest> request);
  SaveDataSourceOrderConfigResponse saveDataSourceOrderConfigWithOptions(shared_ptr<SaveDataSourceOrderConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveDataSourceOrderConfigResponse saveDataSourceOrderConfig(shared_ptr<SaveDataSourceOrderConfigRequest> request);
  SaveMaterialDocumentResponse saveMaterialDocumentWithOptions(shared_ptr<SaveMaterialDocumentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveMaterialDocumentResponse saveMaterialDocument(shared_ptr<SaveMaterialDocumentRequest> request);
  SaveStyleLearningResultResponse saveStyleLearningResultWithOptions(shared_ptr<SaveStyleLearningResultRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveStyleLearningResultResponse saveStyleLearningResult(shared_ptr<SaveStyleLearningResultRequest> request);
  SearchDatasetDocumentsResponse searchDatasetDocumentsWithOptions(shared_ptr<SearchDatasetDocumentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchDatasetDocumentsResponse searchDatasetDocuments(shared_ptr<SearchDatasetDocumentsRequest> request);
  SearchNewsResponse searchNewsWithOptions(shared_ptr<SearchNewsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchNewsResponse searchNews(shared_ptr<SearchNewsRequest> request);
  SubmitAsyncTaskResponse submitAsyncTaskWithOptions(shared_ptr<SubmitAsyncTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAsyncTaskResponse submitAsyncTask(shared_ptr<SubmitAsyncTaskRequest> request);
  SubmitCustomHotTopicBroadcastJobResponse submitCustomHotTopicBroadcastJobWithOptions(shared_ptr<SubmitCustomHotTopicBroadcastJobRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCustomHotTopicBroadcastJobResponse submitCustomHotTopicBroadcastJob(shared_ptr<SubmitCustomHotTopicBroadcastJobRequest> request);
  SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse submitCustomTopicSelectionPerspectiveAnalysisTaskWithOptions(shared_ptr<SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCustomTopicSelectionPerspectiveAnalysisTaskResponse submitCustomTopicSelectionPerspectiveAnalysisTask(shared_ptr<SubmitCustomTopicSelectionPerspectiveAnalysisTaskRequest> request);
  SubmitDocClusterTaskResponse submitDocClusterTaskWithOptions(shared_ptr<SubmitDocClusterTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitDocClusterTaskResponse submitDocClusterTask(shared_ptr<SubmitDocClusterTaskRequest> request);
  SubmitEnterpriseVocAnalysisTaskResponse submitEnterpriseVocAnalysisTaskWithOptions(shared_ptr<SubmitEnterpriseVocAnalysisTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitEnterpriseVocAnalysisTaskResponse submitEnterpriseVocAnalysisTask(shared_ptr<SubmitEnterpriseVocAnalysisTaskRequest> request);
  SubmitSmartClipTaskResponse submitSmartClipTaskWithOptions(shared_ptr<SubmitSmartClipTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitSmartClipTaskResponse submitSmartClipTask(shared_ptr<SubmitSmartClipTaskRequest> request);
  SubmitTopicSelectionPerspectiveAnalysisTaskResponse submitTopicSelectionPerspectiveAnalysisTaskWithOptions(shared_ptr<SubmitTopicSelectionPerspectiveAnalysisTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitTopicSelectionPerspectiveAnalysisTaskResponse submitTopicSelectionPerspectiveAnalysisTask(shared_ptr<SubmitTopicSelectionPerspectiveAnalysisTaskRequest> request);
  UpdateCustomTextResponse updateCustomTextWithOptions(shared_ptr<UpdateCustomTextRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomTextResponse updateCustomText(shared_ptr<UpdateCustomTextRequest> request);
  UpdateDatasetResponse updateDatasetWithOptions(shared_ptr<UpdateDatasetRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDatasetResponse updateDataset(shared_ptr<UpdateDatasetRequest> request);
  UpdateDatasetDocumentResponse updateDatasetDocumentWithOptions(shared_ptr<UpdateDatasetDocumentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDatasetDocumentResponse updateDatasetDocument(shared_ptr<UpdateDatasetDocumentRequest> request);
  UpdateGeneratedContentResponse updateGeneratedContentWithOptions(shared_ptr<UpdateGeneratedContentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGeneratedContentResponse updateGeneratedContent(shared_ptr<UpdateGeneratedContentRequest> request);
  UpdateMaterialDocumentResponse updateMaterialDocumentWithOptions(shared_ptr<UpdateMaterialDocumentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMaterialDocumentResponse updateMaterialDocument(shared_ptr<UpdateMaterialDocumentRequest> request);
  UploadBookResponse uploadBookWithOptions(shared_ptr<UploadBookRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadBookResponse uploadBook(shared_ptr<UploadBookRequest> request);
  UploadDocResponse uploadDocWithOptions(shared_ptr<UploadDocRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UploadDocResponse uploadDoc(shared_ptr<UploadDocRequest> request);
  ValidateUploadTemplateResponse validateUploadTemplateWithOptions(shared_ptr<ValidateUploadTemplateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateUploadTemplateResponse validateUploadTemplate(shared_ptr<ValidateUploadTemplateRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_AiMiaoBi20230801

#endif
