// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_IOVCC20180501_H_
#define ALIBABACLOUD_IOVCC20180501_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Iovcc20180501 {
class ListDeviceBrandsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> start{};
  shared_ptr<string> length{};

  ListDeviceBrandsRequest() {}

  explicit ListDeviceBrandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
  }


  virtual ~ListDeviceBrandsRequest() = default;
};
class ListDeviceBrandsResponseBodyDeviceBrands : public Darabonba::Model {
public:
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> description{};
  shared_ptr<string> projectId{};
  shared_ptr<string> manufacture{};
  shared_ptr<string> deviceBrand{};

  ListDeviceBrandsResponseBodyDeviceBrands() {}

  explicit ListDeviceBrandsResponseBodyDeviceBrands(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (manufacture) {
      res["Manufacture"] = boost::any(*manufacture);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Manufacture") != m.end() && !m["Manufacture"].empty()) {
      manufacture = make_shared<string>(boost::any_cast<string>(m["Manufacture"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~ListDeviceBrandsResponseBodyDeviceBrands() = default;
};
class ListDeviceBrandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceBrandsResponseBodyDeviceBrands>> deviceBrands{};
  shared_ptr<string> requestId{};

  ListDeviceBrandsResponseBody() {}

  explicit ListDeviceBrandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceBrands) {
      vector<boost::any> temp1;
      for(auto item1:*deviceBrands){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceBrands"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceBrands") != m.end() && !m["DeviceBrands"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceBrands"].type()) {
        vector<ListDeviceBrandsResponseBodyDeviceBrands> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceBrands"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceBrandsResponseBodyDeviceBrands model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceBrands = make_shared<vector<ListDeviceBrandsResponseBodyDeviceBrands>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeviceBrandsResponseBody() = default;
};
class ListDeviceBrandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeviceBrandsResponseBody> body{};

  ListDeviceBrandsResponse() {}

  explicit ListDeviceBrandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceBrandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceBrandsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceBrandsResponse() = default;
};
class ListFunctionExecuteLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> fileId{};
  shared_ptr<string> functionName{};
  shared_ptr<long> env{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListFunctionExecuteLogRequest() {}

  explicit ListFunctionExecuteLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<long>(boost::any_cast<long>(m["Env"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFunctionExecuteLogRequest() = default;
};
class ListFunctionExecuteLogResponseBodyLogListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<bool> hasNextPage{};

  ListFunctionExecuteLogResponseBodyLogListPagination() {}

  explicit ListFunctionExecuteLogResponseBodyLogListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (hasNextPage) {
      res["HasNextPage"] = boost::any(*hasNextPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("HasNextPage") != m.end() && !m["HasNextPage"].empty()) {
      hasNextPage = make_shared<bool>(boost::any_cast<bool>(m["HasNextPage"]));
    }
  }


  virtual ~ListFunctionExecuteLogResponseBodyLogListPagination() = default;
};
class ListFunctionExecuteLogResponseBodyLogListLogs : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> backEndRequestId{};

  ListFunctionExecuteLogResponseBodyLogListLogs() {}

  explicit ListFunctionExecuteLogResponseBodyLogListLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (backEndRequestId) {
      res["BackEndRequestId"] = boost::any(*backEndRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("BackEndRequestId") != m.end() && !m["BackEndRequestId"].empty()) {
      backEndRequestId = make_shared<string>(boost::any_cast<string>(m["BackEndRequestId"]));
    }
  }


  virtual ~ListFunctionExecuteLogResponseBodyLogListLogs() = default;
};
class ListFunctionExecuteLogResponseBodyLogList : public Darabonba::Model {
public:
  shared_ptr<ListFunctionExecuteLogResponseBodyLogListPagination> pagination{};
  shared_ptr<vector<ListFunctionExecuteLogResponseBodyLogListLogs>> logs{};

  ListFunctionExecuteLogResponseBodyLogList() {}

  explicit ListFunctionExecuteLogResponseBodyLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logs) {
      vector<boost::any> temp1;
      for(auto item1:*logs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Logs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListFunctionExecuteLogResponseBodyLogListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListFunctionExecuteLogResponseBodyLogListPagination>(model1);
      }
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<ListFunctionExecuteLogResponseBodyLogListLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Logs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFunctionExecuteLogResponseBodyLogListLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logs = make_shared<vector<ListFunctionExecuteLogResponseBodyLogListLogs>>(expect1);
      }
    }
  }


  virtual ~ListFunctionExecuteLogResponseBodyLogList() = default;
};
class ListFunctionExecuteLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListFunctionExecuteLogResponseBodyLogList> logList{};
  shared_ptr<string> requestId{};

  ListFunctionExecuteLogResponseBody() {}

  explicit ListFunctionExecuteLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logList) {
      res["LogList"] = logList ? boost::any(logList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogList") != m.end() && !m["LogList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogList"].type()) {
        ListFunctionExecuteLogResponseBodyLogList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogList"]));
        logList = make_shared<ListFunctionExecuteLogResponseBodyLogList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListFunctionExecuteLogResponseBody() = default;
};
class ListFunctionExecuteLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFunctionExecuteLogResponseBody> body{};

  ListFunctionExecuteLogResponse() {}

  explicit ListFunctionExecuteLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFunctionExecuteLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFunctionExecuteLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListFunctionExecuteLogResponse() = default;
};
class ListDeviceModelsRequest : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> length{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> start{};
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceBrandId{};

  ListDeviceModelsRequest() {}

  explicit ListDeviceModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
  }


  virtual ~ListDeviceModelsRequest() = default;
};
class ListDeviceModelsResponseBodyDeviceModels : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceType{};
  shared_ptr<long> canCreateDeviceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> securityChip{};
  shared_ptr<string> deviceLogoUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> initUsageTypeDesc{};
  shared_ptr<long> initUsageType{};
  shared_ptr<string> deviceBrand{};

  ListDeviceModelsResponseBodyDeviceModels() {}

  explicit ListDeviceModelsResponseBodyDeviceModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (deviceLogoUrl) {
      res["DeviceLogoUrl"] = boost::any(*deviceLogoUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (initUsageTypeDesc) {
      res["InitUsageTypeDesc"] = boost::any(*initUsageTypeDesc);
    }
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<long>(boost::any_cast<long>(m["CanCreateDeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<string>(boost::any_cast<string>(m["SecurityChip"]));
    }
    if (m.find("DeviceLogoUrl") != m.end() && !m["DeviceLogoUrl"].empty()) {
      deviceLogoUrl = make_shared<string>(boost::any_cast<string>(m["DeviceLogoUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("InitUsageTypeDesc") != m.end() && !m["InitUsageTypeDesc"].empty()) {
      initUsageTypeDesc = make_shared<string>(boost::any_cast<string>(m["InitUsageTypeDesc"]));
    }
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<long>(boost::any_cast<long>(m["InitUsageType"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~ListDeviceModelsResponseBodyDeviceModels() = default;
};
class ListDeviceModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceModelsResponseBodyDeviceModels>> deviceModels{};
  shared_ptr<string> requestId{};

  ListDeviceModelsResponseBody() {}

  explicit ListDeviceModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModels) {
      vector<boost::any> temp1;
      for(auto item1:*deviceModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceModels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModels") != m.end() && !m["DeviceModels"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceModels"].type()) {
        vector<ListDeviceModelsResponseBodyDeviceModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceModelsResponseBodyDeviceModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceModels = make_shared<vector<ListDeviceModelsResponseBodyDeviceModels>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeviceModelsResponseBody() = default;
};
class ListDeviceModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeviceModelsResponseBody> body{};

  ListDeviceModelsResponse() {}

  explicit ListDeviceModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceModelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceModelsResponse() = default;
};
class ListMqttMessageLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> projectId{};
  shared_ptr<string> topic{};
  shared_ptr<string> mid{};
  shared_ptr<string> clientId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> type{};

  ListMqttMessageLogsRequest() {}

  explicit ListMqttMessageLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListMqttMessageLogsRequest() = default;
};
class ListMqttMessageLogsResponseBodyTracesPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMqttMessageLogsResponseBodyTracesPagination() {}

  explicit ListMqttMessageLogsResponseBodyTracesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMqttMessageLogsResponseBodyTracesPagination() = default;
};
class ListMqttMessageLogsResponseBodyTracesList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> time{};
  shared_ptr<string> action{};
  shared_ptr<string> topic{};
  shared_ptr<string> mid{};
  shared_ptr<string> clientMid{};
  shared_ptr<string> clientId{};

  ListMqttMessageLogsResponseBodyTracesList() {}

  explicit ListMqttMessageLogsResponseBodyTracesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (clientMid) {
      res["ClientMid"] = boost::any(*clientMid);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("ClientMid") != m.end() && !m["ClientMid"].empty()) {
      clientMid = make_shared<string>(boost::any_cast<string>(m["ClientMid"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~ListMqttMessageLogsResponseBodyTracesList() = default;
};
class ListMqttMessageLogsResponseBodyTraces : public Darabonba::Model {
public:
  shared_ptr<ListMqttMessageLogsResponseBodyTracesPagination> pagination{};
  shared_ptr<vector<ListMqttMessageLogsResponseBodyTracesList>> list{};

  ListMqttMessageLogsResponseBodyTraces() {}

  explicit ListMqttMessageLogsResponseBodyTraces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListMqttMessageLogsResponseBodyTracesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListMqttMessageLogsResponseBodyTracesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListMqttMessageLogsResponseBodyTracesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMqttMessageLogsResponseBodyTracesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListMqttMessageLogsResponseBodyTracesList>>(expect1);
      }
    }
  }


  virtual ~ListMqttMessageLogsResponseBodyTraces() = default;
};
class ListMqttMessageLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMqttMessageLogsResponseBodyTraces> traces{};

  ListMqttMessageLogsResponseBody() {}

  explicit ListMqttMessageLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (traces) {
      res["Traces"] = traces ? boost::any(traces->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Traces") != m.end() && !m["Traces"].empty()) {
      if (typeid(map<string, boost::any>) == m["Traces"].type()) {
        ListMqttMessageLogsResponseBodyTraces model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Traces"]));
        traces = make_shared<ListMqttMessageLogsResponseBodyTraces>(model1);
      }
    }
  }


  virtual ~ListMqttMessageLogsResponseBody() = default;
};
class ListMqttMessageLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMqttMessageLogsResponseBody> body{};

  ListMqttMessageLogsResponse() {}

  explicit ListMqttMessageLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMqttMessageLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMqttMessageLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMqttMessageLogsResponse() = default;
};
class DeleteNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};

  DeleteNamespaceRequest() {}

  explicit DeleteNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~DeleteNamespaceRequest() = default;
};
class DeleteNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNamespaceResponseBody() {}

  explicit DeleteNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNamespaceResponseBody() = default;
};
class DeleteNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteNamespaceResponseBody> body{};

  DeleteNamespaceResponse() {}

  explicit DeleteNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNamespaceResponse() = default;
};
class ListOfflineMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<long> pageIndex{};

  ListOfflineMessagesRequest() {}

  explicit ListOfflineMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~ListOfflineMessagesRequest() = default;
};
class ListOfflineMessagesResponseBodyOfflineMessagesPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListOfflineMessagesResponseBodyOfflineMessagesPagination() {}

  explicit ListOfflineMessagesResponseBodyOfflineMessagesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOfflineMessagesResponseBodyOfflineMessagesPagination() = default;
};
class ListOfflineMessagesResponseBodyOfflineMessagesList : public Darabonba::Model {
public:
  shared_ptr<long> expiredTime{};
  shared_ptr<long> mid{};
  shared_ptr<long> gmtCreate{};

  ListOfflineMessagesResponseBodyOfflineMessagesList() {}

  explicit ListOfflineMessagesResponseBodyOfflineMessagesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<long>(boost::any_cast<long>(m["Mid"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
  }


  virtual ~ListOfflineMessagesResponseBodyOfflineMessagesList() = default;
};
class ListOfflineMessagesResponseBodyOfflineMessages : public Darabonba::Model {
public:
  shared_ptr<ListOfflineMessagesResponseBodyOfflineMessagesPagination> pagination{};
  shared_ptr<vector<ListOfflineMessagesResponseBodyOfflineMessagesList>> list{};

  ListOfflineMessagesResponseBodyOfflineMessages() {}

  explicit ListOfflineMessagesResponseBodyOfflineMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListOfflineMessagesResponseBodyOfflineMessagesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListOfflineMessagesResponseBodyOfflineMessagesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListOfflineMessagesResponseBodyOfflineMessagesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOfflineMessagesResponseBodyOfflineMessagesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListOfflineMessagesResponseBodyOfflineMessagesList>>(expect1);
      }
    }
  }


  virtual ~ListOfflineMessagesResponseBodyOfflineMessages() = default;
};
class ListOfflineMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListOfflineMessagesResponseBodyOfflineMessages> offlineMessages{};

  ListOfflineMessagesResponseBody() {}

  explicit ListOfflineMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (offlineMessages) {
      res["OfflineMessages"] = offlineMessages ? boost::any(offlineMessages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OfflineMessages") != m.end() && !m["OfflineMessages"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineMessages"].type()) {
        ListOfflineMessagesResponseBodyOfflineMessages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineMessages"]));
        offlineMessages = make_shared<ListOfflineMessagesResponseBodyOfflineMessages>(model1);
      }
    }
  }


  virtual ~ListOfflineMessagesResponseBody() = default;
};
class ListOfflineMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOfflineMessagesResponseBody> body{};

  ListOfflineMessagesResponse() {}

  explicit ListOfflineMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOfflineMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOfflineMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListOfflineMessagesResponse() = default;
};
class PushMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appPackage{};
  shared_ptr<string> desc{};
  shared_ptr<string> act{};
  shared_ptr<string> uri{};
  shared_ptr<string> pkgContent{};
  shared_ptr<string> customContent{};
  shared_ptr<string> receiverType{};
  shared_ptr<string> receiverValues{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> title{};
  shared_ptr<string> projectId{};
  shared_ptr<string> appKey{};
  shared_ptr<long> type{};

  PushMessageRequest() {}

  explicit PushMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (act) {
      res["Act"] = boost::any(*act);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    if (pkgContent) {
      res["PkgContent"] = boost::any(*pkgContent);
    }
    if (customContent) {
      res["CustomContent"] = boost::any(*customContent);
    }
    if (receiverType) {
      res["ReceiverType"] = boost::any(*receiverType);
    }
    if (receiverValues) {
      res["ReceiverValues"] = boost::any(*receiverValues);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("Act") != m.end() && !m["Act"].empty()) {
      act = make_shared<string>(boost::any_cast<string>(m["Act"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
    if (m.find("PkgContent") != m.end() && !m["PkgContent"].empty()) {
      pkgContent = make_shared<string>(boost::any_cast<string>(m["PkgContent"]));
    }
    if (m.find("CustomContent") != m.end() && !m["CustomContent"].empty()) {
      customContent = make_shared<string>(boost::any_cast<string>(m["CustomContent"]));
    }
    if (m.find("ReceiverType") != m.end() && !m["ReceiverType"].empty()) {
      receiverType = make_shared<string>(boost::any_cast<string>(m["ReceiverType"]));
    }
    if (m.find("ReceiverValues") != m.end() && !m["ReceiverValues"].empty()) {
      receiverValues = make_shared<string>(boost::any_cast<string>(m["ReceiverValues"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~PushMessageRequest() = default;
};
class PushMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> mid{};

  PushMessageResponseBody() {}

  explicit PushMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<long>(boost::any_cast<long>(m["Mid"]));
    }
  }


  virtual ~PushMessageResponseBody() = default;
};
class PushMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PushMessageResponseBody> body{};

  PushMessageResponse() {}

  explicit PushMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushMessageResponseBody>(model1);
      }
    }
  }


  virtual ~PushMessageResponse() = default;
};
class DeleteCustomizedFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DeleteCustomizedFilterRequest() {}

  explicit DeleteCustomizedFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteCustomizedFilterRequest() = default;
};
class DeleteCustomizedFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomizedFilterResponseBody() {}

  explicit DeleteCustomizedFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomizedFilterResponseBody() = default;
};
class DeleteCustomizedFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCustomizedFilterResponseBody> body{};

  DeleteCustomizedFilterResponse() {}

  explicit DeleteCustomizedFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomizedFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomizedFilterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomizedFilterResponse() = default;
};
class DescribeMqttClientStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> clientId{};
  shared_ptr<string> projectId{};

  DescribeMqttClientStatusRequest() {}

  explicit DescribeMqttClientStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeMqttClientStatusRequest() = default;
};
class DescribeMqttClientStatusResponseBodyClientStatus : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> cleanSession{};
  shared_ptr<long> lastUpdate{};

  DescribeMqttClientStatusResponseBodyClientStatus() {}

  explicit DescribeMqttClientStatusResponseBodyClientStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (cleanSession) {
      res["CleanSession"] = boost::any(*cleanSession);
    }
    if (lastUpdate) {
      res["LastUpdate"] = boost::any(*lastUpdate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("CleanSession") != m.end() && !m["CleanSession"].empty()) {
      cleanSession = make_shared<string>(boost::any_cast<string>(m["CleanSession"]));
    }
    if (m.find("LastUpdate") != m.end() && !m["LastUpdate"].empty()) {
      lastUpdate = make_shared<long>(boost::any_cast<long>(m["LastUpdate"]));
    }
  }


  virtual ~DescribeMqttClientStatusResponseBodyClientStatus() = default;
};
class DescribeMqttClientStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeMqttClientStatusResponseBodyClientStatus> clientStatus{};
  shared_ptr<string> requestId{};

  DescribeMqttClientStatusResponseBody() {}

  explicit DescribeMqttClientStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientStatus) {
      res["ClientStatus"] = clientStatus ? boost::any(clientStatus->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientStatus") != m.end() && !m["ClientStatus"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientStatus"].type()) {
        DescribeMqttClientStatusResponseBodyClientStatus model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientStatus"]));
        clientStatus = make_shared<DescribeMqttClientStatusResponseBodyClientStatus>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMqttClientStatusResponseBody() = default;
};
class DescribeMqttClientStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMqttClientStatusResponseBody> body{};

  DescribeMqttClientStatusResponse() {}

  explicit DescribeMqttClientStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMqttClientStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMqttClientStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMqttClientStatusResponse() = default;
};
class DeleteDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> projectId{};

  DeleteDeviceRequest() {}

  explicit DeleteDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDeviceRequest() = default;
};
class DeleteDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDeviceResponseBody() {}

  explicit DeleteDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDeviceResponseBody() = default;
};
class DeleteDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDeviceResponseBody> body{};

  DeleteDeviceResponse() {}

  explicit DeleteDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeviceResponse() = default;
};
class UpdateDeviceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> initUsageType{};
  shared_ptr<string> modelName{};
  shared_ptr<string> id{};
  shared_ptr<string> brandName{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> canCreateDeviceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> securityChip{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> deviceName{};

  UpdateDeviceModelRequest() {}

  explicit UpdateDeviceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (brandName) {
      res["BrandName"] = boost::any(*brandName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<string>(boost::any_cast<string>(m["InitUsageType"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("BrandName") != m.end() && !m["BrandName"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["BrandName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<string>(boost::any_cast<string>(m["CanCreateDeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<string>(boost::any_cast<string>(m["SecurityChip"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~UpdateDeviceModelRequest() = default;
};
class UpdateDeviceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDeviceModelResponseBody() {}

  explicit UpdateDeviceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDeviceModelResponseBody() = default;
};
class UpdateDeviceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateDeviceModelResponseBody> body{};

  UpdateDeviceModelResponse() {}

  explicit UpdateDeviceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDeviceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDeviceModelResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDeviceModelResponse() = default;
};
class UpdateApiGatewayAppStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> gatewayAppId{};
  shared_ptr<long> status{};

  UpdateApiGatewayAppStatusRequest() {}

  explicit UpdateApiGatewayAppStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gatewayAppId) {
      res["GatewayAppId"] = boost::any(*gatewayAppId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GatewayAppId") != m.end() && !m["GatewayAppId"].empty()) {
      gatewayAppId = make_shared<string>(boost::any_cast<string>(m["GatewayAppId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~UpdateApiGatewayAppStatusRequest() = default;
};
class UpdateApiGatewayAppStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateApiGatewayAppStatusResponseBody() {}

  explicit UpdateApiGatewayAppStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApiGatewayAppStatusResponseBody() = default;
};
class UpdateApiGatewayAppStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateApiGatewayAppStatusResponseBody> body{};

  UpdateApiGatewayAppStatusResponse() {}

  explicit UpdateApiGatewayAppStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApiGatewayAppStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApiGatewayAppStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApiGatewayAppStatusResponse() = default;
};
class ListCameraShootingAttachmentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> edgeDeviceId{};
  shared_ptr<long> shootingRecordId{};

  ListCameraShootingAttachmentsRequest() {}

  explicit ListCameraShootingAttachmentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (edgeDeviceId) {
      res["EdgeDeviceId"] = boost::any(*edgeDeviceId);
    }
    if (shootingRecordId) {
      res["ShootingRecordId"] = boost::any(*shootingRecordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("EdgeDeviceId") != m.end() && !m["EdgeDeviceId"].empty()) {
      edgeDeviceId = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceId"]));
    }
    if (m.find("ShootingRecordId") != m.end() && !m["ShootingRecordId"].empty()) {
      shootingRecordId = make_shared<long>(boost::any_cast<long>(m["ShootingRecordId"]));
    }
  }


  virtual ~ListCameraShootingAttachmentsRequest() = default;
};
class ListCameraShootingAttachmentsResponseBodyAttachments : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> fileId{};
  shared_ptr<long> fileType{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileLength{};
  shared_ptr<long> shootingTime{};
  shared_ptr<string> downloadUrl{};

  ListCameraShootingAttachmentsResponseBodyAttachments() {}

  explicit ListCameraShootingAttachmentsResponseBodyAttachments(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileLength) {
      res["FileLength"] = boost::any(*fileLength);
    }
    if (shootingTime) {
      res["ShootingTime"] = boost::any(*shootingTime);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileLength") != m.end() && !m["FileLength"].empty()) {
      fileLength = make_shared<long>(boost::any_cast<long>(m["FileLength"]));
    }
    if (m.find("ShootingTime") != m.end() && !m["ShootingTime"].empty()) {
      shootingTime = make_shared<long>(boost::any_cast<long>(m["ShootingTime"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
  }


  virtual ~ListCameraShootingAttachmentsResponseBodyAttachments() = default;
};
class ListCameraShootingAttachmentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCameraShootingAttachmentsResponseBodyAttachments>> attachments{};

  ListCameraShootingAttachmentsResponseBody() {}

  explicit ListCameraShootingAttachmentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (attachments) {
      vector<boost::any> temp1;
      for(auto item1:*attachments){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Attachments"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Attachments") != m.end() && !m["Attachments"].empty()) {
      if (typeid(vector<boost::any>) == m["Attachments"].type()) {
        vector<ListCameraShootingAttachmentsResponseBodyAttachments> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Attachments"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCameraShootingAttachmentsResponseBodyAttachments model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attachments = make_shared<vector<ListCameraShootingAttachmentsResponseBodyAttachments>>(expect1);
      }
    }
  }


  virtual ~ListCameraShootingAttachmentsResponseBody() = default;
};
class ListCameraShootingAttachmentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCameraShootingAttachmentsResponseBody> body{};

  ListCameraShootingAttachmentsResponse() {}

  explicit ListCameraShootingAttachmentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCameraShootingAttachmentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCameraShootingAttachmentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCameraShootingAttachmentsResponse() = default;
};
class ListAssistHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<long> perPage{};
  shared_ptr<long> pageIndex{};
  shared_ptr<string> condition{};
  shared_ptr<string> projectId{};

  ListAssistHistoriesRequest() {}

  explicit ListAssistHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (perPage) {
      res["PerPage"] = boost::any(*perPage);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PerPage") != m.end() && !m["PerPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["PerPage"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListAssistHistoriesRequest() = default;
};
class ListAssistHistoriesResponseBodyHistories : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> UNAME{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> UUID{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> VIN{};
  shared_ptr<string> UID{};
  shared_ptr<string> ID{};

  ListAssistHistoriesResponseBodyHistories() {}

  explicit ListAssistHistoriesResponseBodyHistories(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (UNAME) {
      res["UNAME"] = boost::any(*UNAME);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (VIN) {
      res["VIN"] = boost::any(*VIN);
    }
    if (UID) {
      res["UID"] = boost::any(*UID);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UNAME") != m.end() && !m["UNAME"].empty()) {
      UNAME = make_shared<string>(boost::any_cast<string>(m["UNAME"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("VIN") != m.end() && !m["VIN"].empty()) {
      VIN = make_shared<string>(boost::any_cast<string>(m["VIN"]));
    }
    if (m.find("UID") != m.end() && !m["UID"].empty()) {
      UID = make_shared<string>(boost::any_cast<string>(m["UID"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
  }


  virtual ~ListAssistHistoriesResponseBodyHistories() = default;
};
class ListAssistHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> perPage{};
  shared_ptr<vector<ListAssistHistoriesResponseBodyHistories>> histories{};
  shared_ptr<long> pageIndex{};

  ListAssistHistoriesResponseBody() {}

  explicit ListAssistHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (perPage) {
      res["PerPage"] = boost::any(*perPage);
    }
    if (histories) {
      vector<boost::any> temp1;
      for(auto item1:*histories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Histories"] = boost::any(temp1);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PerPage") != m.end() && !m["PerPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["PerPage"]));
    }
    if (m.find("Histories") != m.end() && !m["Histories"].empty()) {
      if (typeid(vector<boost::any>) == m["Histories"].type()) {
        vector<ListAssistHistoriesResponseBodyHistories> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Histories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAssistHistoriesResponseBodyHistories model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        histories = make_shared<vector<ListAssistHistoriesResponseBodyHistories>>(expect1);
      }
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~ListAssistHistoriesResponseBody() = default;
};
class ListAssistHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAssistHistoriesResponseBody> body{};

  ListAssistHistoriesResponse() {}

  explicit ListAssistHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAssistHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAssistHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAssistHistoriesResponse() = default;
};
class GetDeviceSystemUpdateFunnelEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> originalId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> targetVersion{};
  shared_ptr<string> idType{};

  GetDeviceSystemUpdateFunnelEventsRequest() {}

  explicit GetDeviceSystemUpdateFunnelEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetVersion) {
      res["TargetVersion"] = boost::any(*targetVersion);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("TargetVersion") != m.end() && !m["TargetVersion"].empty()) {
      targetVersion = make_shared<string>(boost::any_cast<string>(m["TargetVersion"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
  }


  virtual ~GetDeviceSystemUpdateFunnelEventsRequest() = default;
};
class GetDeviceSystemUpdateFunnelEventsResponseBodyEventList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> targetVersion{};
  shared_ptr<string> event{};
  shared_ptr<long> reportTimestamp{};
  shared_ptr<string> reportTime{};
  shared_ptr<string> tenantId{};

  GetDeviceSystemUpdateFunnelEventsResponseBodyEventList() {}

  explicit GetDeviceSystemUpdateFunnelEventsResponseBodyEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (targetVersion) {
      res["TargetVersion"] = boost::any(*targetVersion);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (reportTimestamp) {
      res["ReportTimestamp"] = boost::any(*reportTimestamp);
    }
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("TargetVersion") != m.end() && !m["TargetVersion"].empty()) {
      targetVersion = make_shared<string>(boost::any_cast<string>(m["TargetVersion"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ReportTimestamp") != m.end() && !m["ReportTimestamp"].empty()) {
      reportTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportTimestamp"]));
    }
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~GetDeviceSystemUpdateFunnelEventsResponseBodyEventList() = default;
};
class GetDeviceSystemUpdateFunnelEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetDeviceSystemUpdateFunnelEventsResponseBodyEventList>> eventList{};

  GetDeviceSystemUpdateFunnelEventsResponseBody() {}

  explicit GetDeviceSystemUpdateFunnelEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eventList) {
      vector<boost::any> temp1;
      for(auto item1:*eventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EventList") != m.end() && !m["EventList"].empty()) {
      if (typeid(vector<boost::any>) == m["EventList"].type()) {
        vector<GetDeviceSystemUpdateFunnelEventsResponseBodyEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeviceSystemUpdateFunnelEventsResponseBodyEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventList = make_shared<vector<GetDeviceSystemUpdateFunnelEventsResponseBodyEventList>>(expect1);
      }
    }
  }


  virtual ~GetDeviceSystemUpdateFunnelEventsResponseBody() = default;
};
class GetDeviceSystemUpdateFunnelEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceSystemUpdateFunnelEventsResponseBody> body{};

  GetDeviceSystemUpdateFunnelEventsResponse() {}

  explicit GetDeviceSystemUpdateFunnelEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceSystemUpdateFunnelEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceSystemUpdateFunnelEventsResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceSystemUpdateFunnelEventsResponse() = default;
};
class DeleteAllCustomizedFiltersRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};

  DeleteAllCustomizedFiltersRequest() {}

  explicit DeleteAllCustomizedFiltersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~DeleteAllCustomizedFiltersRequest() = default;
};
class DeleteAllCustomizedFiltersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAllCustomizedFiltersResponseBody() {}

  explicit DeleteAllCustomizedFiltersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAllCustomizedFiltersResponseBody() = default;
};
class DeleteAllCustomizedFiltersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAllCustomizedFiltersResponseBody> body{};

  DeleteAllCustomizedFiltersResponse() {}

  explicit DeleteAllCustomizedFiltersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllCustomizedFiltersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllCustomizedFiltersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllCustomizedFiltersResponse() = default;
};
class GenerateAssistFileUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> filename{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};

  GenerateAssistFileUploadUrlRequest() {}

  explicit GenerateAssistFileUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~GenerateAssistFileUploadUrlRequest() = default;
};
class GenerateAssistFileUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> fileKey{};
  shared_ptr<string> uploadUrl{};
  shared_ptr<string> requestId{};

  GenerateAssistFileUploadUrlResponseBody() {}

  explicit GenerateAssistFileUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileKey) {
      res["FileKey"] = boost::any(*fileKey);
    }
    if (uploadUrl) {
      res["UploadUrl"] = boost::any(*uploadUrl);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileKey") != m.end() && !m["FileKey"].empty()) {
      fileKey = make_shared<string>(boost::any_cast<string>(m["FileKey"]));
    }
    if (m.find("UploadUrl") != m.end() && !m["UploadUrl"].empty()) {
      uploadUrl = make_shared<string>(boost::any_cast<string>(m["UploadUrl"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GenerateAssistFileUploadUrlResponseBody() = default;
};
class GenerateAssistFileUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateAssistFileUploadUrlResponseBody> body{};

  GenerateAssistFileUploadUrlResponse() {}

  explicit GenerateAssistFileUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateAssistFileUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateAssistFileUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateAssistFileUploadUrlResponse() = default;
};
class DescribeAssistWSServerAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};

  DescribeAssistWSServerAddressRequest() {}

  explicit DescribeAssistWSServerAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~DescribeAssistWSServerAddressRequest() = default;
};
class DescribeAssistWSServerAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> wsServer{};
  shared_ptr<string> OTP{};

  DescribeAssistWSServerAddressResponseBody() {}

  explicit DescribeAssistWSServerAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (wsServer) {
      res["WsServer"] = boost::any(*wsServer);
    }
    if (OTP) {
      res["OTP"] = boost::any(*OTP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WsServer") != m.end() && !m["WsServer"].empty()) {
      wsServer = make_shared<string>(boost::any_cast<string>(m["WsServer"]));
    }
    if (m.find("OTP") != m.end() && !m["OTP"].empty()) {
      OTP = make_shared<string>(boost::any_cast<string>(m["OTP"]));
    }
  }


  virtual ~DescribeAssistWSServerAddressResponseBody() = default;
};
class DescribeAssistWSServerAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAssistWSServerAddressResponseBody> body{};

  DescribeAssistWSServerAddressResponse() {}

  explicit DescribeAssistWSServerAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssistWSServerAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssistWSServerAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssistWSServerAddressResponse() = default;
};
class FindPrepublishesByVersionIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> versionId{};
  shared_ptr<string> versionType{};

  FindPrepublishesByVersionIdRequest() {}

  explicit FindPrepublishesByVersionIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindPrepublishesByVersionIdRequest() = default;
};
class FindPrepublishesByVersionIdResponseBodyPrepublishList : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> isActive{};
  shared_ptr<string> versionId{};
  shared_ptr<string> barrierCount{};
  shared_ptr<string> deviceModelName{};
  shared_ptr<string> isTotalPrepublish{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> parentId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};
  shared_ptr<string> versionType{};
  shared_ptr<string> passedCount{};

  FindPrepublishesByVersionIdResponseBodyPrepublishList() {}

  explicit FindPrepublishesByVersionIdResponseBodyPrepublishList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (isActive) {
      res["IsActive"] = boost::any(*isActive);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (barrierCount) {
      res["BarrierCount"] = boost::any(*barrierCount);
    }
    if (deviceModelName) {
      res["DeviceModelName"] = boost::any(*deviceModelName);
    }
    if (isTotalPrepublish) {
      res["IsTotalPrepublish"] = boost::any(*isTotalPrepublish);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (passedCount) {
      res["PassedCount"] = boost::any(*passedCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("IsActive") != m.end() && !m["IsActive"].empty()) {
      isActive = make_shared<string>(boost::any_cast<string>(m["IsActive"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("BarrierCount") != m.end() && !m["BarrierCount"].empty()) {
      barrierCount = make_shared<string>(boost::any_cast<string>(m["BarrierCount"]));
    }
    if (m.find("DeviceModelName") != m.end() && !m["DeviceModelName"].empty()) {
      deviceModelName = make_shared<string>(boost::any_cast<string>(m["DeviceModelName"]));
    }
    if (m.find("IsTotalPrepublish") != m.end() && !m["IsTotalPrepublish"].empty()) {
      isTotalPrepublish = make_shared<string>(boost::any_cast<string>(m["IsTotalPrepublish"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("PassedCount") != m.end() && !m["PassedCount"].empty()) {
      passedCount = make_shared<string>(boost::any_cast<string>(m["PassedCount"]));
    }
  }


  virtual ~FindPrepublishesByVersionIdResponseBodyPrepublishList() = default;
};
class FindPrepublishesByVersionIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<FindPrepublishesByVersionIdResponseBodyPrepublishList>> prepublishList{};

  FindPrepublishesByVersionIdResponseBody() {}

  explicit FindPrepublishesByVersionIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (prepublishList) {
      vector<boost::any> temp1;
      for(auto item1:*prepublishList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PrepublishList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrepublishList") != m.end() && !m["PrepublishList"].empty()) {
      if (typeid(vector<boost::any>) == m["PrepublishList"].type()) {
        vector<FindPrepublishesByVersionIdResponseBodyPrepublishList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PrepublishList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindPrepublishesByVersionIdResponseBodyPrepublishList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        prepublishList = make_shared<vector<FindPrepublishesByVersionIdResponseBodyPrepublishList>>(expect1);
      }
    }
  }


  virtual ~FindPrepublishesByVersionIdResponseBody() = default;
};
class FindPrepublishesByVersionIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindPrepublishesByVersionIdResponseBody> body{};

  FindPrepublishesByVersionIdResponse() {}

  explicit FindPrepublishesByVersionIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindPrepublishesByVersionIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindPrepublishesByVersionIdResponseBody>(model1);
      }
    }
  }


  virtual ~FindPrepublishesByVersionIdResponse() = default;
};
class FindVersionMessagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> messageType{};
  shared_ptr<string> testId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> sendRecordId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> versionType{};

  FindVersionMessagesRequest() {}

  explicit FindVersionMessagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (sendRecordId) {
      res["SendRecordId"] = boost::any(*sendRecordId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("SendRecordId") != m.end() && !m["SendRecordId"].empty()) {
      sendRecordId = make_shared<string>(boost::any_cast<string>(m["SendRecordId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindVersionMessagesRequest() = default;
};
class FindVersionMessagesResponseBodyMessageListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> status{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> messageId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> versionId{};
  shared_ptr<string> statusDesc{};
  shared_ptr<string> testId{};
  shared_ptr<long> id{};

  FindVersionMessagesResponseBodyMessageListItems() {}

  explicit FindVersionMessagesResponseBodyMessageListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (statusDesc) {
      res["StatusDesc"] = boost::any(*statusDesc);
    }
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("StatusDesc") != m.end() && !m["StatusDesc"].empty()) {
      statusDesc = make_shared<string>(boost::any_cast<string>(m["StatusDesc"]));
    }
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindVersionMessagesResponseBodyMessageListItems() = default;
};
class FindVersionMessagesResponseBodyMessageList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionMessagesResponseBodyMessageListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionMessagesResponseBodyMessageList() {}

  explicit FindVersionMessagesResponseBodyMessageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionMessagesResponseBodyMessageListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionMessagesResponseBodyMessageListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionMessagesResponseBodyMessageListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionMessagesResponseBodyMessageList() = default;
};
class FindVersionMessagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionMessagesResponseBodyMessageList> messageList{};

  FindVersionMessagesResponseBody() {}

  explicit FindVersionMessagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (messageList) {
      res["MessageList"] = messageList ? boost::any(messageList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MessageList") != m.end() && !m["MessageList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageList"].type()) {
        FindVersionMessagesResponseBodyMessageList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageList"]));
        messageList = make_shared<FindVersionMessagesResponseBodyMessageList>(model1);
      }
    }
  }


  virtual ~FindVersionMessagesResponseBody() = default;
};
class FindVersionMessagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionMessagesResponseBody> body{};

  FindVersionMessagesResponse() {}

  explicit FindVersionMessagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionMessagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionMessagesResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionMessagesResponse() = default;
};
class UpdateUpstreamAppServerRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};
  shared_ptr<string> projectId{};

  UpdateUpstreamAppServerRequest() {}

  explicit UpdateUpstreamAppServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~UpdateUpstreamAppServerRequest() = default;
};
class UpdateUpstreamAppServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUpstreamAppServerResponseBody() {}

  explicit UpdateUpstreamAppServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUpstreamAppServerResponseBody() = default;
};
class UpdateUpstreamAppServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateUpstreamAppServerResponseBody> body{};

  UpdateUpstreamAppServerResponse() {}

  explicit UpdateUpstreamAppServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUpstreamAppServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUpstreamAppServerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUpstreamAppServerResponse() = default;
};
class GetVehicleTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> vin{};

  GetVehicleTrackRequest() {}

  explicit GetVehicleTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
  }


  virtual ~GetVehicleTrackRequest() = default;
};
class GetVehicleTrackResponseBodyPoints : public Darabonba::Model {
public:
  shared_ptr<double> longitude{};
  shared_ptr<double> latitude{};
  shared_ptr<double> altitude{};
  shared_ptr<long> speed{};
  shared_ptr<long> updateTime{};

  GetVehicleTrackResponseBodyPoints() {}

  explicit GetVehicleTrackResponseBodyPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (altitude) {
      res["Altitude"] = boost::any(*altitude);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<double>(boost::any_cast<double>(m["Longitude"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<double>(boost::any_cast<double>(m["Latitude"]));
    }
    if (m.find("Altitude") != m.end() && !m["Altitude"].empty()) {
      altitude = make_shared<double>(boost::any_cast<double>(m["Altitude"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<long>(boost::any_cast<long>(m["Speed"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetVehicleTrackResponseBodyPoints() = default;
};
class GetVehicleTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetVehicleTrackResponseBodyPoints>> points{};

  GetVehicleTrackResponseBody() {}

  explicit GetVehicleTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (points) {
      vector<boost::any> temp1;
      for(auto item1:*points){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Points"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<GetVehicleTrackResponseBodyPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Points"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVehicleTrackResponseBodyPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        points = make_shared<vector<GetVehicleTrackResponseBodyPoints>>(expect1);
      }
    }
  }


  virtual ~GetVehicleTrackResponseBody() = default;
};
class GetVehicleTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetVehicleTrackResponseBody> body{};

  GetVehicleTrackResponse() {}

  explicit GetVehicleTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVehicleTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVehicleTrackResponseBody>(model1);
      }
    }
  }


  virtual ~GetVehicleTrackResponse() = default;
};
class CreateVersionTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceGroupId{};
  shared_ptr<string> description{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};

  CreateVersionTestRequest() {}

  explicit CreateVersionTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CreateVersionTestRequest() = default;
};
class CreateVersionTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> testId{};
  shared_ptr<string> requestId{};

  CreateVersionTestResponseBody() {}

  explicit CreateVersionTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (testId) {
      res["TestId"] = boost::any(*testId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TestId") != m.end() && !m["TestId"].empty()) {
      testId = make_shared<string>(boost::any_cast<string>(m["TestId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateVersionTestResponseBody() = default;
};
class CreateVersionTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVersionTestResponseBody> body{};

  CreateVersionTestResponse() {}

  explicit CreateVersionTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVersionTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVersionTestResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVersionTestResponse() = default;
};
class ListDeployedFunctionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> fileId{};

  ListDeployedFunctionsRequest() {}

  explicit ListDeployedFunctionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~ListDeployedFunctionsRequest() = default;
};
class ListDeployedFunctionsResponseBodyFunctions : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> fileId{};

  ListDeployedFunctionsResponseBodyFunctions() {}

  explicit ListDeployedFunctionsResponseBodyFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~ListDeployedFunctionsResponseBodyFunctions() = default;
};
class ListDeployedFunctionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDeployedFunctionsResponseBodyFunctions>> functions{};

  ListDeployedFunctionsResponseBody() {}

  explicit ListDeployedFunctionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (functions) {
      vector<boost::any> temp1;
      for(auto item1:*functions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Functions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      if (typeid(vector<boost::any>) == m["Functions"].type()) {
        vector<ListDeployedFunctionsResponseBodyFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Functions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeployedFunctionsResponseBodyFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functions = make_shared<vector<ListDeployedFunctionsResponseBodyFunctions>>(expect1);
      }
    }
  }


  virtual ~ListDeployedFunctionsResponseBody() = default;
};
class ListDeployedFunctionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeployedFunctionsResponseBody> body{};

  ListDeployedFunctionsResponse() {}

  explicit ListDeployedFunctionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeployedFunctionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeployedFunctionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeployedFunctionsResponse() = default;
};
class ListDeviceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListDeviceModelRequest() {}

  explicit ListDeviceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListDeviceModelRequest() = default;
};
class ListDeviceModelResponseBodyModelList : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> deviceType{};
  shared_ptr<long> canCreateDeviceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> securityChip{};
  shared_ptr<string> description{};
  shared_ptr<string> initUsageTypeDesc{};
  shared_ptr<long> initUsageType{};
  shared_ptr<string> deviceBrand{};

  ListDeviceModelResponseBodyModelList() {}

  explicit ListDeviceModelResponseBodyModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (initUsageTypeDesc) {
      res["InitUsageTypeDesc"] = boost::any(*initUsageTypeDesc);
    }
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<long>(boost::any_cast<long>(m["CanCreateDeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<string>(boost::any_cast<string>(m["SecurityChip"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InitUsageTypeDesc") != m.end() && !m["InitUsageTypeDesc"].empty()) {
      initUsageTypeDesc = make_shared<string>(boost::any_cast<string>(m["InitUsageTypeDesc"]));
    }
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<long>(boost::any_cast<long>(m["InitUsageType"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~ListDeviceModelResponseBodyModelList() = default;
};
class ListDeviceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDeviceModelResponseBodyModelList>> modelList{};
  shared_ptr<string> requestId{};

  ListDeviceModelResponseBody() {}

  explicit ListDeviceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelList) {
      vector<boost::any> temp1;
      for(auto item1:*modelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelList") != m.end() && !m["ModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelList"].type()) {
        vector<ListDeviceModelResponseBodyModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceModelResponseBodyModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelList = make_shared<vector<ListDeviceModelResponseBodyModelList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDeviceModelResponseBody() = default;
};
class ListDeviceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeviceModelResponseBody> body{};

  ListDeviceModelResponse() {}

  explicit ListDeviceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceModelResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceModelResponse() = default;
};
class CreateSchemaSubscribeRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModel{};
  shared_ptr<string> subscribeList{};
  shared_ptr<string> projectId{};
  shared_ptr<string> schemaVersion{};

  CreateSchemaSubscribeRequest() {}

  explicit CreateSchemaSubscribeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (subscribeList) {
      res["SubscribeList"] = boost::any(*subscribeList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schemaVersion) {
      res["SchemaVersion"] = boost::any(*schemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SubscribeList") != m.end() && !m["SubscribeList"].empty()) {
      subscribeList = make_shared<string>(boost::any_cast<string>(m["SubscribeList"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SchemaVersion") != m.end() && !m["SchemaVersion"].empty()) {
      schemaVersion = make_shared<string>(boost::any_cast<string>(m["SchemaVersion"]));
    }
  }


  virtual ~CreateSchemaSubscribeRequest() = default;
};
class CreateSchemaSubscribeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSchemaSubscribeResponseBody() {}

  explicit CreateSchemaSubscribeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSchemaSubscribeResponseBody() = default;
};
class CreateSchemaSubscribeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSchemaSubscribeResponseBody> body{};

  CreateSchemaSubscribeResponse() {}

  explicit CreateSchemaSubscribeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSchemaSubscribeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSchemaSubscribeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSchemaSubscribeResponse() = default;
};
class DescribeAssistRTMPServerAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};

  DescribeAssistRTMPServerAddressRequest() {}

  explicit DescribeAssistRTMPServerAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~DescribeAssistRTMPServerAddressRequest() = default;
};
class DescribeAssistRTMPServerAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> RTMPServer{};
  shared_ptr<string> OTP{};

  DescribeAssistRTMPServerAddressResponseBody() {}

  explicit DescribeAssistRTMPServerAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (RTMPServer) {
      res["RTMPServer"] = boost::any(*RTMPServer);
    }
    if (OTP) {
      res["OTP"] = boost::any(*OTP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RTMPServer") != m.end() && !m["RTMPServer"].empty()) {
      RTMPServer = make_shared<string>(boost::any_cast<string>(m["RTMPServer"]));
    }
    if (m.find("OTP") != m.end() && !m["OTP"].empty()) {
      OTP = make_shared<string>(boost::any_cast<string>(m["OTP"]));
    }
  }


  virtual ~DescribeAssistRTMPServerAddressResponseBody() = default;
};
class DescribeAssistRTMPServerAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAssistRTMPServerAddressResponseBody> body{};

  DescribeAssistRTMPServerAddressResponse() {}

  explicit DescribeAssistRTMPServerAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssistRTMPServerAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssistRTMPServerAddressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssistRTMPServerAddressResponse() = default;
};
class DeleteShadowSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};

  DeleteShadowSchemaRequest() {}

  explicit DeleteShadowSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteShadowSchemaRequest() = default;
};
class DeleteShadowSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteShadowSchemaResponseBody() {}

  explicit DeleteShadowSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteShadowSchemaResponseBody() = default;
};
class DeleteShadowSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteShadowSchemaResponseBody> body{};

  DeleteShadowSchemaResponse() {}

  explicit DeleteShadowSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteShadowSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteShadowSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteShadowSchemaResponse() = default;
};
class DescribeProjectAppSecurityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> appId{};

  DescribeProjectAppSecurityRequest() {}

  explicit DescribeProjectAppSecurityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DescribeProjectAppSecurityRequest() = default;
};
class DescribeProjectAppSecurityResponseBodyProjectAppSecurity : public Darabonba::Model {
public:
  shared_ptr<string> appSecret{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};

  DescribeProjectAppSecurityResponseBodyProjectAppSecurity() {}

  explicit DescribeProjectAppSecurityResponseBodyProjectAppSecurity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeProjectAppSecurityResponseBodyProjectAppSecurity() = default;
};
class DescribeProjectAppSecurityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeProjectAppSecurityResponseBodyProjectAppSecurity> projectAppSecurity{};

  DescribeProjectAppSecurityResponseBody() {}

  explicit DescribeProjectAppSecurityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectAppSecurity) {
      res["ProjectAppSecurity"] = projectAppSecurity ? boost::any(projectAppSecurity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectAppSecurity") != m.end() && !m["ProjectAppSecurity"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectAppSecurity"].type()) {
        DescribeProjectAppSecurityResponseBodyProjectAppSecurity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectAppSecurity"]));
        projectAppSecurity = make_shared<DescribeProjectAppSecurityResponseBodyProjectAppSecurity>(model1);
      }
    }
  }


  virtual ~DescribeProjectAppSecurityResponseBody() = default;
};
class DescribeProjectAppSecurityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeProjectAppSecurityResponseBody> body{};

  DescribeProjectAppSecurityResponse() {}

  explicit DescribeProjectAppSecurityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectAppSecurityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectAppSecurityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectAppSecurityResponse() = default;
};
class CreateDeviceBrandRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> brandName{};
  shared_ptr<string> manufacture{};
  shared_ptr<string> description{};

  CreateDeviceBrandRequest() {}

  explicit CreateDeviceBrandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (brandName) {
      res["BrandName"] = boost::any(*brandName);
    }
    if (manufacture) {
      res["Manufacture"] = boost::any(*manufacture);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("BrandName") != m.end() && !m["BrandName"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["BrandName"]));
    }
    if (m.find("Manufacture") != m.end() && !m["Manufacture"].empty()) {
      manufacture = make_shared<string>(boost::any_cast<string>(m["Manufacture"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateDeviceBrandRequest() = default;
};
class CreateDeviceBrandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> brandId{};

  CreateDeviceBrandResponseBody() {}

  explicit CreateDeviceBrandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (brandId) {
      res["BrandId"] = boost::any(*brandId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BrandId") != m.end() && !m["BrandId"].empty()) {
      brandId = make_shared<long>(boost::any_cast<long>(m["BrandId"]));
    }
  }


  virtual ~CreateDeviceBrandResponseBody() = default;
};
class CreateDeviceBrandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeviceBrandResponseBody> body{};

  CreateDeviceBrandResponse() {}

  explicit CreateDeviceBrandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceBrandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceBrandResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceBrandResponse() = default;
};
class CreateMqttRootTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> rootTopic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> clientToken{};

  CreateMqttRootTopicRequest() {}

  explicit CreateMqttRootTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (rootTopic) {
      res["RootTopic"] = boost::any(*rootTopic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("RootTopic") != m.end() && !m["RootTopic"].empty()) {
      rootTopic = make_shared<string>(boost::any_cast<string>(m["RootTopic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateMqttRootTopicRequest() = default;
};
class CreateMqttRootTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> queueName{};

  CreateMqttRootTopicResponseBody() {}

  explicit CreateMqttRootTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
  }


  virtual ~CreateMqttRootTopicResponseBody() = default;
};
class CreateMqttRootTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMqttRootTopicResponseBody> body{};

  CreateMqttRootTopicResponse() {}

  explicit CreateMqttRootTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMqttRootTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMqttRootTopicResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMqttRootTopicResponse() = default;
};
class DelayPublishOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> prepubTime{};
  shared_ptr<long> publishTime{};
  shared_ptr<long> downTime{};
  shared_ptr<string> email{};
  shared_ptr<string> description{};
  shared_ptr<string> sendMessage{};
  shared_ptr<string> prepublishCount{};

  DelayPublishOsVersionRequest() {}

  explicit DelayPublishOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (prepubTime) {
      res["PrepubTime"] = boost::any(*prepubTime);
    }
    if (publishTime) {
      res["PublishTime"] = boost::any(*publishTime);
    }
    if (downTime) {
      res["DownTime"] = boost::any(*downTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sendMessage) {
      res["SendMessage"] = boost::any(*sendMessage);
    }
    if (prepublishCount) {
      res["PrepublishCount"] = boost::any(*prepublishCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PrepubTime") != m.end() && !m["PrepubTime"].empty()) {
      prepubTime = make_shared<long>(boost::any_cast<long>(m["PrepubTime"]));
    }
    if (m.find("PublishTime") != m.end() && !m["PublishTime"].empty()) {
      publishTime = make_shared<long>(boost::any_cast<long>(m["PublishTime"]));
    }
    if (m.find("DownTime") != m.end() && !m["DownTime"].empty()) {
      downTime = make_shared<long>(boost::any_cast<long>(m["DownTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SendMessage") != m.end() && !m["SendMessage"].empty()) {
      sendMessage = make_shared<string>(boost::any_cast<string>(m["SendMessage"]));
    }
    if (m.find("PrepublishCount") != m.end() && !m["PrepublishCount"].empty()) {
      prepublishCount = make_shared<string>(boost::any_cast<string>(m["PrepublishCount"]));
    }
  }


  virtual ~DelayPublishOsVersionRequest() = default;
};
class DelayPublishOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DelayPublishOsVersionResponseBody() {}

  explicit DelayPublishOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DelayPublishOsVersionResponseBody() = default;
};
class DelayPublishOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DelayPublishOsVersionResponseBody> body{};

  DelayPublishOsVersionResponse() {}

  explicit DelayPublishOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DelayPublishOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DelayPublishOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DelayPublishOsVersionResponse() = default;
};
class ListPreChecksResponseBodyPreChecks : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> link{};
  shared_ptr<string> price{};
  shared_ptr<string> state{};

  ListPreChecksResponseBodyPreChecks() {}

  explicit ListPreChecksResponseBodyPreChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (link) {
      res["Link"] = boost::any(*link);
    }
    if (price) {
      res["Price"] = boost::any(*price);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["Link"]));
    }
    if (m.find("Price") != m.end() && !m["Price"].empty()) {
      price = make_shared<string>(boost::any_cast<string>(m["Price"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListPreChecksResponseBodyPreChecks() = default;
};
class ListPreChecksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListPreChecksResponseBodyPreChecks>> preChecks{};

  ListPreChecksResponseBody() {}

  explicit ListPreChecksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (preChecks) {
      vector<boost::any> temp1;
      for(auto item1:*preChecks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PreChecks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PreChecks") != m.end() && !m["PreChecks"].empty()) {
      if (typeid(vector<boost::any>) == m["PreChecks"].type()) {
        vector<ListPreChecksResponseBodyPreChecks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PreChecks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPreChecksResponseBodyPreChecks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        preChecks = make_shared<vector<ListPreChecksResponseBodyPreChecks>>(expect1);
      }
    }
  }


  virtual ~ListPreChecksResponseBody() = default;
};
class ListPreChecksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListPreChecksResponseBody> body{};

  ListPreChecksResponse() {}

  explicit ListPreChecksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPreChecksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPreChecksResponseBody>(model1);
      }
    }
  }


  virtual ~ListPreChecksResponse() = default;
};
class ListAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListAppsRequest() {}

  explicit ListAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListAppsRequest() = default;
};
class ListAppsResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appKey{};
  shared_ptr<long> osType{};
  shared_ptr<string> appPackage{};

  ListAppsResponseBodyApps() {}

  explicit ListAppsResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
  }


  virtual ~ListAppsResponseBodyApps() = default;
};
class ListAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAppsResponseBodyApps>> apps{};

  ListAppsResponseBody() {}

  explicit ListAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (apps) {
      vector<boost::any> temp1;
      for(auto item1:*apps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(vector<boost::any>) == m["Apps"].type()) {
        vector<ListAppsResponseBodyApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAppsResponseBodyApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apps = make_shared<vector<ListAppsResponseBodyApps>>(expect1);
      }
    }
  }


  virtual ~ListAppsResponseBody() = default;
};
class ListAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAppsResponseBody> body{};

  ListAppsResponse() {}

  explicit ListAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAppsResponse() = default;
};
class DeleteCameraShootingRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> edgeDeviceId{};
  shared_ptr<long> shootingRecordId{};

  DeleteCameraShootingRecordRequest() {}

  explicit DeleteCameraShootingRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (edgeDeviceId) {
      res["EdgeDeviceId"] = boost::any(*edgeDeviceId);
    }
    if (shootingRecordId) {
      res["ShootingRecordId"] = boost::any(*shootingRecordId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("EdgeDeviceId") != m.end() && !m["EdgeDeviceId"].empty()) {
      edgeDeviceId = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceId"]));
    }
    if (m.find("ShootingRecordId") != m.end() && !m["ShootingRecordId"].empty()) {
      shootingRecordId = make_shared<long>(boost::any_cast<long>(m["ShootingRecordId"]));
    }
  }


  virtual ~DeleteCameraShootingRecordRequest() = default;
};
class DeleteCameraShootingRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCameraShootingRecordResponseBody() {}

  explicit DeleteCameraShootingRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCameraShootingRecordResponseBody() = default;
};
class DeleteCameraShootingRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCameraShootingRecordResponseBody> body{};

  DeleteCameraShootingRecordResponse() {}

  explicit DeleteCameraShootingRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCameraShootingRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCameraShootingRecordResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCameraShootingRecordResponse() = default;
};
class DescribeDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};

  DescribeDeviceRequest() {}

  explicit DescribeDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~DescribeDeviceRequest() = default;
};
class DescribeDeviceResponseBodyDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> usageType{};
  shared_ptr<string> vin{};
  shared_ptr<string> usageTypeDesc{};
  shared_ptr<string> uuid{};
  shared_ptr<string> hardwareId{};
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> region{};
  shared_ptr<string> attributes{};
  shared_ptr<string> softwareId{};
  shared_ptr<string> name{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> deviceProduct{};

  DescribeDeviceResponseBodyDeviceInfo() {}

  explicit DescribeDeviceResponseBodyDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (usageType) {
      res["UsageType"] = boost::any(*usageType);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (usageTypeDesc) {
      res["UsageTypeDesc"] = boost::any(*usageTypeDesc);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (attributes) {
      res["Attributes"] = boost::any(*attributes);
    }
    if (softwareId) {
      res["SoftwareId"] = boost::any(*softwareId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (deviceProduct) {
      res["DeviceProduct"] = boost::any(*deviceProduct);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("UsageType") != m.end() && !m["UsageType"].empty()) {
      usageType = make_shared<long>(boost::any_cast<long>(m["UsageType"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("UsageTypeDesc") != m.end() && !m["UsageTypeDesc"].empty()) {
      usageTypeDesc = make_shared<string>(boost::any_cast<string>(m["UsageTypeDesc"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Attributes") != m.end() && !m["Attributes"].empty()) {
      attributes = make_shared<string>(boost::any_cast<string>(m["Attributes"]));
    }
    if (m.find("SoftwareId") != m.end() && !m["SoftwareId"].empty()) {
      softwareId = make_shared<string>(boost::any_cast<string>(m["SoftwareId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("DeviceProduct") != m.end() && !m["DeviceProduct"].empty()) {
      deviceProduct = make_shared<string>(boost::any_cast<string>(m["DeviceProduct"]));
    }
  }


  virtual ~DescribeDeviceResponseBodyDeviceInfo() = default;
};
class DescribeDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeviceResponseBodyDeviceInfo> deviceInfo{};

  DescribeDeviceResponseBody() {}

  explicit DescribeDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceInfo) {
      res["DeviceInfo"] = deviceInfo ? boost::any(deviceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceInfo"].type()) {
        DescribeDeviceResponseBodyDeviceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceInfo"]));
        deviceInfo = make_shared<DescribeDeviceResponseBodyDeviceInfo>(model1);
      }
    }
  }


  virtual ~DescribeDeviceResponseBody() = default;
};
class DescribeDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceResponseBody> body{};

  DescribeDeviceResponse() {}

  explicit DescribeDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceResponse() = default;
};
class AddVersionGroupDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIdType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceIds{};
  shared_ptr<string> deviceGroupId{};

  AddVersionGroupDevicesRequest() {}

  explicit AddVersionGroupDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
  }


  virtual ~AddVersionGroupDevicesRequest() = default;
};
class AddVersionGroupDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVersionGroupDevicesResponseBody() {}

  explicit AddVersionGroupDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVersionGroupDevicesResponseBody() = default;
};
class AddVersionGroupDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddVersionGroupDevicesResponseBody> body{};

  AddVersionGroupDevicesResponse() {}

  explicit AddVersionGroupDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVersionGroupDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVersionGroupDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~AddVersionGroupDevicesResponse() = default;
};
class ListProjectAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> keywords{};

  ListProjectAppsRequest() {}

  explicit ListProjectAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      keywords = make_shared<string>(boost::any_cast<string>(m["Keywords"]));
    }
  }


  virtual ~ListProjectAppsRequest() = default;
};
class ListProjectAppsResponseBodyResultProjectApps : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> projectId{};
  shared_ptr<string> userId{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> appPkgName{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appId{};
  shared_ptr<long> osType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> id{};

  ListProjectAppsResponseBodyResultProjectApps() {}

  explicit ListProjectAppsResponseBodyResultProjectApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (appPkgName) {
      res["AppPkgName"] = boost::any(*appPkgName);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("AppPkgName") != m.end() && !m["AppPkgName"].empty()) {
      appPkgName = make_shared<string>(boost::any_cast<string>(m["AppPkgName"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListProjectAppsResponseBodyResultProjectApps() = default;
};
class ListProjectAppsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListProjectAppsResponseBodyResultProjectApps>> projectApps{};
  shared_ptr<long> totalPage{};
  shared_ptr<long> totalCount{};

  ListProjectAppsResponseBodyResult() {}

  explicit ListProjectAppsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectApps) {
      vector<boost::any> temp1;
      for(auto item1:*projectApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ProjectApps"] = boost::any(temp1);
    }
    if (totalPage) {
      res["TotalPage"] = boost::any(*totalPage);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectApps") != m.end() && !m["ProjectApps"].empty()) {
      if (typeid(vector<boost::any>) == m["ProjectApps"].type()) {
        vector<ListProjectAppsResponseBodyResultProjectApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ProjectApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectAppsResponseBodyResultProjectApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projectApps = make_shared<vector<ListProjectAppsResponseBodyResultProjectApps>>(expect1);
      }
    }
    if (m.find("TotalPage") != m.end() && !m["TotalPage"].empty()) {
      totalPage = make_shared<long>(boost::any_cast<long>(m["TotalPage"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectAppsResponseBodyResult() = default;
};
class ListProjectAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListProjectAppsResponseBodyResult> result{};

  ListProjectAppsResponseBody() {}

  explicit ListProjectAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListProjectAppsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListProjectAppsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListProjectAppsResponseBody() = default;
};
class ListProjectAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProjectAppsResponseBody> body{};

  ListProjectAppsResponse() {}

  explicit ListProjectAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectAppsResponse() = default;
};
class ConnectAssistDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> hardwareId{};
  shared_ptr<bool> allowCommandExtension{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> VIN{};
  shared_ptr<string> UUID{};
  shared_ptr<string> projectId{};

  ConnectAssistDeviceRequest() {}

  explicit ConnectAssistDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (allowCommandExtension) {
      res["AllowCommandExtension"] = boost::any(*allowCommandExtension);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (VIN) {
      res["VIN"] = boost::any(*VIN);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("AllowCommandExtension") != m.end() && !m["AllowCommandExtension"].empty()) {
      allowCommandExtension = make_shared<bool>(boost::any_cast<bool>(m["AllowCommandExtension"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("VIN") != m.end() && !m["VIN"].empty()) {
      VIN = make_shared<string>(boost::any_cast<string>(m["VIN"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ConnectAssistDeviceRequest() = default;
};
class ConnectAssistDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConnectAssistDeviceResponseBody() {}

  explicit ConnectAssistDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConnectAssistDeviceResponseBody() = default;
};
class ConnectAssistDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ConnectAssistDeviceResponseBody> body{};

  ConnectAssistDeviceResponse() {}

  explicit ConnectAssistDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConnectAssistDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConnectAssistDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~ConnectAssistDeviceResponse() = default;
};
class ListApiGatewayAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListApiGatewayAppsRequest() {}

  explicit ListApiGatewayAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListApiGatewayAppsRequest() = default;
};
class ListApiGatewayAppsResponseBodyApiGatewayApps : public Darabonba::Model {
public:
  shared_ptr<string> gatewayAppKey{};
  shared_ptr<long> status{};
  shared_ptr<string> gatewayAppSecret{};
  shared_ptr<string> gatewayAppId{};
  shared_ptr<string> userId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};

  ListApiGatewayAppsResponseBodyApiGatewayApps() {}

  explicit ListApiGatewayAppsResponseBodyApiGatewayApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayAppKey) {
      res["GatewayAppKey"] = boost::any(*gatewayAppKey);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gatewayAppSecret) {
      res["GatewayAppSecret"] = boost::any(*gatewayAppSecret);
    }
    if (gatewayAppId) {
      res["GatewayAppId"] = boost::any(*gatewayAppId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayAppKey") != m.end() && !m["GatewayAppKey"].empty()) {
      gatewayAppKey = make_shared<string>(boost::any_cast<string>(m["GatewayAppKey"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("GatewayAppSecret") != m.end() && !m["GatewayAppSecret"].empty()) {
      gatewayAppSecret = make_shared<string>(boost::any_cast<string>(m["GatewayAppSecret"]));
    }
    if (m.find("GatewayAppId") != m.end() && !m["GatewayAppId"].empty()) {
      gatewayAppId = make_shared<string>(boost::any_cast<string>(m["GatewayAppId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListApiGatewayAppsResponseBodyApiGatewayApps() = default;
};
class ListApiGatewayAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApiGatewayAppsResponseBodyApiGatewayApps>> apiGatewayApps{};
  shared_ptr<string> requestId{};

  ListApiGatewayAppsResponseBody() {}

  explicit ListApiGatewayAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGatewayApps) {
      vector<boost::any> temp1;
      for(auto item1:*apiGatewayApps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiGatewayApps"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGatewayApps") != m.end() && !m["ApiGatewayApps"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiGatewayApps"].type()) {
        vector<ListApiGatewayAppsResponseBodyApiGatewayApps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiGatewayApps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiGatewayAppsResponseBodyApiGatewayApps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiGatewayApps = make_shared<vector<ListApiGatewayAppsResponseBodyApiGatewayApps>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListApiGatewayAppsResponseBody() = default;
};
class ListApiGatewayAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListApiGatewayAppsResponseBody> body{};

  ListApiGatewayAppsResponse() {}

  explicit ListApiGatewayAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApiGatewayAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApiGatewayAppsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApiGatewayAppsResponse() = default;
};
class DeleteRpcServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};

  DeleteRpcServiceRequest() {}

  explicit DeleteRpcServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteRpcServiceRequest() = default;
};
class DeleteRpcServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRpcServiceResponseBody() {}

  explicit DeleteRpcServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRpcServiceResponseBody() = default;
};
class DeleteRpcServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRpcServiceResponseBody> body{};

  DeleteRpcServiceResponse() {}

  explicit DeleteRpcServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRpcServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRpcServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRpcServiceResponse() = default;
};
class FindPrepublishPassedDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> prepublishId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> deviceId{};

  FindPrepublishPassedDevicesRequest() {}

  explicit FindPrepublishPassedDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (prepublishId) {
      res["PrepublishId"] = boost::any(*prepublishId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrepublishId") != m.end() && !m["PrepublishId"].empty()) {
      prepublishId = make_shared<string>(boost::any_cast<string>(m["PrepublishId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~FindPrepublishPassedDevicesRequest() = default;
};
class FindPrepublishPassedDevicesResponseBodyDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> gmtCreate{};

  FindPrepublishPassedDevicesResponseBodyDeviceListItems() {}

  explicit FindPrepublishPassedDevicesResponseBodyDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
  }


  virtual ~FindPrepublishPassedDevicesResponseBodyDeviceListItems() = default;
};
class FindPrepublishPassedDevicesResponseBodyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<FindPrepublishPassedDevicesResponseBodyDeviceListItems>> items{};
  shared_ptr<long> totalCount{};

  FindPrepublishPassedDevicesResponseBodyDeviceList() {}

  explicit FindPrepublishPassedDevicesResponseBodyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindPrepublishPassedDevicesResponseBodyDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindPrepublishPassedDevicesResponseBodyDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindPrepublishPassedDevicesResponseBodyDeviceListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindPrepublishPassedDevicesResponseBodyDeviceList() = default;
};
class FindPrepublishPassedDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindPrepublishPassedDevicesResponseBodyDeviceList> deviceList{};

  FindPrepublishPassedDevicesResponseBody() {}

  explicit FindPrepublishPassedDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        FindPrepublishPassedDevicesResponseBodyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<FindPrepublishPassedDevicesResponseBodyDeviceList>(model1);
      }
    }
  }


  virtual ~FindPrepublishPassedDevicesResponseBody() = default;
};
class FindPrepublishPassedDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindPrepublishPassedDevicesResponseBody> body{};

  FindPrepublishPassedDevicesResponse() {}

  explicit FindPrepublishPassedDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindPrepublishPassedDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindPrepublishPassedDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~FindPrepublishPassedDevicesResponse() = default;
};
class DeleteVersionBlackDevicesByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};

  DeleteVersionBlackDevicesByIdRequest() {}

  explicit DeleteVersionBlackDevicesByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteVersionBlackDevicesByIdRequest() = default;
};
class DeleteVersionBlackDevicesByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionBlackDevicesByIdResponseBody() {}

  explicit DeleteVersionBlackDevicesByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionBlackDevicesByIdResponseBody() = default;
};
class DeleteVersionBlackDevicesByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionBlackDevicesByIdResponseBody> body{};

  DeleteVersionBlackDevicesByIdResponse() {}

  explicit DeleteVersionBlackDevicesByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionBlackDevicesByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionBlackDevicesByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionBlackDevicesByIdResponse() = default;
};
class DescribeOpenAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> identityId{};
  shared_ptr<string> idp{};
  shared_ptr<string> idToken{};
  shared_ptr<string> openId{};

  DescribeOpenAccountRequest() {}

  explicit DescribeOpenAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (idp) {
      res["Idp"] = boost::any(*idp);
    }
    if (idToken) {
      res["IdToken"] = boost::any(*idToken);
    }
    if (openId) {
      res["OpenId"] = boost::any(*openId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("Idp") != m.end() && !m["Idp"].empty()) {
      idp = make_shared<string>(boost::any_cast<string>(m["Idp"]));
    }
    if (m.find("IdToken") != m.end() && !m["IdToken"].empty()) {
      idToken = make_shared<string>(boost::any_cast<string>(m["IdToken"]));
    }
    if (m.find("OpenId") != m.end() && !m["OpenId"].empty()) {
      openId = make_shared<string>(boost::any_cast<string>(m["OpenId"]));
    }
  }


  virtual ~DescribeOpenAccountRequest() = default;
};
class DescribeOpenAccountResponseBodyOpenAccount : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> displayName{};
  shared_ptr<string> createAccessKey{};
  shared_ptr<string> openId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> region{};
  shared_ptr<string> identityId{};
  shared_ptr<string> loginId{};
  shared_ptr<string> idp{};
  shared_ptr<string> aliyunId{};

  DescribeOpenAccountResponseBodyOpenAccount() {}

  explicit DescribeOpenAccountResponseBodyOpenAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (createAccessKey) {
      res["CreateAccessKey"] = boost::any(*createAccessKey);
    }
    if (openId) {
      res["OpenId"] = boost::any(*openId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (loginId) {
      res["LoginId"] = boost::any(*loginId);
    }
    if (idp) {
      res["Idp"] = boost::any(*idp);
    }
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("CreateAccessKey") != m.end() && !m["CreateAccessKey"].empty()) {
      createAccessKey = make_shared<string>(boost::any_cast<string>(m["CreateAccessKey"]));
    }
    if (m.find("OpenId") != m.end() && !m["OpenId"].empty()) {
      openId = make_shared<string>(boost::any_cast<string>(m["OpenId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("LoginId") != m.end() && !m["LoginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["LoginId"]));
    }
    if (m.find("Idp") != m.end() && !m["Idp"].empty()) {
      idp = make_shared<string>(boost::any_cast<string>(m["Idp"]));
    }
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<string>(boost::any_cast<string>(m["AliyunId"]));
    }
  }


  virtual ~DescribeOpenAccountResponseBodyOpenAccount() = default;
};
class DescribeOpenAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeOpenAccountResponseBodyOpenAccount> openAccount{};
  shared_ptr<string> requestId{};

  DescribeOpenAccountResponseBody() {}

  explicit DescribeOpenAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openAccount) {
      res["OpenAccount"] = openAccount ? boost::any(openAccount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenAccount") != m.end() && !m["OpenAccount"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenAccount"].type()) {
        DescribeOpenAccountResponseBodyOpenAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenAccount"]));
        openAccount = make_shared<DescribeOpenAccountResponseBodyOpenAccount>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOpenAccountResponseBody() = default;
};
class DescribeOpenAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeOpenAccountResponseBody> body{};

  DescribeOpenAccountResponse() {}

  explicit DescribeOpenAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOpenAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOpenAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOpenAccountResponse() = default;
};
class FindCustomizedFiltersRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> name{};
  shared_ptr<string> versionType{};

  FindCustomizedFiltersRequest() {}

  explicit FindCustomizedFiltersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindCustomizedFiltersRequest() = default;
};
class FindCustomizedFiltersResponseBodyCustomizedFilterListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> value{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> valueCompareType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> blackWhiteType{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  FindCustomizedFiltersResponseBodyCustomizedFilterListItems() {}

  explicit FindCustomizedFiltersResponseBodyCustomizedFilterListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (valueCompareType) {
      res["ValueCompareType"] = boost::any(*valueCompareType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (blackWhiteType) {
      res["BlackWhiteType"] = boost::any(*blackWhiteType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("ValueCompareType") != m.end() && !m["ValueCompareType"].empty()) {
      valueCompareType = make_shared<string>(boost::any_cast<string>(m["ValueCompareType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("BlackWhiteType") != m.end() && !m["BlackWhiteType"].empty()) {
      blackWhiteType = make_shared<string>(boost::any_cast<string>(m["BlackWhiteType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindCustomizedFiltersResponseBodyCustomizedFilterListItems() = default;
};
class FindCustomizedFiltersResponseBodyCustomizedFilterList : public Darabonba::Model {
public:
  shared_ptr<vector<FindCustomizedFiltersResponseBodyCustomizedFilterListItems>> items{};
  shared_ptr<long> totalCount{};

  FindCustomizedFiltersResponseBodyCustomizedFilterList() {}

  explicit FindCustomizedFiltersResponseBodyCustomizedFilterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindCustomizedFiltersResponseBodyCustomizedFilterListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindCustomizedFiltersResponseBodyCustomizedFilterListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindCustomizedFiltersResponseBodyCustomizedFilterListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindCustomizedFiltersResponseBodyCustomizedFilterList() = default;
};
class FindCustomizedFiltersResponseBody : public Darabonba::Model {
public:
  shared_ptr<FindCustomizedFiltersResponseBodyCustomizedFilterList> customizedFilterList{};
  shared_ptr<string> requestId{};

  FindCustomizedFiltersResponseBody() {}

  explicit FindCustomizedFiltersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedFilterList) {
      res["CustomizedFilterList"] = customizedFilterList ? boost::any(customizedFilterList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedFilterList") != m.end() && !m["CustomizedFilterList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomizedFilterList"].type()) {
        FindCustomizedFiltersResponseBodyCustomizedFilterList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomizedFilterList"]));
        customizedFilterList = make_shared<FindCustomizedFiltersResponseBodyCustomizedFilterList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FindCustomizedFiltersResponseBody() = default;
};
class FindCustomizedFiltersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindCustomizedFiltersResponseBody> body{};

  FindCustomizedFiltersResponse() {}

  explicit FindCustomizedFiltersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindCustomizedFiltersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindCustomizedFiltersResponseBody>(model1);
      }
    }
  }


  virtual ~FindCustomizedFiltersResponse() = default;
};
class DeployFunctionFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> fileId{};
  shared_ptr<long> deployEnv{};

  DeployFunctionFileRequest() {}

  explicit DeployFunctionFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (deployEnv) {
      res["DeployEnv"] = boost::any(*deployEnv);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("DeployEnv") != m.end() && !m["DeployEnv"].empty()) {
      deployEnv = make_shared<long>(boost::any_cast<long>(m["DeployEnv"]));
    }
  }


  virtual ~DeployFunctionFileRequest() = default;
};
class DeployFunctionFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeployFunctionFileResponseBody() {}

  explicit DeployFunctionFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployFunctionFileResponseBody() = default;
};
class DeployFunctionFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeployFunctionFileResponseBody> body{};

  DeployFunctionFileResponse() {}

  explicit DeployFunctionFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployFunctionFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployFunctionFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeployFunctionFileResponse() = default;
};
class ListAssistActionDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionTimestamp{};
  shared_ptr<string> projectId{};

  ListAssistActionDetailsRequest() {}

  explicit ListAssistActionDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionTimestamp) {
      res["ActionTimestamp"] = boost::any(*actionTimestamp);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionTimestamp") != m.end() && !m["ActionTimestamp"].empty()) {
      actionTimestamp = make_shared<string>(boost::any_cast<string>(m["ActionTimestamp"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListAssistActionDetailsRequest() = default;
};
class ListAssistActionDetailsResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> action{};
  shared_ptr<string> data{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> createdAt{};
  shared_ptr<long> updatedAt{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> ID{};

  ListAssistActionDetailsResponseBodyResults() {}

  explicit ListAssistActionDetailsResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (updatedAt) {
      res["UpdatedAt"] = boost::any(*updatedAt);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<long>(boost::any_cast<long>(m["CreatedAt"]));
    }
    if (m.find("UpdatedAt") != m.end() && !m["UpdatedAt"].empty()) {
      updatedAt = make_shared<long>(boost::any_cast<long>(m["UpdatedAt"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
  }


  virtual ~ListAssistActionDetailsResponseBodyResults() = default;
};
class ListAssistActionDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAssistActionDetailsResponseBodyResults>> results{};

  ListAssistActionDetailsResponseBody() {}

  explicit ListAssistActionDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<ListAssistActionDetailsResponseBodyResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAssistActionDetailsResponseBodyResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<ListAssistActionDetailsResponseBodyResults>>(expect1);
      }
    }
  }


  virtual ~ListAssistActionDetailsResponseBody() = default;
};
class ListAssistActionDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAssistActionDetailsResponseBody> body{};

  ListAssistActionDetailsResponse() {}

  explicit ListAssistActionDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAssistActionDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAssistActionDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAssistActionDetailsResponse() = default;
};
class DescribeMqttTopicSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> topic{};
  shared_ptr<string> projectId{};

  DescribeMqttTopicSubscriptionRequest() {}

  explicit DescribeMqttTopicSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeMqttTopicSubscriptionRequest() = default;
};
class DescribeMqttTopicSubscriptionResponseBodySubscription : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<long> count{};

  DescribeMqttTopicSubscriptionResponseBodySubscription() {}

  explicit DescribeMqttTopicSubscriptionResponseBodySubscription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~DescribeMqttTopicSubscriptionResponseBodySubscription() = default;
};
class DescribeMqttTopicSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMqttTopicSubscriptionResponseBodySubscription> subscription{};

  DescribeMqttTopicSubscriptionResponseBody() {}

  explicit DescribeMqttTopicSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subscription) {
      res["Subscription"] = subscription ? boost::any(subscription->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Subscription") != m.end() && !m["Subscription"].empty()) {
      if (typeid(map<string, boost::any>) == m["Subscription"].type()) {
        DescribeMqttTopicSubscriptionResponseBodySubscription model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Subscription"]));
        subscription = make_shared<DescribeMqttTopicSubscriptionResponseBodySubscription>(model1);
      }
    }
  }


  virtual ~DescribeMqttTopicSubscriptionResponseBody() = default;
};
class DescribeMqttTopicSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMqttTopicSubscriptionResponseBody> body{};

  DescribeMqttTopicSubscriptionResponse() {}

  explicit DescribeMqttTopicSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMqttTopicSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMqttTopicSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMqttTopicSubscriptionResponse() = default;
};
class PushVersionMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};

  PushVersionMessageRequest() {}

  explicit PushVersionMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~PushVersionMessageRequest() = default;
};
class PushVersionMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PushVersionMessageResponseBody() {}

  explicit PushVersionMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushVersionMessageResponseBody() = default;
};
class PushVersionMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PushVersionMessageResponseBody> body{};

  PushVersionMessageResponse() {}

  explicit PushVersionMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushVersionMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushVersionMessageResponseBody>(model1);
      }
    }
  }


  virtual ~PushVersionMessageResponse() = default;
};
class CountDeviceModelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceBrand{};

  CountDeviceModelsRequest() {}

  explicit CountDeviceModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~CountDeviceModelsRequest() = default;
};
class CountDeviceModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> modelCount{};

  CountDeviceModelsResponseBody() {}

  explicit CountDeviceModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (modelCount) {
      res["ModelCount"] = boost::any(*modelCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ModelCount") != m.end() && !m["ModelCount"].empty()) {
      modelCount = make_shared<long>(boost::any_cast<long>(m["ModelCount"]));
    }
  }


  virtual ~CountDeviceModelsResponseBody() = default;
};
class CountDeviceModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountDeviceModelsResponseBody> body{};

  CountDeviceModelsResponse() {}

  explicit CountDeviceModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountDeviceModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountDeviceModelsResponseBody>(model1);
      }
    }
  }


  virtual ~CountDeviceModelsResponse() = default;
};
class CreateDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> modelName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> hardwareId{};

  CreateDeviceRequest() {}

  explicit CreateDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
  }


  virtual ~CreateDeviceRequest() = default;
};
class CreateDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> deviceId{};

  CreateDeviceResponseBody() {}

  explicit CreateDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<long>(boost::any_cast<long>(m["DeviceId"]));
    }
  }


  virtual ~CreateDeviceResponseBody() = default;
};
class CreateDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeviceResponseBody> body{};

  CreateDeviceResponse() {}

  explicit CreateDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceResponse() = default;
};
class CreateNamespaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> authType{};
  shared_ptr<string> name{};
  shared_ptr<string> desc{};

  CreateNamespaceRequest() {}

  explicit CreateNamespaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
  }


  virtual ~CreateNamespaceRequest() = default;
};
class CreateNamespaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> namespace_{};

  CreateNamespaceResponseBody() {}

  explicit CreateNamespaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
  }


  virtual ~CreateNamespaceResponseBody() = default;
};
class CreateNamespaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateNamespaceResponseBody> body{};

  CreateNamespaceResponse() {}

  explicit CreateNamespaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNamespaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNamespaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNamespaceResponse() = default;
};
class FindVersionDeviceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> originalId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};

  FindVersionDeviceGroupsRequest() {}

  explicit FindVersionDeviceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~FindVersionDeviceGroupsRequest() = default;
};
class FindVersionDeviceGroupsResponseBodyDeviceGroupListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> maxCount{};

  FindVersionDeviceGroupsResponseBodyDeviceGroupListItems() {}

  explicit FindVersionDeviceGroupsResponseBodyDeviceGroupListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxCount) {
      res["MaxCount"] = boost::any(*maxCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxCount") != m.end() && !m["MaxCount"].empty()) {
      maxCount = make_shared<string>(boost::any_cast<string>(m["MaxCount"]));
    }
  }


  virtual ~FindVersionDeviceGroupsResponseBodyDeviceGroupListItems() = default;
};
class FindVersionDeviceGroupsResponseBodyDeviceGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionDeviceGroupsResponseBodyDeviceGroupListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionDeviceGroupsResponseBodyDeviceGroupList() {}

  explicit FindVersionDeviceGroupsResponseBodyDeviceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionDeviceGroupsResponseBodyDeviceGroupListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionDeviceGroupsResponseBodyDeviceGroupListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionDeviceGroupsResponseBodyDeviceGroupListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionDeviceGroupsResponseBodyDeviceGroupList() = default;
};
class FindVersionDeviceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionDeviceGroupsResponseBodyDeviceGroupList> deviceGroupList{};

  FindVersionDeviceGroupsResponseBody() {}

  explicit FindVersionDeviceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceGroupList) {
      res["DeviceGroupList"] = deviceGroupList ? boost::any(deviceGroupList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceGroupList") != m.end() && !m["DeviceGroupList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceGroupList"].type()) {
        FindVersionDeviceGroupsResponseBodyDeviceGroupList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceGroupList"]));
        deviceGroupList = make_shared<FindVersionDeviceGroupsResponseBodyDeviceGroupList>(model1);
      }
    }
  }


  virtual ~FindVersionDeviceGroupsResponseBody() = default;
};
class FindVersionDeviceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionDeviceGroupsResponseBody> body{};

  FindVersionDeviceGroupsResponse() {}

  explicit FindVersionDeviceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionDeviceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionDeviceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionDeviceGroupsResponse() = default;
};
class ExecuteRemoteCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> clientId{};
  shared_ptr<long> command{};
  shared_ptr<string> params{};

  ExecuteRemoteCommandRequest() {}

  explicit ExecuteRemoteCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<long>(boost::any_cast<long>(m["Command"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
  }


  virtual ~ExecuteRemoteCommandRequest() = default;
};
class ExecuteRemoteCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  ExecuteRemoteCommandResponseBody() {}

  explicit ExecuteRemoteCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~ExecuteRemoteCommandResponseBody() = default;
};
class ExecuteRemoteCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExecuteRemoteCommandResponseBody> body{};

  ExecuteRemoteCommandResponse() {}

  explicit ExecuteRemoteCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteRemoteCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteRemoteCommandResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteRemoteCommandResponse() = default;
};
class CreateVersionDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> maxCount{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  CreateVersionDeviceGroupRequest() {}

  explicit CreateVersionDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCount) {
      res["MaxCount"] = boost::any(*maxCount);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCount") != m.end() && !m["MaxCount"].empty()) {
      maxCount = make_shared<string>(boost::any_cast<string>(m["MaxCount"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateVersionDeviceGroupRequest() = default;
};
class CreateVersionDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> deviceGroupId{};

  CreateVersionDeviceGroupResponseBody() {}

  explicit CreateVersionDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
  }


  virtual ~CreateVersionDeviceGroupResponseBody() = default;
};
class CreateVersionDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVersionDeviceGroupResponseBody> body{};

  CreateVersionDeviceGroupResponse() {}

  explicit CreateVersionDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVersionDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVersionDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVersionDeviceGroupResponse() = default;
};
class DescribeAssistReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> assistId{};

  DescribeAssistReportRequest() {}

  explicit DescribeAssistReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (assistId) {
      res["AssistId"] = boost::any(*assistId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AssistId") != m.end() && !m["AssistId"].empty()) {
      assistId = make_shared<string>(boost::any_cast<string>(m["AssistId"]));
    }
  }


  virtual ~DescribeAssistReportRequest() = default;
};
class DescribeAssistReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> assistResult{};
  shared_ptr<string> assistReason{};
  shared_ptr<string> assistId{};
  shared_ptr<string> assistDescription{};
  shared_ptr<string> assistTag{};

  DescribeAssistReportResponseBody() {}

  explicit DescribeAssistReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (assistResult) {
      res["AssistResult"] = boost::any(*assistResult);
    }
    if (assistReason) {
      res["AssistReason"] = boost::any(*assistReason);
    }
    if (assistId) {
      res["AssistId"] = boost::any(*assistId);
    }
    if (assistDescription) {
      res["AssistDescription"] = boost::any(*assistDescription);
    }
    if (assistTag) {
      res["AssistTag"] = boost::any(*assistTag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AssistResult") != m.end() && !m["AssistResult"].empty()) {
      assistResult = make_shared<string>(boost::any_cast<string>(m["AssistResult"]));
    }
    if (m.find("AssistReason") != m.end() && !m["AssistReason"].empty()) {
      assistReason = make_shared<string>(boost::any_cast<string>(m["AssistReason"]));
    }
    if (m.find("AssistId") != m.end() && !m["AssistId"].empty()) {
      assistId = make_shared<string>(boost::any_cast<string>(m["AssistId"]));
    }
    if (m.find("AssistDescription") != m.end() && !m["AssistDescription"].empty()) {
      assistDescription = make_shared<string>(boost::any_cast<string>(m["AssistDescription"]));
    }
    if (m.find("AssistTag") != m.end() && !m["AssistTag"].empty()) {
      assistTag = make_shared<string>(boost::any_cast<string>(m["AssistTag"]));
    }
  }


  virtual ~DescribeAssistReportResponseBody() = default;
};
class DescribeAssistReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAssistReportResponseBody> body{};

  DescribeAssistReportResponse() {}

  explicit DescribeAssistReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAssistReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAssistReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAssistReportResponse() = default;
};
class ListConnectLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageIndex{};

  ListConnectLogsRequest() {}

  explicit ListConnectLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~ListConnectLogsRequest() = default;
};
class ListConnectLogsResponseBodyLogsPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListConnectLogsResponseBodyLogsPagination() {}

  explicit ListConnectLogsResponseBodyLogsPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConnectLogsResponseBodyLogsPagination() = default;
};
class ListConnectLogsResponseBodyLogsList : public Darabonba::Model {
public:
  shared_ptr<string> sid{};
  shared_ptr<string> status{};
  shared_ptr<long> time{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> ip{};
  shared_ptr<string> netWorking{};
  shared_ptr<string> terminal{};

  ListConnectLogsResponseBodyLogsList() {}

  explicit ListConnectLogsResponseBodyLogsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sid) {
      res["Sid"] = boost::any(*sid);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (netWorking) {
      res["NetWorking"] = boost::any(*netWorking);
    }
    if (terminal) {
      res["Terminal"] = boost::any(*terminal);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sid") != m.end() && !m["Sid"].empty()) {
      sid = make_shared<string>(boost::any_cast<string>(m["Sid"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("NetWorking") != m.end() && !m["NetWorking"].empty()) {
      netWorking = make_shared<string>(boost::any_cast<string>(m["NetWorking"]));
    }
    if (m.find("Terminal") != m.end() && !m["Terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["Terminal"]));
    }
  }


  virtual ~ListConnectLogsResponseBodyLogsList() = default;
};
class ListConnectLogsResponseBodyLogs : public Darabonba::Model {
public:
  shared_ptr<ListConnectLogsResponseBodyLogsPagination> pagination{};
  shared_ptr<vector<ListConnectLogsResponseBodyLogsList>> list{};

  ListConnectLogsResponseBodyLogs() {}

  explicit ListConnectLogsResponseBodyLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListConnectLogsResponseBodyLogsPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListConnectLogsResponseBodyLogsPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListConnectLogsResponseBodyLogsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConnectLogsResponseBodyLogsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListConnectLogsResponseBodyLogsList>>(expect1);
      }
    }
  }


  virtual ~ListConnectLogsResponseBodyLogs() = default;
};
class ListConnectLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListConnectLogsResponseBodyLogs> logs{};

  ListConnectLogsResponseBody() {}

  explicit ListConnectLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (logs) {
      res["Logs"] = logs ? boost::any(logs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Logs"].type()) {
        ListConnectLogsResponseBodyLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Logs"]));
        logs = make_shared<ListConnectLogsResponseBodyLogs>(model1);
      }
    }
  }


  virtual ~ListConnectLogsResponseBody() = default;
};
class ListConnectLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListConnectLogsResponseBody> body{};

  ListConnectLogsResponse() {}

  explicit ListConnectLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConnectLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConnectLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConnectLogsResponse() = default;
};
class ListClientPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> osType{};

  ListClientPluginsRequest() {}

  explicit ListClientPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
  }


  virtual ~ListClientPluginsRequest() = default;
};
class ListClientPluginsResponseBodyClientPlugins : public Darabonba::Model {
public:
  shared_ptr<string> pkgName{};
  shared_ptr<string> name{};

  ListClientPluginsResponseBodyClientPlugins() {}

  explicit ListClientPluginsResponseBodyClientPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListClientPluginsResponseBodyClientPlugins() = default;
};
class ListClientPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListClientPluginsResponseBodyClientPlugins>> clientPlugins{};

  ListClientPluginsResponseBody() {}

  explicit ListClientPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clientPlugins) {
      vector<boost::any> temp1;
      for(auto item1:*clientPlugins){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientPlugins"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClientPlugins") != m.end() && !m["ClientPlugins"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientPlugins"].type()) {
        vector<ListClientPluginsResponseBodyClientPlugins> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientPlugins"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientPluginsResponseBodyClientPlugins model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientPlugins = make_shared<vector<ListClientPluginsResponseBodyClientPlugins>>(expect1);
      }
    }
  }


  virtual ~ListClientPluginsResponseBody() = default;
};
class ListClientPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClientPluginsResponseBody> body{};

  ListClientPluginsResponse() {}

  explicit ListClientPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientPluginsResponse() = default;
};
class DescribeShadowSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModel{};
  shared_ptr<bool> isSimple{};
  shared_ptr<string> projectId{};

  DescribeShadowSchemaRequest() {}

  explicit DescribeShadowSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (isSimple) {
      res["IsSimple"] = boost::any(*isSimple);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("IsSimple") != m.end() && !m["IsSimple"].empty()) {
      isSimple = make_shared<bool>(boost::any_cast<bool>(m["IsSimple"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeShadowSchemaRequest() = default;
};
class DescribeShadowSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> schema{};

  DescribeShadowSchemaResponseBody() {}

  explicit DescribeShadowSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~DescribeShadowSchemaResponseBody() = default;
};
class DescribeShadowSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeShadowSchemaResponseBody> body{};

  DescribeShadowSchemaResponse() {}

  explicit DescribeShadowSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeShadowSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeShadowSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeShadowSchemaResponse() = default;
};
class FindVersionBlackDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> originalId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  FindVersionBlackDevicesRequest() {}

  explicit FindVersionBlackDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~FindVersionBlackDevicesRequest() = default;
};
class FindVersionBlackDevicesResponseBodyDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> originalId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> idType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> id{};

  FindVersionBlackDevicesResponseBodyDeviceListItems() {}

  explicit FindVersionBlackDevicesResponseBodyDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindVersionBlackDevicesResponseBodyDeviceListItems() = default;
};
class FindVersionBlackDevicesResponseBodyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionBlackDevicesResponseBodyDeviceListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionBlackDevicesResponseBodyDeviceList() {}

  explicit FindVersionBlackDevicesResponseBodyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionBlackDevicesResponseBodyDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionBlackDevicesResponseBodyDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionBlackDevicesResponseBodyDeviceListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionBlackDevicesResponseBodyDeviceList() = default;
};
class FindVersionBlackDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionBlackDevicesResponseBodyDeviceList> deviceList{};

  FindVersionBlackDevicesResponseBody() {}

  explicit FindVersionBlackDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        FindVersionBlackDevicesResponseBodyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<FindVersionBlackDevicesResponseBodyDeviceList>(model1);
      }
    }
  }


  virtual ~FindVersionBlackDevicesResponseBody() = default;
};
class FindVersionBlackDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionBlackDevicesResponseBody> body{};

  FindVersionBlackDevicesResponse() {}

  explicit FindVersionBlackDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionBlackDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionBlackDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionBlackDevicesResponse() = default;
};
class ListFunctionFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> fileType{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListFunctionFilesRequest() {}

  explicit ListFunctionFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFunctionFilesRequest() = default;
};
class ListFunctionFilesResponseBodyFileListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListFunctionFilesResponseBodyFileListPagination() {}

  explicit ListFunctionFilesResponseBodyFileListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListFunctionFilesResponseBodyFileListPagination() = default;
};
class ListFunctionFilesResponseBodyFileListFiles : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> productionDeployTime{};
  shared_ptr<long> productionDeployStatus{};
  shared_ptr<string> description{};
  shared_ptr<long> sandboxDeployTime{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> sandboxDeployStatus{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> contentId{};
  shared_ptr<long> id{};

  ListFunctionFilesResponseBodyFileListFiles() {}

  explicit ListFunctionFilesResponseBodyFileListFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (productionDeployTime) {
      res["ProductionDeployTime"] = boost::any(*productionDeployTime);
    }
    if (productionDeployStatus) {
      res["ProductionDeployStatus"] = boost::any(*productionDeployStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (sandboxDeployTime) {
      res["SandboxDeployTime"] = boost::any(*sandboxDeployTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (sandboxDeployStatus) {
      res["SandboxDeployStatus"] = boost::any(*sandboxDeployStatus);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("ProductionDeployTime") != m.end() && !m["ProductionDeployTime"].empty()) {
      productionDeployTime = make_shared<long>(boost::any_cast<long>(m["ProductionDeployTime"]));
    }
    if (m.find("ProductionDeployStatus") != m.end() && !m["ProductionDeployStatus"].empty()) {
      productionDeployStatus = make_shared<long>(boost::any_cast<long>(m["ProductionDeployStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SandboxDeployTime") != m.end() && !m["SandboxDeployTime"].empty()) {
      sandboxDeployTime = make_shared<long>(boost::any_cast<long>(m["SandboxDeployTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("SandboxDeployStatus") != m.end() && !m["SandboxDeployStatus"].empty()) {
      sandboxDeployStatus = make_shared<long>(boost::any_cast<long>(m["SandboxDeployStatus"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<long>(boost::any_cast<long>(m["ContentId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListFunctionFilesResponseBodyFileListFiles() = default;
};
class ListFunctionFilesResponseBodyFileList : public Darabonba::Model {
public:
  shared_ptr<ListFunctionFilesResponseBodyFileListPagination> pagination{};
  shared_ptr<vector<ListFunctionFilesResponseBodyFileListFiles>> files{};

  ListFunctionFilesResponseBodyFileList() {}

  explicit ListFunctionFilesResponseBodyFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListFunctionFilesResponseBodyFileListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListFunctionFilesResponseBodyFileListPagination>(model1);
      }
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFunctionFilesResponseBodyFileListFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFunctionFilesResponseBodyFileListFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFunctionFilesResponseBodyFileListFiles>>(expect1);
      }
    }
  }


  virtual ~ListFunctionFilesResponseBodyFileList() = default;
};
class ListFunctionFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListFunctionFilesResponseBodyFileList> fileList{};

  ListFunctionFilesResponseBody() {}

  explicit ListFunctionFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (fileList) {
      res["FileList"] = fileList ? boost::any(fileList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileList"].type()) {
        ListFunctionFilesResponseBodyFileList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileList"]));
        fileList = make_shared<ListFunctionFilesResponseBodyFileList>(model1);
      }
    }
  }


  virtual ~ListFunctionFilesResponseBody() = default;
};
class ListFunctionFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFunctionFilesResponseBody> body{};

  ListFunctionFilesResponse() {}

  explicit ListFunctionFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFunctionFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFunctionFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFunctionFilesResponse() = default;
};
class UpdateNamespaceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> authType{};
  shared_ptr<string> deviceIdType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> accountType{};
  shared_ptr<string> accountId{};
  shared_ptr<string> path{};
  shared_ptr<string> oldData{};
  shared_ptr<string> newData{};

  UpdateNamespaceDataRequest() {}

  explicit UpdateNamespaceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (oldData) {
      res["OldData"] = boost::any(*oldData);
    }
    if (newData) {
      res["NewData"] = boost::any(*newData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("OldData") != m.end() && !m["OldData"].empty()) {
      oldData = make_shared<string>(boost::any_cast<string>(m["OldData"]));
    }
    if (m.find("NewData") != m.end() && !m["NewData"].empty()) {
      newData = make_shared<string>(boost::any_cast<string>(m["NewData"]));
    }
  }


  virtual ~UpdateNamespaceDataRequest() = default;
};
class UpdateNamespaceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateNamespaceDataResponseBody() {}

  explicit UpdateNamespaceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNamespaceDataResponseBody() = default;
};
class UpdateNamespaceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateNamespaceDataResponseBody> body{};

  UpdateNamespaceDataResponse() {}

  explicit UpdateNamespaceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNamespaceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNamespaceDataResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNamespaceDataResponse() = default;
};
class ListEdgeDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> hostDeviceId{};
  shared_ptr<long> edgeDeviceType{};
  shared_ptr<string> edgeDeviceName{};

  ListEdgeDevicesRequest() {}

  explicit ListEdgeDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (hostDeviceId) {
      res["HostDeviceId"] = boost::any(*hostDeviceId);
    }
    if (edgeDeviceType) {
      res["EdgeDeviceType"] = boost::any(*edgeDeviceType);
    }
    if (edgeDeviceName) {
      res["EdgeDeviceName"] = boost::any(*edgeDeviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("HostDeviceId") != m.end() && !m["HostDeviceId"].empty()) {
      hostDeviceId = make_shared<string>(boost::any_cast<string>(m["HostDeviceId"]));
    }
    if (m.find("EdgeDeviceType") != m.end() && !m["EdgeDeviceType"].empty()) {
      edgeDeviceType = make_shared<long>(boost::any_cast<long>(m["EdgeDeviceType"]));
    }
    if (m.find("EdgeDeviceName") != m.end() && !m["EdgeDeviceName"].empty()) {
      edgeDeviceName = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceName"]));
    }
  }


  virtual ~ListEdgeDevicesRequest() = default;
};
class ListEdgeDevicesResponseBodyEdgeDevicesPagination : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListEdgeDevicesResponseBodyEdgeDevicesPagination() {}

  explicit ListEdgeDevicesResponseBodyEdgeDevicesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListEdgeDevicesResponseBodyEdgeDevicesPagination() = default;
};
class ListEdgeDevicesResponseBodyEdgeDevicesList : public Darabonba::Model {
public:
  shared_ptr<string> edgeDeviceId{};
  shared_ptr<long> edgeDeviceType{};
  shared_ptr<string> edgeDeviceName{};
  shared_ptr<long> onlineStatus{};
  shared_ptr<long> activateTime{};
  shared_ptr<long> lastOnlineTime{};

  ListEdgeDevicesResponseBodyEdgeDevicesList() {}

  explicit ListEdgeDevicesResponseBodyEdgeDevicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edgeDeviceId) {
      res["EdgeDeviceId"] = boost::any(*edgeDeviceId);
    }
    if (edgeDeviceType) {
      res["EdgeDeviceType"] = boost::any(*edgeDeviceType);
    }
    if (edgeDeviceName) {
      res["EdgeDeviceName"] = boost::any(*edgeDeviceName);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (activateTime) {
      res["ActivateTime"] = boost::any(*activateTime);
    }
    if (lastOnlineTime) {
      res["LastOnlineTime"] = boost::any(*lastOnlineTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdgeDeviceId") != m.end() && !m["EdgeDeviceId"].empty()) {
      edgeDeviceId = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceId"]));
    }
    if (m.find("EdgeDeviceType") != m.end() && !m["EdgeDeviceType"].empty()) {
      edgeDeviceType = make_shared<long>(boost::any_cast<long>(m["EdgeDeviceType"]));
    }
    if (m.find("EdgeDeviceName") != m.end() && !m["EdgeDeviceName"].empty()) {
      edgeDeviceName = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceName"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<long>(boost::any_cast<long>(m["OnlineStatus"]));
    }
    if (m.find("ActivateTime") != m.end() && !m["ActivateTime"].empty()) {
      activateTime = make_shared<long>(boost::any_cast<long>(m["ActivateTime"]));
    }
    if (m.find("LastOnlineTime") != m.end() && !m["LastOnlineTime"].empty()) {
      lastOnlineTime = make_shared<long>(boost::any_cast<long>(m["LastOnlineTime"]));
    }
  }


  virtual ~ListEdgeDevicesResponseBodyEdgeDevicesList() = default;
};
class ListEdgeDevicesResponseBodyEdgeDevices : public Darabonba::Model {
public:
  shared_ptr<ListEdgeDevicesResponseBodyEdgeDevicesPagination> pagination{};
  shared_ptr<vector<ListEdgeDevicesResponseBodyEdgeDevicesList>> list{};

  ListEdgeDevicesResponseBodyEdgeDevices() {}

  explicit ListEdgeDevicesResponseBodyEdgeDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListEdgeDevicesResponseBodyEdgeDevicesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListEdgeDevicesResponseBodyEdgeDevicesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListEdgeDevicesResponseBodyEdgeDevicesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEdgeDevicesResponseBodyEdgeDevicesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListEdgeDevicesResponseBodyEdgeDevicesList>>(expect1);
      }
    }
  }


  virtual ~ListEdgeDevicesResponseBodyEdgeDevices() = default;
};
class ListEdgeDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListEdgeDevicesResponseBodyEdgeDevices> edgeDevices{};

  ListEdgeDevicesResponseBody() {}

  explicit ListEdgeDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (edgeDevices) {
      res["EdgeDevices"] = edgeDevices ? boost::any(edgeDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EdgeDevices") != m.end() && !m["EdgeDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["EdgeDevices"].type()) {
        ListEdgeDevicesResponseBodyEdgeDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EdgeDevices"]));
        edgeDevices = make_shared<ListEdgeDevicesResponseBodyEdgeDevices>(model1);
      }
    }
  }


  virtual ~ListEdgeDevicesResponseBody() = default;
};
class ListEdgeDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListEdgeDevicesResponseBody> body{};

  ListEdgeDevicesResponse() {}

  explicit ListEdgeDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEdgeDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEdgeDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEdgeDevicesResponse() = default;
};
class DeleteCustomizedPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DeleteCustomizedPropertyRequest() {}

  explicit DeleteCustomizedPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteCustomizedPropertyRequest() = default;
};
class DeleteCustomizedPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomizedPropertyResponseBody() {}

  explicit DeleteCustomizedPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomizedPropertyResponseBody() = default;
};
class DeleteCustomizedPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCustomizedPropertyResponseBody> body{};

  DeleteCustomizedPropertyResponse() {}

  explicit DeleteCustomizedPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomizedPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomizedPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomizedPropertyResponse() = default;
};
class UpdateAppVersionReleaseNoteRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> releaseNote{};

  UpdateAppVersionReleaseNoteRequest() {}

  explicit UpdateAppVersionReleaseNoteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
  }


  virtual ~UpdateAppVersionReleaseNoteRequest() = default;
};
class UpdateAppVersionReleaseNoteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppVersionReleaseNoteResponseBody() {}

  explicit UpdateAppVersionReleaseNoteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppVersionReleaseNoteResponseBody() = default;
};
class UpdateAppVersionReleaseNoteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAppVersionReleaseNoteResponseBody> body{};

  UpdateAppVersionReleaseNoteResponse() {}

  explicit UpdateAppVersionReleaseNoteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppVersionReleaseNoteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppVersionReleaseNoteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppVersionReleaseNoteResponse() = default;
};
class CreateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> source{};
  shared_ptr<string> fileIds{};
  shared_ptr<string> functionIds{};
  shared_ptr<long> invocationMode{};
  shared_ptr<long> sandbox{};
  shared_ptr<long> production{};

  CreateTriggerRequest() {}

  explicit CreateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (fileIds) {
      res["FileIds"] = boost::any(*fileIds);
    }
    if (functionIds) {
      res["FunctionIds"] = boost::any(*functionIds);
    }
    if (invocationMode) {
      res["InvocationMode"] = boost::any(*invocationMode);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (production) {
      res["Production"] = boost::any(*production);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("FileIds") != m.end() && !m["FileIds"].empty()) {
      fileIds = make_shared<string>(boost::any_cast<string>(m["FileIds"]));
    }
    if (m.find("FunctionIds") != m.end() && !m["FunctionIds"].empty()) {
      functionIds = make_shared<string>(boost::any_cast<string>(m["FunctionIds"]));
    }
    if (m.find("InvocationMode") != m.end() && !m["InvocationMode"].empty()) {
      invocationMode = make_shared<long>(boost::any_cast<long>(m["InvocationMode"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<long>(boost::any_cast<long>(m["Sandbox"]));
    }
    if (m.find("Production") != m.end() && !m["Production"].empty()) {
      production = make_shared<long>(boost::any_cast<long>(m["Production"]));
    }
  }


  virtual ~CreateTriggerRequest() = default;
};
class CreateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateTriggerResponseBody() {}

  explicit CreateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTriggerResponseBody() = default;
};
class CreateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTriggerResponseBody> body{};

  CreateTriggerResponse() {}

  explicit CreateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTriggerResponse() = default;
};
class DiagnosisVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> originalId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};
  shared_ptr<string> idType{};
  shared_ptr<string> diagnoseStyle{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  DiagnosisVersionRequest() {}

  explicit DiagnosisVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (diagnoseStyle) {
      res["DiagnoseStyle"] = boost::any(*diagnoseStyle);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("DiagnoseStyle") != m.end() && !m["DiagnoseStyle"].empty()) {
      diagnoseStyle = make_shared<string>(boost::any_cast<string>(m["DiagnoseStyle"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~DiagnosisVersionRequest() = default;
};
class DiagnosisVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> diagnosisResult{};

  DiagnosisVersionResponseBody() {}

  explicit DiagnosisVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (diagnosisResult) {
      res["DiagnosisResult"] = boost::any(*diagnosisResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DiagnosisResult") != m.end() && !m["DiagnosisResult"].empty()) {
      diagnosisResult = make_shared<string>(boost::any_cast<string>(m["DiagnosisResult"]));
    }
  }


  virtual ~DiagnosisVersionResponseBody() = default;
};
class DiagnosisVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DiagnosisVersionResponseBody> body{};

  DiagnosisVersionResponse() {}

  explicit DiagnosisVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiagnosisVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiagnosisVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DiagnosisVersionResponse() = default;
};
class ListShadowSchemaDeviceModelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListShadowSchemaDeviceModelsRequest() {}

  explicit ListShadowSchemaDeviceModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListShadowSchemaDeviceModelsRequest() = default;
};
class ListShadowSchemaDeviceModelsResponseBodyModelList : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> deviceType{};
  shared_ptr<long> canCreateDeviceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> securityChip{};
  shared_ptr<string> description{};
  shared_ptr<string> initUsageTypeDesc{};
  shared_ptr<long> initUsageType{};
  shared_ptr<string> deviceBrand{};

  ListShadowSchemaDeviceModelsResponseBodyModelList() {}

  explicit ListShadowSchemaDeviceModelsResponseBodyModelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (initUsageTypeDesc) {
      res["InitUsageTypeDesc"] = boost::any(*initUsageTypeDesc);
    }
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<long>(boost::any_cast<long>(m["CanCreateDeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<long>(boost::any_cast<long>(m["SecurityChip"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InitUsageTypeDesc") != m.end() && !m["InitUsageTypeDesc"].empty()) {
      initUsageTypeDesc = make_shared<string>(boost::any_cast<string>(m["InitUsageTypeDesc"]));
    }
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<long>(boost::any_cast<long>(m["InitUsageType"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~ListShadowSchemaDeviceModelsResponseBodyModelList() = default;
};
class ListShadowSchemaDeviceModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListShadowSchemaDeviceModelsResponseBodyModelList>> modelList{};
  shared_ptr<string> requestId{};

  ListShadowSchemaDeviceModelsResponseBody() {}

  explicit ListShadowSchemaDeviceModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelList) {
      vector<boost::any> temp1;
      for(auto item1:*modelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelList") != m.end() && !m["ModelList"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelList"].type()) {
        vector<ListShadowSchemaDeviceModelsResponseBodyModelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListShadowSchemaDeviceModelsResponseBodyModelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelList = make_shared<vector<ListShadowSchemaDeviceModelsResponseBodyModelList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListShadowSchemaDeviceModelsResponseBody() = default;
};
class ListShadowSchemaDeviceModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListShadowSchemaDeviceModelsResponseBody> body{};

  ListShadowSchemaDeviceModelsResponse() {}

  explicit ListShadowSchemaDeviceModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListShadowSchemaDeviceModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListShadowSchemaDeviceModelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListShadowSchemaDeviceModelsResponse() = default;
};
class PushConfigInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> hostDeviceId{};
  shared_ptr<string> config{};

  PushConfigInfoRequest() {}

  explicit PushConfigInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (hostDeviceId) {
      res["HostDeviceId"] = boost::any(*hostDeviceId);
    }
    if (config) {
      res["Config"] = boost::any(*config);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("HostDeviceId") != m.end() && !m["HostDeviceId"].empty()) {
      hostDeviceId = make_shared<string>(boost::any_cast<string>(m["HostDeviceId"]));
    }
    if (m.find("Config") != m.end() && !m["Config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["Config"]));
    }
  }


  virtual ~PushConfigInfoRequest() = default;
};
class PushConfigInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PushConfigInfoResponseBody() {}

  explicit PushConfigInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PushConfigInfoResponseBody() = default;
};
class PushConfigInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PushConfigInfoResponseBody> body{};

  PushConfigInfoResponse() {}

  explicit PushConfigInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushConfigInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushConfigInfoResponseBody>(model1);
      }
    }
  }


  virtual ~PushConfigInfoResponse() = default;
};
class GenerateOssUploadMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> ext{};

  GenerateOssUploadMetaRequest() {}

  explicit GenerateOssUploadMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
  }


  virtual ~GenerateOssUploadMetaRequest() = default;
};
class GenerateOssUploadMetaResponseBodyOssUploadMeta : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> bucket{};

  GenerateOssUploadMetaResponseBodyOssUploadMeta() {}

  explicit GenerateOssUploadMetaResponseBodyOssUploadMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
  }


  virtual ~GenerateOssUploadMetaResponseBodyOssUploadMeta() = default;
};
class GenerateOssUploadMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GenerateOssUploadMetaResponseBodyOssUploadMeta> ossUploadMeta{};

  GenerateOssUploadMetaResponseBody() {}

  explicit GenerateOssUploadMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ossUploadMeta) {
      res["OssUploadMeta"] = ossUploadMeta ? boost::any(ossUploadMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OssUploadMeta") != m.end() && !m["OssUploadMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssUploadMeta"].type()) {
        GenerateOssUploadMetaResponseBodyOssUploadMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssUploadMeta"]));
        ossUploadMeta = make_shared<GenerateOssUploadMetaResponseBodyOssUploadMeta>(model1);
      }
    }
  }


  virtual ~GenerateOssUploadMetaResponseBody() = default;
};
class GenerateOssUploadMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateOssUploadMetaResponseBody> body{};

  GenerateOssUploadMetaResponse() {}

  explicit GenerateOssUploadMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateOssUploadMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateOssUploadMetaResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateOssUploadMetaResponse() = default;
};
class AddVersionBlackDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIds{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> deviceIdType{};
  shared_ptr<string> versionId{};

  AddVersionBlackDevicesRequest() {}

  explicit AddVersionBlackDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~AddVersionBlackDevicesRequest() = default;
};
class AddVersionBlackDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVersionBlackDevicesResponseBody() {}

  explicit AddVersionBlackDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVersionBlackDevicesResponseBody() = default;
};
class AddVersionBlackDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddVersionBlackDevicesResponseBody> body{};

  AddVersionBlackDevicesResponse() {}

  explicit AddVersionBlackDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVersionBlackDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVersionBlackDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~AddVersionBlackDevicesResponse() = default;
};
class DescribeCustomizedFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DescribeCustomizedFilterRequest() {}

  explicit DescribeCustomizedFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeCustomizedFilterRequest() = default;
};
class DescribeCustomizedFilterResponseBodyCustomizedFilter : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> valueCompareType{};
  shared_ptr<long> versionId{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> value{};
  shared_ptr<string> valueType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> blackWhiteType{};
  shared_ptr<string> name{};
  shared_ptr<string> versionType{};
  shared_ptr<long> id{};

  DescribeCustomizedFilterResponseBodyCustomizedFilter() {}

  explicit DescribeCustomizedFilterResponseBodyCustomizedFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (valueCompareType) {
      res["ValueCompareType"] = boost::any(*valueCompareType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (blackWhiteType) {
      res["BlackWhiteType"] = boost::any(*blackWhiteType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("ValueCompareType") != m.end() && !m["ValueCompareType"].empty()) {
      valueCompareType = make_shared<string>(boost::any_cast<string>(m["ValueCompareType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("BlackWhiteType") != m.end() && !m["BlackWhiteType"].empty()) {
      blackWhiteType = make_shared<string>(boost::any_cast<string>(m["BlackWhiteType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeCustomizedFilterResponseBodyCustomizedFilter() = default;
};
class DescribeCustomizedFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCustomizedFilterResponseBodyCustomizedFilter> customizedFilter{};
  shared_ptr<string> requestId{};

  DescribeCustomizedFilterResponseBody() {}

  explicit DescribeCustomizedFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedFilter) {
      res["CustomizedFilter"] = customizedFilter ? boost::any(customizedFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedFilter") != m.end() && !m["CustomizedFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomizedFilter"].type()) {
        DescribeCustomizedFilterResponseBodyCustomizedFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomizedFilter"]));
        customizedFilter = make_shared<DescribeCustomizedFilterResponseBodyCustomizedFilter>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCustomizedFilterResponseBody() = default;
};
class DescribeCustomizedFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCustomizedFilterResponseBody> body{};

  DescribeCustomizedFilterResponse() {}

  explicit DescribeCustomizedFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomizedFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomizedFilterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomizedFilterResponse() = default;
};
class DescribeDeviceIdByOuterInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> queryType{};
  shared_ptr<string> queryValue{};

  DescribeDeviceIdByOuterInfoRequest() {}

  explicit DescribeDeviceIdByOuterInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (queryValue) {
      res["QueryValue"] = boost::any(*queryValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("QueryValue") != m.end() && !m["QueryValue"].empty()) {
      queryValue = make_shared<string>(boost::any_cast<string>(m["QueryValue"]));
    }
  }


  virtual ~DescribeDeviceIdByOuterInfoRequest() = default;
};
class DescribeDeviceIdByOuterInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> deviceId{};

  DescribeDeviceIdByOuterInfoResponseBody() {}

  explicit DescribeDeviceIdByOuterInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~DescribeDeviceIdByOuterInfoResponseBody() = default;
};
class DescribeDeviceIdByOuterInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceIdByOuterInfoResponseBody> body{};

  DescribeDeviceIdByOuterInfoResponse() {}

  explicit DescribeDeviceIdByOuterInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceIdByOuterInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceIdByOuterInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceIdByOuterInfoResponse() = default;
};
class CreateAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<string> isAllowNewInstall{};
  shared_ptr<string> projectId{};
  shared_ptr<string> appId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> installType{};
  shared_ptr<string> remark{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> isSilentUpgrade{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> isNeedRestart{};
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> restartType{};
  shared_ptr<string> restartAppType{};
  shared_ptr<string> restartAppParam{};
  shared_ptr<string> deviceAdapterList{};
  shared_ptr<string> apkMd5{};

  CreateAppVersionRequest() {}

  explicit CreateAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (isAllowNewInstall) {
      res["IsAllowNewInstall"] = boost::any(*isAllowNewInstall);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (isSilentUpgrade) {
      res["IsSilentUpgrade"] = boost::any(*isSilentUpgrade);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (isNeedRestart) {
      res["IsNeedRestart"] = boost::any(*isNeedRestart);
    }
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (restartType) {
      res["RestartType"] = boost::any(*restartType);
    }
    if (restartAppType) {
      res["RestartAppType"] = boost::any(*restartAppType);
    }
    if (restartAppParam) {
      res["RestartAppParam"] = boost::any(*restartAppParam);
    }
    if (deviceAdapterList) {
      res["DeviceAdapterList"] = boost::any(*deviceAdapterList);
    }
    if (apkMd5) {
      res["ApkMd5"] = boost::any(*apkMd5);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("IsAllowNewInstall") != m.end() && !m["IsAllowNewInstall"].empty()) {
      isAllowNewInstall = make_shared<string>(boost::any_cast<string>(m["IsAllowNewInstall"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<string>(boost::any_cast<string>(m["InstallType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("IsSilentUpgrade") != m.end() && !m["IsSilentUpgrade"].empty()) {
      isSilentUpgrade = make_shared<string>(boost::any_cast<string>(m["IsSilentUpgrade"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("IsNeedRestart") != m.end() && !m["IsNeedRestart"].empty()) {
      isNeedRestart = make_shared<string>(boost::any_cast<string>(m["IsNeedRestart"]));
    }
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("RestartType") != m.end() && !m["RestartType"].empty()) {
      restartType = make_shared<string>(boost::any_cast<string>(m["RestartType"]));
    }
    if (m.find("RestartAppType") != m.end() && !m["RestartAppType"].empty()) {
      restartAppType = make_shared<string>(boost::any_cast<string>(m["RestartAppType"]));
    }
    if (m.find("RestartAppParam") != m.end() && !m["RestartAppParam"].empty()) {
      restartAppParam = make_shared<string>(boost::any_cast<string>(m["RestartAppParam"]));
    }
    if (m.find("DeviceAdapterList") != m.end() && !m["DeviceAdapterList"].empty()) {
      deviceAdapterList = make_shared<string>(boost::any_cast<string>(m["DeviceAdapterList"]));
    }
    if (m.find("ApkMd5") != m.end() && !m["ApkMd5"].empty()) {
      apkMd5 = make_shared<string>(boost::any_cast<string>(m["ApkMd5"]));
    }
  }


  virtual ~CreateAppVersionRequest() = default;
};
class CreateAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};
  shared_ptr<string> requestId{};

  CreateAppVersionResponseBody() {}

  explicit CreateAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAppVersionResponseBody() = default;
};
class CreateAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAppVersionResponseBody> body{};

  CreateAppVersionResponse() {}

  explicit CreateAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppVersionResponse() = default;
};
class CountActivatedOrNewRegistrationDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> deviceBrandId{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> deviceCountStatType{};
  shared_ptr<string> isQueryNewRegistrationDevice{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> isQueryYearlyActivate{};

  CountActivatedOrNewRegistrationDeviceRequest() {}

  explicit CountActivatedOrNewRegistrationDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (deviceCountStatType) {
      res["DeviceCountStatType"] = boost::any(*deviceCountStatType);
    }
    if (isQueryNewRegistrationDevice) {
      res["IsQueryNewRegistrationDevice"] = boost::any(*isQueryNewRegistrationDevice);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (isQueryYearlyActivate) {
      res["IsQueryYearlyActivate"] = boost::any(*isQueryYearlyActivate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<string>(boost::any_cast<string>(m["DeviceBrandId"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("DeviceCountStatType") != m.end() && !m["DeviceCountStatType"].empty()) {
      deviceCountStatType = make_shared<string>(boost::any_cast<string>(m["DeviceCountStatType"]));
    }
    if (m.find("IsQueryNewRegistrationDevice") != m.end() && !m["IsQueryNewRegistrationDevice"].empty()) {
      isQueryNewRegistrationDevice = make_shared<string>(boost::any_cast<string>(m["IsQueryNewRegistrationDevice"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("IsQueryYearlyActivate") != m.end() && !m["IsQueryYearlyActivate"].empty()) {
      isQueryYearlyActivate = make_shared<string>(boost::any_cast<string>(m["IsQueryYearlyActivate"]));
    }
  }


  virtual ~CountActivatedOrNewRegistrationDeviceRequest() = default;
};
class CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries : public Darabonba::Model {
public:
  shared_ptr<vector<string>> data{};
  shared_ptr<string> name{};

  CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries() {}

  explicit CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries() = default;
};
class CountActivatedOrNewRegistrationDeviceResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<vector<CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries>> series{};

  CountActivatedOrNewRegistrationDeviceResponseBodyStatistics() {}

  explicit CountActivatedOrNewRegistrationDeviceResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      if (typeid(vector<boost::any>) == m["Series"].type()) {
        vector<CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<CountActivatedOrNewRegistrationDeviceResponseBodyStatisticsSeries>>(expect1);
      }
    }
  }


  virtual ~CountActivatedOrNewRegistrationDeviceResponseBodyStatistics() = default;
};
class CountActivatedOrNewRegistrationDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CountActivatedOrNewRegistrationDeviceResponseBodyStatistics> statistics{};

  CountActivatedOrNewRegistrationDeviceResponseBody() {}

  explicit CountActivatedOrNewRegistrationDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        CountActivatedOrNewRegistrationDeviceResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<CountActivatedOrNewRegistrationDeviceResponseBodyStatistics>(model1);
      }
    }
  }


  virtual ~CountActivatedOrNewRegistrationDeviceResponseBody() = default;
};
class CountActivatedOrNewRegistrationDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountActivatedOrNewRegistrationDeviceResponseBody> body{};

  CountActivatedOrNewRegistrationDeviceResponse() {}

  explicit CountActivatedOrNewRegistrationDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountActivatedOrNewRegistrationDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountActivatedOrNewRegistrationDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~CountActivatedOrNewRegistrationDeviceResponse() = default;
};
class ListDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> start{};
  shared_ptr<string> length{};

  ListDevicesRequest() {}

  explicit ListDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
  }


  virtual ~ListDevicesRequest() = default;
};
class ListDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> usageType{};
  shared_ptr<string> vin{};
  shared_ptr<string> usageTypeDesc{};
  shared_ptr<string> uuid{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> region{};
  shared_ptr<string> softwareId{};
  shared_ptr<string> name{};
  shared_ptr<string> deviceBrand{};

  ListDevicesResponseBodyDevices() {}

  explicit ListDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (usageType) {
      res["UsageType"] = boost::any(*usageType);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (usageTypeDesc) {
      res["UsageTypeDesc"] = boost::any(*usageTypeDesc);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (softwareId) {
      res["SoftwareId"] = boost::any(*softwareId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("UsageType") != m.end() && !m["UsageType"].empty()) {
      usageType = make_shared<long>(boost::any_cast<long>(m["UsageType"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("UsageTypeDesc") != m.end() && !m["UsageTypeDesc"].empty()) {
      usageTypeDesc = make_shared<string>(boost::any_cast<string>(m["UsageTypeDesc"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SoftwareId") != m.end() && !m["SoftwareId"].empty()) {
      softwareId = make_shared<string>(boost::any_cast<string>(m["SoftwareId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~ListDevicesResponseBodyDevices() = default;
};
class ListDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDevicesResponseBodyDevices>> devices{};

  ListDevicesResponseBody() {}

  explicit ListDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<ListDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<ListDevicesResponseBodyDevices>>(expect1);
      }
    }
  }


  virtual ~ListDevicesResponseBody() = default;
};
class ListDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDevicesResponseBody> body{};

  ListDevicesResponse() {}

  explicit ListDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDevicesResponse() = default;
};
class FindVersionTestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};

  FindVersionTestsRequest() {}

  explicit FindVersionTestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindVersionTestsRequest() = default;
};
class FindVersionTestsResponseBodyVersionTestListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> versionId{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> failedCount{};
  shared_ptr<string> deviceGroupId{};
  shared_ptr<string> skippedCount{};
  shared_ptr<string> description{};
  shared_ptr<string> succeededCount{};
  shared_ptr<string> deviceGroupName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> versionType{};

  FindVersionTestsResponseBodyVersionTestListItems() {}

  explicit FindVersionTestsResponseBodyVersionTestListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    if (skippedCount) {
      res["SkippedCount"] = boost::any(*skippedCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (succeededCount) {
      res["SucceededCount"] = boost::any(*succeededCount);
    }
    if (deviceGroupName) {
      res["DeviceGroupName"] = boost::any(*deviceGroupName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<string>(boost::any_cast<string>(m["FailedCount"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
    if (m.find("SkippedCount") != m.end() && !m["SkippedCount"].empty()) {
      skippedCount = make_shared<string>(boost::any_cast<string>(m["SkippedCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SucceededCount") != m.end() && !m["SucceededCount"].empty()) {
      succeededCount = make_shared<string>(boost::any_cast<string>(m["SucceededCount"]));
    }
    if (m.find("DeviceGroupName") != m.end() && !m["DeviceGroupName"].empty()) {
      deviceGroupName = make_shared<string>(boost::any_cast<string>(m["DeviceGroupName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindVersionTestsResponseBodyVersionTestListItems() = default;
};
class FindVersionTestsResponseBodyVersionTestList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionTestsResponseBodyVersionTestListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionTestsResponseBodyVersionTestList() {}

  explicit FindVersionTestsResponseBodyVersionTestList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionTestsResponseBodyVersionTestListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionTestsResponseBodyVersionTestListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionTestsResponseBodyVersionTestListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionTestsResponseBodyVersionTestList() = default;
};
class FindVersionTestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionTestsResponseBodyVersionTestList> versionTestList{};

  FindVersionTestsResponseBody() {}

  explicit FindVersionTestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (versionTestList) {
      res["VersionTestList"] = versionTestList ? boost::any(versionTestList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VersionTestList") != m.end() && !m["VersionTestList"].empty()) {
      if (typeid(map<string, boost::any>) == m["VersionTestList"].type()) {
        FindVersionTestsResponseBodyVersionTestList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VersionTestList"]));
        versionTestList = make_shared<FindVersionTestsResponseBodyVersionTestList>(model1);
      }
    }
  }


  virtual ~FindVersionTestsResponseBody() = default;
};
class FindVersionTestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionTestsResponseBody> body{};

  FindVersionTestsResponse() {}

  explicit FindVersionTestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionTestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionTestsResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionTestsResponse() = default;
};
class PublishOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<bool> sendMessage{};

  PublishOsVersionRequest() {}

  explicit PublishOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (sendMessage) {
      res["SendMessage"] = boost::any(*sendMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("SendMessage") != m.end() && !m["SendMessage"].empty()) {
      sendMessage = make_shared<bool>(boost::any_cast<bool>(m["SendMessage"]));
    }
  }


  virtual ~PublishOsVersionRequest() = default;
};
class PublishOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishOsVersionResponseBody() {}

  explicit PublishOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishOsVersionResponseBody() = default;
};
class PublishOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishOsVersionResponseBody> body{};

  PublishOsVersionResponse() {}

  explicit PublishOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishOsVersionResponse() = default;
};
class CreateUpstreamAppKeyRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKeys{};
  shared_ptr<string> appServerId{};
  shared_ptr<string> projectId{};

  CreateUpstreamAppKeyRelationsRequest() {}

  explicit CreateUpstreamAppKeyRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKeys) {
      res["AppKeys"] = boost::any(*appKeys);
    }
    if (appServerId) {
      res["AppServerId"] = boost::any(*appServerId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKeys") != m.end() && !m["AppKeys"].empty()) {
      appKeys = make_shared<string>(boost::any_cast<string>(m["AppKeys"]));
    }
    if (m.find("AppServerId") != m.end() && !m["AppServerId"].empty()) {
      appServerId = make_shared<string>(boost::any_cast<string>(m["AppServerId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CreateUpstreamAppKeyRelationsRequest() = default;
};
class CreateUpstreamAppKeyRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateUpstreamAppKeyRelationsResponseBody() {}

  explicit CreateUpstreamAppKeyRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUpstreamAppKeyRelationsResponseBody() = default;
};
class CreateUpstreamAppKeyRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateUpstreamAppKeyRelationsResponseBody> body{};

  CreateUpstreamAppKeyRelationsResponse() {}

  explicit CreateUpstreamAppKeyRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUpstreamAppKeyRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUpstreamAppKeyRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUpstreamAppKeyRelationsResponse() = default;
};
class UpdateOsVersionReleaseNoteRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> releaseNote{};

  UpdateOsVersionReleaseNoteRequest() {}

  explicit UpdateOsVersionReleaseNoteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
  }


  virtual ~UpdateOsVersionReleaseNoteRequest() = default;
};
class UpdateOsVersionReleaseNoteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsVersionReleaseNoteResponseBody() {}

  explicit UpdateOsVersionReleaseNoteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsVersionReleaseNoteResponseBody() = default;
};
class UpdateOsVersionReleaseNoteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOsVersionReleaseNoteResponseBody> body{};

  UpdateOsVersionReleaseNoteResponse() {}

  explicit UpdateOsVersionReleaseNoteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsVersionReleaseNoteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsVersionReleaseNoteResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsVersionReleaseNoteResponse() = default;
};
class PublishAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<bool> sendMessage{};

  PublishAppVersionRequest() {}

  explicit PublishAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (sendMessage) {
      res["SendMessage"] = boost::any(*sendMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("SendMessage") != m.end() && !m["SendMessage"].empty()) {
      sendMessage = make_shared<bool>(boost::any_cast<bool>(m["SendMessage"]));
    }
  }


  virtual ~PublishAppVersionRequest() = default;
};
class PublishAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  PublishAppVersionResponseBody() {}

  explicit PublishAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PublishAppVersionResponseBody() = default;
};
class PublishAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishAppVersionResponseBody> body{};

  PublishAppVersionResponse() {}

  explicit PublishAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~PublishAppVersionResponse() = default;
};
class PublishMqttMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> topic{};
  shared_ptr<string> projectId{};
  shared_ptr<string> message{};
  shared_ptr<long> qoS{};

  PublishMqttMessageRequest() {}

  explicit PublishMqttMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (qoS) {
      res["QoS"] = boost::any(*qoS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("QoS") != m.end() && !m["QoS"].empty()) {
      qoS = make_shared<long>(boost::any_cast<long>(m["QoS"]));
    }
  }


  virtual ~PublishMqttMessageRequest() = default;
};
class PublishMqttMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> mid{};

  PublishMqttMessageResponseBody() {}

  explicit PublishMqttMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
  }


  virtual ~PublishMqttMessageResponseBody() = default;
};
class PublishMqttMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<PublishMqttMessageResponseBody> body{};

  PublishMqttMessageResponse() {}

  explicit PublishMqttMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishMqttMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishMqttMessageResponseBody>(model1);
      }
    }
  }


  virtual ~PublishMqttMessageResponse() = default;
};
class DeleteVersionGroupDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIds{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceGroupId{};
  shared_ptr<string> deviceIdType{};

  DeleteVersionGroupDeviceRequest() {}

  explicit DeleteVersionGroupDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
  }


  virtual ~DeleteVersionGroupDeviceRequest() = default;
};
class DeleteVersionGroupDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionGroupDeviceResponseBody() {}

  explicit DeleteVersionGroupDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionGroupDeviceResponseBody() = default;
};
class DeleteVersionGroupDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionGroupDeviceResponseBody> body{};

  DeleteVersionGroupDeviceResponse() {}

  explicit DeleteVersionGroupDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionGroupDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionGroupDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionGroupDeviceResponse() = default;
};
class DeleteFunctionFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> fileName{};
  shared_ptr<long> fileType{};

  DeleteFunctionFileRequest() {}

  explicit DeleteFunctionFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<long>(boost::any_cast<long>(m["FileType"]));
    }
  }


  virtual ~DeleteFunctionFileRequest() = default;
};
class DeleteFunctionFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFunctionFileResponseBody() {}

  explicit DeleteFunctionFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFunctionFileResponseBody() = default;
};
class DeleteFunctionFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFunctionFileResponseBody> body{};

  DeleteFunctionFileResponse() {}

  explicit DeleteFunctionFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFunctionFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFunctionFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFunctionFileResponse() = default;
};
class AddVersionWhiteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIds{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> deviceIdType{};
  shared_ptr<string> versionId{};

  AddVersionWhiteDevicesRequest() {}

  explicit AddVersionWhiteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~AddVersionWhiteDevicesRequest() = default;
};
class AddVersionWhiteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddVersionWhiteDevicesResponseBody() {}

  explicit AddVersionWhiteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddVersionWhiteDevicesResponseBody() = default;
};
class AddVersionWhiteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddVersionWhiteDevicesResponseBody> body{};

  AddVersionWhiteDevicesResponse() {}

  explicit AddVersionWhiteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVersionWhiteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVersionWhiteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~AddVersionWhiteDevicesResponse() = default;
};
class ListAssistHistoryDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> assistId{};

  ListAssistHistoryDetailsRequest() {}

  explicit ListAssistHistoryDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (assistId) {
      res["AssistId"] = boost::any(*assistId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AssistId") != m.end() && !m["AssistId"].empty()) {
      assistId = make_shared<string>(boost::any_cast<string>(m["AssistId"]));
    }
  }


  virtual ~ListAssistHistoryDetailsRequest() = default;
};
class ListAssistHistoryDetailsResponseBodyActions : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<long> createdAt{};
  shared_ptr<string> timestamp{};
  shared_ptr<long> updatedAt{};
  shared_ptr<string> assistId{};
  shared_ptr<string> ID{};

  ListAssistHistoryDetailsResponseBodyActions() {}

  explicit ListAssistHistoryDetailsResponseBodyActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (createdAt) {
      res["CreatedAt"] = boost::any(*createdAt);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (updatedAt) {
      res["UpdatedAt"] = boost::any(*updatedAt);
    }
    if (assistId) {
      res["AssistId"] = boost::any(*assistId);
    }
    if (ID) {
      res["ID"] = boost::any(*ID);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("CreatedAt") != m.end() && !m["CreatedAt"].empty()) {
      createdAt = make_shared<long>(boost::any_cast<long>(m["CreatedAt"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("UpdatedAt") != m.end() && !m["UpdatedAt"].empty()) {
      updatedAt = make_shared<long>(boost::any_cast<long>(m["UpdatedAt"]));
    }
    if (m.find("AssistId") != m.end() && !m["AssistId"].empty()) {
      assistId = make_shared<string>(boost::any_cast<string>(m["AssistId"]));
    }
    if (m.find("ID") != m.end() && !m["ID"].empty()) {
      ID = make_shared<string>(boost::any_cast<string>(m["ID"]));
    }
  }


  virtual ~ListAssistHistoryDetailsResponseBodyActions() = default;
};
class ListAssistHistoryDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAssistHistoryDetailsResponseBodyActions>> actions{};

  ListAssistHistoryDetailsResponseBody() {}

  explicit ListAssistHistoryDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<ListAssistHistoryDetailsResponseBodyActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAssistHistoryDetailsResponseBodyActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<ListAssistHistoryDetailsResponseBodyActions>>(expect1);
      }
    }
  }


  virtual ~ListAssistHistoryDetailsResponseBody() = default;
};
class ListAssistHistoryDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAssistHistoryDetailsResponseBody> body{};

  ListAssistHistoryDetailsResponse() {}

  explicit ListAssistHistoryDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAssistHistoryDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAssistHistoryDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAssistHistoryDetailsResponse() = default;
};
class CreateCustomizedFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionType{};
  shared_ptr<string> blackWhiteType{};
  shared_ptr<string> value{};
  shared_ptr<string> projectId{};
  shared_ptr<string> valueCompareType{};
  shared_ptr<string> name{};
  shared_ptr<string> valueType{};
  shared_ptr<string> versionId{};

  CreateCustomizedFilterRequest() {}

  explicit CreateCustomizedFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (blackWhiteType) {
      res["BlackWhiteType"] = boost::any(*blackWhiteType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (valueCompareType) {
      res["ValueCompareType"] = boost::any(*valueCompareType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("BlackWhiteType") != m.end() && !m["BlackWhiteType"].empty()) {
      blackWhiteType = make_shared<string>(boost::any_cast<string>(m["BlackWhiteType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ValueCompareType") != m.end() && !m["ValueCompareType"].empty()) {
      valueCompareType = make_shared<string>(boost::any_cast<string>(m["ValueCompareType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~CreateCustomizedFilterRequest() = default;
};
class CreateCustomizedFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> customizedFilterId{};
  shared_ptr<string> requestId{};

  CreateCustomizedFilterResponseBody() {}

  explicit CreateCustomizedFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customizedFilterId) {
      res["CustomizedFilterId"] = boost::any(*customizedFilterId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomizedFilterId") != m.end() && !m["CustomizedFilterId"].empty()) {
      customizedFilterId = make_shared<string>(boost::any_cast<string>(m["CustomizedFilterId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomizedFilterResponseBody() = default;
};
class CreateCustomizedFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCustomizedFilterResponseBody> body{};

  CreateCustomizedFilterResponse() {}

  explicit CreateCustomizedFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomizedFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomizedFilterResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomizedFilterResponse() = default;
};
class DeleteUpstreamAppKeyRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};

  DeleteUpstreamAppKeyRelationRequest() {}

  explicit DeleteUpstreamAppKeyRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteUpstreamAppKeyRelationRequest() = default;
};
class DeleteUpstreamAppKeyRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUpstreamAppKeyRelationResponseBody() {}

  explicit DeleteUpstreamAppKeyRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUpstreamAppKeyRelationResponseBody() = default;
};
class DeleteUpstreamAppKeyRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteUpstreamAppKeyRelationResponseBody> body{};

  DeleteUpstreamAppKeyRelationResponse() {}

  explicit DeleteUpstreamAppKeyRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUpstreamAppKeyRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUpstreamAppKeyRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUpstreamAppKeyRelationResponse() = default;
};
class DescribeAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};

  DescribeAppVersionRequest() {}

  explicit DescribeAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DescribeAppVersionRequest() = default;
};
class DescribeAppVersionResponseBodyAppVersionAdapters : public Darabonba::Model {
public:
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> maxOsVersion{};
  shared_ptr<string> minOsVersion{};
  shared_ptr<long> versionId{};
  shared_ptr<long> id{};
  shared_ptr<string> deviceModelName{};

  DescribeAppVersionResponseBodyAppVersionAdapters() {}

  explicit DescribeAppVersionResponseBodyAppVersionAdapters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (maxOsVersion) {
      res["MaxOsVersion"] = boost::any(*maxOsVersion);
    }
    if (minOsVersion) {
      res["MinOsVersion"] = boost::any(*minOsVersion);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (deviceModelName) {
      res["DeviceModelName"] = boost::any(*deviceModelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("MaxOsVersion") != m.end() && !m["MaxOsVersion"].empty()) {
      maxOsVersion = make_shared<string>(boost::any_cast<string>(m["MaxOsVersion"]));
    }
    if (m.find("MinOsVersion") != m.end() && !m["MinOsVersion"].empty()) {
      minOsVersion = make_shared<string>(boost::any_cast<string>(m["MinOsVersion"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("DeviceModelName") != m.end() && !m["DeviceModelName"].empty()) {
      deviceModelName = make_shared<string>(boost::any_cast<string>(m["DeviceModelName"]));
    }
  }


  virtual ~DescribeAppVersionResponseBodyAppVersionAdapters() = default;
};
class DescribeAppVersionResponseBodyAppVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> isAllowNewInstall{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> packageName{};
  shared_ptr<string> remark{};
  shared_ptr<string> statusName{};
  shared_ptr<string> apkMd5{};
  shared_ptr<string> restartAppParam{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> appName{};
  shared_ptr<string> appId{};
  shared_ptr<string> restartAppType{};
  shared_ptr<long> versionCode{};
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<vector<DescribeAppVersionResponseBodyAppVersionAdapters>> adapters{};
  shared_ptr<string> isSilentUpgrade{};
  shared_ptr<string> installType{};
  shared_ptr<string> isNeedRestart{};
  shared_ptr<string> size{};
  shared_ptr<string> restartType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> md5{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<long> id{};
  shared_ptr<string> originalUrl{};

  DescribeAppVersionResponseBodyAppVersion() {}

  explicit DescribeAppVersionResponseBodyAppVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (isAllowNewInstall) {
      res["IsAllowNewInstall"] = boost::any(*isAllowNewInstall);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (apkMd5) {
      res["ApkMd5"] = boost::any(*apkMd5);
    }
    if (restartAppParam) {
      res["RestartAppParam"] = boost::any(*restartAppParam);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (restartAppType) {
      res["RestartAppType"] = boost::any(*restartAppType);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (adapters) {
      vector<boost::any> temp1;
      for(auto item1:*adapters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Adapters"] = boost::any(temp1);
    }
    if (isSilentUpgrade) {
      res["IsSilentUpgrade"] = boost::any(*isSilentUpgrade);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (isNeedRestart) {
      res["IsNeedRestart"] = boost::any(*isNeedRestart);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (restartType) {
      res["RestartType"] = boost::any(*restartType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originalUrl) {
      res["OriginalUrl"] = boost::any(*originalUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IsAllowNewInstall") != m.end() && !m["IsAllowNewInstall"].empty()) {
      isAllowNewInstall = make_shared<string>(boost::any_cast<string>(m["IsAllowNewInstall"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("ApkMd5") != m.end() && !m["ApkMd5"].empty()) {
      apkMd5 = make_shared<string>(boost::any_cast<string>(m["ApkMd5"]));
    }
    if (m.find("RestartAppParam") != m.end() && !m["RestartAppParam"].empty()) {
      restartAppParam = make_shared<string>(boost::any_cast<string>(m["RestartAppParam"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RestartAppType") != m.end() && !m["RestartAppType"].empty()) {
      restartAppType = make_shared<string>(boost::any_cast<string>(m["RestartAppType"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<long>(boost::any_cast<long>(m["VersionCode"]));
    }
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Adapters") != m.end() && !m["Adapters"].empty()) {
      if (typeid(vector<boost::any>) == m["Adapters"].type()) {
        vector<DescribeAppVersionResponseBodyAppVersionAdapters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Adapters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppVersionResponseBodyAppVersionAdapters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adapters = make_shared<vector<DescribeAppVersionResponseBodyAppVersionAdapters>>(expect1);
      }
    }
    if (m.find("IsSilentUpgrade") != m.end() && !m["IsSilentUpgrade"].empty()) {
      isSilentUpgrade = make_shared<string>(boost::any_cast<string>(m["IsSilentUpgrade"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<string>(boost::any_cast<string>(m["InstallType"]));
    }
    if (m.find("IsNeedRestart") != m.end() && !m["IsNeedRestart"].empty()) {
      isNeedRestart = make_shared<string>(boost::any_cast<string>(m["IsNeedRestart"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("RestartType") != m.end() && !m["RestartType"].empty()) {
      restartType = make_shared<string>(boost::any_cast<string>(m["RestartType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OriginalUrl") != m.end() && !m["OriginalUrl"].empty()) {
      originalUrl = make_shared<string>(boost::any_cast<string>(m["OriginalUrl"]));
    }
  }


  virtual ~DescribeAppVersionResponseBodyAppVersion() = default;
};
class DescribeAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppVersionResponseBodyAppVersion> appVersion{};
  shared_ptr<string> requestId{};

  DescribeAppVersionResponseBody() {}

  explicit DescribeAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersion) {
      res["AppVersion"] = appVersion ? boost::any(appVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppVersion"].type()) {
        DescribeAppVersionResponseBodyAppVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppVersion"]));
        appVersion = make_shared<DescribeAppVersionResponseBodyAppVersion>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppVersionResponseBody() = default;
};
class DescribeAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAppVersionResponseBody> body{};

  DescribeAppVersionResponse() {}

  explicit DescribeAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppVersionResponse() = default;
};
class ListVehicleRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> vin{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListVehicleRequest() {}

  explicit ListVehicleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListVehicleRequest() = default;
};
class ListVehicleResponseBodyVehiclesPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListVehicleResponseBodyVehiclesPagination() {}

  explicit ListVehicleResponseBodyVehiclesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListVehicleResponseBodyVehiclesPagination() = default;
};
class ListVehicleResponseBodyVehiclesList : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> vin{};

  ListVehicleResponseBodyVehiclesList() {}

  explicit ListVehicleResponseBodyVehiclesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["ConnectionStatus"] = boost::any(*connectionStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectionStatus") != m.end() && !m["ConnectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["ConnectionStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
  }


  virtual ~ListVehicleResponseBodyVehiclesList() = default;
};
class ListVehicleResponseBodyVehicles : public Darabonba::Model {
public:
  shared_ptr<ListVehicleResponseBodyVehiclesPagination> pagination{};
  shared_ptr<vector<ListVehicleResponseBodyVehiclesList>> list{};

  ListVehicleResponseBodyVehicles() {}

  explicit ListVehicleResponseBodyVehicles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListVehicleResponseBodyVehiclesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListVehicleResponseBodyVehiclesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListVehicleResponseBodyVehiclesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVehicleResponseBodyVehiclesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListVehicleResponseBodyVehiclesList>>(expect1);
      }
    }
  }


  virtual ~ListVehicleResponseBodyVehicles() = default;
};
class ListVehicleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListVehicleResponseBodyVehicles> vehicles{};

  ListVehicleResponseBody() {}

  explicit ListVehicleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vehicles) {
      res["Vehicles"] = vehicles ? boost::any(vehicles->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Vehicles") != m.end() && !m["Vehicles"].empty()) {
      if (typeid(map<string, boost::any>) == m["Vehicles"].type()) {
        ListVehicleResponseBodyVehicles model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Vehicles"]));
        vehicles = make_shared<ListVehicleResponseBodyVehicles>(model1);
      }
    }
  }


  virtual ~ListVehicleResponseBody() = default;
};
class ListVehicleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListVehicleResponseBody> body{};

  ListVehicleResponse() {}

  explicit ListVehicleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVehicleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVehicleResponseBody>(model1);
      }
    }
  }


  virtual ~ListVehicleResponse() = default;
};
class ExecuteCameraShootingCommandRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> edgeDeviceId{};
  shared_ptr<long> shootingType{};
  shared_ptr<long> number{};
  shared_ptr<long> time{};

  ExecuteCameraShootingCommandRequest() {}

  explicit ExecuteCameraShootingCommandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (edgeDeviceId) {
      res["EdgeDeviceId"] = boost::any(*edgeDeviceId);
    }
    if (shootingType) {
      res["ShootingType"] = boost::any(*shootingType);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("EdgeDeviceId") != m.end() && !m["EdgeDeviceId"].empty()) {
      edgeDeviceId = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceId"]));
    }
    if (m.find("ShootingType") != m.end() && !m["ShootingType"].empty()) {
      shootingType = make_shared<long>(boost::any_cast<long>(m["ShootingType"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~ExecuteCameraShootingCommandRequest() = default;
};
class ExecuteCameraShootingCommandResponseBodyShootingRecord : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> shootingType{};
  shared_ptr<long> number{};
  shared_ptr<long> time{};
  shared_ptr<long> recordTime{};
  shared_ptr<long> status{};

  ExecuteCameraShootingCommandResponseBodyShootingRecord() {}

  explicit ExecuteCameraShootingCommandResponseBodyShootingRecord(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (shootingType) {
      res["ShootingType"] = boost::any(*shootingType);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (recordTime) {
      res["RecordTime"] = boost::any(*recordTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ShootingType") != m.end() && !m["ShootingType"].empty()) {
      shootingType = make_shared<long>(boost::any_cast<long>(m["ShootingType"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("RecordTime") != m.end() && !m["RecordTime"].empty()) {
      recordTime = make_shared<long>(boost::any_cast<long>(m["RecordTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ExecuteCameraShootingCommandResponseBodyShootingRecord() = default;
};
class ExecuteCameraShootingCommandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ExecuteCameraShootingCommandResponseBodyShootingRecord> shootingRecord{};

  ExecuteCameraShootingCommandResponseBody() {}

  explicit ExecuteCameraShootingCommandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shootingRecord) {
      res["ShootingRecord"] = shootingRecord ? boost::any(shootingRecord->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShootingRecord") != m.end() && !m["ShootingRecord"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShootingRecord"].type()) {
        ExecuteCameraShootingCommandResponseBodyShootingRecord model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShootingRecord"]));
        shootingRecord = make_shared<ExecuteCameraShootingCommandResponseBodyShootingRecord>(model1);
      }
    }
  }


  virtual ~ExecuteCameraShootingCommandResponseBody() = default;
};
class ExecuteCameraShootingCommandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExecuteCameraShootingCommandResponseBody> body{};

  ExecuteCameraShootingCommandResponse() {}

  explicit ExecuteCameraShootingCommandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteCameraShootingCommandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteCameraShootingCommandResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteCameraShootingCommandResponse() = default;
};
class DeleteVersionDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DeleteVersionDeviceGroupRequest() {}

  explicit DeleteVersionDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteVersionDeviceGroupRequest() = default;
};
class DeleteVersionDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionDeviceGroupResponseBody() {}

  explicit DeleteVersionDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionDeviceGroupResponseBody() = default;
};
class DeleteVersionDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionDeviceGroupResponseBody> body{};

  DeleteVersionDeviceGroupResponse() {}

  explicit DeleteVersionDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionDeviceGroupResponse() = default;
};
class ListFunctionFilesByProjectIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListFunctionFilesByProjectIdRequest() {}

  explicit ListFunctionFilesByProjectIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListFunctionFilesByProjectIdRequest() = default;
};
class ListFunctionFilesByProjectIdResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<long> type{};
  shared_ptr<long> status{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<long> contentId{};

  ListFunctionFilesByProjectIdResponseBodyFiles() {}

  explicit ListFunctionFilesByProjectIdResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<long>(boost::any_cast<long>(m["ContentId"]));
    }
  }


  virtual ~ListFunctionFilesByProjectIdResponseBodyFiles() = default;
};
class ListFunctionFilesByProjectIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListFunctionFilesByProjectIdResponseBodyFiles>> files{};

  ListFunctionFilesByProjectIdResponseBody() {}

  explicit ListFunctionFilesByProjectIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ListFunctionFilesByProjectIdResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFunctionFilesByProjectIdResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ListFunctionFilesByProjectIdResponseBodyFiles>>(expect1);
      }
    }
  }


  virtual ~ListFunctionFilesByProjectIdResponseBody() = default;
};
class ListFunctionFilesByProjectIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListFunctionFilesByProjectIdResponseBody> body{};

  ListFunctionFilesByProjectIdResponse() {}

  explicit ListFunctionFilesByProjectIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFunctionFilesByProjectIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFunctionFilesByProjectIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListFunctionFilesByProjectIdResponse() = default;
};
class FindVersionWhiteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> originalId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  FindVersionWhiteDevicesRequest() {}

  explicit FindVersionWhiteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~FindVersionWhiteDevicesRequest() = default;
};
class FindVersionWhiteDevicesResponseBodyDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> originalId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> idType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> id{};

  FindVersionWhiteDevicesResponseBodyDeviceListItems() {}

  explicit FindVersionWhiteDevicesResponseBodyDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindVersionWhiteDevicesResponseBodyDeviceListItems() = default;
};
class FindVersionWhiteDevicesResponseBodyDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionWhiteDevicesResponseBodyDeviceListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionWhiteDevicesResponseBodyDeviceList() {}

  explicit FindVersionWhiteDevicesResponseBodyDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionWhiteDevicesResponseBodyDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionWhiteDevicesResponseBodyDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionWhiteDevicesResponseBodyDeviceListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionWhiteDevicesResponseBodyDeviceList() = default;
};
class FindVersionWhiteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionWhiteDevicesResponseBodyDeviceList> deviceList{};

  FindVersionWhiteDevicesResponseBody() {}

  explicit FindVersionWhiteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceList) {
      res["DeviceList"] = deviceList ? boost::any(deviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceList") != m.end() && !m["DeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceList"].type()) {
        FindVersionWhiteDevicesResponseBodyDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceList"]));
        deviceList = make_shared<FindVersionWhiteDevicesResponseBodyDeviceList>(model1);
      }
    }
  }


  virtual ~FindVersionWhiteDevicesResponseBody() = default;
};
class FindVersionWhiteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionWhiteDevicesResponseBody> body{};

  FindVersionWhiteDevicesResponse() {}

  explicit FindVersionWhiteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionWhiteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionWhiteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionWhiteDevicesResponse() = default;
};
class CreateUpstreamAppServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> tags{};

  CreateUpstreamAppServerRequest() {}

  explicit CreateUpstreamAppServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateUpstreamAppServerRequest() = default;
};
class CreateUpstreamAppServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> id{};

  CreateUpstreamAppServerResponseBody() {}

  explicit CreateUpstreamAppServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CreateUpstreamAppServerResponseBody() = default;
};
class CreateUpstreamAppServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateUpstreamAppServerResponseBody> body{};

  CreateUpstreamAppServerResponse() {}

  explicit CreateUpstreamAppServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUpstreamAppServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUpstreamAppServerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUpstreamAppServerResponse() = default;
};
class DescribeVersionDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DescribeVersionDeviceGroupRequest() {}

  explicit DescribeVersionDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeVersionDeviceGroupRequest() = default;
};
class DescribeVersionDeviceGroupResponseBodyDeviceGroup : public Darabonba::Model {
public:
  shared_ptr<string> gmtModify{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> maxCount{};

  DescribeVersionDeviceGroupResponseBodyDeviceGroup() {}

  explicit DescribeVersionDeviceGroupResponseBodyDeviceGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxCount) {
      res["MaxCount"] = boost::any(*maxCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxCount") != m.end() && !m["MaxCount"].empty()) {
      maxCount = make_shared<string>(boost::any_cast<string>(m["MaxCount"]));
    }
  }


  virtual ~DescribeVersionDeviceGroupResponseBodyDeviceGroup() = default;
};
class DescribeVersionDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeVersionDeviceGroupResponseBodyDeviceGroup> deviceGroup{};

  DescribeVersionDeviceGroupResponseBody() {}

  explicit DescribeVersionDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceGroup) {
      res["DeviceGroup"] = deviceGroup ? boost::any(deviceGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceGroup") != m.end() && !m["DeviceGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceGroup"].type()) {
        DescribeVersionDeviceGroupResponseBodyDeviceGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceGroup"]));
        deviceGroup = make_shared<DescribeVersionDeviceGroupResponseBodyDeviceGroup>(model1);
      }
    }
  }


  virtual ~DescribeVersionDeviceGroupResponseBody() = default;
};
class DescribeVersionDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVersionDeviceGroupResponseBody> body{};

  DescribeVersionDeviceGroupResponse() {}

  explicit DescribeVersionDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVersionDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVersionDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVersionDeviceGroupResponse() = default;
};
class UpdateAppVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> isAllowNewInstall{};
  shared_ptr<string> projectId{};
  shared_ptr<string> appId{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> installType{};
  shared_ptr<string> remark{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<string> isSilentUpgrade{};
  shared_ptr<string> isNeedRestart{};
  shared_ptr<string> packageUrl{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> restartType{};
  shared_ptr<string> restartAppType{};
  shared_ptr<string> restartAppParam{};
  shared_ptr<string> deviceAdapterList{};
  shared_ptr<string> versionId{};
  shared_ptr<string> apkMd5{};

  UpdateAppVersionRequest() {}

  explicit UpdateAppVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (isAllowNewInstall) {
      res["IsAllowNewInstall"] = boost::any(*isAllowNewInstall);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (isSilentUpgrade) {
      res["IsSilentUpgrade"] = boost::any(*isSilentUpgrade);
    }
    if (isNeedRestart) {
      res["IsNeedRestart"] = boost::any(*isNeedRestart);
    }
    if (packageUrl) {
      res["PackageUrl"] = boost::any(*packageUrl);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (restartType) {
      res["RestartType"] = boost::any(*restartType);
    }
    if (restartAppType) {
      res["RestartAppType"] = boost::any(*restartAppType);
    }
    if (restartAppParam) {
      res["RestartAppParam"] = boost::any(*restartAppParam);
    }
    if (deviceAdapterList) {
      res["DeviceAdapterList"] = boost::any(*deviceAdapterList);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (apkMd5) {
      res["ApkMd5"] = boost::any(*apkMd5);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("IsAllowNewInstall") != m.end() && !m["IsAllowNewInstall"].empty()) {
      isAllowNewInstall = make_shared<string>(boost::any_cast<string>(m["IsAllowNewInstall"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<string>(boost::any_cast<string>(m["InstallType"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("IsSilentUpgrade") != m.end() && !m["IsSilentUpgrade"].empty()) {
      isSilentUpgrade = make_shared<string>(boost::any_cast<string>(m["IsSilentUpgrade"]));
    }
    if (m.find("IsNeedRestart") != m.end() && !m["IsNeedRestart"].empty()) {
      isNeedRestart = make_shared<string>(boost::any_cast<string>(m["IsNeedRestart"]));
    }
    if (m.find("PackageUrl") != m.end() && !m["PackageUrl"].empty()) {
      packageUrl = make_shared<string>(boost::any_cast<string>(m["PackageUrl"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("RestartType") != m.end() && !m["RestartType"].empty()) {
      restartType = make_shared<string>(boost::any_cast<string>(m["RestartType"]));
    }
    if (m.find("RestartAppType") != m.end() && !m["RestartAppType"].empty()) {
      restartAppType = make_shared<string>(boost::any_cast<string>(m["RestartAppType"]));
    }
    if (m.find("RestartAppParam") != m.end() && !m["RestartAppParam"].empty()) {
      restartAppParam = make_shared<string>(boost::any_cast<string>(m["RestartAppParam"]));
    }
    if (m.find("DeviceAdapterList") != m.end() && !m["DeviceAdapterList"].empty()) {
      deviceAdapterList = make_shared<string>(boost::any_cast<string>(m["DeviceAdapterList"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ApkMd5") != m.end() && !m["ApkMd5"].empty()) {
      apkMd5 = make_shared<string>(boost::any_cast<string>(m["ApkMd5"]));
    }
  }


  virtual ~UpdateAppVersionRequest() = default;
};
class UpdateAppVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppVersionResponseBody() {}

  explicit UpdateAppVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppVersionResponseBody() = default;
};
class UpdateAppVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAppVersionResponseBody> body{};

  UpdateAppVersionResponse() {}

  explicit UpdateAppVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppVersionResponse() = default;
};
class CreateCustomizedPropertyRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> versionType{};

  CreateCustomizedPropertyRequest() {}

  explicit CreateCustomizedPropertyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~CreateCustomizedPropertyRequest() = default;
};
class CreateCustomizedPropertyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> customizedPropertyId{};

  CreateCustomizedPropertyResponseBody() {}

  explicit CreateCustomizedPropertyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (customizedPropertyId) {
      res["CustomizedPropertyId"] = boost::any(*customizedPropertyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CustomizedPropertyId") != m.end() && !m["CustomizedPropertyId"].empty()) {
      customizedPropertyId = make_shared<string>(boost::any_cast<string>(m["CustomizedPropertyId"]));
    }
  }


  virtual ~CreateCustomizedPropertyResponseBody() = default;
};
class CreateCustomizedPropertyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCustomizedPropertyResponseBody> body{};

  CreateCustomizedPropertyResponse() {}

  explicit CreateCustomizedPropertyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomizedPropertyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomizedPropertyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomizedPropertyResponse() = default;
};
class ListSchemaSubscribesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListSchemaSubscribesRequest() {}

  explicit ListSchemaSubscribesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListSchemaSubscribesRequest() = default;
};
class ListSchemaSubscribesResponseBodyPageListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<bool> simpleSign{};
  shared_ptr<bool> hasNextPage{};

  ListSchemaSubscribesResponseBodyPageListPagination() {}

  explicit ListSchemaSubscribesResponseBodyPageListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (simpleSign) {
      res["SimpleSign"] = boost::any(*simpleSign);
    }
    if (hasNextPage) {
      res["HasNextPage"] = boost::any(*hasNextPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SimpleSign") != m.end() && !m["SimpleSign"].empty()) {
      simpleSign = make_shared<bool>(boost::any_cast<bool>(m["SimpleSign"]));
    }
    if (m.find("HasNextPage") != m.end() && !m["HasNextPage"].empty()) {
      hasNextPage = make_shared<bool>(boost::any_cast<bool>(m["HasNextPage"]));
    }
  }


  virtual ~ListSchemaSubscribesResponseBodyPageListPagination() = default;
};
class ListSchemaSubscribesResponseBodyPageListList : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> version{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> validitySchema{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};

  ListSchemaSubscribesResponseBodyPageListList() {}

  explicit ListSchemaSubscribesResponseBodyPageListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (validitySchema) {
      res["ValiditySchema"] = boost::any(*validitySchema);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ValiditySchema") != m.end() && !m["ValiditySchema"].empty()) {
      validitySchema = make_shared<string>(boost::any_cast<string>(m["ValiditySchema"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListSchemaSubscribesResponseBodyPageListList() = default;
};
class ListSchemaSubscribesResponseBodyPageList : public Darabonba::Model {
public:
  shared_ptr<ListSchemaSubscribesResponseBodyPageListPagination> pagination{};
  shared_ptr<vector<ListSchemaSubscribesResponseBodyPageListList>> list{};

  ListSchemaSubscribesResponseBodyPageList() {}

  explicit ListSchemaSubscribesResponseBodyPageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListSchemaSubscribesResponseBodyPageListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListSchemaSubscribesResponseBodyPageListPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSchemaSubscribesResponseBodyPageListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSchemaSubscribesResponseBodyPageListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSchemaSubscribesResponseBodyPageListList>>(expect1);
      }
    }
  }


  virtual ~ListSchemaSubscribesResponseBodyPageList() = default;
};
class ListSchemaSubscribesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSchemaSubscribesResponseBodyPageList>> pageList{};

  ListSchemaSubscribesResponseBody() {}

  explicit ListSchemaSubscribesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageList) {
      vector<boost::any> temp1;
      for(auto item1:*pageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageList") != m.end() && !m["PageList"].empty()) {
      if (typeid(vector<boost::any>) == m["PageList"].type()) {
        vector<ListSchemaSubscribesResponseBodyPageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSchemaSubscribesResponseBodyPageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pageList = make_shared<vector<ListSchemaSubscribesResponseBodyPageList>>(expect1);
      }
    }
  }


  virtual ~ListSchemaSubscribesResponseBody() = default;
};
class ListSchemaSubscribesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSchemaSubscribesResponseBody> body{};

  ListSchemaSubscribesResponse() {}

  explicit ListSchemaSubscribesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSchemaSubscribesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSchemaSubscribesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSchemaSubscribesResponse() = default;
};
class UpdateSchemaSubscribeRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModel{};
  shared_ptr<string> subscribeList{};
  shared_ptr<string> projectId{};
  shared_ptr<string> schemaVersion{};

  UpdateSchemaSubscribeRequest() {}

  explicit UpdateSchemaSubscribeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (subscribeList) {
      res["SubscribeList"] = boost::any(*subscribeList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schemaVersion) {
      res["SchemaVersion"] = boost::any(*schemaVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SubscribeList") != m.end() && !m["SubscribeList"].empty()) {
      subscribeList = make_shared<string>(boost::any_cast<string>(m["SubscribeList"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SchemaVersion") != m.end() && !m["SchemaVersion"].empty()) {
      schemaVersion = make_shared<string>(boost::any_cast<string>(m["SchemaVersion"]));
    }
  }


  virtual ~UpdateSchemaSubscribeRequest() = default;
};
class UpdateSchemaSubscribeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSchemaSubscribeResponseBody() {}

  explicit UpdateSchemaSubscribeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSchemaSubscribeResponseBody() = default;
};
class UpdateSchemaSubscribeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSchemaSubscribeResponseBody> body{};

  UpdateSchemaSubscribeResponse() {}

  explicit UpdateSchemaSubscribeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSchemaSubscribeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSchemaSubscribeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSchemaSubscribeResponse() = default;
};
class DeleteAllVersionGroupDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceGroupId{};

  DeleteAllVersionGroupDevicesRequest() {}

  explicit DeleteAllVersionGroupDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
  }


  virtual ~DeleteAllVersionGroupDevicesRequest() = default;
};
class DeleteAllVersionGroupDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAllVersionGroupDevicesResponseBody() {}

  explicit DeleteAllVersionGroupDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAllVersionGroupDevicesResponseBody() = default;
};
class DeleteAllVersionGroupDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAllVersionGroupDevicesResponseBody> body{};

  DeleteAllVersionGroupDevicesResponse() {}

  explicit DeleteAllVersionGroupDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllVersionGroupDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllVersionGroupDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllVersionGroupDevicesResponse() = default;
};
class DeleteVersionWhiteDevicesByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> ids{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};

  DeleteVersionWhiteDevicesByIdRequest() {}

  explicit DeleteVersionWhiteDevicesByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteVersionWhiteDevicesByIdRequest() = default;
};
class DeleteVersionWhiteDevicesByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionWhiteDevicesByIdResponseBody() {}

  explicit DeleteVersionWhiteDevicesByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionWhiteDevicesByIdResponseBody() = default;
};
class DeleteVersionWhiteDevicesByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionWhiteDevicesByIdResponseBody> body{};

  DeleteVersionWhiteDevicesByIdResponse() {}

  explicit DeleteVersionWhiteDevicesByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionWhiteDevicesByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionWhiteDevicesByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionWhiteDevicesByIdResponse() = default;
};
class UpdateOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> isMilestone{};
  shared_ptr<string> isForceNightUpgrade{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> remark{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> maxClientVersion{};
  shared_ptr<string> minClientVersion{};
  shared_ptr<string> nightUpgradeDownloadType{};
  shared_ptr<string> nightUpgradeIsShowTip{};
  shared_ptr<string> nightUpgradeIsAllowedCancel{};
  shared_ptr<string> romList{};
  shared_ptr<string> id{};
  shared_ptr<string> enableMobileDownload{};
  shared_ptr<string> mobileDownloadMaxSize{};

  UpdateOsVersionRequest() {}

  explicit UpdateOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isMilestone) {
      res["IsMilestone"] = boost::any(*isMilestone);
    }
    if (isForceNightUpgrade) {
      res["IsForceNightUpgrade"] = boost::any(*isForceNightUpgrade);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (maxClientVersion) {
      res["MaxClientVersion"] = boost::any(*maxClientVersion);
    }
    if (minClientVersion) {
      res["MinClientVersion"] = boost::any(*minClientVersion);
    }
    if (nightUpgradeDownloadType) {
      res["NightUpgradeDownloadType"] = boost::any(*nightUpgradeDownloadType);
    }
    if (nightUpgradeIsShowTip) {
      res["NightUpgradeIsShowTip"] = boost::any(*nightUpgradeIsShowTip);
    }
    if (nightUpgradeIsAllowedCancel) {
      res["NightUpgradeIsAllowedCancel"] = boost::any(*nightUpgradeIsAllowedCancel);
    }
    if (romList) {
      res["RomList"] = boost::any(*romList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (enableMobileDownload) {
      res["EnableMobileDownload"] = boost::any(*enableMobileDownload);
    }
    if (mobileDownloadMaxSize) {
      res["MobileDownloadMaxSize"] = boost::any(*mobileDownloadMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsMilestone") != m.end() && !m["IsMilestone"].empty()) {
      isMilestone = make_shared<string>(boost::any_cast<string>(m["IsMilestone"]));
    }
    if (m.find("IsForceNightUpgrade") != m.end() && !m["IsForceNightUpgrade"].empty()) {
      isForceNightUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceNightUpgrade"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("MaxClientVersion") != m.end() && !m["MaxClientVersion"].empty()) {
      maxClientVersion = make_shared<string>(boost::any_cast<string>(m["MaxClientVersion"]));
    }
    if (m.find("MinClientVersion") != m.end() && !m["MinClientVersion"].empty()) {
      minClientVersion = make_shared<string>(boost::any_cast<string>(m["MinClientVersion"]));
    }
    if (m.find("NightUpgradeDownloadType") != m.end() && !m["NightUpgradeDownloadType"].empty()) {
      nightUpgradeDownloadType = make_shared<string>(boost::any_cast<string>(m["NightUpgradeDownloadType"]));
    }
    if (m.find("NightUpgradeIsShowTip") != m.end() && !m["NightUpgradeIsShowTip"].empty()) {
      nightUpgradeIsShowTip = make_shared<string>(boost::any_cast<string>(m["NightUpgradeIsShowTip"]));
    }
    if (m.find("NightUpgradeIsAllowedCancel") != m.end() && !m["NightUpgradeIsAllowedCancel"].empty()) {
      nightUpgradeIsAllowedCancel = make_shared<string>(boost::any_cast<string>(m["NightUpgradeIsAllowedCancel"]));
    }
    if (m.find("RomList") != m.end() && !m["RomList"].empty()) {
      romList = make_shared<string>(boost::any_cast<string>(m["RomList"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("EnableMobileDownload") != m.end() && !m["EnableMobileDownload"].empty()) {
      enableMobileDownload = make_shared<string>(boost::any_cast<string>(m["EnableMobileDownload"]));
    }
    if (m.find("MobileDownloadMaxSize") != m.end() && !m["MobileDownloadMaxSize"].empty()) {
      mobileDownloadMaxSize = make_shared<string>(boost::any_cast<string>(m["MobileDownloadMaxSize"]));
    }
  }


  virtual ~UpdateOsVersionRequest() = default;
};
class UpdateOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsVersionResponseBody() {}

  explicit UpdateOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsVersionResponseBody() = default;
};
class UpdateOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOsVersionResponseBody> body{};

  UpdateOsVersionResponse() {}

  explicit UpdateOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsVersionResponse() = default;
};
class GenerateOssPostPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> ext{};
  shared_ptr<string> accessId{};
  shared_ptr<string> accessKey{};

  GenerateOssPostPolicyRequest() {}

  explicit GenerateOssPostPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
  }


  virtual ~GenerateOssPostPolicyRequest() = default;
};
class GenerateOssPostPolicyResponseBodyOssPostPolicy : public Darabonba::Model {
public:
  shared_ptr<string> signature{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> expire{};
  shared_ptr<string> accessId{};

  GenerateOssPostPolicyResponseBodyOssPostPolicy() {}

  explicit GenerateOssPostPolicyResponseBodyOssPostPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<string>(boost::any_cast<string>(m["Expire"]));
    }
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
  }


  virtual ~GenerateOssPostPolicyResponseBodyOssPostPolicy() = default;
};
class GenerateOssPostPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GenerateOssPostPolicyResponseBodyOssPostPolicy> ossPostPolicy{};

  GenerateOssPostPolicyResponseBody() {}

  explicit GenerateOssPostPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ossPostPolicy) {
      res["OssPostPolicy"] = ossPostPolicy ? boost::any(ossPostPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OssPostPolicy") != m.end() && !m["OssPostPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssPostPolicy"].type()) {
        GenerateOssPostPolicyResponseBodyOssPostPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssPostPolicy"]));
        ossPostPolicy = make_shared<GenerateOssPostPolicyResponseBodyOssPostPolicy>(model1);
      }
    }
  }


  virtual ~GenerateOssPostPolicyResponseBody() = default;
};
class GenerateOssPostPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateOssPostPolicyResponseBody> body{};

  GenerateOssPostPolicyResponse() {}

  explicit GenerateOssPostPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateOssPostPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateOssPostPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateOssPostPolicyResponse() = default;
};
class FindVersionGroupDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> originalId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> deviceGroupId{};
  shared_ptr<string> deviceId{};

  FindVersionGroupDevicesRequest() {}

  explicit FindVersionGroupDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
  }


  virtual ~FindVersionGroupDevicesRequest() = default;
};
class FindVersionGroupDevicesResponseBodyGroupDeviceListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> originalId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> idType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> id{};

  FindVersionGroupDevicesResponseBodyGroupDeviceListItems() {}

  explicit FindVersionGroupDevicesResponseBodyGroupDeviceListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~FindVersionGroupDevicesResponseBodyGroupDeviceListItems() = default;
};
class FindVersionGroupDevicesResponseBodyGroupDeviceList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionGroupDevicesResponseBodyGroupDeviceListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionGroupDevicesResponseBodyGroupDeviceList() {}

  explicit FindVersionGroupDevicesResponseBodyGroupDeviceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionGroupDevicesResponseBodyGroupDeviceListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionGroupDevicesResponseBodyGroupDeviceListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionGroupDevicesResponseBodyGroupDeviceListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionGroupDevicesResponseBodyGroupDeviceList() = default;
};
class FindVersionGroupDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindVersionGroupDevicesResponseBodyGroupDeviceList> groupDeviceList{};

  FindVersionGroupDevicesResponseBody() {}

  explicit FindVersionGroupDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (groupDeviceList) {
      res["GroupDeviceList"] = groupDeviceList ? boost::any(groupDeviceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("GroupDeviceList") != m.end() && !m["GroupDeviceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupDeviceList"].type()) {
        FindVersionGroupDevicesResponseBodyGroupDeviceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupDeviceList"]));
        groupDeviceList = make_shared<FindVersionGroupDevicesResponseBodyGroupDeviceList>(model1);
      }
    }
  }


  virtual ~FindVersionGroupDevicesResponseBody() = default;
};
class FindVersionGroupDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionGroupDevicesResponseBody> body{};

  FindVersionGroupDevicesResponse() {}

  explicit FindVersionGroupDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionGroupDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionGroupDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionGroupDevicesResponse() = default;
};
class DeleteOpenAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityId{};
  shared_ptr<string> projectId{};

  DeleteOpenAccountRequest() {}

  explicit DeleteOpenAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteOpenAccountRequest() = default;
};
class DeleteOpenAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOpenAccountResponseBody() {}

  explicit DeleteOpenAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOpenAccountResponseBody() = default;
};
class DeleteOpenAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteOpenAccountResponseBody> body{};

  DeleteOpenAccountResponse() {}

  explicit DeleteOpenAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOpenAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOpenAccountResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOpenAccountResponse() = default;
};
class DescribeDefaultSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModelId{};

  DescribeDefaultSchemaRequest() {}

  explicit DescribeDefaultSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
  }


  virtual ~DescribeDefaultSchemaRequest() = default;
};
class DescribeDefaultSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> schema{};

  DescribeDefaultSchemaResponseBody() {}

  explicit DescribeDefaultSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~DescribeDefaultSchemaResponseBody() = default;
};
class DescribeDefaultSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDefaultSchemaResponseBody> body{};

  DescribeDefaultSchemaResponse() {}

  explicit DescribeDefaultSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDefaultSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDefaultSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDefaultSchemaResponse() = default;
};
class ListUpstreamAppServersRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> pageIndex{};
  shared_ptr<string> pageSize{};

  ListUpstreamAppServersRequest() {}

  explicit ListUpstreamAppServersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<string>(boost::any_cast<string>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~ListUpstreamAppServersRequest() = default;
};
class ListUpstreamAppServersResponseBodyAppServersPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUpstreamAppServersResponseBodyAppServersPagination() {}

  explicit ListUpstreamAppServersResponseBodyAppServersPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUpstreamAppServersResponseBodyAppServersPagination() = default;
};
class ListUpstreamAppServersResponseBodyAppServersList : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> tags{};
  shared_ptr<string> queueNameList{};
  shared_ptr<string> PAppKey{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  ListUpstreamAppServersResponseBodyAppServersList() {}

  explicit ListUpstreamAppServersResponseBodyAppServersList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (queueNameList) {
      res["QueueNameList"] = boost::any(*queueNameList);
    }
    if (PAppKey) {
      res["PAppKey"] = boost::any(*PAppKey);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("QueueNameList") != m.end() && !m["QueueNameList"].empty()) {
      queueNameList = make_shared<string>(boost::any_cast<string>(m["QueueNameList"]));
    }
    if (m.find("PAppKey") != m.end() && !m["PAppKey"].empty()) {
      PAppKey = make_shared<string>(boost::any_cast<string>(m["PAppKey"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListUpstreamAppServersResponseBodyAppServersList() = default;
};
class ListUpstreamAppServersResponseBodyAppServers : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamAppServersResponseBodyAppServersPagination> pagination{};
  shared_ptr<vector<ListUpstreamAppServersResponseBodyAppServersList>> list{};

  ListUpstreamAppServersResponseBodyAppServers() {}

  explicit ListUpstreamAppServersResponseBodyAppServers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListUpstreamAppServersResponseBodyAppServersPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListUpstreamAppServersResponseBodyAppServersPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUpstreamAppServersResponseBodyAppServersList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamAppServersResponseBodyAppServersList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUpstreamAppServersResponseBodyAppServersList>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamAppServersResponseBodyAppServers() = default;
};
class ListUpstreamAppServersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListUpstreamAppServersResponseBodyAppServers> appServers{};

  ListUpstreamAppServersResponseBody() {}

  explicit ListUpstreamAppServersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (appServers) {
      res["AppServers"] = appServers ? boost::any(appServers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AppServers") != m.end() && !m["AppServers"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppServers"].type()) {
        ListUpstreamAppServersResponseBodyAppServers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppServers"]));
        appServers = make_shared<ListUpstreamAppServersResponseBodyAppServers>(model1);
      }
    }
  }


  virtual ~ListUpstreamAppServersResponseBody() = default;
};
class ListUpstreamAppServersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUpstreamAppServersResponseBody> body{};

  ListUpstreamAppServersResponse() {}

  explicit ListUpstreamAppServersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamAppServersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamAppServersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamAppServersResponse() = default;
};
class DeleteVersionTestRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};

  DeleteVersionTestRequest() {}

  explicit DeleteVersionTestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteVersionTestRequest() = default;
};
class DeleteVersionTestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionTestResponseBody() {}

  explicit DeleteVersionTestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionTestResponseBody() = default;
};
class DeleteVersionTestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionTestResponseBody> body{};

  DeleteVersionTestResponse() {}

  explicit DeleteVersionTestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionTestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionTestResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionTestResponse() = default;
};
class CreateUpstreamAppKeyRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> PAppKey{};
  shared_ptr<string> projectId{};

  CreateUpstreamAppKeyRelationRequest() {}

  explicit CreateUpstreamAppKeyRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (PAppKey) {
      res["PAppKey"] = boost::any(*PAppKey);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("PAppKey") != m.end() && !m["PAppKey"].empty()) {
      PAppKey = make_shared<string>(boost::any_cast<string>(m["PAppKey"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CreateUpstreamAppKeyRelationRequest() = default;
};
class CreateUpstreamAppKeyRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> id{};

  CreateUpstreamAppKeyRelationResponseBody() {}

  explicit CreateUpstreamAppKeyRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CreateUpstreamAppKeyRelationResponseBody() = default;
};
class CreateUpstreamAppKeyRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateUpstreamAppKeyRelationResponseBody> body{};

  CreateUpstreamAppKeyRelationResponse() {}

  explicit CreateUpstreamAppKeyRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUpstreamAppKeyRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUpstreamAppKeyRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUpstreamAppKeyRelationResponse() = default;
};
class FindAppVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> versionId{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<string> appId{};
  shared_ptr<string> remark{};

  FindAppVersionsRequest() {}

  explicit FindAppVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~FindAppVersionsRequest() = default;
};
class FindAppVersionsResponseBodyAppVersionListItems : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> isAllowNewInstall{};
  shared_ptr<string> statusName{};
  shared_ptr<string> restartAppParam{};
  shared_ptr<string> isSilentUpgrade{};
  shared_ptr<string> appPackageName{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> appName{};
  shared_ptr<string> installType{};
  shared_ptr<string> isNeedRestart{};
  shared_ptr<string> restartAppType{};
  shared_ptr<string> appId{};
  shared_ptr<string> restartType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> appVersion{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<long> id{};

  FindAppVersionsResponseBodyAppVersionListItems() {}

  explicit FindAppVersionsResponseBodyAppVersionListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (isAllowNewInstall) {
      res["IsAllowNewInstall"] = boost::any(*isAllowNewInstall);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (restartAppParam) {
      res["RestartAppParam"] = boost::any(*restartAppParam);
    }
    if (isSilentUpgrade) {
      res["IsSilentUpgrade"] = boost::any(*isSilentUpgrade);
    }
    if (appPackageName) {
      res["AppPackageName"] = boost::any(*appPackageName);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (installType) {
      res["InstallType"] = boost::any(*installType);
    }
    if (isNeedRestart) {
      res["IsNeedRestart"] = boost::any(*isNeedRestart);
    }
    if (restartAppType) {
      res["RestartAppType"] = boost::any(*restartAppType);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (restartType) {
      res["RestartType"] = boost::any(*restartType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (appVersion) {
      res["AppVersion"] = boost::any(*appVersion);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("IsAllowNewInstall") != m.end() && !m["IsAllowNewInstall"].empty()) {
      isAllowNewInstall = make_shared<string>(boost::any_cast<string>(m["IsAllowNewInstall"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("RestartAppParam") != m.end() && !m["RestartAppParam"].empty()) {
      restartAppParam = make_shared<string>(boost::any_cast<string>(m["RestartAppParam"]));
    }
    if (m.find("IsSilentUpgrade") != m.end() && !m["IsSilentUpgrade"].empty()) {
      isSilentUpgrade = make_shared<string>(boost::any_cast<string>(m["IsSilentUpgrade"]));
    }
    if (m.find("AppPackageName") != m.end() && !m["AppPackageName"].empty()) {
      appPackageName = make_shared<string>(boost::any_cast<string>(m["AppPackageName"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("InstallType") != m.end() && !m["InstallType"].empty()) {
      installType = make_shared<string>(boost::any_cast<string>(m["InstallType"]));
    }
    if (m.find("IsNeedRestart") != m.end() && !m["IsNeedRestart"].empty()) {
      isNeedRestart = make_shared<string>(boost::any_cast<string>(m["IsNeedRestart"]));
    }
    if (m.find("RestartAppType") != m.end() && !m["RestartAppType"].empty()) {
      restartAppType = make_shared<string>(boost::any_cast<string>(m["RestartAppType"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("RestartType") != m.end() && !m["RestartType"].empty()) {
      restartType = make_shared<string>(boost::any_cast<string>(m["RestartType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("AppVersion") != m.end() && !m["AppVersion"].empty()) {
      appVersion = make_shared<string>(boost::any_cast<string>(m["AppVersion"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindAppVersionsResponseBodyAppVersionListItems() = default;
};
class FindAppVersionsResponseBodyAppVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<FindAppVersionsResponseBodyAppVersionListItems>> items{};
  shared_ptr<long> totalCount{};

  FindAppVersionsResponseBodyAppVersionList() {}

  explicit FindAppVersionsResponseBodyAppVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindAppVersionsResponseBodyAppVersionListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindAppVersionsResponseBodyAppVersionListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindAppVersionsResponseBodyAppVersionListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindAppVersionsResponseBodyAppVersionList() = default;
};
class FindAppVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<FindAppVersionsResponseBodyAppVersionList> appVersionList{};
  shared_ptr<string> requestId{};

  FindAppVersionsResponseBody() {}

  explicit FindAppVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appVersionList) {
      res["AppVersionList"] = appVersionList ? boost::any(appVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppVersionList") != m.end() && !m["AppVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppVersionList"].type()) {
        FindAppVersionsResponseBodyAppVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppVersionList"]));
        appVersionList = make_shared<FindAppVersionsResponseBodyAppVersionList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FindAppVersionsResponseBody() = default;
};
class FindAppVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindAppVersionsResponseBody> body{};

  FindAppVersionsResponse() {}

  explicit FindAppVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindAppVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindAppVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~FindAppVersionsResponse() = default;
};
class ListMqttRootTopicsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> projectId{};

  ListMqttRootTopicsRequest() {}

  explicit ListMqttRootTopicsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListMqttRootTopicsRequest() = default;
};
class ListMqttRootTopicsResponseBodyRootTopicsPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMqttRootTopicsResponseBodyRootTopicsPagination() {}

  explicit ListMqttRootTopicsResponseBodyRootTopicsPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMqttRootTopicsResponseBodyRootTopicsPagination() = default;
};
class ListMqttRootTopicsResponseBodyRootTopicsList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> appKey{};
  shared_ptr<string> queueName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> rootTopic{};

  ListMqttRootTopicsResponseBodyRootTopicsList() {}

  explicit ListMqttRootTopicsResponseBodyRootTopicsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (rootTopic) {
      res["RootTopic"] = boost::any(*rootTopic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("RootTopic") != m.end() && !m["RootTopic"].empty()) {
      rootTopic = make_shared<string>(boost::any_cast<string>(m["RootTopic"]));
    }
  }


  virtual ~ListMqttRootTopicsResponseBodyRootTopicsList() = default;
};
class ListMqttRootTopicsResponseBodyRootTopics : public Darabonba::Model {
public:
  shared_ptr<ListMqttRootTopicsResponseBodyRootTopicsPagination> pagination{};
  shared_ptr<vector<ListMqttRootTopicsResponseBodyRootTopicsList>> list{};

  ListMqttRootTopicsResponseBodyRootTopics() {}

  explicit ListMqttRootTopicsResponseBodyRootTopics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListMqttRootTopicsResponseBodyRootTopicsPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListMqttRootTopicsResponseBodyRootTopicsPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListMqttRootTopicsResponseBodyRootTopicsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMqttRootTopicsResponseBodyRootTopicsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListMqttRootTopicsResponseBodyRootTopicsList>>(expect1);
      }
    }
  }


  virtual ~ListMqttRootTopicsResponseBodyRootTopics() = default;
};
class ListMqttRootTopicsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMqttRootTopicsResponseBodyRootTopics> rootTopics{};

  ListMqttRootTopicsResponseBody() {}

  explicit ListMqttRootTopicsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rootTopics) {
      res["RootTopics"] = rootTopics ? boost::any(rootTopics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RootTopics") != m.end() && !m["RootTopics"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootTopics"].type()) {
        ListMqttRootTopicsResponseBodyRootTopics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootTopics"]));
        rootTopics = make_shared<ListMqttRootTopicsResponseBodyRootTopics>(model1);
      }
    }
  }


  virtual ~ListMqttRootTopicsResponseBody() = default;
};
class ListMqttRootTopicsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMqttRootTopicsResponseBody> body{};

  ListMqttRootTopicsResponse() {}

  explicit ListMqttRootTopicsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMqttRootTopicsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMqttRootTopicsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMqttRootTopicsResponse() = default;
};
class ListAssistDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<string> condition{};
  shared_ptr<long> perPage{};

  ListAssistDevicesRequest() {}

  explicit ListAssistDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (condition) {
      res["Condition"] = boost::any(*condition);
    }
    if (perPage) {
      res["PerPage"] = boost::any(*perPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("Condition") != m.end() && !m["Condition"].empty()) {
      condition = make_shared<string>(boost::any_cast<string>(m["Condition"]));
    }
    if (m.find("PerPage") != m.end() && !m["PerPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["PerPage"]));
    }
  }


  virtual ~ListAssistDevicesRequest() = default;
};
class ListAssistDevicesResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> accessTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> UUID{};
  shared_ptr<string> VIN{};

  ListAssistDevicesResponseBodyDevices() {}

  explicit ListAssistDevicesResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (accessTime) {
      res["AccessTime"] = boost::any(*accessTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (UUID) {
      res["UUID"] = boost::any(*UUID);
    }
    if (VIN) {
      res["VIN"] = boost::any(*VIN);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("AccessTime") != m.end() && !m["AccessTime"].empty()) {
      accessTime = make_shared<long>(boost::any_cast<long>(m["AccessTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("UUID") != m.end() && !m["UUID"].empty()) {
      UUID = make_shared<string>(boost::any_cast<string>(m["UUID"]));
    }
    if (m.find("VIN") != m.end() && !m["VIN"].empty()) {
      VIN = make_shared<string>(boost::any_cast<string>(m["VIN"]));
    }
  }


  virtual ~ListAssistDevicesResponseBodyDevices() = default;
};
class ListAssistDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> perPage{};
  shared_ptr<long> pageIndex{};
  shared_ptr<vector<ListAssistDevicesResponseBodyDevices>> devices{};

  ListAssistDevicesResponseBody() {}

  explicit ListAssistDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (perPage) {
      res["PerPage"] = boost::any(*perPage);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PerPage") != m.end() && !m["PerPage"].empty()) {
      perPage = make_shared<long>(boost::any_cast<long>(m["PerPage"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<ListAssistDevicesResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAssistDevicesResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<ListAssistDevicesResponseBodyDevices>>(expect1);
      }
    }
  }


  virtual ~ListAssistDevicesResponseBody() = default;
};
class ListAssistDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAssistDevicesResponseBody> body{};

  ListAssistDevicesResponse() {}

  explicit ListAssistDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAssistDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAssistDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAssistDevicesResponse() = default;
};
class DeleteUpstreamAppServerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> id{};

  DeleteUpstreamAppServerRequest() {}

  explicit DeleteUpstreamAppServerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteUpstreamAppServerRequest() = default;
};
class DeleteUpstreamAppServerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUpstreamAppServerResponseBody() {}

  explicit DeleteUpstreamAppServerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUpstreamAppServerResponseBody() = default;
};
class DeleteUpstreamAppServerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteUpstreamAppServerResponseBody> body{};

  DeleteUpstreamAppServerResponse() {}

  explicit DeleteUpstreamAppServerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUpstreamAppServerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUpstreamAppServerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUpstreamAppServerResponse() = default;
};
class UpdateVersionDeviceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};

  UpdateVersionDeviceGroupRequest() {}

  explicit UpdateVersionDeviceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateVersionDeviceGroupRequest() = default;
};
class UpdateVersionDeviceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVersionDeviceGroupResponseBody() {}

  explicit UpdateVersionDeviceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVersionDeviceGroupResponseBody() = default;
};
class UpdateVersionDeviceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateVersionDeviceGroupResponseBody> body{};

  UpdateVersionDeviceGroupResponse() {}

  explicit UpdateVersionDeviceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVersionDeviceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVersionDeviceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVersionDeviceGroupResponse() = default;
};
class ListOpenAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<long> length{};
  shared_ptr<long> start{};
  shared_ptr<string> mobile{};
  shared_ptr<string> email{};
  shared_ptr<string> displayName{};
  shared_ptr<string> projectId{};

  ListOpenAccountsRequest() {}

  explicit ListOpenAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListOpenAccountsRequest() = default;
};
class ListOpenAccountsResponseBodyOpenAccounts : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> displayName{};
  shared_ptr<string> createAccessKey{};
  shared_ptr<string> openId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> region{};
  shared_ptr<string> identityId{};
  shared_ptr<string> loginId{};
  shared_ptr<string> idp{};
  shared_ptr<string> aliyunId{};

  ListOpenAccountsResponseBodyOpenAccounts() {}

  explicit ListOpenAccountsResponseBodyOpenAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (createAccessKey) {
      res["CreateAccessKey"] = boost::any(*createAccessKey);
    }
    if (openId) {
      res["OpenId"] = boost::any(*openId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (loginId) {
      res["LoginId"] = boost::any(*loginId);
    }
    if (idp) {
      res["Idp"] = boost::any(*idp);
    }
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("CreateAccessKey") != m.end() && !m["CreateAccessKey"].empty()) {
      createAccessKey = make_shared<string>(boost::any_cast<string>(m["CreateAccessKey"]));
    }
    if (m.find("OpenId") != m.end() && !m["OpenId"].empty()) {
      openId = make_shared<string>(boost::any_cast<string>(m["OpenId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("LoginId") != m.end() && !m["LoginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["LoginId"]));
    }
    if (m.find("Idp") != m.end() && !m["Idp"].empty()) {
      idp = make_shared<string>(boost::any_cast<string>(m["Idp"]));
    }
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<string>(boost::any_cast<string>(m["AliyunId"]));
    }
  }


  virtual ~ListOpenAccountsResponseBodyOpenAccounts() = default;
};
class ListOpenAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListOpenAccountsResponseBodyOpenAccounts>> openAccounts{};

  ListOpenAccountsResponseBody() {}

  explicit ListOpenAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (openAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*openAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpenAccounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OpenAccounts") != m.end() && !m["OpenAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["OpenAccounts"].type()) {
        vector<ListOpenAccountsResponseBodyOpenAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpenAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOpenAccountsResponseBodyOpenAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        openAccounts = make_shared<vector<ListOpenAccountsResponseBodyOpenAccounts>>(expect1);
      }
    }
  }


  virtual ~ListOpenAccountsResponseBody() = default;
};
class ListOpenAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOpenAccountsResponseBody> body{};

  ListOpenAccountsResponse() {}

  explicit ListOpenAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOpenAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOpenAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOpenAccountsResponse() = default;
};
class UpdateOsVersionStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> status{};

  UpdateOsVersionStatusRequest() {}

  explicit UpdateOsVersionStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateOsVersionStatusRequest() = default;
};
class UpdateOsVersionStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsVersionStatusResponseBody() {}

  explicit UpdateOsVersionStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsVersionStatusResponseBody() = default;
};
class UpdateOsVersionStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOsVersionStatusResponseBody> body{};

  UpdateOsVersionStatusResponse() {}

  explicit UpdateOsVersionStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsVersionStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsVersionStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsVersionStatusResponse() = default;
};
class CountProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> projectCount{};

  CountProjectsResponseBody() {}

  explicit CountProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectCount) {
      res["ProjectCount"] = boost::any(*projectCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectCount") != m.end() && !m["ProjectCount"].empty()) {
      projectCount = make_shared<long>(boost::any_cast<long>(m["ProjectCount"]));
    }
  }


  virtual ~CountProjectsResponseBody() = default;
};
class CountProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountProjectsResponseBody> body{};

  CountProjectsResponse() {}

  explicit CountProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~CountProjectsResponse() = default;
};
class ListCommercialVehicleDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> clientId{};

  ListCommercialVehicleDevicesRequest() {}

  explicit ListCommercialVehicleDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~ListCommercialVehicleDevicesRequest() = default;
};
class ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination() {}

  explicit ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination() = default;
};
class ListCommercialVehicleDevicesResponseBodyVehicleDevicesList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> hardwareId{};
  shared_ptr<long> clientId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> onlineStatus{};
  shared_ptr<string> plateNumber{};

  ListCommercialVehicleDevicesResponseBodyVehicleDevicesList() {}

  explicit ListCommercialVehicleDevicesResponseBodyVehicleDevicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (plateNumber) {
      res["PlateNumber"] = boost::any(*plateNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<long>(boost::any_cast<long>(m["ClientId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<long>(boost::any_cast<long>(m["OnlineStatus"]));
    }
    if (m.find("PlateNumber") != m.end() && !m["PlateNumber"].empty()) {
      plateNumber = make_shared<string>(boost::any_cast<string>(m["PlateNumber"]));
    }
  }


  virtual ~ListCommercialVehicleDevicesResponseBodyVehicleDevicesList() = default;
};
class ListCommercialVehicleDevicesResponseBodyVehicleDevices : public Darabonba::Model {
public:
  shared_ptr<ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination> pagination{};
  shared_ptr<vector<ListCommercialVehicleDevicesResponseBodyVehicleDevicesList>> list{};

  ListCommercialVehicleDevicesResponseBodyVehicleDevices() {}

  explicit ListCommercialVehicleDevicesResponseBodyVehicleDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListCommercialVehicleDevicesResponseBodyVehicleDevicesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCommercialVehicleDevicesResponseBodyVehicleDevicesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCommercialVehicleDevicesResponseBodyVehicleDevicesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCommercialVehicleDevicesResponseBodyVehicleDevicesList>>(expect1);
      }
    }
  }


  virtual ~ListCommercialVehicleDevicesResponseBodyVehicleDevices() = default;
};
class ListCommercialVehicleDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListCommercialVehicleDevicesResponseBodyVehicleDevices> vehicleDevices{};

  ListCommercialVehicleDevicesResponseBody() {}

  explicit ListCommercialVehicleDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vehicleDevices) {
      res["VehicleDevices"] = vehicleDevices ? boost::any(vehicleDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VehicleDevices") != m.end() && !m["VehicleDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["VehicleDevices"].type()) {
        ListCommercialVehicleDevicesResponseBodyVehicleDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VehicleDevices"]));
        vehicleDevices = make_shared<ListCommercialVehicleDevicesResponseBodyVehicleDevices>(model1);
      }
    }
  }


  virtual ~ListCommercialVehicleDevicesResponseBody() = default;
};
class ListCommercialVehicleDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCommercialVehicleDevicesResponseBody> body{};

  ListCommercialVehicleDevicesResponse() {}

  explicit ListCommercialVehicleDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCommercialVehicleDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCommercialVehicleDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCommercialVehicleDevicesResponse() = default;
};
class ListMessageReceiversRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> messageId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListMessageReceiversRequest() {}

  explicit ListMessageReceiversRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<string>(boost::any_cast<string>(m["MessageId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListMessageReceiversRequest() = default;
};
class ListMessageReceiversResponseBodyMessageReceiversPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMessageReceiversResponseBodyMessageReceiversPagination() {}

  explicit ListMessageReceiversResponseBodyMessageReceiversPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMessageReceiversResponseBodyMessageReceiversPagination() = default;
};
class ListMessageReceiversResponseBodyMessageReceiversList : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> value{};
  shared_ptr<long> mid{};

  ListMessageReceiversResponseBodyMessageReceiversList() {}

  explicit ListMessageReceiversResponseBodyMessageReceiversList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<long>(boost::any_cast<long>(m["Mid"]));
    }
  }


  virtual ~ListMessageReceiversResponseBodyMessageReceiversList() = default;
};
class ListMessageReceiversResponseBodyMessageReceivers : public Darabonba::Model {
public:
  shared_ptr<ListMessageReceiversResponseBodyMessageReceiversPagination> pagination{};
  shared_ptr<vector<ListMessageReceiversResponseBodyMessageReceiversList>> list{};

  ListMessageReceiversResponseBodyMessageReceivers() {}

  explicit ListMessageReceiversResponseBodyMessageReceivers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListMessageReceiversResponseBodyMessageReceiversPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListMessageReceiversResponseBodyMessageReceiversPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListMessageReceiversResponseBodyMessageReceiversList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageReceiversResponseBodyMessageReceiversList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListMessageReceiversResponseBodyMessageReceiversList>>(expect1);
      }
    }
  }


  virtual ~ListMessageReceiversResponseBodyMessageReceivers() = default;
};
class ListMessageReceiversResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListMessageReceiversResponseBodyMessageReceivers> messageReceivers{};
  shared_ptr<string> requestId{};

  ListMessageReceiversResponseBody() {}

  explicit ListMessageReceiversResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageReceivers) {
      res["MessageReceivers"] = messageReceivers ? boost::any(messageReceivers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageReceivers") != m.end() && !m["MessageReceivers"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageReceivers"].type()) {
        ListMessageReceiversResponseBodyMessageReceivers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageReceivers"]));
        messageReceivers = make_shared<ListMessageReceiversResponseBodyMessageReceivers>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMessageReceiversResponseBody() = default;
};
class ListMessageReceiversResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMessageReceiversResponseBody> body{};

  ListMessageReceiversResponse() {}

  explicit ListMessageReceiversResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageReceiversResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageReceiversResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageReceiversResponse() = default;
};
class CountDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> deviceModel{};

  CountDevicesRequest() {}

  explicit CountDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
  }


  virtual ~CountDevicesRequest() = default;
};
class CountDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> deviceCount{};

  CountDevicesResponseBody() {}

  explicit CountDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceCount) {
      res["DeviceCount"] = boost::any(*deviceCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceCount") != m.end() && !m["DeviceCount"].empty()) {
      deviceCount = make_shared<long>(boost::any_cast<long>(m["DeviceCount"]));
    }
  }


  virtual ~CountDevicesResponseBody() = default;
};
class CountDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountDevicesResponseBody> body{};

  CountDevicesResponse() {}

  explicit CountDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~CountDevicesResponse() = default;
};
class UpdateOsBlackWhiteVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> whiteVersions{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> blackVersions{};

  UpdateOsBlackWhiteVersionsRequest() {}

  explicit UpdateOsBlackWhiteVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteVersions) {
      res["WhiteVersions"] = boost::any(*whiteVersions);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (blackVersions) {
      res["BlackVersions"] = boost::any(*blackVersions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WhiteVersions") != m.end() && !m["WhiteVersions"].empty()) {
      whiteVersions = make_shared<string>(boost::any_cast<string>(m["WhiteVersions"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("BlackVersions") != m.end() && !m["BlackVersions"].empty()) {
      blackVersions = make_shared<string>(boost::any_cast<string>(m["BlackVersions"]));
    }
  }


  virtual ~UpdateOsBlackWhiteVersionsRequest() = default;
};
class UpdateOsBlackWhiteVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsBlackWhiteVersionsResponseBody() {}

  explicit UpdateOsBlackWhiteVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsBlackWhiteVersionsResponseBody() = default;
};
class UpdateOsBlackWhiteVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOsBlackWhiteVersionsResponseBody> body{};

  UpdateOsBlackWhiteVersionsResponse() {}

  explicit UpdateOsBlackWhiteVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsBlackWhiteVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsBlackWhiteVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsBlackWhiteVersionsResponse() = default;
};
class GetNamespaceDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> authType{};
  shared_ptr<string> deviceIdType{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> accountType{};
  shared_ptr<string> accountId{};

  GetNamespaceDataRequest() {}

  explicit GetNamespaceDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
  }


  virtual ~GetNamespaceDataRequest() = default;
};
class GetNamespaceDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  GetNamespaceDataResponseBody() {}

  explicit GetNamespaceDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~GetNamespaceDataResponseBody() = default;
};
class GetNamespaceDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNamespaceDataResponseBody> body{};

  GetNamespaceDataResponse() {}

  explicit GetNamespaceDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNamespaceDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNamespaceDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetNamespaceDataResponse() = default;
};
class UpdateOsVersionRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> remark{};

  UpdateOsVersionRemarkRequest() {}

  explicit UpdateOsVersionRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateOsVersionRemarkRequest() = default;
};
class UpdateOsVersionRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOsVersionRemarkResponseBody() {}

  explicit UpdateOsVersionRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOsVersionRemarkResponseBody() = default;
};
class UpdateOsVersionRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateOsVersionRemarkResponseBody> body{};

  UpdateOsVersionRemarkResponse() {}

  explicit UpdateOsVersionRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOsVersionRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOsVersionRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOsVersionRemarkResponse() = default;
};
class QueryPrepublishPassedDeviceCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> prepublishId{};

  QueryPrepublishPassedDeviceCountRequest() {}

  explicit QueryPrepublishPassedDeviceCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (prepublishId) {
      res["PrepublishId"] = boost::any(*prepublishId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PrepublishId") != m.end() && !m["PrepublishId"].empty()) {
      prepublishId = make_shared<string>(boost::any_cast<string>(m["PrepublishId"]));
    }
  }


  virtual ~QueryPrepublishPassedDeviceCountRequest() = default;
};
class QueryPrepublishPassedDeviceCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> count{};

  QueryPrepublishPassedDeviceCountResponseBody() {}

  explicit QueryPrepublishPassedDeviceCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
  }


  virtual ~QueryPrepublishPassedDeviceCountResponseBody() = default;
};
class QueryPrepublishPassedDeviceCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<QueryPrepublishPassedDeviceCountResponseBody> body{};

  QueryPrepublishPassedDeviceCountResponse() {}

  explicit QueryPrepublishPassedDeviceCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryPrepublishPassedDeviceCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryPrepublishPassedDeviceCountResponseBody>(model1);
      }
    }
  }


  virtual ~QueryPrepublishPassedDeviceCountResponse() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> projectDesc{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectDesc) {
      res["ProjectDesc"] = boost::any(*projectDesc);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectDesc") != m.end() && !m["ProjectDesc"].empty()) {
      projectDesc = make_shared<string>(boost::any_cast<string>(m["ProjectDesc"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class ListNamespacesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> authType{};

  ListNamespacesRequest() {}

  explicit ListNamespacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
  }


  virtual ~ListNamespacesRequest() = default;
};
class ListNamespacesResponseBodyNamespaces : public Darabonba::Model {
public:
  shared_ptr<long> authType{};
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};

  ListNamespacesResponseBodyNamespaces() {}

  explicit ListNamespacesResponseBodyNamespaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<long>(boost::any_cast<long>(m["AuthType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListNamespacesResponseBodyNamespaces() = default;
};
class ListNamespacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNamespacesResponseBodyNamespaces>> namespaces{};
  shared_ptr<string> requestId{};

  ListNamespacesResponseBody() {}

  explicit ListNamespacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespaces) {
      vector<boost::any> temp1;
      for(auto item1:*namespaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Namespaces"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Namespaces") != m.end() && !m["Namespaces"].empty()) {
      if (typeid(vector<boost::any>) == m["Namespaces"].type()) {
        vector<ListNamespacesResponseBodyNamespaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Namespaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNamespacesResponseBodyNamespaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        namespaces = make_shared<vector<ListNamespacesResponseBodyNamespaces>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNamespacesResponseBody() = default;
};
class ListNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListNamespacesResponseBody> body{};

  ListNamespacesResponse() {}

  explicit ListNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNamespacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNamespacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNamespacesResponse() = default;
};
class ListSupportFeaturesResponseBodySupportFeatures : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListSupportFeaturesResponseBodySupportFeatures() {}

  explicit ListSupportFeaturesResponseBodySupportFeatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListSupportFeaturesResponseBodySupportFeatures() = default;
};
class ListSupportFeaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSupportFeaturesResponseBodySupportFeatures>> supportFeatures{};

  ListSupportFeaturesResponseBody() {}

  explicit ListSupportFeaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (supportFeatures) {
      vector<boost::any> temp1;
      for(auto item1:*supportFeatures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportFeatures"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SupportFeatures") != m.end() && !m["SupportFeatures"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportFeatures"].type()) {
        vector<ListSupportFeaturesResponseBodySupportFeatures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportFeatures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSupportFeaturesResponseBodySupportFeatures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportFeatures = make_shared<vector<ListSupportFeaturesResponseBodySupportFeatures>>(expect1);
      }
    }
  }


  virtual ~ListSupportFeaturesResponseBody() = default;
};
class ListSupportFeaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSupportFeaturesResponseBody> body{};

  ListSupportFeaturesResponse() {}

  explicit ListSupportFeaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSupportFeaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSupportFeaturesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSupportFeaturesResponse() = default;
};
class DeleteMqttRootTopicRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> rootTopic{};
  shared_ptr<string> projectId{};

  DeleteMqttRootTopicRequest() {}

  explicit DeleteMqttRootTopicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (rootTopic) {
      res["RootTopic"] = boost::any(*rootTopic);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("RootTopic") != m.end() && !m["RootTopic"].empty()) {
      rootTopic = make_shared<string>(boost::any_cast<string>(m["RootTopic"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteMqttRootTopicRequest() = default;
};
class DeleteMqttRootTopicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMqttRootTopicResponseBody() {}

  explicit DeleteMqttRootTopicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMqttRootTopicResponseBody() = default;
};
class DeleteMqttRootTopicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteMqttRootTopicResponseBody> body{};

  DeleteMqttRootTopicResponse() {}

  explicit DeleteMqttRootTopicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMqttRootTopicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMqttRootTopicResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMqttRootTopicResponse() = default;
};
class DeleteVersionGroupDeviceByIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceGroupId{};
  shared_ptr<string> ids{};

  DeleteVersionGroupDeviceByIdRequest() {}

  explicit DeleteVersionGroupDeviceByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceGroupId) {
      res["DeviceGroupId"] = boost::any(*deviceGroupId);
    }
    if (ids) {
      res["Ids"] = boost::any(*ids);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceGroupId") != m.end() && !m["DeviceGroupId"].empty()) {
      deviceGroupId = make_shared<string>(boost::any_cast<string>(m["DeviceGroupId"]));
    }
    if (m.find("Ids") != m.end() && !m["Ids"].empty()) {
      ids = make_shared<string>(boost::any_cast<string>(m["Ids"]));
    }
  }


  virtual ~DeleteVersionGroupDeviceByIdRequest() = default;
};
class DeleteVersionGroupDeviceByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionGroupDeviceByIdResponseBody() {}

  explicit DeleteVersionGroupDeviceByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionGroupDeviceByIdResponseBody() = default;
};
class DeleteVersionGroupDeviceByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionGroupDeviceByIdResponseBody> body{};

  DeleteVersionGroupDeviceByIdResponse() {}

  explicit DeleteVersionGroupDeviceByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionGroupDeviceByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionGroupDeviceByIdResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionGroupDeviceByIdResponse() = default;
};
class ListClientPluginVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> osType{};
  shared_ptr<string> pkgName{};

  ListClientPluginVersionsRequest() {}

  explicit ListClientPluginVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
  }


  virtual ~ListClientPluginVersionsRequest() = default;
};
class ListClientPluginVersionsResponseBodyClientPluginVersions : public Darabonba::Model {
public:
  shared_ptr<string> version{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> size{};
  shared_ptr<string> pkgName{};
  shared_ptr<long> versionCode{};
  shared_ptr<long> id{};

  ListClientPluginVersionsResponseBodyClientPluginVersions() {}

  explicit ListClientPluginVersionsResponseBodyClientPluginVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<long>(boost::any_cast<long>(m["VersionCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListClientPluginVersionsResponseBodyClientPluginVersions() = default;
};
class ListClientPluginVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClientPluginVersionsResponseBodyClientPluginVersions>> clientPluginVersions{};
  shared_ptr<string> requestId{};

  ListClientPluginVersionsResponseBody() {}

  explicit ListClientPluginVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientPluginVersions) {
      vector<boost::any> temp1;
      for(auto item1:*clientPluginVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientPluginVersions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientPluginVersions") != m.end() && !m["ClientPluginVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientPluginVersions"].type()) {
        vector<ListClientPluginVersionsResponseBodyClientPluginVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientPluginVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientPluginVersionsResponseBodyClientPluginVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientPluginVersions = make_shared<vector<ListClientPluginVersionsResponseBodyClientPluginVersions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClientPluginVersionsResponseBody() = default;
};
class ListClientPluginVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClientPluginVersionsResponseBody> body{};

  ListClientPluginVersionsResponse() {}

  explicit ListClientPluginVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientPluginVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientPluginVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientPluginVersionsResponse() = default;
};
class FindVersionMessageSendRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> versionType{};
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> messageType{};
  shared_ptr<string> versionId{};

  FindVersionMessageSendRecordsRequest() {}

  explicit FindVersionMessageSendRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~FindVersionMessageSendRecordsRequest() = default;
};
class FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> messageType{};
  shared_ptr<string> failedCount{};
  shared_ptr<string> skippedCount{};
  shared_ptr<string> result{};
  shared_ptr<string> succeededCount{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> versionId{};
  shared_ptr<string> resultDesc{};
  shared_ptr<string> targetId{};
  shared_ptr<long> id{};

  FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems() {}

  explicit FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (messageType) {
      res["MessageType"] = boost::any(*messageType);
    }
    if (failedCount) {
      res["FailedCount"] = boost::any(*failedCount);
    }
    if (skippedCount) {
      res["SkippedCount"] = boost::any(*skippedCount);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (succeededCount) {
      res["SucceededCount"] = boost::any(*succeededCount);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (resultDesc) {
      res["ResultDesc"] = boost::any(*resultDesc);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("MessageType") != m.end() && !m["MessageType"].empty()) {
      messageType = make_shared<string>(boost::any_cast<string>(m["MessageType"]));
    }
    if (m.find("FailedCount") != m.end() && !m["FailedCount"].empty()) {
      failedCount = make_shared<string>(boost::any_cast<string>(m["FailedCount"]));
    }
    if (m.find("SkippedCount") != m.end() && !m["SkippedCount"].empty()) {
      skippedCount = make_shared<string>(boost::any_cast<string>(m["SkippedCount"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("SucceededCount") != m.end() && !m["SucceededCount"].empty()) {
      succeededCount = make_shared<string>(boost::any_cast<string>(m["SucceededCount"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("ResultDesc") != m.end() && !m["ResultDesc"].empty()) {
      resultDesc = make_shared<string>(boost::any_cast<string>(m["ResultDesc"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems() = default;
};
class FindVersionMessageSendRecordsResponseBodyMessageSendRecordList : public Darabonba::Model {
public:
  shared_ptr<vector<FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems>> items{};
  shared_ptr<long> totalCount{};

  FindVersionMessageSendRecordsResponseBodyMessageSendRecordList() {}

  explicit FindVersionMessageSendRecordsResponseBodyMessageSendRecordList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindVersionMessageSendRecordsResponseBodyMessageSendRecordListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindVersionMessageSendRecordsResponseBodyMessageSendRecordList() = default;
};
class FindVersionMessageSendRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<FindVersionMessageSendRecordsResponseBodyMessageSendRecordList> messageSendRecordList{};
  shared_ptr<string> requestId{};

  FindVersionMessageSendRecordsResponseBody() {}

  explicit FindVersionMessageSendRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (messageSendRecordList) {
      res["MessageSendRecordList"] = messageSendRecordList ? boost::any(messageSendRecordList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MessageSendRecordList") != m.end() && !m["MessageSendRecordList"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageSendRecordList"].type()) {
        FindVersionMessageSendRecordsResponseBodyMessageSendRecordList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageSendRecordList"]));
        messageSendRecordList = make_shared<FindVersionMessageSendRecordsResponseBodyMessageSendRecordList>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~FindVersionMessageSendRecordsResponseBody() = default;
};
class FindVersionMessageSendRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindVersionMessageSendRecordsResponseBody> body{};

  FindVersionMessageSendRecordsResponse() {}

  explicit FindVersionMessageSendRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindVersionMessageSendRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindVersionMessageSendRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~FindVersionMessageSendRecordsResponse() = default;
};
class GenerateSysAppDownloadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> plugins{};
  shared_ptr<string> signMode{};
  shared_ptr<long> osType{};
  shared_ptr<string> pkgName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> certFileObjectKey{};

  GenerateSysAppDownloadInfoRequest() {}

  explicit GenerateSysAppDownloadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (plugins) {
      res["Plugins"] = boost::any(*plugins);
    }
    if (signMode) {
      res["SignMode"] = boost::any(*signMode);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (certFileObjectKey) {
      res["CertFileObjectKey"] = boost::any(*certFileObjectKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Plugins") != m.end() && !m["Plugins"].empty()) {
      plugins = make_shared<string>(boost::any_cast<string>(m["Plugins"]));
    }
    if (m.find("SignMode") != m.end() && !m["SignMode"].empty()) {
      signMode = make_shared<string>(boost::any_cast<string>(m["SignMode"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("CertFileObjectKey") != m.end() && !m["CertFileObjectKey"].empty()) {
      certFileObjectKey = make_shared<string>(boost::any_cast<string>(m["CertFileObjectKey"]));
    }
  }


  virtual ~GenerateSysAppDownloadInfoRequest() = default;
};
class GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo() {}

  explicit GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo() = default;
};
class GenerateSysAppDownloadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo> sysAppDownloadInfo{};

  GenerateSysAppDownloadInfoResponseBody() {}

  explicit GenerateSysAppDownloadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sysAppDownloadInfo) {
      res["SysAppDownloadInfo"] = sysAppDownloadInfo ? boost::any(sysAppDownloadInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SysAppDownloadInfo") != m.end() && !m["SysAppDownloadInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SysAppDownloadInfo"].type()) {
        GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SysAppDownloadInfo"]));
        sysAppDownloadInfo = make_shared<GenerateSysAppDownloadInfoResponseBodySysAppDownloadInfo>(model1);
      }
    }
  }


  virtual ~GenerateSysAppDownloadInfoResponseBody() = default;
};
class GenerateSysAppDownloadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateSysAppDownloadInfoResponseBody> body{};

  GenerateSysAppDownloadInfoResponse() {}

  explicit GenerateSysAppDownloadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateSysAppDownloadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateSysAppDownloadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateSysAppDownloadInfoResponse() = default;
};
class DeleteTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> id{};

  DeleteTriggerRequest() {}

  explicit DeleteTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DeleteTriggerRequest() = default;
};
class DeleteTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTriggerResponseBody() {}

  explicit DeleteTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTriggerResponseBody() = default;
};
class DeleteTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTriggerResponseBody> body{};

  DeleteTriggerResponse() {}

  explicit DeleteTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTriggerResponse() = default;
};
class DescribeDeviceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceToken{};
  shared_ptr<string> projectId{};

  DescribeDeviceInfoRequest() {}

  explicit DescribeDeviceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceToken) {
      res["DeviceToken"] = boost::any(*deviceToken);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceToken") != m.end() && !m["DeviceToken"].empty()) {
      deviceToken = make_shared<string>(boost::any_cast<string>(m["DeviceToken"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeDeviceInfoRequest() = default;
};
class DescribeDeviceInfoResponseBodyDeviceInfo : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> macAddress{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> usageType{};
  shared_ptr<string> vin{};
  shared_ptr<string> usageTypeDesc{};
  shared_ptr<string> uuid{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> region{};
  shared_ptr<string> softwareId{};
  shared_ptr<string> name{};
  shared_ptr<string> deviceBrand{};

  DescribeDeviceInfoResponseBodyDeviceInfo() {}

  explicit DescribeDeviceInfoResponseBodyDeviceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (macAddress) {
      res["MacAddress"] = boost::any(*macAddress);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (usageType) {
      res["UsageType"] = boost::any(*usageType);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (usageTypeDesc) {
      res["UsageTypeDesc"] = boost::any(*usageTypeDesc);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (softwareId) {
      res["SoftwareId"] = boost::any(*softwareId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("MacAddress") != m.end() && !m["MacAddress"].empty()) {
      macAddress = make_shared<string>(boost::any_cast<string>(m["MacAddress"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("UsageType") != m.end() && !m["UsageType"].empty()) {
      usageType = make_shared<long>(boost::any_cast<long>(m["UsageType"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("UsageTypeDesc") != m.end() && !m["UsageTypeDesc"].empty()) {
      usageTypeDesc = make_shared<string>(boost::any_cast<string>(m["UsageTypeDesc"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("SoftwareId") != m.end() && !m["SoftwareId"].empty()) {
      softwareId = make_shared<string>(boost::any_cast<string>(m["SoftwareId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~DescribeDeviceInfoResponseBodyDeviceInfo() = default;
};
class DescribeDeviceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeviceInfoResponseBodyDeviceInfo> deviceInfo{};

  DescribeDeviceInfoResponseBody() {}

  explicit DescribeDeviceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceInfo) {
      res["DeviceInfo"] = deviceInfo ? boost::any(deviceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceInfo"].type()) {
        DescribeDeviceInfoResponseBodyDeviceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceInfo"]));
        deviceInfo = make_shared<DescribeDeviceInfoResponseBodyDeviceInfo>(model1);
      }
    }
  }


  virtual ~DescribeDeviceInfoResponseBody() = default;
};
class DescribeDeviceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceInfoResponseBody> body{};

  DescribeDeviceInfoResponse() {}

  explicit DescribeDeviceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceInfoResponse() = default;
};
class CreateDeviceModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> initUsageType{};
  shared_ptr<string> canCreateDeviceId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> brandName{};
  shared_ptr<string> description{};
  shared_ptr<string> deviceType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> securityChip{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> deviceName{};

  CreateDeviceModelRequest() {}

  explicit CreateDeviceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (brandName) {
      res["BrandName"] = boost::any(*brandName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<string>(boost::any_cast<string>(m["InitUsageType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<string>(boost::any_cast<string>(m["CanCreateDeviceId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("BrandName") != m.end() && !m["BrandName"].empty()) {
      brandName = make_shared<string>(boost::any_cast<string>(m["BrandName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<string>(boost::any_cast<string>(m["SecurityChip"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~CreateDeviceModelRequest() = default;
};
class CreateDeviceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> deviceModelId{};

  CreateDeviceModelResponseBody() {}

  explicit CreateDeviceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
  }


  virtual ~CreateDeviceModelResponseBody() = default;
};
class CreateDeviceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateDeviceModelResponseBody> body{};

  CreateDeviceModelResponse() {}

  explicit CreateDeviceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDeviceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDeviceModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDeviceModelResponse() = default;
};
class UpdateAppVersionStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> id{};
  shared_ptr<string> status{};

  UpdateAppVersionStatusRequest() {}

  explicit UpdateAppVersionStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~UpdateAppVersionStatusRequest() = default;
};
class UpdateAppVersionStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppVersionStatusResponseBody() {}

  explicit UpdateAppVersionStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppVersionStatusResponseBody() = default;
};
class UpdateAppVersionStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAppVersionStatusResponseBody> body{};

  UpdateAppVersionStatusResponse() {}

  explicit UpdateAppVersionStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppVersionStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppVersionStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppVersionStatusResponse() = default;
};
class UpdateShadowSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> authType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> projectId{};
  shared_ptr<string> schema{};
  shared_ptr<string> id{};

  UpdateShadowSchemaRequest() {}

  explicit UpdateShadowSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateShadowSchemaRequest() = default;
};
class UpdateShadowSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateShadowSchemaResponseBody() {}

  explicit UpdateShadowSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateShadowSchemaResponseBody() = default;
};
class UpdateShadowSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateShadowSchemaResponseBody> body{};

  UpdateShadowSchemaResponse() {}

  explicit UpdateShadowSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateShadowSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateShadowSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateShadowSchemaResponse() = default;
};
class DescribeDeviceShadowRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> path{};
  shared_ptr<bool> viewSubscribed{};

  DescribeDeviceShadowRequest() {}

  explicit DescribeDeviceShadowRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (viewSubscribed) {
      res["ViewSubscribed"] = boost::any(*viewSubscribed);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ViewSubscribed") != m.end() && !m["ViewSubscribed"].empty()) {
      viewSubscribed = make_shared<bool>(boost::any_cast<bool>(m["ViewSubscribed"]));
    }
  }


  virtual ~DescribeDeviceShadowRequest() = default;
};
class DescribeDeviceShadowResponseBodyDeviceShadow : public Darabonba::Model {
public:
  shared_ptr<string> deviceShadow{};
  shared_ptr<string> deviceInfo{};

  DescribeDeviceShadowResponseBodyDeviceShadow() {}

  explicit DescribeDeviceShadowResponseBodyDeviceShadow(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceShadow) {
      res["DeviceShadow"] = boost::any(*deviceShadow);
    }
    if (deviceInfo) {
      res["DeviceInfo"] = boost::any(*deviceInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceShadow") != m.end() && !m["DeviceShadow"].empty()) {
      deviceShadow = make_shared<string>(boost::any_cast<string>(m["DeviceShadow"]));
    }
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      deviceInfo = make_shared<string>(boost::any_cast<string>(m["DeviceInfo"]));
    }
  }


  virtual ~DescribeDeviceShadowResponseBodyDeviceShadow() = default;
};
class DescribeDeviceShadowResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeviceShadowResponseBodyDeviceShadow> deviceShadow{};

  DescribeDeviceShadowResponseBody() {}

  explicit DescribeDeviceShadowResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceShadow) {
      res["DeviceShadow"] = deviceShadow ? boost::any(deviceShadow->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceShadow") != m.end() && !m["DeviceShadow"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceShadow"].type()) {
        DescribeDeviceShadowResponseBodyDeviceShadow model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceShadow"]));
        deviceShadow = make_shared<DescribeDeviceShadowResponseBodyDeviceShadow>(model1);
      }
    }
  }


  virtual ~DescribeDeviceShadowResponseBody() = default;
};
class DescribeDeviceShadowResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceShadowResponseBody> body{};

  DescribeDeviceShadowResponse() {}

  explicit DescribeDeviceShadowResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceShadowResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceShadowResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceShadowResponse() = default;
};
class ListTriggersRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListTriggersRequest() {}

  explicit ListTriggersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListTriggersRequest() = default;
};
class ListTriggersResponseBodyTriggerListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListTriggersResponseBodyTriggerListPagination() {}

  explicit ListTriggersResponseBodyTriggerListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTriggersResponseBodyTriggerListPagination() = default;
};
class ListTriggersResponseBodyTriggerListTriggersFunctions : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> fileName{};
  shared_ptr<string> name{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> fileId{};

  ListTriggersResponseBodyTriggerListTriggersFunctions() {}

  explicit ListTriggersResponseBodyTriggerListTriggersFunctions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~ListTriggersResponseBodyTriggerListTriggersFunctions() = default;
};
class ListTriggersResponseBodyTriggerListTriggers : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<long> production{};
  shared_ptr<vector<ListTriggersResponseBodyTriggerListTriggersFunctions>> functions{};
  shared_ptr<long> sandbox{};
  shared_ptr<string> namespace_{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> source{};
  shared_ptr<string> chainedFunctionIds{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> invocationMode{};
  shared_ptr<long> id{};

  ListTriggersResponseBodyTriggerListTriggers() {}

  explicit ListTriggersResponseBodyTriggerListTriggers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (production) {
      res["Production"] = boost::any(*production);
    }
    if (functions) {
      vector<boost::any> temp1;
      for(auto item1:*functions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Functions"] = boost::any(temp1);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (chainedFunctionIds) {
      res["ChainedFunctionIds"] = boost::any(*chainedFunctionIds);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (invocationMode) {
      res["InvocationMode"] = boost::any(*invocationMode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Production") != m.end() && !m["Production"].empty()) {
      production = make_shared<long>(boost::any_cast<long>(m["Production"]));
    }
    if (m.find("Functions") != m.end() && !m["Functions"].empty()) {
      if (typeid(vector<boost::any>) == m["Functions"].type()) {
        vector<ListTriggersResponseBodyTriggerListTriggersFunctions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Functions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTriggersResponseBodyTriggerListTriggersFunctions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        functions = make_shared<vector<ListTriggersResponseBodyTriggerListTriggersFunctions>>(expect1);
      }
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<long>(boost::any_cast<long>(m["Sandbox"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("ChainedFunctionIds") != m.end() && !m["ChainedFunctionIds"].empty()) {
      chainedFunctionIds = make_shared<string>(boost::any_cast<string>(m["ChainedFunctionIds"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("InvocationMode") != m.end() && !m["InvocationMode"].empty()) {
      invocationMode = make_shared<long>(boost::any_cast<long>(m["InvocationMode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListTriggersResponseBodyTriggerListTriggers() = default;
};
class ListTriggersResponseBodyTriggerList : public Darabonba::Model {
public:
  shared_ptr<ListTriggersResponseBodyTriggerListPagination> pagination{};
  shared_ptr<vector<ListTriggersResponseBodyTriggerListTriggers>> triggers{};

  ListTriggersResponseBodyTriggerList() {}

  explicit ListTriggersResponseBodyTriggerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListTriggersResponseBodyTriggerListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListTriggersResponseBodyTriggerListPagination>(model1);
      }
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<ListTriggersResponseBodyTriggerListTriggers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTriggersResponseBodyTriggerListTriggers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<ListTriggersResponseBodyTriggerListTriggers>>(expect1);
      }
    }
  }


  virtual ~ListTriggersResponseBodyTriggerList() = default;
};
class ListTriggersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListTriggersResponseBodyTriggerList> triggerList{};

  ListTriggersResponseBody() {}

  explicit ListTriggersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (triggerList) {
      res["TriggerList"] = triggerList ? boost::any(triggerList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TriggerList") != m.end() && !m["TriggerList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TriggerList"].type()) {
        ListTriggersResponseBodyTriggerList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TriggerList"]));
        triggerList = make_shared<ListTriggersResponseBodyTriggerList>(model1);
      }
    }
  }


  virtual ~ListTriggersResponseBody() = default;
};
class ListTriggersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTriggersResponseBody> body{};

  ListTriggersResponse() {}

  explicit ListTriggersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTriggersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTriggersResponseBody>(model1);
      }
    }
  }


  virtual ~ListTriggersResponse() = default;
};
class UpdateCustomizedFilterRequest : public Darabonba::Model {
public:
  shared_ptr<string> blackWhiteType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueType{};
  shared_ptr<string> valueCompareType{};
  shared_ptr<long> id{};

  UpdateCustomizedFilterRequest() {}

  explicit UpdateCustomizedFilterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blackWhiteType) {
      res["BlackWhiteType"] = boost::any(*blackWhiteType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    if (valueCompareType) {
      res["ValueCompareType"] = boost::any(*valueCompareType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlackWhiteType") != m.end() && !m["BlackWhiteType"].empty()) {
      blackWhiteType = make_shared<string>(boost::any_cast<string>(m["BlackWhiteType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
    if (m.find("ValueCompareType") != m.end() && !m["ValueCompareType"].empty()) {
      valueCompareType = make_shared<string>(boost::any_cast<string>(m["ValueCompareType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateCustomizedFilterRequest() = default;
};
class UpdateCustomizedFilterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCustomizedFilterResponseBody() {}

  explicit UpdateCustomizedFilterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomizedFilterResponseBody() = default;
};
class UpdateCustomizedFilterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateCustomizedFilterResponseBody> body{};

  UpdateCustomizedFilterResponse() {}

  explicit UpdateCustomizedFilterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomizedFilterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomizedFilterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomizedFilterResponse() = default;
};
class CreateVersionPrepublishRequest : public Darabonba::Model {
public:
  shared_ptr<string> isTotalPrepublish{};
  shared_ptr<string> versionId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> barrierCount{};

  CreateVersionPrepublishRequest() {}

  explicit CreateVersionPrepublishRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isTotalPrepublish) {
      res["IsTotalPrepublish"] = boost::any(*isTotalPrepublish);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (barrierCount) {
      res["BarrierCount"] = boost::any(*barrierCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsTotalPrepublish") != m.end() && !m["IsTotalPrepublish"].empty()) {
      isTotalPrepublish = make_shared<string>(boost::any_cast<string>(m["IsTotalPrepublish"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("BarrierCount") != m.end() && !m["BarrierCount"].empty()) {
      barrierCount = make_shared<string>(boost::any_cast<string>(m["BarrierCount"]));
    }
  }


  virtual ~CreateVersionPrepublishRequest() = default;
};
class CreateVersionPrepublishResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> prepublishId{};

  CreateVersionPrepublishResponseBody() {}

  explicit CreateVersionPrepublishResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (prepublishId) {
      res["PrepublishId"] = boost::any(*prepublishId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrepublishId") != m.end() && !m["PrepublishId"].empty()) {
      prepublishId = make_shared<string>(boost::any_cast<string>(m["PrepublishId"]));
    }
  }


  virtual ~CreateVersionPrepublishResponseBody() = default;
};
class CreateVersionPrepublishResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateVersionPrepublishResponseBody> body{};

  CreateVersionPrepublishResponse() {}

  explicit CreateVersionPrepublishResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVersionPrepublishResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVersionPrepublishResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVersionPrepublishResponse() = default;
};
class UpdateAppVersionRemarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> remark{};

  UpdateAppVersionRemarkRequest() {}

  explicit UpdateAppVersionRemarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~UpdateAppVersionRemarkRequest() = default;
};
class UpdateAppVersionRemarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppVersionRemarkResponseBody() {}

  explicit UpdateAppVersionRemarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppVersionRemarkResponseBody() = default;
};
class UpdateAppVersionRemarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAppVersionRemarkResponseBody> body{};

  UpdateAppVersionRemarkResponse() {}

  explicit UpdateAppVersionRemarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppVersionRemarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppVersionRemarkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppVersionRemarkResponse() = default;
};
class DescribeDeviceModelRequest : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> projectId{};

  DescribeDeviceModelRequest() {}

  explicit DescribeDeviceModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeDeviceModelRequest() = default;
};
class DescribeDeviceModelResponseBodyDeviceModel : public Darabonba::Model {
public:
  shared_ptr<long> deviceModelId{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> deviceName{};
  shared_ptr<string> deviceType{};
  shared_ptr<long> canCreateDeviceId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> osPlatform{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> securityChip{};
  shared_ptr<string> deviceLogoUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> initUsageTypeDesc{};
  shared_ptr<long> initUsageType{};
  shared_ptr<string> deviceBrand{};

  DescribeDeviceModelResponseBodyDeviceModel() {}

  explicit DescribeDeviceModelResponseBodyDeviceModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (canCreateDeviceId) {
      res["CanCreateDeviceId"] = boost::any(*canCreateDeviceId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (osPlatform) {
      res["OsPlatform"] = boost::any(*osPlatform);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (securityChip) {
      res["SecurityChip"] = boost::any(*securityChip);
    }
    if (deviceLogoUrl) {
      res["DeviceLogoUrl"] = boost::any(*deviceLogoUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (initUsageTypeDesc) {
      res["InitUsageTypeDesc"] = boost::any(*initUsageTypeDesc);
    }
    if (initUsageType) {
      res["InitUsageType"] = boost::any(*initUsageType);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("CanCreateDeviceId") != m.end() && !m["CanCreateDeviceId"].empty()) {
      canCreateDeviceId = make_shared<long>(boost::any_cast<long>(m["CanCreateDeviceId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("OsPlatform") != m.end() && !m["OsPlatform"].empty()) {
      osPlatform = make_shared<string>(boost::any_cast<string>(m["OsPlatform"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SecurityChip") != m.end() && !m["SecurityChip"].empty()) {
      securityChip = make_shared<string>(boost::any_cast<string>(m["SecurityChip"]));
    }
    if (m.find("DeviceLogoUrl") != m.end() && !m["DeviceLogoUrl"].empty()) {
      deviceLogoUrl = make_shared<string>(boost::any_cast<string>(m["DeviceLogoUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("InitUsageTypeDesc") != m.end() && !m["InitUsageTypeDesc"].empty()) {
      initUsageTypeDesc = make_shared<string>(boost::any_cast<string>(m["InitUsageTypeDesc"]));
    }
    if (m.find("InitUsageType") != m.end() && !m["InitUsageType"].empty()) {
      initUsageType = make_shared<long>(boost::any_cast<long>(m["InitUsageType"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~DescribeDeviceModelResponseBodyDeviceModel() = default;
};
class DescribeDeviceModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeviceModelResponseBodyDeviceModel> deviceModel{};
  shared_ptr<string> requestId{};

  DescribeDeviceModelResponseBody() {}

  explicit DescribeDeviceModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModel) {
      res["DeviceModel"] = deviceModel ? boost::any(deviceModel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceModel"].type()) {
        DescribeDeviceModelResponseBodyDeviceModel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceModel"]));
        deviceModel = make_shared<DescribeDeviceModelResponseBodyDeviceModel>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDeviceModelResponseBody() = default;
};
class DescribeDeviceModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceModelResponseBody> body{};

  DescribeDeviceModelResponse() {}

  explicit DescribeDeviceModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceModelResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceModelResponse() = default;
};
class ListDeviceTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListDeviceTypesRequest() {}

  explicit ListDeviceTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListDeviceTypesRequest() = default;
};
class ListDeviceTypesResponseBodyDeviceTypes : public Darabonba::Model {
public:
  shared_ptr<string> deviceType{};
  shared_ptr<string> name{};

  ListDeviceTypesResponseBodyDeviceTypes() {}

  explicit ListDeviceTypesResponseBodyDeviceTypes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceType) {
      res["DeviceType"] = boost::any(*deviceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceType") != m.end() && !m["DeviceType"].empty()) {
      deviceType = make_shared<string>(boost::any_cast<string>(m["DeviceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDeviceTypesResponseBodyDeviceTypes() = default;
};
class ListDeviceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDeviceTypesResponseBodyDeviceTypes>> deviceTypes{};

  ListDeviceTypesResponseBody() {}

  explicit ListDeviceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceTypes) {
      vector<boost::any> temp1;
      for(auto item1:*deviceTypes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceTypes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceTypes") != m.end() && !m["DeviceTypes"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceTypes"].type()) {
        vector<ListDeviceTypesResponseBodyDeviceTypes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceTypes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeviceTypesResponseBodyDeviceTypes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceTypes = make_shared<vector<ListDeviceTypesResponseBodyDeviceTypes>>(expect1);
      }
    }
  }


  virtual ~ListDeviceTypesResponseBody() = default;
};
class ListDeviceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDeviceTypesResponseBody> body{};

  ListDeviceTypesResponse() {}

  explicit ListDeviceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeviceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeviceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeviceTypesResponse() = default;
};
class GenerateSdkDownloadInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> sdks{};
  shared_ptr<string> appId{};
  shared_ptr<long> osType{};
  shared_ptr<string> pkgName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> certFileObjectKey{};

  GenerateSdkDownloadInfoRequest() {}

  explicit GenerateSdkDownloadInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sdks) {
      res["Sdks"] = boost::any(*sdks);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (certFileObjectKey) {
      res["CertFileObjectKey"] = boost::any(*certFileObjectKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sdks") != m.end() && !m["Sdks"].empty()) {
      sdks = make_shared<string>(boost::any_cast<string>(m["Sdks"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("CertFileObjectKey") != m.end() && !m["CertFileObjectKey"].empty()) {
      certFileObjectKey = make_shared<string>(boost::any_cast<string>(m["CertFileObjectKey"]));
    }
  }


  virtual ~GenerateSdkDownloadInfoRequest() = default;
};
class GenerateSdkDownloadInfoResponseBodySdkDownloadInfo : public Darabonba::Model {
public:
  shared_ptr<string> url{};

  GenerateSdkDownloadInfoResponseBodySdkDownloadInfo() {}

  explicit GenerateSdkDownloadInfoResponseBodySdkDownloadInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GenerateSdkDownloadInfoResponseBodySdkDownloadInfo() = default;
};
class GenerateSdkDownloadInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GenerateSdkDownloadInfoResponseBodySdkDownloadInfo> sdkDownloadInfo{};

  GenerateSdkDownloadInfoResponseBody() {}

  explicit GenerateSdkDownloadInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sdkDownloadInfo) {
      res["SdkDownloadInfo"] = sdkDownloadInfo ? boost::any(sdkDownloadInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SdkDownloadInfo") != m.end() && !m["SdkDownloadInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SdkDownloadInfo"].type()) {
        GenerateSdkDownloadInfoResponseBodySdkDownloadInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SdkDownloadInfo"]));
        sdkDownloadInfo = make_shared<GenerateSdkDownloadInfoResponseBodySdkDownloadInfo>(model1);
      }
    }
  }


  virtual ~GenerateSdkDownloadInfoResponseBody() = default;
};
class GenerateSdkDownloadInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateSdkDownloadInfoResponseBody> body{};

  GenerateSdkDownloadInfoResponse() {}

  explicit GenerateSdkDownloadInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateSdkDownloadInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateSdkDownloadInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateSdkDownloadInfoResponse() = default;
};
class ExecuteVehicleControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> command{};
  shared_ptr<string> commandParam{};
  shared_ptr<string> vin{};
  shared_ptr<string> projectId{};

  ExecuteVehicleControlRequest() {}

  explicit ExecuteVehicleControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (commandParam) {
      res["CommandParam"] = boost::any(*commandParam);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("CommandParam") != m.end() && !m["CommandParam"].empty()) {
      commandParam = make_shared<string>(boost::any_cast<string>(m["CommandParam"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ExecuteVehicleControlRequest() = default;
};
class ExecuteVehicleControlResponseBodyExecutionInfo : public Darabonba::Model {
public:
  shared_ptr<string> executionId{};

  ExecuteVehicleControlResponseBodyExecutionInfo() {}

  explicit ExecuteVehicleControlResponseBodyExecutionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
  }


  virtual ~ExecuteVehicleControlResponseBodyExecutionInfo() = default;
};
class ExecuteVehicleControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ExecuteVehicleControlResponseBodyExecutionInfo> executionInfo{};

  ExecuteVehicleControlResponseBody() {}

  explicit ExecuteVehicleControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (executionInfo) {
      res["ExecutionInfo"] = executionInfo ? boost::any(executionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExecutionInfo") != m.end() && !m["ExecutionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecutionInfo"].type()) {
        ExecuteVehicleControlResponseBodyExecutionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecutionInfo"]));
        executionInfo = make_shared<ExecuteVehicleControlResponseBodyExecutionInfo>(model1);
      }
    }
  }


  virtual ~ExecuteVehicleControlResponseBody() = default;
};
class ExecuteVehicleControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ExecuteVehicleControlResponseBody> body{};

  ExecuteVehicleControlResponse() {}

  explicit ExecuteVehicleControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteVehicleControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteVehicleControlResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteVehicleControlResponse() = default;
};
class DescribeApiGatewayAppSecurityRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> gatewayAppId{};

  DescribeApiGatewayAppSecurityRequest() {}

  explicit DescribeApiGatewayAppSecurityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gatewayAppId) {
      res["GatewayAppId"] = boost::any(*gatewayAppId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GatewayAppId") != m.end() && !m["GatewayAppId"].empty()) {
      gatewayAppId = make_shared<string>(boost::any_cast<string>(m["GatewayAppId"]));
    }
  }


  virtual ~DescribeApiGatewayAppSecurityRequest() = default;
};
class DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity : public Darabonba::Model {
public:
  shared_ptr<string> gatewayAppKey{};
  shared_ptr<string> gatewayAppSecret{};
  shared_ptr<string> gatewayAppId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};

  DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity() {}

  explicit DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gatewayAppKey) {
      res["GatewayAppKey"] = boost::any(*gatewayAppKey);
    }
    if (gatewayAppSecret) {
      res["GatewayAppSecret"] = boost::any(*gatewayAppSecret);
    }
    if (gatewayAppId) {
      res["GatewayAppId"] = boost::any(*gatewayAppId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GatewayAppKey") != m.end() && !m["GatewayAppKey"].empty()) {
      gatewayAppKey = make_shared<string>(boost::any_cast<string>(m["GatewayAppKey"]));
    }
    if (m.find("GatewayAppSecret") != m.end() && !m["GatewayAppSecret"].empty()) {
      gatewayAppSecret = make_shared<string>(boost::any_cast<string>(m["GatewayAppSecret"]));
    }
    if (m.find("GatewayAppId") != m.end() && !m["GatewayAppId"].empty()) {
      gatewayAppId = make_shared<string>(boost::any_cast<string>(m["GatewayAppId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
  }


  virtual ~DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity() = default;
};
class DescribeApiGatewayAppSecurityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity> apiGatewayAppSecurity{};

  DescribeApiGatewayAppSecurityResponseBody() {}

  explicit DescribeApiGatewayAppSecurityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (apiGatewayAppSecurity) {
      res["ApiGatewayAppSecurity"] = apiGatewayAppSecurity ? boost::any(apiGatewayAppSecurity->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ApiGatewayAppSecurity") != m.end() && !m["ApiGatewayAppSecurity"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiGatewayAppSecurity"].type()) {
        DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiGatewayAppSecurity"]));
        apiGatewayAppSecurity = make_shared<DescribeApiGatewayAppSecurityResponseBodyApiGatewayAppSecurity>(model1);
      }
    }
  }


  virtual ~DescribeApiGatewayAppSecurityResponseBody() = default;
};
class DescribeApiGatewayAppSecurityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiGatewayAppSecurityResponseBody> body{};

  DescribeApiGatewayAppSecurityResponse() {}

  explicit DescribeApiGatewayAppSecurityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGatewayAppSecurityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGatewayAppSecurityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGatewayAppSecurityResponse() = default;
};
class DescribeDeviceOnlineInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> type{};
  shared_ptr<string> value{};

  DescribeDeviceOnlineInfoRequest() {}

  explicit DescribeDeviceOnlineInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDeviceOnlineInfoRequest() = default;
};
class DescribeDeviceOnlineInfoResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<long> loginTime{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> online{};
  shared_ptr<string> projectId{};
  shared_ptr<string> iasId{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> terminal{};
  shared_ptr<string> clientVersion{};

  DescribeDeviceOnlineInfoResponseBodyDevices() {}

  explicit DescribeDeviceOnlineInfoResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loginTime) {
      res["LoginTime"] = boost::any(*loginTime);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (iasId) {
      res["IasId"] = boost::any(*iasId);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (terminal) {
      res["Terminal"] = boost::any(*terminal);
    }
    if (clientVersion) {
      res["ClientVersion"] = boost::any(*clientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LoginTime") != m.end() && !m["LoginTime"].empty()) {
      loginTime = make_shared<long>(boost::any_cast<long>(m["LoginTime"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<long>(boost::any_cast<long>(m["Online"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("IasId") != m.end() && !m["IasId"].empty()) {
      iasId = make_shared<string>(boost::any_cast<string>(m["IasId"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Terminal") != m.end() && !m["Terminal"].empty()) {
      terminal = make_shared<string>(boost::any_cast<string>(m["Terminal"]));
    }
    if (m.find("ClientVersion") != m.end() && !m["ClientVersion"].empty()) {
      clientVersion = make_shared<string>(boost::any_cast<string>(m["ClientVersion"]));
    }
  }


  virtual ~DescribeDeviceOnlineInfoResponseBodyDevices() = default;
};
class DescribeDeviceOnlineInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDeviceOnlineInfoResponseBodyDevices>> devices{};

  DescribeDeviceOnlineInfoResponseBody() {}

  explicit DescribeDeviceOnlineInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (devices) {
      vector<boost::any> temp1;
      for(auto item1:*devices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Devices"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(vector<boost::any>) == m["Devices"].type()) {
        vector<DescribeDeviceOnlineInfoResponseBodyDevices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Devices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceOnlineInfoResponseBodyDevices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devices = make_shared<vector<DescribeDeviceOnlineInfoResponseBodyDevices>>(expect1);
      }
    }
  }


  virtual ~DescribeDeviceOnlineInfoResponseBody() = default;
};
class DescribeDeviceOnlineInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceOnlineInfoResponseBody> body{};

  DescribeDeviceOnlineInfoResponse() {}

  explicit DescribeDeviceOnlineInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceOnlineInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceOnlineInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceOnlineInfoResponse() = default;
};
class CreateRpcServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> interfaceName{};
  shared_ptr<string> invokeType{};
  shared_ptr<string> params{};
  shared_ptr<string> groupName{};
  shared_ptr<string> methodName{};
  shared_ptr<string> versionCode{};

  CreateRpcServiceRequest() {}

  explicit CreateRpcServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (interfaceName) {
      res["InterfaceName"] = boost::any(*interfaceName);
    }
    if (invokeType) {
      res["InvokeType"] = boost::any(*invokeType);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("InterfaceName") != m.end() && !m["InterfaceName"].empty()) {
      interfaceName = make_shared<string>(boost::any_cast<string>(m["InterfaceName"]));
    }
    if (m.find("InvokeType") != m.end() && !m["InvokeType"].empty()) {
      invokeType = make_shared<string>(boost::any_cast<string>(m["InvokeType"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~CreateRpcServiceRequest() = default;
};
class CreateRpcServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> id{};

  CreateRpcServiceResponseBody() {}

  explicit CreateRpcServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~CreateRpcServiceResponseBody() = default;
};
class CreateRpcServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateRpcServiceResponseBody> body{};

  CreateRpcServiceResponse() {}

  explicit CreateRpcServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRpcServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRpcServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRpcServiceResponse() = default;
};
class DeleteVersionWhiteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIds{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};
  shared_ptr<string> deviceIdType{};

  DeleteVersionWhiteDevicesRequest() {}

  explicit DeleteVersionWhiteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
  }


  virtual ~DeleteVersionWhiteDevicesRequest() = default;
};
class DeleteVersionWhiteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionWhiteDevicesResponseBody() {}

  explicit DeleteVersionWhiteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionWhiteDevicesResponseBody() = default;
};
class DeleteVersionWhiteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionWhiteDevicesResponseBody> body{};

  DeleteVersionWhiteDevicesResponse() {}

  explicit DeleteVersionWhiteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionWhiteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionWhiteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionWhiteDevicesResponse() = default;
};
class ListProjectsResponseBodyProjects : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> creator{};

  ListProjectsResponseBodyProjects() {}

  explicit ListProjectsResponseBodyProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
  }


  virtual ~ListProjectsResponseBodyProjects() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListProjectsResponseBodyProjects>> projects{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<ListProjectsResponseBodyProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<ListProjectsResponseBodyProjects>>(expect1);
      }
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class GenerateFunctionFileUploadMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> fileName{};

  GenerateFunctionFileUploadMetaRequest() {}

  explicit GenerateFunctionFileUploadMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~GenerateFunctionFileUploadMetaRequest() = default;
};
class GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy : public Darabonba::Model {
public:
  shared_ptr<string> signature{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> expire{};
  shared_ptr<string> accessId{};

  GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy() {}

  explicit GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<string>(boost::any_cast<string>(m["Expire"]));
    }
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
  }


  virtual ~GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy() = default;
};
class GenerateFunctionFileUploadMetaResponseBodyUploadMeta : public Darabonba::Model {
public:
  shared_ptr<GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy> postObjectPolicy{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> objectKey{};

  GenerateFunctionFileUploadMetaResponseBodyUploadMeta() {}

  explicit GenerateFunctionFileUploadMetaResponseBodyUploadMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (postObjectPolicy) {
      res["PostObjectPolicy"] = postObjectPolicy ? boost::any(postObjectPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PostObjectPolicy") != m.end() && !m["PostObjectPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["PostObjectPolicy"].type()) {
        GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PostObjectPolicy"]));
        postObjectPolicy = make_shared<GenerateFunctionFileUploadMetaResponseBodyUploadMetaPostObjectPolicy>(model1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
  }


  virtual ~GenerateFunctionFileUploadMetaResponseBodyUploadMeta() = default;
};
class GenerateFunctionFileUploadMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GenerateFunctionFileUploadMetaResponseBodyUploadMeta> uploadMeta{};

  GenerateFunctionFileUploadMetaResponseBody() {}

  explicit GenerateFunctionFileUploadMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (uploadMeta) {
      res["UploadMeta"] = uploadMeta ? boost::any(uploadMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UploadMeta") != m.end() && !m["UploadMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["UploadMeta"].type()) {
        GenerateFunctionFileUploadMetaResponseBodyUploadMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UploadMeta"]));
        uploadMeta = make_shared<GenerateFunctionFileUploadMetaResponseBodyUploadMeta>(model1);
      }
    }
  }


  virtual ~GenerateFunctionFileUploadMetaResponseBody() = default;
};
class GenerateFunctionFileUploadMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GenerateFunctionFileUploadMetaResponseBody> body{};

  GenerateFunctionFileUploadMetaResponse() {}

  explicit GenerateFunctionFileUploadMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateFunctionFileUploadMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateFunctionFileUploadMetaResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateFunctionFileUploadMetaResponse() = default;
};
class DescribeProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  DescribeProjectRequest() {}

  explicit DescribeProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeProjectRequest() = default;
};
class DescribeProjectResponseBodyProject : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<string> description{};
  shared_ptr<string> userId{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> creator{};
  shared_ptr<string> vehicleCommunicationProtocol{};

  DescribeProjectResponseBodyProject() {}

  explicit DescribeProjectResponseBodyProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (vehicleCommunicationProtocol) {
      res["VehicleCommunicationProtocol"] = boost::any(*vehicleCommunicationProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("VehicleCommunicationProtocol") != m.end() && !m["VehicleCommunicationProtocol"].empty()) {
      vehicleCommunicationProtocol = make_shared<string>(boost::any_cast<string>(m["VehicleCommunicationProtocol"]));
    }
  }


  virtual ~DescribeProjectResponseBodyProject() = default;
};
class DescribeProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyProject> project{};
  shared_ptr<string> requestId{};

  DescribeProjectResponseBody() {}

  explicit DescribeProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        DescribeProjectResponseBodyProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<DescribeProjectResponseBodyProject>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeProjectResponseBody() = default;
};
class DescribeProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeProjectResponseBody> body{};

  DescribeProjectResponse() {}

  explicit DescribeProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectResponse() = default;
};
class DescribeMqttMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> mid{};
  shared_ptr<string> projectId{};

  DescribeMqttMessageRequest() {}

  explicit DescribeMqttMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeMqttMessageRequest() = default;
};
class DescribeMqttMessageResponseBodyMessage : public Darabonba::Model {
public:
  shared_ptr<long> time{};
  shared_ptr<string> appKey{};
  shared_ptr<string> mid{};
  shared_ptr<string> topic{};
  shared_ptr<string> payload{};
  shared_ptr<long> qoS{};

  DescribeMqttMessageResponseBodyMessage() {}

  explicit DescribeMqttMessageResponseBodyMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (payload) {
      res["Payload"] = boost::any(*payload);
    }
    if (qoS) {
      res["QoS"] = boost::any(*qoS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<string>(boost::any_cast<string>(m["Mid"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Payload") != m.end() && !m["Payload"].empty()) {
      payload = make_shared<string>(boost::any_cast<string>(m["Payload"]));
    }
    if (m.find("QoS") != m.end() && !m["QoS"].empty()) {
      qoS = make_shared<long>(boost::any_cast<long>(m["QoS"]));
    }
  }


  virtual ~DescribeMqttMessageResponseBodyMessage() = default;
};
class DescribeMqttMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMqttMessageResponseBodyMessage> message{};

  DescribeMqttMessageResponseBody() {}

  explicit DescribeMqttMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = message ? boost::any(message->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      if (typeid(map<string, boost::any>) == m["Message"].type()) {
        DescribeMqttMessageResponseBodyMessage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Message"]));
        message = make_shared<DescribeMqttMessageResponseBodyMessage>(model1);
      }
    }
  }


  virtual ~DescribeMqttMessageResponseBody() = default;
};
class DescribeMqttMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMqttMessageResponseBody> body{};

  DescribeMqttMessageResponse() {}

  explicit DescribeMqttMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMqttMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMqttMessageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMqttMessageResponse() = default;
};
class ListCameraShootingRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> edgeDeviceId{};
  shared_ptr<long> shootingType{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListCameraShootingRecordsRequest() {}

  explicit ListCameraShootingRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (edgeDeviceId) {
      res["EdgeDeviceId"] = boost::any(*edgeDeviceId);
    }
    if (shootingType) {
      res["ShootingType"] = boost::any(*shootingType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("EdgeDeviceId") != m.end() && !m["EdgeDeviceId"].empty()) {
      edgeDeviceId = make_shared<string>(boost::any_cast<string>(m["EdgeDeviceId"]));
    }
    if (m.find("ShootingType") != m.end() && !m["ShootingType"].empty()) {
      shootingType = make_shared<long>(boost::any_cast<long>(m["ShootingType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCameraShootingRecordsRequest() = default;
};
class ListCameraShootingRecordsResponseBodyShootingRecordsPagination : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListCameraShootingRecordsResponseBodyShootingRecordsPagination() {}

  explicit ListCameraShootingRecordsResponseBodyShootingRecordsPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCameraShootingRecordsResponseBodyShootingRecordsPagination() = default;
};
class ListCameraShootingRecordsResponseBodyShootingRecordsList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> shootingType{};
  shared_ptr<long> number{};
  shared_ptr<long> time{};
  shared_ptr<long> recordTime{};
  shared_ptr<long> status{};

  ListCameraShootingRecordsResponseBodyShootingRecordsList() {}

  explicit ListCameraShootingRecordsResponseBodyShootingRecordsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (shootingType) {
      res["ShootingType"] = boost::any(*shootingType);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    if (recordTime) {
      res["RecordTime"] = boost::any(*recordTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ShootingType") != m.end() && !m["ShootingType"].empty()) {
      shootingType = make_shared<long>(boost::any_cast<long>(m["ShootingType"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
    if (m.find("RecordTime") != m.end() && !m["RecordTime"].empty()) {
      recordTime = make_shared<long>(boost::any_cast<long>(m["RecordTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
  }


  virtual ~ListCameraShootingRecordsResponseBodyShootingRecordsList() = default;
};
class ListCameraShootingRecordsResponseBodyShootingRecords : public Darabonba::Model {
public:
  shared_ptr<ListCameraShootingRecordsResponseBodyShootingRecordsPagination> pagination{};
  shared_ptr<vector<ListCameraShootingRecordsResponseBodyShootingRecordsList>> list{};

  ListCameraShootingRecordsResponseBodyShootingRecords() {}

  explicit ListCameraShootingRecordsResponseBodyShootingRecords(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListCameraShootingRecordsResponseBodyShootingRecordsPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListCameraShootingRecordsResponseBodyShootingRecordsPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCameraShootingRecordsResponseBodyShootingRecordsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCameraShootingRecordsResponseBodyShootingRecordsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCameraShootingRecordsResponseBodyShootingRecordsList>>(expect1);
      }
    }
  }


  virtual ~ListCameraShootingRecordsResponseBodyShootingRecords() = default;
};
class ListCameraShootingRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListCameraShootingRecordsResponseBodyShootingRecords> shootingRecords{};

  ListCameraShootingRecordsResponseBody() {}

  explicit ListCameraShootingRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (shootingRecords) {
      res["ShootingRecords"] = shootingRecords ? boost::any(shootingRecords->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ShootingRecords") != m.end() && !m["ShootingRecords"].empty()) {
      if (typeid(map<string, boost::any>) == m["ShootingRecords"].type()) {
        ListCameraShootingRecordsResponseBodyShootingRecords model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ShootingRecords"]));
        shootingRecords = make_shared<ListCameraShootingRecordsResponseBodyShootingRecords>(model1);
      }
    }
  }


  virtual ~ListCameraShootingRecordsResponseBody() = default;
};
class ListCameraShootingRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListCameraShootingRecordsResponseBody> body{};

  ListCameraShootingRecordsResponse() {}

  explicit ListCameraShootingRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCameraShootingRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCameraShootingRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCameraShootingRecordsResponse() = default;
};
class DeleteVersionBlackDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceIds{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};
  shared_ptr<string> deviceIdType{};

  DeleteVersionBlackDevicesRequest() {}

  explicit DeleteVersionBlackDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceIds) {
      res["DeviceIds"] = boost::any(*deviceIds);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (deviceIdType) {
      res["DeviceIdType"] = boost::any(*deviceIdType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceIds") != m.end() && !m["DeviceIds"].empty()) {
      deviceIds = make_shared<string>(boost::any_cast<string>(m["DeviceIds"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("DeviceIdType") != m.end() && !m["DeviceIdType"].empty()) {
      deviceIdType = make_shared<string>(boost::any_cast<string>(m["DeviceIdType"]));
    }
  }


  virtual ~DeleteVersionBlackDevicesRequest() = default;
};
class DeleteVersionBlackDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionBlackDevicesResponseBody() {}

  explicit DeleteVersionBlackDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionBlackDevicesResponseBody() = default;
};
class DeleteVersionBlackDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionBlackDevicesResponseBody> body{};

  DeleteVersionBlackDevicesResponse() {}

  explicit DeleteVersionBlackDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionBlackDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionBlackDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionBlackDevicesResponse() = default;
};
class DescribeOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> versionId{};

  DescribeOsVersionRequest() {}

  explicit DescribeOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
  }


  virtual ~DescribeOsVersionRequest() = default;
};
class DescribeOsVersionResponseBodyOsVersionRomList : public Darabonba::Model {
public:
  shared_ptr<string> gmtModify{};
  shared_ptr<string> splitNum{};
  shared_ptr<string> downloadUrl{};
  shared_ptr<string> size{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<long> versionId{};
  shared_ptr<string> md5{};
  shared_ptr<string> baseVersion{};
  shared_ptr<long> id{};
  shared_ptr<string> originalUrl{};

  DescribeOsVersionResponseBodyOsVersionRomList() {}

  explicit DescribeOsVersionResponseBodyOsVersionRomList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (splitNum) {
      res["SplitNum"] = boost::any(*splitNum);
    }
    if (downloadUrl) {
      res["DownloadUrl"] = boost::any(*downloadUrl);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (md5) {
      res["Md5"] = boost::any(*md5);
    }
    if (baseVersion) {
      res["BaseVersion"] = boost::any(*baseVersion);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (originalUrl) {
      res["OriginalUrl"] = boost::any(*originalUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("SplitNum") != m.end() && !m["SplitNum"].empty()) {
      splitNum = make_shared<string>(boost::any_cast<string>(m["SplitNum"]));
    }
    if (m.find("DownloadUrl") != m.end() && !m["DownloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["DownloadUrl"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<string>(boost::any_cast<string>(m["Size"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
    if (m.find("Md5") != m.end() && !m["Md5"].empty()) {
      md5 = make_shared<string>(boost::any_cast<string>(m["Md5"]));
    }
    if (m.find("BaseVersion") != m.end() && !m["BaseVersion"].empty()) {
      baseVersion = make_shared<string>(boost::any_cast<string>(m["BaseVersion"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OriginalUrl") != m.end() && !m["OriginalUrl"].empty()) {
      originalUrl = make_shared<string>(boost::any_cast<string>(m["OriginalUrl"]));
    }
  }


  virtual ~DescribeOsVersionResponseBodyOsVersionRomList() = default;
};
class DescribeOsVersionResponseBodyOsVersionNightUpgradeOption : public Darabonba::Model {
public:
  shared_ptr<string> downloadType{};
  shared_ptr<string> isAllowedCancel{};
  shared_ptr<string> isShowTip{};

  DescribeOsVersionResponseBodyOsVersionNightUpgradeOption() {}

  explicit DescribeOsVersionResponseBodyOsVersionNightUpgradeOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadType) {
      res["DownloadType"] = boost::any(*downloadType);
    }
    if (isAllowedCancel) {
      res["IsAllowedCancel"] = boost::any(*isAllowedCancel);
    }
    if (isShowTip) {
      res["IsShowTip"] = boost::any(*isShowTip);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadType") != m.end() && !m["DownloadType"].empty()) {
      downloadType = make_shared<string>(boost::any_cast<string>(m["DownloadType"]));
    }
    if (m.find("IsAllowedCancel") != m.end() && !m["IsAllowedCancel"].empty()) {
      isAllowedCancel = make_shared<string>(boost::any_cast<string>(m["IsAllowedCancel"]));
    }
    if (m.find("IsShowTip") != m.end() && !m["IsShowTip"].empty()) {
      isShowTip = make_shared<string>(boost::any_cast<string>(m["IsShowTip"]));
    }
  }


  virtual ~DescribeOsVersionResponseBodyOsVersionNightUpgradeOption() = default;
};
class DescribeOsVersionResponseBodyOsVersion : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> isMilestone{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> statusName{};
  shared_ptr<string> deviceModelName{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> maxClientVersion{};
  shared_ptr<vector<DescribeOsVersionResponseBodyOsVersionRomList>> romList{};
  shared_ptr<string> minClientVersion{};
  shared_ptr<DescribeOsVersionResponseBodyOsVersionNightUpgradeOption> nightUpgradeOption{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> isForceNightUpgrade{};
  shared_ptr<string> mobileDownloadMaxSize{};
  shared_ptr<string> enableMobileDownload{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<long> id{};

  DescribeOsVersionResponseBodyOsVersion() {}

  explicit DescribeOsVersionResponseBodyOsVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (isMilestone) {
      res["IsMilestone"] = boost::any(*isMilestone);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (deviceModelName) {
      res["DeviceModelName"] = boost::any(*deviceModelName);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (maxClientVersion) {
      res["MaxClientVersion"] = boost::any(*maxClientVersion);
    }
    if (romList) {
      vector<boost::any> temp1;
      for(auto item1:*romList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RomList"] = boost::any(temp1);
    }
    if (minClientVersion) {
      res["MinClientVersion"] = boost::any(*minClientVersion);
    }
    if (nightUpgradeOption) {
      res["NightUpgradeOption"] = nightUpgradeOption ? boost::any(nightUpgradeOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isForceNightUpgrade) {
      res["IsForceNightUpgrade"] = boost::any(*isForceNightUpgrade);
    }
    if (mobileDownloadMaxSize) {
      res["MobileDownloadMaxSize"] = boost::any(*mobileDownloadMaxSize);
    }
    if (enableMobileDownload) {
      res["EnableMobileDownload"] = boost::any(*enableMobileDownload);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("IsMilestone") != m.end() && !m["IsMilestone"].empty()) {
      isMilestone = make_shared<string>(boost::any_cast<string>(m["IsMilestone"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("DeviceModelName") != m.end() && !m["DeviceModelName"].empty()) {
      deviceModelName = make_shared<string>(boost::any_cast<string>(m["DeviceModelName"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("MaxClientVersion") != m.end() && !m["MaxClientVersion"].empty()) {
      maxClientVersion = make_shared<string>(boost::any_cast<string>(m["MaxClientVersion"]));
    }
    if (m.find("RomList") != m.end() && !m["RomList"].empty()) {
      if (typeid(vector<boost::any>) == m["RomList"].type()) {
        vector<DescribeOsVersionResponseBodyOsVersionRomList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RomList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOsVersionResponseBodyOsVersionRomList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        romList = make_shared<vector<DescribeOsVersionResponseBodyOsVersionRomList>>(expect1);
      }
    }
    if (m.find("MinClientVersion") != m.end() && !m["MinClientVersion"].empty()) {
      minClientVersion = make_shared<string>(boost::any_cast<string>(m["MinClientVersion"]));
    }
    if (m.find("NightUpgradeOption") != m.end() && !m["NightUpgradeOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["NightUpgradeOption"].type()) {
        DescribeOsVersionResponseBodyOsVersionNightUpgradeOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NightUpgradeOption"]));
        nightUpgradeOption = make_shared<DescribeOsVersionResponseBodyOsVersionNightUpgradeOption>(model1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IsForceNightUpgrade") != m.end() && !m["IsForceNightUpgrade"].empty()) {
      isForceNightUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceNightUpgrade"]));
    }
    if (m.find("MobileDownloadMaxSize") != m.end() && !m["MobileDownloadMaxSize"].empty()) {
      mobileDownloadMaxSize = make_shared<string>(boost::any_cast<string>(m["MobileDownloadMaxSize"]));
    }
    if (m.find("EnableMobileDownload") != m.end() && !m["EnableMobileDownload"].empty()) {
      enableMobileDownload = make_shared<string>(boost::any_cast<string>(m["EnableMobileDownload"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~DescribeOsVersionResponseBodyOsVersion() = default;
};
class DescribeOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOsVersionResponseBodyOsVersion> osVersion{};

  DescribeOsVersionResponseBody() {}

  explicit DescribeOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (osVersion) {
      res["OsVersion"] = osVersion ? boost::any(osVersion->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OsVersion") != m.end() && !m["OsVersion"].empty()) {
      if (typeid(map<string, boost::any>) == m["OsVersion"].type()) {
        DescribeOsVersionResponseBodyOsVersion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OsVersion"]));
        osVersion = make_shared<DescribeOsVersionResponseBodyOsVersion>(model1);
      }
    }
  }


  virtual ~DescribeOsVersionResponseBody() = default;
};
class DescribeOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeOsVersionResponseBody> body{};

  DescribeOsVersionResponse() {}

  explicit DescribeOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOsVersionResponse() = default;
};
class ListRpcServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListRpcServicesRequest() {}

  explicit ListRpcServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRpcServicesRequest() = default;
};
class ListRpcServicesResponseBodyRpcServicesPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRpcServicesResponseBodyRpcServicesPagination() {}

  explicit ListRpcServicesResponseBodyRpcServicesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRpcServicesResponseBodyRpcServicesPagination() = default;
};
class ListRpcServicesResponseBodyRpcServicesList : public Darabonba::Model {
public:
  shared_ptr<string> methodName{};
  shared_ptr<string> type{};
  shared_ptr<string> interfaceName{};
  shared_ptr<string> params{};
  shared_ptr<string> appKey{};
  shared_ptr<string> groupName{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> isDelete{};
  shared_ptr<string> versionCode{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};

  ListRpcServicesResponseBodyRpcServicesList() {}

  explicit ListRpcServicesResponseBodyRpcServicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (interfaceName) {
      res["InterfaceName"] = boost::any(*interfaceName);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("InterfaceName") != m.end() && !m["InterfaceName"].empty()) {
      interfaceName = make_shared<string>(boost::any_cast<string>(m["InterfaceName"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      params = make_shared<string>(boost::any_cast<string>(m["Params"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<string>(boost::any_cast<string>(m["IsDelete"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListRpcServicesResponseBodyRpcServicesList() = default;
};
class ListRpcServicesResponseBodyRpcServices : public Darabonba::Model {
public:
  shared_ptr<ListRpcServicesResponseBodyRpcServicesPagination> pagination{};
  shared_ptr<vector<ListRpcServicesResponseBodyRpcServicesList>> list{};

  ListRpcServicesResponseBodyRpcServices() {}

  explicit ListRpcServicesResponseBodyRpcServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListRpcServicesResponseBodyRpcServicesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListRpcServicesResponseBodyRpcServicesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRpcServicesResponseBodyRpcServicesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRpcServicesResponseBodyRpcServicesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRpcServicesResponseBodyRpcServicesList>>(expect1);
      }
    }
  }


  virtual ~ListRpcServicesResponseBodyRpcServices() = default;
};
class ListRpcServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListRpcServicesResponseBodyRpcServices> rpcServices{};

  ListRpcServicesResponseBody() {}

  explicit ListRpcServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rpcServices) {
      res["RpcServices"] = rpcServices ? boost::any(rpcServices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RpcServices") != m.end() && !m["RpcServices"].empty()) {
      if (typeid(map<string, boost::any>) == m["RpcServices"].type()) {
        ListRpcServicesResponseBodyRpcServices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RpcServices"]));
        rpcServices = make_shared<ListRpcServicesResponseBodyRpcServices>(model1);
      }
    }
  }


  virtual ~ListRpcServicesResponseBody() = default;
};
class ListRpcServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListRpcServicesResponseBody> body{};

  ListRpcServicesResponse() {}

  explicit ListRpcServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRpcServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRpcServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRpcServicesResponse() = default;
};
class DeleteSchemaSubscribeRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectId{};

  DeleteSchemaSubscribeRequest() {}

  explicit DeleteSchemaSubscribeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteSchemaSubscribeRequest() = default;
};
class DeleteSchemaSubscribeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSchemaSubscribeResponseBody() {}

  explicit DeleteSchemaSubscribeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSchemaSubscribeResponseBody() = default;
};
class DeleteSchemaSubscribeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSchemaSubscribeResponseBody> body{};

  DeleteSchemaSubscribeResponse() {}

  explicit DeleteSchemaSubscribeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSchemaSubscribeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSchemaSubscribeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSchemaSubscribeResponse() = default;
};
class AddUploadedFunctionFileInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> objectKey{};
  shared_ptr<string> fileName{};

  AddUploadedFunctionFileInfoRequest() {}

  explicit AddUploadedFunctionFileInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~AddUploadedFunctionFileInfoRequest() = default;
};
class AddUploadedFunctionFileInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUploadedFunctionFileInfoResponseBody() {}

  explicit AddUploadedFunctionFileInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUploadedFunctionFileInfoResponseBody() = default;
};
class AddUploadedFunctionFileInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddUploadedFunctionFileInfoResponseBody> body{};

  AddUploadedFunctionFileInfoResponse() {}

  explicit AddUploadedFunctionFileInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUploadedFunctionFileInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUploadedFunctionFileInfoResponseBody>(model1);
      }
    }
  }


  virtual ~AddUploadedFunctionFileInfoResponse() = default;
};
class CreateProjectAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> appName{};
  shared_ptr<string> appPkgName{};
  shared_ptr<long> osType{};

  CreateProjectAppRequest() {}

  explicit CreateProjectAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appPkgName) {
      res["AppPkgName"] = boost::any(*appPkgName);
    }
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppPkgName") != m.end() && !m["AppPkgName"].empty()) {
      appPkgName = make_shared<string>(boost::any_cast<string>(m["AppPkgName"]));
    }
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
  }


  virtual ~CreateProjectAppRequest() = default;
};
class CreateProjectAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateProjectAppResponseBody() {}

  explicit CreateProjectAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectAppResponseBody() = default;
};
class CreateProjectAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateProjectAppResponseBody> body{};

  CreateProjectAppResponse() {}

  explicit CreateProjectAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectAppResponse() = default;
};
class ListServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> serviceList{};

  ListServicesResponseBody() {}

  explicit ListServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceList) {
      res["ServiceList"] = boost::any(*serviceList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceList") != m.end() && !m["ServiceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ServiceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ServiceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      serviceList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListServicesResponseBody() = default;
};
class ListServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListServicesResponseBody> body{};

  ListServicesResponse() {}

  explicit ListServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListServicesResponse() = default;
};
class FindOsVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> versionId{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> isMilestone{};
  shared_ptr<string> remark{};

  FindOsVersionsRequest() {}

  explicit FindOsVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (isMilestone) {
      res["IsMilestone"] = boost::any(*isMilestone);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("IsMilestone") != m.end() && !m["IsMilestone"].empty()) {
      isMilestone = make_shared<string>(boost::any_cast<string>(m["IsMilestone"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~FindOsVersionsRequest() = default;
};
class FindOsVersionsResponseBodyOsVersionListItems : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> isMilestone{};
  shared_ptr<string> remark{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> statusName{};
  shared_ptr<string> isForceReboot{};
  shared_ptr<string> deviceModelName{};
  shared_ptr<string> isSilentUpgrade{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> isForceNightUpgrade{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<long> id{};

  FindOsVersionsResponseBodyOsVersionListItems() {}

  explicit FindOsVersionsResponseBodyOsVersionListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (isMilestone) {
      res["IsMilestone"] = boost::any(*isMilestone);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (statusName) {
      res["StatusName"] = boost::any(*statusName);
    }
    if (isForceReboot) {
      res["IsForceReboot"] = boost::any(*isForceReboot);
    }
    if (deviceModelName) {
      res["DeviceModelName"] = boost::any(*deviceModelName);
    }
    if (isSilentUpgrade) {
      res["IsSilentUpgrade"] = boost::any(*isSilentUpgrade);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (isForceNightUpgrade) {
      res["IsForceNightUpgrade"] = boost::any(*isForceNightUpgrade);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("IsMilestone") != m.end() && !m["IsMilestone"].empty()) {
      isMilestone = make_shared<string>(boost::any_cast<string>(m["IsMilestone"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("StatusName") != m.end() && !m["StatusName"].empty()) {
      statusName = make_shared<string>(boost::any_cast<string>(m["StatusName"]));
    }
    if (m.find("IsForceReboot") != m.end() && !m["IsForceReboot"].empty()) {
      isForceReboot = make_shared<string>(boost::any_cast<string>(m["IsForceReboot"]));
    }
    if (m.find("DeviceModelName") != m.end() && !m["DeviceModelName"].empty()) {
      deviceModelName = make_shared<string>(boost::any_cast<string>(m["DeviceModelName"]));
    }
    if (m.find("IsSilentUpgrade") != m.end() && !m["IsSilentUpgrade"].empty()) {
      isSilentUpgrade = make_shared<string>(boost::any_cast<string>(m["IsSilentUpgrade"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("IsForceNightUpgrade") != m.end() && !m["IsForceNightUpgrade"].empty()) {
      isForceNightUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceNightUpgrade"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindOsVersionsResponseBodyOsVersionListItems() = default;
};
class FindOsVersionsResponseBodyOsVersionList : public Darabonba::Model {
public:
  shared_ptr<vector<FindOsVersionsResponseBodyOsVersionListItems>> items{};
  shared_ptr<long> totalCount{};

  FindOsVersionsResponseBodyOsVersionList() {}

  explicit FindOsVersionsResponseBodyOsVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindOsVersionsResponseBodyOsVersionListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindOsVersionsResponseBodyOsVersionListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindOsVersionsResponseBodyOsVersionListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindOsVersionsResponseBodyOsVersionList() = default;
};
class FindOsVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindOsVersionsResponseBodyOsVersionList> osVersionList{};

  FindOsVersionsResponseBody() {}

  explicit FindOsVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (osVersionList) {
      res["OsVersionList"] = osVersionList ? boost::any(osVersionList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OsVersionList") != m.end() && !m["OsVersionList"].empty()) {
      if (typeid(map<string, boost::any>) == m["OsVersionList"].type()) {
        FindOsVersionsResponseBodyOsVersionList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OsVersionList"]));
        osVersionList = make_shared<FindOsVersionsResponseBodyOsVersionList>(model1);
      }
    }
  }


  virtual ~FindOsVersionsResponseBody() = default;
};
class FindOsVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindOsVersionsResponseBody> body{};

  FindOsVersionsResponse() {}

  explicit FindOsVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindOsVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindOsVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~FindOsVersionsResponse() = default;
};
class UpdateVersionPrepublishActiveStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> prepublishId{};
  shared_ptr<string> isActive{};

  UpdateVersionPrepublishActiveStatusRequest() {}

  explicit UpdateVersionPrepublishActiveStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (prepublishId) {
      res["PrepublishId"] = boost::any(*prepublishId);
    }
    if (isActive) {
      res["IsActive"] = boost::any(*isActive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PrepublishId") != m.end() && !m["PrepublishId"].empty()) {
      prepublishId = make_shared<string>(boost::any_cast<string>(m["PrepublishId"]));
    }
    if (m.find("IsActive") != m.end() && !m["IsActive"].empty()) {
      isActive = make_shared<string>(boost::any_cast<string>(m["IsActive"]));
    }
  }


  virtual ~UpdateVersionPrepublishActiveStatusRequest() = default;
};
class UpdateVersionPrepublishActiveStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateVersionPrepublishActiveStatusResponseBody() {}

  explicit UpdateVersionPrepublishActiveStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateVersionPrepublishActiveStatusResponseBody() = default;
};
class UpdateVersionPrepublishActiveStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateVersionPrepublishActiveStatusResponseBody> body{};

  UpdateVersionPrepublishActiveStatusResponse() {}

  explicit UpdateVersionPrepublishActiveStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateVersionPrepublishActiveStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateVersionPrepublishActiveStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateVersionPrepublishActiveStatusResponse() = default;
};
class CreateOsVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> isForceNightUpgrade{};
  shared_ptr<string> maxClientVersion{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> systemVersion{};
  shared_ptr<string> releaseNote{};
  shared_ptr<string> remark{};
  shared_ptr<string> blackVersionList{};
  shared_ptr<string> isMilestone{};
  shared_ptr<string> minClientVersion{};
  shared_ptr<string> whiteVersionList{};
  shared_ptr<string> isForceUpgrade{};
  shared_ptr<string> nightUpgradeDownloadType{};
  shared_ptr<string> nightUpgradeIsShowTip{};
  shared_ptr<string> nightUpgradeIsAllowedCancel{};
  shared_ptr<string> romList{};
  shared_ptr<string> enableMobileDownload{};
  shared_ptr<string> mobileDownloadMaxSize{};

  CreateOsVersionRequest() {}

  explicit CreateOsVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isForceNightUpgrade) {
      res["IsForceNightUpgrade"] = boost::any(*isForceNightUpgrade);
    }
    if (maxClientVersion) {
      res["MaxClientVersion"] = boost::any(*maxClientVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (systemVersion) {
      res["SystemVersion"] = boost::any(*systemVersion);
    }
    if (releaseNote) {
      res["ReleaseNote"] = boost::any(*releaseNote);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (blackVersionList) {
      res["BlackVersionList"] = boost::any(*blackVersionList);
    }
    if (isMilestone) {
      res["IsMilestone"] = boost::any(*isMilestone);
    }
    if (minClientVersion) {
      res["MinClientVersion"] = boost::any(*minClientVersion);
    }
    if (whiteVersionList) {
      res["WhiteVersionList"] = boost::any(*whiteVersionList);
    }
    if (isForceUpgrade) {
      res["IsForceUpgrade"] = boost::any(*isForceUpgrade);
    }
    if (nightUpgradeDownloadType) {
      res["NightUpgradeDownloadType"] = boost::any(*nightUpgradeDownloadType);
    }
    if (nightUpgradeIsShowTip) {
      res["NightUpgradeIsShowTip"] = boost::any(*nightUpgradeIsShowTip);
    }
    if (nightUpgradeIsAllowedCancel) {
      res["NightUpgradeIsAllowedCancel"] = boost::any(*nightUpgradeIsAllowedCancel);
    }
    if (romList) {
      res["RomList"] = boost::any(*romList);
    }
    if (enableMobileDownload) {
      res["EnableMobileDownload"] = boost::any(*enableMobileDownload);
    }
    if (mobileDownloadMaxSize) {
      res["MobileDownloadMaxSize"] = boost::any(*mobileDownloadMaxSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsForceNightUpgrade") != m.end() && !m["IsForceNightUpgrade"].empty()) {
      isForceNightUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceNightUpgrade"]));
    }
    if (m.find("MaxClientVersion") != m.end() && !m["MaxClientVersion"].empty()) {
      maxClientVersion = make_shared<string>(boost::any_cast<string>(m["MaxClientVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("SystemVersion") != m.end() && !m["SystemVersion"].empty()) {
      systemVersion = make_shared<string>(boost::any_cast<string>(m["SystemVersion"]));
    }
    if (m.find("ReleaseNote") != m.end() && !m["ReleaseNote"].empty()) {
      releaseNote = make_shared<string>(boost::any_cast<string>(m["ReleaseNote"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("BlackVersionList") != m.end() && !m["BlackVersionList"].empty()) {
      blackVersionList = make_shared<string>(boost::any_cast<string>(m["BlackVersionList"]));
    }
    if (m.find("IsMilestone") != m.end() && !m["IsMilestone"].empty()) {
      isMilestone = make_shared<string>(boost::any_cast<string>(m["IsMilestone"]));
    }
    if (m.find("MinClientVersion") != m.end() && !m["MinClientVersion"].empty()) {
      minClientVersion = make_shared<string>(boost::any_cast<string>(m["MinClientVersion"]));
    }
    if (m.find("WhiteVersionList") != m.end() && !m["WhiteVersionList"].empty()) {
      whiteVersionList = make_shared<string>(boost::any_cast<string>(m["WhiteVersionList"]));
    }
    if (m.find("IsForceUpgrade") != m.end() && !m["IsForceUpgrade"].empty()) {
      isForceUpgrade = make_shared<string>(boost::any_cast<string>(m["IsForceUpgrade"]));
    }
    if (m.find("NightUpgradeDownloadType") != m.end() && !m["NightUpgradeDownloadType"].empty()) {
      nightUpgradeDownloadType = make_shared<string>(boost::any_cast<string>(m["NightUpgradeDownloadType"]));
    }
    if (m.find("NightUpgradeIsShowTip") != m.end() && !m["NightUpgradeIsShowTip"].empty()) {
      nightUpgradeIsShowTip = make_shared<string>(boost::any_cast<string>(m["NightUpgradeIsShowTip"]));
    }
    if (m.find("NightUpgradeIsAllowedCancel") != m.end() && !m["NightUpgradeIsAllowedCancel"].empty()) {
      nightUpgradeIsAllowedCancel = make_shared<string>(boost::any_cast<string>(m["NightUpgradeIsAllowedCancel"]));
    }
    if (m.find("RomList") != m.end() && !m["RomList"].empty()) {
      romList = make_shared<string>(boost::any_cast<string>(m["RomList"]));
    }
    if (m.find("EnableMobileDownload") != m.end() && !m["EnableMobileDownload"].empty()) {
      enableMobileDownload = make_shared<string>(boost::any_cast<string>(m["EnableMobileDownload"]));
    }
    if (m.find("MobileDownloadMaxSize") != m.end() && !m["MobileDownloadMaxSize"].empty()) {
      mobileDownloadMaxSize = make_shared<string>(boost::any_cast<string>(m["MobileDownloadMaxSize"]));
    }
  }


  virtual ~CreateOsVersionRequest() = default;
};
class CreateOsVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> versionId{};
  shared_ptr<string> requestId{};

  CreateOsVersionResponseBody() {}

  explicit CreateOsVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOsVersionResponseBody() = default;
};
class CreateOsVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateOsVersionResponseBody> body{};

  CreateOsVersionResponse() {}

  explicit CreateOsVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOsVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOsVersionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOsVersionResponse() = default;
};
class CountDeviceBrandsRequest : public Darabonba::Model {
public:
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> projectId{};

  CountDeviceBrandsRequest() {}

  explicit CountDeviceBrandsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CountDeviceBrandsRequest() = default;
};
class CountDeviceBrandsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> brandCount{};

  CountDeviceBrandsResponseBody() {}

  explicit CountDeviceBrandsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (brandCount) {
      res["BrandCount"] = boost::any(*brandCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BrandCount") != m.end() && !m["BrandCount"].empty()) {
      brandCount = make_shared<long>(boost::any_cast<long>(m["BrandCount"]));
    }
  }


  virtual ~CountDeviceBrandsResponseBody() = default;
};
class CountDeviceBrandsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountDeviceBrandsResponseBody> body{};

  CountDeviceBrandsResponse() {}

  explicit CountDeviceBrandsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountDeviceBrandsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountDeviceBrandsResponseBody>(model1);
      }
    }
  }


  virtual ~CountDeviceBrandsResponse() = default;
};
class DescribeDeviceBrandRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> deviceBrand{};
  shared_ptr<string> start{};
  shared_ptr<string> length{};

  DescribeDeviceBrandRequest() {}

  explicit DescribeDeviceBrandRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<string>(boost::any_cast<string>(m["Length"]));
    }
  }


  virtual ~DescribeDeviceBrandRequest() = default;
};
class DescribeDeviceBrandResponseBodyDeviceBrand : public Darabonba::Model {
public:
  shared_ptr<long> deviceBrandId{};
  shared_ptr<string> description{};
  shared_ptr<string> projectId{};
  shared_ptr<string> manufacture{};
  shared_ptr<string> deviceBrand{};

  DescribeDeviceBrandResponseBodyDeviceBrand() {}

  explicit DescribeDeviceBrandResponseBodyDeviceBrand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceBrandId) {
      res["DeviceBrandId"] = boost::any(*deviceBrandId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (manufacture) {
      res["Manufacture"] = boost::any(*manufacture);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = boost::any(*deviceBrand);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceBrandId") != m.end() && !m["DeviceBrandId"].empty()) {
      deviceBrandId = make_shared<long>(boost::any_cast<long>(m["DeviceBrandId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Manufacture") != m.end() && !m["Manufacture"].empty()) {
      manufacture = make_shared<string>(boost::any_cast<string>(m["Manufacture"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      deviceBrand = make_shared<string>(boost::any_cast<string>(m["DeviceBrand"]));
    }
  }


  virtual ~DescribeDeviceBrandResponseBodyDeviceBrand() = default;
};
class DescribeDeviceBrandResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeviceBrandResponseBodyDeviceBrand> deviceBrand{};

  DescribeDeviceBrandResponseBody() {}

  explicit DescribeDeviceBrandResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceBrand) {
      res["DeviceBrand"] = deviceBrand ? boost::any(deviceBrand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceBrand") != m.end() && !m["DeviceBrand"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeviceBrand"].type()) {
        DescribeDeviceBrandResponseBodyDeviceBrand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeviceBrand"]));
        deviceBrand = make_shared<DescribeDeviceBrandResponseBodyDeviceBrand>(model1);
      }
    }
  }


  virtual ~DescribeDeviceBrandResponseBody() = default;
};
class DescribeDeviceBrandResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceBrandResponseBody> body{};

  DescribeDeviceBrandResponse() {}

  explicit DescribeDeviceBrandResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceBrandResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceBrandResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceBrandResponse() = default;
};
class CreateShadowSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> authType{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> projectId{};
  shared_ptr<string> schema{};

  CreateShadowSchemaRequest() {}

  explicit CreateShadowSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~CreateShadowSchemaRequest() = default;
};
class CreateShadowSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateShadowSchemaResponseBody() {}

  explicit CreateShadowSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateShadowSchemaResponseBody() = default;
};
class CreateShadowSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateShadowSchemaResponseBody> body{};

  CreateShadowSchemaResponse() {}

  explicit CreateShadowSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateShadowSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateShadowSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~CreateShadowSchemaResponse() = default;
};
class DescribeDeviceValiditySchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceModel{};
  shared_ptr<string> schemaVersion{};
  shared_ptr<string> projectId{};

  DescribeDeviceValiditySchemaRequest() {}

  explicit DescribeDeviceValiditySchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (schemaVersion) {
      res["SchemaVersion"] = boost::any(*schemaVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("SchemaVersion") != m.end() && !m["SchemaVersion"].empty()) {
      schemaVersion = make_shared<string>(boost::any_cast<string>(m["SchemaVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeDeviceValiditySchemaRequest() = default;
};
class DescribeDeviceValiditySchemaResponseBodyItemList : public Darabonba::Model {
public:
  shared_ptr<double> minimum{};
  shared_ptr<string> type{};
  shared_ptr<double> maximum{};
  shared_ptr<string> itemType{};
  shared_ptr<string> enumListStr{};
  shared_ptr<bool> exclusiveMinimum{};
  shared_ptr<long> maxLength{};
  shared_ptr<string> required{};
  shared_ptr<string> description{};
  shared_ptr<bool> exclusiveMaximum{};
  shared_ptr<string> path{};
  shared_ptr<long> minLength{};

  DescribeDeviceValiditySchemaResponseBodyItemList() {}

  explicit DescribeDeviceValiditySchemaResponseBodyItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (minimum) {
      res["Minimum"] = boost::any(*minimum);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (maximum) {
      res["Maximum"] = boost::any(*maximum);
    }
    if (itemType) {
      res["ItemType"] = boost::any(*itemType);
    }
    if (enumListStr) {
      res["EnumListStr"] = boost::any(*enumListStr);
    }
    if (exclusiveMinimum) {
      res["ExclusiveMinimum"] = boost::any(*exclusiveMinimum);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (exclusiveMaximum) {
      res["ExclusiveMaximum"] = boost::any(*exclusiveMaximum);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Minimum") != m.end() && !m["Minimum"].empty()) {
      minimum = make_shared<double>(boost::any_cast<double>(m["Minimum"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Maximum") != m.end() && !m["Maximum"].empty()) {
      maximum = make_shared<double>(boost::any_cast<double>(m["Maximum"]));
    }
    if (m.find("ItemType") != m.end() && !m["ItemType"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["ItemType"]));
    }
    if (m.find("EnumListStr") != m.end() && !m["EnumListStr"].empty()) {
      enumListStr = make_shared<string>(boost::any_cast<string>(m["EnumListStr"]));
    }
    if (m.find("ExclusiveMinimum") != m.end() && !m["ExclusiveMinimum"].empty()) {
      exclusiveMinimum = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveMinimum"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExclusiveMaximum") != m.end() && !m["ExclusiveMaximum"].empty()) {
      exclusiveMaximum = make_shared<bool>(boost::any_cast<bool>(m["ExclusiveMaximum"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
  }


  virtual ~DescribeDeviceValiditySchemaResponseBodyItemList() = default;
};
class DescribeDeviceValiditySchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeDeviceValiditySchemaResponseBodyItemList>> itemList{};

  DescribeDeviceValiditySchemaResponseBody() {}

  explicit DescribeDeviceValiditySchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (itemList) {
      vector<boost::any> temp1;
      for(auto item1:*itemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ItemList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ItemList") != m.end() && !m["ItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ItemList"].type()) {
        vector<DescribeDeviceValiditySchemaResponseBodyItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeviceValiditySchemaResponseBodyItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        itemList = make_shared<vector<DescribeDeviceValiditySchemaResponseBodyItemList>>(expect1);
      }
    }
  }


  virtual ~DescribeDeviceValiditySchemaResponseBody() = default;
};
class DescribeDeviceValiditySchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceValiditySchemaResponseBody> body{};

  DescribeDeviceValiditySchemaResponse() {}

  explicit DescribeDeviceValiditySchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceValiditySchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceValiditySchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceValiditySchemaResponse() = default;
};
class GetOssUploadMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> ext{};

  GetOssUploadMetaRequest() {}

  explicit GetOssUploadMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (ext) {
      res["Ext"] = boost::any(*ext);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Ext") != m.end() && !m["Ext"].empty()) {
      ext = make_shared<string>(boost::any_cast<string>(m["Ext"]));
    }
  }


  virtual ~GetOssUploadMetaRequest() = default;
};
class GetOssUploadMetaResponseBodyOssUploadMeta : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> signature{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> objectKey{};

  GetOssUploadMetaResponseBodyOssUploadMeta() {}

  explicit GetOssUploadMetaResponseBodyOssUploadMeta(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (objectKey) {
      res["ObjectKey"] = boost::any(*objectKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ObjectKey") != m.end() && !m["ObjectKey"].empty()) {
      objectKey = make_shared<string>(boost::any_cast<string>(m["ObjectKey"]));
    }
  }


  virtual ~GetOssUploadMetaResponseBodyOssUploadMeta() = default;
};
class GetOssUploadMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetOssUploadMetaResponseBodyOssUploadMeta> ossUploadMeta{};

  GetOssUploadMetaResponseBody() {}

  explicit GetOssUploadMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ossUploadMeta) {
      res["OssUploadMeta"] = ossUploadMeta ? boost::any(ossUploadMeta->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OssUploadMeta") != m.end() && !m["OssUploadMeta"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssUploadMeta"].type()) {
        GetOssUploadMetaResponseBodyOssUploadMeta model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssUploadMeta"]));
        ossUploadMeta = make_shared<GetOssUploadMetaResponseBodyOssUploadMeta>(model1);
      }
    }
  }


  virtual ~GetOssUploadMetaResponseBody() = default;
};
class GetOssUploadMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetOssUploadMetaResponseBody> body{};

  GetOssUploadMetaResponse() {}

  explicit GetOssUploadMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOssUploadMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOssUploadMetaResponseBody>(model1);
      }
    }
  }


  virtual ~GetOssUploadMetaResponse() = default;
};
class ListUpstreamAppKeyRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<long> appServerId{};
  shared_ptr<long> pageIndex{};

  ListUpstreamAppKeyRelationsRequest() {}

  explicit ListUpstreamAppKeyRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appServerId) {
      res["AppServerId"] = boost::any(*appServerId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppServerId") != m.end() && !m["AppServerId"].empty()) {
      appServerId = make_shared<long>(boost::any_cast<long>(m["AppServerId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~ListUpstreamAppKeyRelationsRequest() = default;
};
class ListUpstreamAppKeyRelationsResponseBodyRelationListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUpstreamAppKeyRelationsResponseBodyRelationListPagination() {}

  explicit ListUpstreamAppKeyRelationsResponseBodyRelationListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUpstreamAppKeyRelationsResponseBodyRelationListPagination() = default;
};
class ListUpstreamAppKeyRelationsResponseBodyRelationListList : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appPackage{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> PAppKey{};
  shared_ptr<long> id{};

  ListUpstreamAppKeyRelationsResponseBodyRelationListList() {}

  explicit ListUpstreamAppKeyRelationsResponseBodyRelationListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appPackage) {
      res["AppPackage"] = boost::any(*appPackage);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (PAppKey) {
      res["PAppKey"] = boost::any(*PAppKey);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppPackage") != m.end() && !m["AppPackage"].empty()) {
      appPackage = make_shared<string>(boost::any_cast<string>(m["AppPackage"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("PAppKey") != m.end() && !m["PAppKey"].empty()) {
      PAppKey = make_shared<string>(boost::any_cast<string>(m["PAppKey"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListUpstreamAppKeyRelationsResponseBodyRelationListList() = default;
};
class ListUpstreamAppKeyRelationsResponseBodyRelationList : public Darabonba::Model {
public:
  shared_ptr<ListUpstreamAppKeyRelationsResponseBodyRelationListPagination> pagination{};
  shared_ptr<vector<ListUpstreamAppKeyRelationsResponseBodyRelationListList>> list{};

  ListUpstreamAppKeyRelationsResponseBodyRelationList() {}

  explicit ListUpstreamAppKeyRelationsResponseBodyRelationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListUpstreamAppKeyRelationsResponseBodyRelationListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListUpstreamAppKeyRelationsResponseBodyRelationListPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUpstreamAppKeyRelationsResponseBodyRelationListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUpstreamAppKeyRelationsResponseBodyRelationListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUpstreamAppKeyRelationsResponseBodyRelationListList>>(expect1);
      }
    }
  }


  virtual ~ListUpstreamAppKeyRelationsResponseBodyRelationList() = default;
};
class ListUpstreamAppKeyRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListUpstreamAppKeyRelationsResponseBodyRelationList> relationList{};

  ListUpstreamAppKeyRelationsResponseBody() {}

  explicit ListUpstreamAppKeyRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (relationList) {
      res["RelationList"] = relationList ? boost::any(relationList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RelationList") != m.end() && !m["RelationList"].empty()) {
      if (typeid(map<string, boost::any>) == m["RelationList"].type()) {
        ListUpstreamAppKeyRelationsResponseBodyRelationList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RelationList"]));
        relationList = make_shared<ListUpstreamAppKeyRelationsResponseBodyRelationList>(model1);
      }
    }
  }


  virtual ~ListUpstreamAppKeyRelationsResponseBody() = default;
};
class ListUpstreamAppKeyRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListUpstreamAppKeyRelationsResponseBody> body{};

  ListUpstreamAppKeyRelationsResponse() {}

  explicit ListUpstreamAppKeyRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUpstreamAppKeyRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUpstreamAppKeyRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUpstreamAppKeyRelationsResponse() = default;
};
class ListShadowSchemasRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> queryType{};
  shared_ptr<string> queryValue{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListShadowSchemasRequest() {}

  explicit ListShadowSchemasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queryType) {
      res["QueryType"] = boost::any(*queryType);
    }
    if (queryValue) {
      res["QueryValue"] = boost::any(*queryValue);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("QueryType") != m.end() && !m["QueryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["QueryType"]));
    }
    if (m.find("QueryValue") != m.end() && !m["QueryValue"].empty()) {
      queryValue = make_shared<string>(boost::any_cast<string>(m["QueryValue"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListShadowSchemasRequest() = default;
};
class ListShadowSchemasResponseBodyPageListPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};
  shared_ptr<bool> simpleSign{};
  shared_ptr<bool> hasNextPage{};

  ListShadowSchemasResponseBodyPageListPagination() {}

  explicit ListShadowSchemasResponseBodyPageListPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (simpleSign) {
      res["SimpleSign"] = boost::any(*simpleSign);
    }
    if (hasNextPage) {
      res["HasNextPage"] = boost::any(*hasNextPage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("SimpleSign") != m.end() && !m["SimpleSign"].empty()) {
      simpleSign = make_shared<bool>(boost::any_cast<bool>(m["SimpleSign"]));
    }
    if (m.find("HasNextPage") != m.end() && !m["HasNextPage"].empty()) {
      hasNextPage = make_shared<bool>(boost::any_cast<bool>(m["HasNextPage"]));
    }
  }


  virtual ~ListShadowSchemasResponseBodyPageListPagination() = default;
};
class ListShadowSchemasResponseBodyPageListList : public Darabonba::Model {
public:
  shared_ptr<string> authTypeDesc{};
  shared_ptr<long> deviceModelId{};
  shared_ptr<long> authType{};
  shared_ptr<string> projectId{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> moduleSchema{};
  shared_ptr<long> id{};

  ListShadowSchemasResponseBodyPageListList() {}

  explicit ListShadowSchemasResponseBodyPageListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authTypeDesc) {
      res["AuthTypeDesc"] = boost::any(*authTypeDesc);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (moduleSchema) {
      res["ModuleSchema"] = boost::any(*moduleSchema);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthTypeDesc") != m.end() && !m["AuthTypeDesc"].empty()) {
      authTypeDesc = make_shared<string>(boost::any_cast<string>(m["AuthTypeDesc"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<long>(boost::any_cast<long>(m["DeviceModelId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<long>(boost::any_cast<long>(m["AuthType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("ModuleSchema") != m.end() && !m["ModuleSchema"].empty()) {
      moduleSchema = make_shared<string>(boost::any_cast<string>(m["ModuleSchema"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListShadowSchemasResponseBodyPageListList() = default;
};
class ListShadowSchemasResponseBodyPageList : public Darabonba::Model {
public:
  shared_ptr<ListShadowSchemasResponseBodyPageListPagination> pagination{};
  shared_ptr<vector<ListShadowSchemasResponseBodyPageListList>> list{};

  ListShadowSchemasResponseBodyPageList() {}

  explicit ListShadowSchemasResponseBodyPageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListShadowSchemasResponseBodyPageListPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListShadowSchemasResponseBodyPageListPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListShadowSchemasResponseBodyPageListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListShadowSchemasResponseBodyPageListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListShadowSchemasResponseBodyPageListList>>(expect1);
      }
    }
  }


  virtual ~ListShadowSchemasResponseBodyPageList() = default;
};
class ListShadowSchemasResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListShadowSchemasResponseBodyPageList> pageList{};

  ListShadowSchemasResponseBody() {}

  explicit ListShadowSchemasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageList) {
      res["PageList"] = pageList ? boost::any(pageList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageList") != m.end() && !m["PageList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageList"].type()) {
        ListShadowSchemasResponseBodyPageList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageList"]));
        pageList = make_shared<ListShadowSchemasResponseBodyPageList>(model1);
      }
    }
  }


  virtual ~ListShadowSchemasResponseBody() = default;
};
class ListShadowSchemasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListShadowSchemasResponseBody> body{};

  ListShadowSchemasResponse() {}

  explicit ListShadowSchemasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListShadowSchemasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListShadowSchemasResponseBody>(model1);
      }
    }
  }


  virtual ~ListShadowSchemasResponse() = default;
};
class DeleteProjectAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> appId{};

  DeleteProjectAppRequest() {}

  explicit DeleteProjectAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteProjectAppRequest() = default;
};
class DeleteProjectAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectAppResponseBody() {}

  explicit DeleteProjectAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectAppResponseBody() = default;
};
class DeleteProjectAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteProjectAppResponseBody> body{};

  DeleteProjectAppResponse() {}

  explicit DeleteProjectAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectAppResponse() = default;
};
class CountYunIdInfoResponseBodyYunIdInfo : public Darabonba::Model {
public:
  shared_ptr<long> totalBrandCount{};
  shared_ptr<long> totalDeviceCount{};
  shared_ptr<long> totalDeviceModelCount{};

  CountYunIdInfoResponseBodyYunIdInfo() {}

  explicit CountYunIdInfoResponseBodyYunIdInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalBrandCount) {
      res["TotalBrandCount"] = boost::any(*totalBrandCount);
    }
    if (totalDeviceCount) {
      res["TotalDeviceCount"] = boost::any(*totalDeviceCount);
    }
    if (totalDeviceModelCount) {
      res["TotalDeviceModelCount"] = boost::any(*totalDeviceModelCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalBrandCount") != m.end() && !m["TotalBrandCount"].empty()) {
      totalBrandCount = make_shared<long>(boost::any_cast<long>(m["TotalBrandCount"]));
    }
    if (m.find("TotalDeviceCount") != m.end() && !m["TotalDeviceCount"].empty()) {
      totalDeviceCount = make_shared<long>(boost::any_cast<long>(m["TotalDeviceCount"]));
    }
    if (m.find("TotalDeviceModelCount") != m.end() && !m["TotalDeviceModelCount"].empty()) {
      totalDeviceModelCount = make_shared<long>(boost::any_cast<long>(m["TotalDeviceModelCount"]));
    }
  }


  virtual ~CountYunIdInfoResponseBodyYunIdInfo() = default;
};
class CountYunIdInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<CountYunIdInfoResponseBodyYunIdInfo>> yunIdInfo{};

  CountYunIdInfoResponseBody() {}

  explicit CountYunIdInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (yunIdInfo) {
      vector<boost::any> temp1;
      for(auto item1:*yunIdInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["YunIdInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("YunIdInfo") != m.end() && !m["YunIdInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["YunIdInfo"].type()) {
        vector<CountYunIdInfoResponseBodyYunIdInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["YunIdInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CountYunIdInfoResponseBodyYunIdInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        yunIdInfo = make_shared<vector<CountYunIdInfoResponseBodyYunIdInfo>>(expect1);
      }
    }
  }


  virtual ~CountYunIdInfoResponseBody() = default;
};
class CountYunIdInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CountYunIdInfoResponseBody> body{};

  CountYunIdInfoResponse() {}

  explicit CountYunIdInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CountYunIdInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CountYunIdInfoResponseBody>(model1);
      }
    }
  }


  virtual ~CountYunIdInfoResponse() = default;
};
class FindPrepublishesByParentIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> parentId{};

  FindPrepublishesByParentIdRequest() {}

  explicit FindPrepublishesByParentIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~FindPrepublishesByParentIdRequest() = default;
};
class FindPrepublishesByParentIdResponseBodyPrepublishListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> deviceModelId{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> isActive{};
  shared_ptr<string> versionId{};
  shared_ptr<string> barrierCount{};
  shared_ptr<string> isTotalPrepublish{};
  shared_ptr<long> gmtModifyTimestamp{};
  shared_ptr<string> parentId{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};
  shared_ptr<string> versionType{};

  FindPrepublishesByParentIdResponseBodyPrepublishListItems() {}

  explicit FindPrepublishesByParentIdResponseBodyPrepublishListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (deviceModelId) {
      res["DeviceModelId"] = boost::any(*deviceModelId);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (isActive) {
      res["IsActive"] = boost::any(*isActive);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (barrierCount) {
      res["BarrierCount"] = boost::any(*barrierCount);
    }
    if (isTotalPrepublish) {
      res["IsTotalPrepublish"] = boost::any(*isTotalPrepublish);
    }
    if (gmtModifyTimestamp) {
      res["GmtModifyTimestamp"] = boost::any(*gmtModifyTimestamp);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("DeviceModelId") != m.end() && !m["DeviceModelId"].empty()) {
      deviceModelId = make_shared<string>(boost::any_cast<string>(m["DeviceModelId"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("IsActive") != m.end() && !m["IsActive"].empty()) {
      isActive = make_shared<string>(boost::any_cast<string>(m["IsActive"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("BarrierCount") != m.end() && !m["BarrierCount"].empty()) {
      barrierCount = make_shared<string>(boost::any_cast<string>(m["BarrierCount"]));
    }
    if (m.find("IsTotalPrepublish") != m.end() && !m["IsTotalPrepublish"].empty()) {
      isTotalPrepublish = make_shared<string>(boost::any_cast<string>(m["IsTotalPrepublish"]));
    }
    if (m.find("GmtModifyTimestamp") != m.end() && !m["GmtModifyTimestamp"].empty()) {
      gmtModifyTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtModifyTimestamp"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindPrepublishesByParentIdResponseBodyPrepublishListItems() = default;
};
class FindPrepublishesByParentIdResponseBodyPrepublishList : public Darabonba::Model {
public:
  shared_ptr<vector<FindPrepublishesByParentIdResponseBodyPrepublishListItems>> items{};
  shared_ptr<long> totalCount{};

  FindPrepublishesByParentIdResponseBodyPrepublishList() {}

  explicit FindPrepublishesByParentIdResponseBodyPrepublishList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindPrepublishesByParentIdResponseBodyPrepublishListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindPrepublishesByParentIdResponseBodyPrepublishListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindPrepublishesByParentIdResponseBodyPrepublishListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindPrepublishesByParentIdResponseBodyPrepublishList() = default;
};
class FindPrepublishesByParentIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindPrepublishesByParentIdResponseBodyPrepublishList> prepublishList{};

  FindPrepublishesByParentIdResponseBody() {}

  explicit FindPrepublishesByParentIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (prepublishList) {
      res["PrepublishList"] = prepublishList ? boost::any(prepublishList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PrepublishList") != m.end() && !m["PrepublishList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrepublishList"].type()) {
        FindPrepublishesByParentIdResponseBodyPrepublishList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrepublishList"]));
        prepublishList = make_shared<FindPrepublishesByParentIdResponseBodyPrepublishList>(model1);
      }
    }
  }


  virtual ~FindPrepublishesByParentIdResponseBody() = default;
};
class FindPrepublishesByParentIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindPrepublishesByParentIdResponseBody> body{};

  FindPrepublishesByParentIdResponse() {}

  explicit FindPrepublishesByParentIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindPrepublishesByParentIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindPrepublishesByParentIdResponseBody>(model1);
      }
    }
  }


  virtual ~FindPrepublishesByParentIdResponse() = default;
};
class GetVehicleControlResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> executionId{};
  shared_ptr<string> projectId{};

  GetVehicleControlResultRequest() {}

  explicit GetVehicleControlResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (executionId) {
      res["ExecutionId"] = boost::any(*executionId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("ExecutionId") != m.end() && !m["ExecutionId"].empty()) {
      executionId = make_shared<string>(boost::any_cast<string>(m["ExecutionId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetVehicleControlResultRequest() = default;
};
class GetVehicleControlResultResponseBodyExecutionInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> subStatus{};

  GetVehicleControlResultResponseBodyExecutionInfo() {}

  explicit GetVehicleControlResultResponseBodyExecutionInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subStatus) {
      res["SubStatus"] = boost::any(*subStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubStatus") != m.end() && !m["SubStatus"].empty()) {
      subStatus = make_shared<string>(boost::any_cast<string>(m["SubStatus"]));
    }
  }


  virtual ~GetVehicleControlResultResponseBodyExecutionInfo() = default;
};
class GetVehicleControlResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetVehicleControlResultResponseBodyExecutionInfo> executionInfo{};

  GetVehicleControlResultResponseBody() {}

  explicit GetVehicleControlResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (executionInfo) {
      res["ExecutionInfo"] = executionInfo ? boost::any(executionInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ExecutionInfo") != m.end() && !m["ExecutionInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecutionInfo"].type()) {
        GetVehicleControlResultResponseBodyExecutionInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecutionInfo"]));
        executionInfo = make_shared<GetVehicleControlResultResponseBodyExecutionInfo>(model1);
      }
    }
  }


  virtual ~GetVehicleControlResultResponseBody() = default;
};
class GetVehicleControlResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetVehicleControlResultResponseBody> body{};

  GetVehicleControlResultResponse() {}

  explicit GetVehicleControlResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVehicleControlResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVehicleControlResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetVehicleControlResultResponse() = default;
};
class UpdateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> id{};
  shared_ptr<long> sandbox{};
  shared_ptr<long> production{};

  UpdateTriggerRequest() {}

  explicit UpdateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sandbox) {
      res["Sandbox"] = boost::any(*sandbox);
    }
    if (production) {
      res["Production"] = boost::any(*production);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Sandbox") != m.end() && !m["Sandbox"].empty()) {
      sandbox = make_shared<long>(boost::any_cast<long>(m["Sandbox"]));
    }
    if (m.find("Production") != m.end() && !m["Production"].empty()) {
      production = make_shared<long>(boost::any_cast<long>(m["Production"]));
    }
  }


  virtual ~UpdateTriggerRequest() = default;
};
class UpdateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTriggerResponseBody() {}

  explicit UpdateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTriggerResponseBody() = default;
};
class UpdateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateTriggerResponseBody> body{};

  UpdateTriggerResponse() {}

  explicit UpdateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTriggerResponse() = default;
};
class ListClientSdksRequest : public Darabonba::Model {
public:
  shared_ptr<string> osType{};

  ListClientSdksRequest() {}

  explicit ListClientSdksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["OsType"]));
    }
  }


  virtual ~ListClientSdksRequest() = default;
};
class ListClientSdksResponseBodyClientSdks : public Darabonba::Model {
public:
  shared_ptr<long> osType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> name{};
  shared_ptr<string> pkgName{};
  shared_ptr<long> pkgType{};
  shared_ptr<long> id{};

  ListClientSdksResponseBodyClientSdks() {}

  explicit ListClientSdksResponseBodyClientSdks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (osType) {
      res["OsType"] = boost::any(*osType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pkgName) {
      res["PkgName"] = boost::any(*pkgName);
    }
    if (pkgType) {
      res["PkgType"] = boost::any(*pkgType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OsType") != m.end() && !m["OsType"].empty()) {
      osType = make_shared<long>(boost::any_cast<long>(m["OsType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PkgName") != m.end() && !m["PkgName"].empty()) {
      pkgName = make_shared<string>(boost::any_cast<string>(m["PkgName"]));
    }
    if (m.find("PkgType") != m.end() && !m["PkgType"].empty()) {
      pkgType = make_shared<long>(boost::any_cast<long>(m["PkgType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListClientSdksResponseBodyClientSdks() = default;
};
class ListClientSdksResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListClientSdksResponseBodyClientSdks>> clientSdks{};
  shared_ptr<string> requestId{};

  ListClientSdksResponseBody() {}

  explicit ListClientSdksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientSdks) {
      vector<boost::any> temp1;
      for(auto item1:*clientSdks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ClientSdks"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientSdks") != m.end() && !m["ClientSdks"].empty()) {
      if (typeid(vector<boost::any>) == m["ClientSdks"].type()) {
        vector<ListClientSdksResponseBodyClientSdks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ClientSdks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListClientSdksResponseBodyClientSdks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientSdks = make_shared<vector<ListClientSdksResponseBodyClientSdks>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListClientSdksResponseBody() = default;
};
class ListClientSdksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListClientSdksResponseBody> body{};

  ListClientSdksResponse() {}

  explicit ListClientSdksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListClientSdksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListClientSdksResponseBody>(model1);
      }
    }
  }


  virtual ~ListClientSdksResponse() = default;
};
class ListVersionDeviceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  ListVersionDeviceGroupsRequest() {}

  explicit ListVersionDeviceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListVersionDeviceGroupsRequest() = default;
};
class ListVersionDeviceGroupsResponseBodyDeviceGroupList : public Darabonba::Model {
public:
  shared_ptr<string> gmtModify{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<string> id{};

  ListVersionDeviceGroupsResponseBodyDeviceGroupList() {}

  explicit ListVersionDeviceGroupsResponseBodyDeviceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListVersionDeviceGroupsResponseBodyDeviceGroupList() = default;
};
class ListVersionDeviceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListVersionDeviceGroupsResponseBodyDeviceGroupList>> deviceGroupList{};

  ListVersionDeviceGroupsResponseBody() {}

  explicit ListVersionDeviceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deviceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*deviceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeviceGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeviceGroupList") != m.end() && !m["DeviceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["DeviceGroupList"].type()) {
        vector<ListVersionDeviceGroupsResponseBodyDeviceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeviceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVersionDeviceGroupsResponseBodyDeviceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deviceGroupList = make_shared<vector<ListVersionDeviceGroupsResponseBodyDeviceGroupList>>(expect1);
      }
    }
  }


  virtual ~ListVersionDeviceGroupsResponseBody() = default;
};
class ListVersionDeviceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListVersionDeviceGroupsResponseBody> body{};

  ListVersionDeviceGroupsResponse() {}

  explicit ListVersionDeviceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVersionDeviceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVersionDeviceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVersionDeviceGroupsResponse() = default;
};
class GetCommercialVehicleDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> clientId{};

  GetCommercialVehicleDeviceRequest() {}

  explicit GetCommercialVehicleDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
  }


  virtual ~GetCommercialVehicleDeviceRequest() = default;
};
class GetCommercialVehicleDeviceResponseBodyVehicleDevice : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> modifiedTime{};
  shared_ptr<string> hardwareId{};
  shared_ptr<string> clientId{};
  shared_ptr<string> manufacturerId{};
  shared_ptr<string> deviceModel{};
  shared_ptr<long> onlineStatus{};
  shared_ptr<long> plateColor{};
  shared_ptr<string> plateNumber{};
  shared_ptr<string> vin{};
  shared_ptr<string> imei{};
  shared_ptr<string> softVersion{};
  shared_ptr<long> lastAuthTime{};

  GetCommercialVehicleDeviceResponseBodyVehicleDevice() {}

  explicit GetCommercialVehicleDeviceResponseBodyVehicleDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (hardwareId) {
      res["HardwareId"] = boost::any(*hardwareId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (manufacturerId) {
      res["ManufacturerId"] = boost::any(*manufacturerId);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (plateColor) {
      res["PlateColor"] = boost::any(*plateColor);
    }
    if (plateNumber) {
      res["PlateNumber"] = boost::any(*plateNumber);
    }
    if (vin) {
      res["Vin"] = boost::any(*vin);
    }
    if (imei) {
      res["Imei"] = boost::any(*imei);
    }
    if (softVersion) {
      res["SoftVersion"] = boost::any(*softVersion);
    }
    if (lastAuthTime) {
      res["LastAuthTime"] = boost::any(*lastAuthTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<long>(boost::any_cast<long>(m["ModifiedTime"]));
    }
    if (m.find("HardwareId") != m.end() && !m["HardwareId"].empty()) {
      hardwareId = make_shared<string>(boost::any_cast<string>(m["HardwareId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ManufacturerId") != m.end() && !m["ManufacturerId"].empty()) {
      manufacturerId = make_shared<string>(boost::any_cast<string>(m["ManufacturerId"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<long>(boost::any_cast<long>(m["OnlineStatus"]));
    }
    if (m.find("PlateColor") != m.end() && !m["PlateColor"].empty()) {
      plateColor = make_shared<long>(boost::any_cast<long>(m["PlateColor"]));
    }
    if (m.find("PlateNumber") != m.end() && !m["PlateNumber"].empty()) {
      plateNumber = make_shared<string>(boost::any_cast<string>(m["PlateNumber"]));
    }
    if (m.find("Vin") != m.end() && !m["Vin"].empty()) {
      vin = make_shared<string>(boost::any_cast<string>(m["Vin"]));
    }
    if (m.find("Imei") != m.end() && !m["Imei"].empty()) {
      imei = make_shared<string>(boost::any_cast<string>(m["Imei"]));
    }
    if (m.find("SoftVersion") != m.end() && !m["SoftVersion"].empty()) {
      softVersion = make_shared<string>(boost::any_cast<string>(m["SoftVersion"]));
    }
    if (m.find("LastAuthTime") != m.end() && !m["LastAuthTime"].empty()) {
      lastAuthTime = make_shared<long>(boost::any_cast<long>(m["LastAuthTime"]));
    }
  }


  virtual ~GetCommercialVehicleDeviceResponseBodyVehicleDevice() = default;
};
class GetCommercialVehicleDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetCommercialVehicleDeviceResponseBodyVehicleDevice> vehicleDevice{};

  GetCommercialVehicleDeviceResponseBody() {}

  explicit GetCommercialVehicleDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vehicleDevice) {
      res["VehicleDevice"] = vehicleDevice ? boost::any(vehicleDevice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VehicleDevice") != m.end() && !m["VehicleDevice"].empty()) {
      if (typeid(map<string, boost::any>) == m["VehicleDevice"].type()) {
        GetCommercialVehicleDeviceResponseBodyVehicleDevice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VehicleDevice"]));
        vehicleDevice = make_shared<GetCommercialVehicleDeviceResponseBodyVehicleDevice>(model1);
      }
    }
  }


  virtual ~GetCommercialVehicleDeviceResponseBody() = default;
};
class GetCommercialVehicleDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetCommercialVehicleDeviceResponseBody> body{};

  GetCommercialVehicleDeviceResponse() {}

  explicit GetCommercialVehicleDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCommercialVehicleDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCommercialVehicleDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~GetCommercialVehicleDeviceResponse() = default;
};
class SubmitAssistReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> assistId{};
  shared_ptr<string> assistDescription{};
  shared_ptr<string> assistResult{};
  shared_ptr<string> assistTag{};
  shared_ptr<string> assistReason{};
  shared_ptr<string> deviceModel{};

  SubmitAssistReportRequest() {}

  explicit SubmitAssistReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (assistId) {
      res["AssistId"] = boost::any(*assistId);
    }
    if (assistDescription) {
      res["AssistDescription"] = boost::any(*assistDescription);
    }
    if (assistResult) {
      res["AssistResult"] = boost::any(*assistResult);
    }
    if (assistTag) {
      res["AssistTag"] = boost::any(*assistTag);
    }
    if (assistReason) {
      res["AssistReason"] = boost::any(*assistReason);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("AssistId") != m.end() && !m["AssistId"].empty()) {
      assistId = make_shared<string>(boost::any_cast<string>(m["AssistId"]));
    }
    if (m.find("AssistDescription") != m.end() && !m["AssistDescription"].empty()) {
      assistDescription = make_shared<string>(boost::any_cast<string>(m["AssistDescription"]));
    }
    if (m.find("AssistResult") != m.end() && !m["AssistResult"].empty()) {
      assistResult = make_shared<string>(boost::any_cast<string>(m["AssistResult"]));
    }
    if (m.find("AssistTag") != m.end() && !m["AssistTag"].empty()) {
      assistTag = make_shared<string>(boost::any_cast<string>(m["AssistTag"]));
    }
    if (m.find("AssistReason") != m.end() && !m["AssistReason"].empty()) {
      assistReason = make_shared<string>(boost::any_cast<string>(m["AssistReason"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
  }


  virtual ~SubmitAssistReportRequest() = default;
};
class SubmitAssistReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SubmitAssistReportResponseBody() {}

  explicit SubmitAssistReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitAssistReportResponseBody() = default;
};
class SubmitAssistReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SubmitAssistReportResponseBody> body{};

  SubmitAssistReportResponse() {}

  explicit SubmitAssistReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitAssistReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitAssistReportResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitAssistReportResponse() = default;
};
class DeleteVersionAllBlackDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};

  DeleteVersionAllBlackDevicesRequest() {}

  explicit DeleteVersionAllBlackDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteVersionAllBlackDevicesRequest() = default;
};
class DeleteVersionAllBlackDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionAllBlackDevicesResponseBody() {}

  explicit DeleteVersionAllBlackDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionAllBlackDevicesResponseBody() = default;
};
class DeleteVersionAllBlackDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionAllBlackDevicesResponseBody> body{};

  DeleteVersionAllBlackDevicesResponse() {}

  explicit DeleteVersionAllBlackDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionAllBlackDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionAllBlackDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionAllBlackDevicesResponse() = default;
};
class ListOpenAccountLinksRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> identityId{};
  shared_ptr<string> idp{};
  shared_ptr<string> openId{};

  ListOpenAccountLinksRequest() {}

  explicit ListOpenAccountLinksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (idp) {
      res["Idp"] = boost::any(*idp);
    }
    if (openId) {
      res["OpenId"] = boost::any(*openId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("Idp") != m.end() && !m["Idp"].empty()) {
      idp = make_shared<string>(boost::any_cast<string>(m["Idp"]));
    }
    if (m.find("OpenId") != m.end() && !m["OpenId"].empty()) {
      openId = make_shared<string>(boost::any_cast<string>(m["OpenId"]));
    }
  }


  virtual ~ListOpenAccountLinksRequest() = default;
};
class ListOpenAccountLinksResponseBodyOpenAccounts : public Darabonba::Model {
public:
  shared_ptr<long> status{};
  shared_ptr<long> type{};
  shared_ptr<string> displayName{};
  shared_ptr<string> createAccessKey{};
  shared_ptr<string> openId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> region{};
  shared_ptr<string> identityId{};
  shared_ptr<string> loginId{};
  shared_ptr<string> idp{};
  shared_ptr<string> aliyunId{};

  ListOpenAccountLinksResponseBodyOpenAccounts() {}

  explicit ListOpenAccountLinksResponseBodyOpenAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (createAccessKey) {
      res["CreateAccessKey"] = boost::any(*createAccessKey);
    }
    if (openId) {
      res["OpenId"] = boost::any(*openId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (identityId) {
      res["IdentityId"] = boost::any(*identityId);
    }
    if (loginId) {
      res["LoginId"] = boost::any(*loginId);
    }
    if (idp) {
      res["Idp"] = boost::any(*idp);
    }
    if (aliyunId) {
      res["AliyunId"] = boost::any(*aliyunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("CreateAccessKey") != m.end() && !m["CreateAccessKey"].empty()) {
      createAccessKey = make_shared<string>(boost::any_cast<string>(m["CreateAccessKey"]));
    }
    if (m.find("OpenId") != m.end() && !m["OpenId"].empty()) {
      openId = make_shared<string>(boost::any_cast<string>(m["OpenId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("IdentityId") != m.end() && !m["IdentityId"].empty()) {
      identityId = make_shared<string>(boost::any_cast<string>(m["IdentityId"]));
    }
    if (m.find("LoginId") != m.end() && !m["LoginId"].empty()) {
      loginId = make_shared<string>(boost::any_cast<string>(m["LoginId"]));
    }
    if (m.find("Idp") != m.end() && !m["Idp"].empty()) {
      idp = make_shared<string>(boost::any_cast<string>(m["Idp"]));
    }
    if (m.find("AliyunId") != m.end() && !m["AliyunId"].empty()) {
      aliyunId = make_shared<string>(boost::any_cast<string>(m["AliyunId"]));
    }
  }


  virtual ~ListOpenAccountLinksResponseBodyOpenAccounts() = default;
};
class ListOpenAccountLinksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListOpenAccountLinksResponseBodyOpenAccounts>> openAccounts{};

  ListOpenAccountLinksResponseBody() {}

  explicit ListOpenAccountLinksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (openAccounts) {
      vector<boost::any> temp1;
      for(auto item1:*openAccounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OpenAccounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OpenAccounts") != m.end() && !m["OpenAccounts"].empty()) {
      if (typeid(vector<boost::any>) == m["OpenAccounts"].type()) {
        vector<ListOpenAccountLinksResponseBodyOpenAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OpenAccounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOpenAccountLinksResponseBodyOpenAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        openAccounts = make_shared<vector<ListOpenAccountLinksResponseBodyOpenAccounts>>(expect1);
      }
    }
  }


  virtual ~ListOpenAccountLinksResponseBody() = default;
};
class ListOpenAccountLinksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListOpenAccountLinksResponseBody> body{};

  ListOpenAccountLinksResponse() {}

  explicit ListOpenAccountLinksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOpenAccountLinksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOpenAccountLinksResponseBody>(model1);
      }
    }
  }


  virtual ~ListOpenAccountLinksResponse() = default;
};
class AddVersionWhiteDevicesByDeviceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> groupIds{};
  shared_ptr<string> versionId{};

  AddVersionWhiteDevicesByDeviceGroupsRequest() {}

  explicit AddVersionWhiteDevicesByDeviceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      groupIds = make_shared<string>(boost::any_cast<string>(m["GroupIds"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~AddVersionWhiteDevicesByDeviceGroupsRequest() = default;
};
class AddVersionWhiteDevicesByDeviceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> data{};

  AddVersionWhiteDevicesByDeviceGroupsResponseBody() {}

  explicit AddVersionWhiteDevicesByDeviceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
  }


  virtual ~AddVersionWhiteDevicesByDeviceGroupsResponseBody() = default;
};
class AddVersionWhiteDevicesByDeviceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddVersionWhiteDevicesByDeviceGroupsResponseBody> body{};

  AddVersionWhiteDevicesByDeviceGroupsResponse() {}

  explicit AddVersionWhiteDevicesByDeviceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddVersionWhiteDevicesByDeviceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddVersionWhiteDevicesByDeviceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AddVersionWhiteDevicesByDeviceGroupsResponse() = default;
};
class FindCustomizedPropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> name{};
  shared_ptr<string> versionType{};

  FindCustomizedPropertiesRequest() {}

  explicit FindCustomizedPropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~FindCustomizedPropertiesRequest() = default;
};
class FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems : public Darabonba::Model {
public:
  shared_ptr<long> gmtCreateTimestamp{};
  shared_ptr<string> value{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> name{};
  shared_ptr<long> id{};

  FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems() {}

  explicit FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreateTimestamp) {
      res["GmtCreateTimestamp"] = boost::any(*gmtCreateTimestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreateTimestamp") != m.end() && !m["GmtCreateTimestamp"].empty()) {
      gmtCreateTimestamp = make_shared<long>(boost::any_cast<long>(m["GmtCreateTimestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems() = default;
};
class FindCustomizedPropertiesResponseBodyCustomizedPropertyList : public Darabonba::Model {
public:
  shared_ptr<vector<FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems>> items{};
  shared_ptr<long> totalCount{};

  FindCustomizedPropertiesResponseBodyCustomizedPropertyList() {}

  explicit FindCustomizedPropertiesResponseBodyCustomizedPropertyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<FindCustomizedPropertiesResponseBodyCustomizedPropertyListItems>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~FindCustomizedPropertiesResponseBodyCustomizedPropertyList() = default;
};
class FindCustomizedPropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<FindCustomizedPropertiesResponseBodyCustomizedPropertyList> customizedPropertyList{};

  FindCustomizedPropertiesResponseBody() {}

  explicit FindCustomizedPropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (customizedPropertyList) {
      res["CustomizedPropertyList"] = customizedPropertyList ? boost::any(customizedPropertyList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CustomizedPropertyList") != m.end() && !m["CustomizedPropertyList"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomizedPropertyList"].type()) {
        FindCustomizedPropertiesResponseBodyCustomizedPropertyList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomizedPropertyList"]));
        customizedPropertyList = make_shared<FindCustomizedPropertiesResponseBodyCustomizedPropertyList>(model1);
      }
    }
  }


  virtual ~FindCustomizedPropertiesResponseBody() = default;
};
class FindCustomizedPropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<FindCustomizedPropertiesResponseBody> body{};

  FindCustomizedPropertiesResponse() {}

  explicit FindCustomizedPropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FindCustomizedPropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FindCustomizedPropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~FindCustomizedPropertiesResponse() = default;
};
class ListMessageAcksRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> messageId{};
  shared_ptr<long> pageIndex{};

  ListMessageAcksRequest() {}

  explicit ListMessageAcksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
  }


  virtual ~ListMessageAcksRequest() = default;
};
class ListMessageAcksResponseBodyMessageAcksPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMessageAcksResponseBodyMessageAcksPagination() {}

  explicit ListMessageAcksResponseBodyMessageAcksPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMessageAcksResponseBodyMessageAcksPagination() = default;
};
class ListMessageAcksResponseBodyMessageAcksList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<long> ackTime{};
  shared_ptr<long> mid{};

  ListMessageAcksResponseBodyMessageAcksList() {}

  explicit ListMessageAcksResponseBodyMessageAcksList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (ackTime) {
      res["AckTime"] = boost::any(*ackTime);
    }
    if (mid) {
      res["Mid"] = boost::any(*mid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("AckTime") != m.end() && !m["AckTime"].empty()) {
      ackTime = make_shared<long>(boost::any_cast<long>(m["AckTime"]));
    }
    if (m.find("Mid") != m.end() && !m["Mid"].empty()) {
      mid = make_shared<long>(boost::any_cast<long>(m["Mid"]));
    }
  }


  virtual ~ListMessageAcksResponseBodyMessageAcksList() = default;
};
class ListMessageAcksResponseBodyMessageAcks : public Darabonba::Model {
public:
  shared_ptr<ListMessageAcksResponseBodyMessageAcksPagination> pagination{};
  shared_ptr<vector<ListMessageAcksResponseBodyMessageAcksList>> list{};

  ListMessageAcksResponseBodyMessageAcks() {}

  explicit ListMessageAcksResponseBodyMessageAcks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListMessageAcksResponseBodyMessageAcksPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListMessageAcksResponseBodyMessageAcksPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListMessageAcksResponseBodyMessageAcksList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMessageAcksResponseBodyMessageAcksList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListMessageAcksResponseBodyMessageAcksList>>(expect1);
      }
    }
  }


  virtual ~ListMessageAcksResponseBodyMessageAcks() = default;
};
class ListMessageAcksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMessageAcksResponseBodyMessageAcks> messageAcks{};

  ListMessageAcksResponseBody() {}

  explicit ListMessageAcksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (messageAcks) {
      res["MessageAcks"] = messageAcks ? boost::any(messageAcks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MessageAcks") != m.end() && !m["MessageAcks"].empty()) {
      if (typeid(map<string, boost::any>) == m["MessageAcks"].type()) {
        ListMessageAcksResponseBodyMessageAcks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MessageAcks"]));
        messageAcks = make_shared<ListMessageAcksResponseBodyMessageAcks>(model1);
      }
    }
  }


  virtual ~ListMessageAcksResponseBody() = default;
};
class ListMessageAcksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMessageAcksResponseBody> body{};

  ListMessageAcksResponse() {}

  explicit ListMessageAcksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMessageAcksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMessageAcksResponseBody>(model1);
      }
    }
  }


  virtual ~ListMessageAcksResponse() = default;
};
class GetCommercialVehicleTrackRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> clientId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> endTime{};

  GetCommercialVehicleTrackRequest() {}

  explicit GetCommercialVehicleTrackRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
  }


  virtual ~GetCommercialVehicleTrackRequest() = default;
};
class GetCommercialVehicleTrackResponseBodyPoints : public Darabonba::Model {
public:
  shared_ptr<string> longitude{};
  shared_ptr<string> latitude{};
  shared_ptr<string> altitude{};
  shared_ptr<long> speed{};
  shared_ptr<long> direction{};
  shared_ptr<long> time{};

  GetCommercialVehicleTrackResponseBodyPoints() {}

  explicit GetCommercialVehicleTrackResponseBodyPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (altitude) {
      res["Altitude"] = boost::any(*altitude);
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("Altitude") != m.end() && !m["Altitude"].empty()) {
      altitude = make_shared<string>(boost::any_cast<string>(m["Altitude"]));
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<long>(boost::any_cast<long>(m["Speed"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<long>(boost::any_cast<long>(m["Direction"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<long>(boost::any_cast<long>(m["Time"]));
    }
  }


  virtual ~GetCommercialVehicleTrackResponseBodyPoints() = default;
};
class GetCommercialVehicleTrackResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetCommercialVehicleTrackResponseBodyPoints>> points{};

  GetCommercialVehicleTrackResponseBody() {}

  explicit GetCommercialVehicleTrackResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (points) {
      vector<boost::any> temp1;
      for(auto item1:*points){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Points"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Points") != m.end() && !m["Points"].empty()) {
      if (typeid(vector<boost::any>) == m["Points"].type()) {
        vector<GetCommercialVehicleTrackResponseBodyPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Points"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCommercialVehicleTrackResponseBodyPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        points = make_shared<vector<GetCommercialVehicleTrackResponseBodyPoints>>(expect1);
      }
    }
  }


  virtual ~GetCommercialVehicleTrackResponseBody() = default;
};
class GetCommercialVehicleTrackResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetCommercialVehicleTrackResponseBody> body{};

  GetCommercialVehicleTrackResponse() {}

  explicit GetCommercialVehicleTrackResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCommercialVehicleTrackResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCommercialVehicleTrackResponseBody>(model1);
      }
    }
  }


  virtual ~GetCommercialVehicleTrackResponse() = default;
};
class ListHostDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> deviceName{};

  ListHostDevicesRequest() {}

  explicit ListHostDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
  }


  virtual ~ListHostDevicesRequest() = default;
};
class ListHostDevicesResponseBodyHostDevicesPagination : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageIndex{};
  shared_ptr<long> pageSize{};

  ListHostDevicesResponseBodyHostDevicesPagination() {}

  explicit ListHostDevicesResponseBodyHostDevicesPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListHostDevicesResponseBodyHostDevicesPagination() = default;
};
class ListHostDevicesResponseBodyHostDevicesList : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> deviceName{};
  shared_ptr<long> status{};
  shared_ptr<string> deviceModel{};
  shared_ptr<string> ip{};
  shared_ptr<long> activateTime{};

  ListHostDevicesResponseBodyHostDevicesList() {}

  explicit ListHostDevicesResponseBodyHostDevicesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (deviceName) {
      res["DeviceName"] = boost::any(*deviceName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (deviceModel) {
      res["DeviceModel"] = boost::any(*deviceModel);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (activateTime) {
      res["ActivateTime"] = boost::any(*activateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("DeviceName") != m.end() && !m["DeviceName"].empty()) {
      deviceName = make_shared<string>(boost::any_cast<string>(m["DeviceName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("DeviceModel") != m.end() && !m["DeviceModel"].empty()) {
      deviceModel = make_shared<string>(boost::any_cast<string>(m["DeviceModel"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("ActivateTime") != m.end() && !m["ActivateTime"].empty()) {
      activateTime = make_shared<long>(boost::any_cast<long>(m["ActivateTime"]));
    }
  }


  virtual ~ListHostDevicesResponseBodyHostDevicesList() = default;
};
class ListHostDevicesResponseBodyHostDevices : public Darabonba::Model {
public:
  shared_ptr<ListHostDevicesResponseBodyHostDevicesPagination> pagination{};
  shared_ptr<vector<ListHostDevicesResponseBodyHostDevicesList>> list{};

  ListHostDevicesResponseBodyHostDevices() {}

  explicit ListHostDevicesResponseBodyHostDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListHostDevicesResponseBodyHostDevicesPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListHostDevicesResponseBodyHostDevicesPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHostDevicesResponseBodyHostDevicesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHostDevicesResponseBodyHostDevicesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHostDevicesResponseBodyHostDevicesList>>(expect1);
      }
    }
  }


  virtual ~ListHostDevicesResponseBodyHostDevices() = default;
};
class ListHostDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListHostDevicesResponseBodyHostDevices> hostDevices{};

  ListHostDevicesResponseBody() {}

  explicit ListHostDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (hostDevices) {
      res["HostDevices"] = hostDevices ? boost::any(hostDevices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("HostDevices") != m.end() && !m["HostDevices"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostDevices"].type()) {
        ListHostDevicesResponseBodyHostDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostDevices"]));
        hostDevices = make_shared<ListHostDevicesResponseBodyHostDevices>(model1);
      }
    }
  }


  virtual ~ListHostDevicesResponseBody() = default;
};
class ListHostDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListHostDevicesResponseBody> body{};

  ListHostDevicesResponse() {}

  explicit ListHostDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHostDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHostDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListHostDevicesResponse() = default;
};
class ListMqttClientSubscriptionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> clientId{};
  shared_ptr<string> projectId{};

  ListMqttClientSubscriptionsRequest() {}

  explicit ListMqttClientSubscriptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~ListMqttClientSubscriptionsRequest() = default;
};
class ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageIndex{};
  shared_ptr<long> totalPageCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination() {}

  explicit ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageIndex) {
      res["PageIndex"] = boost::any(*pageIndex);
    }
    if (totalPageCount) {
      res["TotalPageCount"] = boost::any(*totalPageCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageIndex") != m.end() && !m["PageIndex"].empty()) {
      pageIndex = make_shared<long>(boost::any_cast<long>(m["PageIndex"]));
    }
    if (m.find("TotalPageCount") != m.end() && !m["TotalPageCount"].empty()) {
      totalPageCount = make_shared<long>(boost::any_cast<long>(m["TotalPageCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination() = default;
};
class ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList : public Darabonba::Model {
public:
  shared_ptr<string> topic{};
  shared_ptr<long> qoS{};

  ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList() {}

  explicit ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (qoS) {
      res["QoS"] = boost::any(*qoS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("QoS") != m.end() && !m["QoS"].empty()) {
      qoS = make_shared<long>(boost::any_cast<long>(m["QoS"]));
    }
  }


  virtual ~ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList() = default;
};
class ListMqttClientSubscriptionsResponseBodyClientSubscriptions : public Darabonba::Model {
public:
  shared_ptr<ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination> pagination{};
  shared_ptr<vector<ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList>> list{};

  ListMqttClientSubscriptionsResponseBodyClientSubscriptions() {}

  explicit ListMqttClientSubscriptionsResponseBodyClientSubscriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<ListMqttClientSubscriptionsResponseBodyClientSubscriptionsPagination>(model1);
      }
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListMqttClientSubscriptionsResponseBodyClientSubscriptionsList>>(expect1);
      }
    }
  }


  virtual ~ListMqttClientSubscriptionsResponseBodyClientSubscriptions() = default;
};
class ListMqttClientSubscriptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListMqttClientSubscriptionsResponseBodyClientSubscriptions> clientSubscriptions{};

  ListMqttClientSubscriptionsResponseBody() {}

  explicit ListMqttClientSubscriptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (clientSubscriptions) {
      res["ClientSubscriptions"] = clientSubscriptions ? boost::any(clientSubscriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ClientSubscriptions") != m.end() && !m["ClientSubscriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ClientSubscriptions"].type()) {
        ListMqttClientSubscriptionsResponseBodyClientSubscriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ClientSubscriptions"]));
        clientSubscriptions = make_shared<ListMqttClientSubscriptionsResponseBodyClientSubscriptions>(model1);
      }
    }
  }


  virtual ~ListMqttClientSubscriptionsResponseBody() = default;
};
class ListMqttClientSubscriptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListMqttClientSubscriptionsResponseBody> body{};

  ListMqttClientSubscriptionsResponse() {}

  explicit ListMqttClientSubscriptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMqttClientSubscriptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMqttClientSubscriptionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMqttClientSubscriptionsResponse() = default;
};
class InvokeFunctionRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> fileId{};
  shared_ptr<string> functionName{};
  shared_ptr<long> env{};
  shared_ptr<string> parameters{};

  InvokeFunctionRequest() {}

  explicit InvokeFunctionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<long>(boost::any_cast<long>(m["Env"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~InvokeFunctionRequest() = default;
};
class InvokeFunctionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> output{};
  shared_ptr<string> backEndRequestId{};

  InvokeFunctionResponseBodyResult() {}

  explicit InvokeFunctionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (output) {
      res["Output"] = boost::any(*output);
    }
    if (backEndRequestId) {
      res["BackEndRequestId"] = boost::any(*backEndRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Output") != m.end() && !m["Output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["Output"]));
    }
    if (m.find("BackEndRequestId") != m.end() && !m["BackEndRequestId"].empty()) {
      backEndRequestId = make_shared<string>(boost::any_cast<string>(m["BackEndRequestId"]));
    }
  }


  virtual ~InvokeFunctionResponseBodyResult() = default;
};
class InvokeFunctionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<InvokeFunctionResponseBodyResult> result{};

  InvokeFunctionResponseBody() {}

  explicit InvokeFunctionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InvokeFunctionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InvokeFunctionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~InvokeFunctionResponseBody() = default;
};
class InvokeFunctionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<InvokeFunctionResponseBody> body{};

  InvokeFunctionResponse() {}

  explicit InvokeFunctionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InvokeFunctionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InvokeFunctionResponseBody>(model1);
      }
    }
  }


  virtual ~InvokeFunctionResponse() = default;
};
class DeleteVersionAllWhiteDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> versionType{};
  shared_ptr<string> versionId{};

  DeleteVersionAllWhiteDevicesRequest() {}

  explicit DeleteVersionAllWhiteDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
  }


  virtual ~DeleteVersionAllWhiteDevicesRequest() = default;
};
class DeleteVersionAllWhiteDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteVersionAllWhiteDevicesResponseBody() {}

  explicit DeleteVersionAllWhiteDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteVersionAllWhiteDevicesResponseBody() = default;
};
class DeleteVersionAllWhiteDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteVersionAllWhiteDevicesResponseBody> body{};

  DeleteVersionAllWhiteDevicesResponse() {}

  explicit DeleteVersionAllWhiteDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVersionAllWhiteDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVersionAllWhiteDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVersionAllWhiteDevicesResponse() = default;
};
class DescribeMessageRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<long> messageId{};

  DescribeMessageRequest() {}

  explicit DescribeMessageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (messageId) {
      res["MessageId"] = boost::any(*messageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("MessageId") != m.end() && !m["MessageId"].empty()) {
      messageId = make_shared<long>(boost::any_cast<long>(m["MessageId"]));
    }
  }


  virtual ~DescribeMessageRequest() = default;
};
class DescribeMessageResponseBodyMessage : public Darabonba::Model {
public:
  shared_ptr<long> type{};
  shared_ptr<string> action{};
  shared_ptr<string> projectId{};
  shared_ptr<long> predictSendCnt{};
  shared_ptr<string> uri{};
  shared_ptr<string> desc{};
  shared_ptr<string> auditMsg{};
  shared_ptr<string> appName{};
  shared_ptr<string> appKey{};
  shared_ptr<long> gmtCreateTime{};
  shared_ptr<long> exipiredTime{};
  shared_ptr<long> ackCnt{};
  shared_ptr<string> title{};
  shared_ptr<string> parameter{};
  shared_ptr<long> audit{};
  shared_ptr<long> id{};
  shared_ptr<long> sendStatus{};

  DescribeMessageResponseBodyMessage() {}

  explicit DescribeMessageResponseBodyMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (predictSendCnt) {
      res["PredictSendCnt"] = boost::any(*predictSendCnt);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    if (desc) {
      res["Desc"] = boost::any(*desc);
    }
    if (auditMsg) {
      res["AuditMsg"] = boost::any(*auditMsg);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (gmtCreateTime) {
      res["GmtCreateTime"] = boost::any(*gmtCreateTime);
    }
    if (exipiredTime) {
      res["ExipiredTime"] = boost::any(*exipiredTime);
    }
    if (ackCnt) {
      res["AckCnt"] = boost::any(*ackCnt);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (parameter) {
      res["Parameter"] = boost::any(*parameter);
    }
    if (audit) {
      res["Audit"] = boost::any(*audit);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sendStatus) {
      res["SendStatus"] = boost::any(*sendStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PredictSendCnt") != m.end() && !m["PredictSendCnt"].empty()) {
      predictSendCnt = make_shared<long>(boost::any_cast<long>(m["PredictSendCnt"]));
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
    if (m.find("Desc") != m.end() && !m["Desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["Desc"]));
    }
    if (m.find("AuditMsg") != m.end() && !m["AuditMsg"].empty()) {
      auditMsg = make_shared<string>(boost::any_cast<string>(m["AuditMsg"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("GmtCreateTime") != m.end() && !m["GmtCreateTime"].empty()) {
      gmtCreateTime = make_shared<long>(boost::any_cast<long>(m["GmtCreateTime"]));
    }
    if (m.find("ExipiredTime") != m.end() && !m["ExipiredTime"].empty()) {
      exipiredTime = make_shared<long>(boost::any_cast<long>(m["ExipiredTime"]));
    }
    if (m.find("AckCnt") != m.end() && !m["AckCnt"].empty()) {
      ackCnt = make_shared<long>(boost::any_cast<long>(m["AckCnt"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("Parameter") != m.end() && !m["Parameter"].empty()) {
      parameter = make_shared<string>(boost::any_cast<string>(m["Parameter"]));
    }
    if (m.find("Audit") != m.end() && !m["Audit"].empty()) {
      audit = make_shared<long>(boost::any_cast<long>(m["Audit"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SendStatus") != m.end() && !m["SendStatus"].empty()) {
      sendStatus = make_shared<long>(boost::any_cast<long>(m["SendStatus"]));
    }
  }


  virtual ~DescribeMessageResponseBodyMessage() = default;
};
class DescribeMessageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMessageResponseBodyMessage> message{};

  DescribeMessageResponseBody() {}

  explicit DescribeMessageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = message ? boost::any(message->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      if (typeid(map<string, boost::any>) == m["Message"].type()) {
        DescribeMessageResponseBodyMessage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Message"]));
        message = make_shared<DescribeMessageResponseBodyMessage>(model1);
      }
    }
  }


  virtual ~DescribeMessageResponseBody() = default;
};
class DescribeMessageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMessageResponseBody> body{};

  DescribeMessageResponse() {}

  explicit DescribeMessageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMessageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMessageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMessageResponse() = default;
};
class UpdateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};

  UpdateProjectRequest() {}

  explicit UpdateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~UpdateProjectRequest() = default;
};
class UpdateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProjectResponseBody() {}

  explicit UpdateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProjectResponseBody() = default;
};
class UpdateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateProjectResponseBody> body{};

  UpdateProjectResponse() {}

  explicit UpdateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectResponse() = default;
};
class UpdateAppBlackWhiteVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> whiteAppVersions{};
  shared_ptr<string> projectId{};
  shared_ptr<string> versionId{};
  shared_ptr<string> blackAppVersions{};

  UpdateAppBlackWhiteVersionsRequest() {}

  explicit UpdateAppBlackWhiteVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteAppVersions) {
      res["WhiteAppVersions"] = boost::any(*whiteAppVersions);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    if (blackAppVersions) {
      res["BlackAppVersions"] = boost::any(*blackAppVersions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WhiteAppVersions") != m.end() && !m["WhiteAppVersions"].empty()) {
      whiteAppVersions = make_shared<string>(boost::any_cast<string>(m["WhiteAppVersions"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<string>(boost::any_cast<string>(m["VersionId"]));
    }
    if (m.find("BlackAppVersions") != m.end() && !m["BlackAppVersions"].empty()) {
      blackAppVersions = make_shared<string>(boost::any_cast<string>(m["BlackAppVersions"]));
    }
  }


  virtual ~UpdateAppBlackWhiteVersionsRequest() = default;
};
class UpdateAppBlackWhiteVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAppBlackWhiteVersionsResponseBody() {}

  explicit UpdateAppBlackWhiteVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAppBlackWhiteVersionsResponseBody() = default;
};
class UpdateAppBlackWhiteVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateAppBlackWhiteVersionsResponseBody> body{};

  UpdateAppBlackWhiteVersionsResponse() {}

  explicit UpdateAppBlackWhiteVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAppBlackWhiteVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAppBlackWhiteVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAppBlackWhiteVersionsResponse() = default;
};
class GetDeviceAppUpdateFunnelEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> packageName{};
  shared_ptr<string> projectId{};
  shared_ptr<string> targetVersionCode{};
  shared_ptr<string> idType{};
  shared_ptr<string> originalId{};

  GetDeviceAppUpdateFunnelEventsRequest() {}

  explicit GetDeviceAppUpdateFunnelEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (targetVersionCode) {
      res["TargetVersionCode"] = boost::any(*targetVersionCode);
    }
    if (idType) {
      res["IdType"] = boost::any(*idType);
    }
    if (originalId) {
      res["OriginalId"] = boost::any(*originalId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("TargetVersionCode") != m.end() && !m["TargetVersionCode"].empty()) {
      targetVersionCode = make_shared<string>(boost::any_cast<string>(m["TargetVersionCode"]));
    }
    if (m.find("IdType") != m.end() && !m["IdType"].empty()) {
      idType = make_shared<string>(boost::any_cast<string>(m["IdType"]));
    }
    if (m.find("OriginalId") != m.end() && !m["OriginalId"].empty()) {
      originalId = make_shared<string>(boost::any_cast<string>(m["OriginalId"]));
    }
  }


  virtual ~GetDeviceAppUpdateFunnelEventsRequest() = default;
};
class GetDeviceAppUpdateFunnelEventsResponseBodyEventList : public Darabonba::Model {
public:
  shared_ptr<string> packageName{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> targetVersionCode{};
  shared_ptr<string> event{};
  shared_ptr<long> reportTimestamp{};
  shared_ptr<string> reportTime{};
  shared_ptr<string> tenantId{};

  GetDeviceAppUpdateFunnelEventsResponseBodyEventList() {}

  explicit GetDeviceAppUpdateFunnelEventsResponseBodyEventList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (targetVersionCode) {
      res["TargetVersionCode"] = boost::any(*targetVersionCode);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (reportTimestamp) {
      res["ReportTimestamp"] = boost::any(*reportTimestamp);
    }
    if (reportTime) {
      res["ReportTime"] = boost::any(*reportTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("TargetVersionCode") != m.end() && !m["TargetVersionCode"].empty()) {
      targetVersionCode = make_shared<string>(boost::any_cast<string>(m["TargetVersionCode"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ReportTimestamp") != m.end() && !m["ReportTimestamp"].empty()) {
      reportTimestamp = make_shared<long>(boost::any_cast<long>(m["ReportTimestamp"]));
    }
    if (m.find("ReportTime") != m.end() && !m["ReportTime"].empty()) {
      reportTime = make_shared<string>(boost::any_cast<string>(m["ReportTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~GetDeviceAppUpdateFunnelEventsResponseBodyEventList() = default;
};
class GetDeviceAppUpdateFunnelEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetDeviceAppUpdateFunnelEventsResponseBodyEventList>> eventList{};

  GetDeviceAppUpdateFunnelEventsResponseBody() {}

  explicit GetDeviceAppUpdateFunnelEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (eventList) {
      vector<boost::any> temp1;
      for(auto item1:*eventList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("EventList") != m.end() && !m["EventList"].empty()) {
      if (typeid(vector<boost::any>) == m["EventList"].type()) {
        vector<GetDeviceAppUpdateFunnelEventsResponseBodyEventList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDeviceAppUpdateFunnelEventsResponseBodyEventList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventList = make_shared<vector<GetDeviceAppUpdateFunnelEventsResponseBodyEventList>>(expect1);
      }
    }
  }


  virtual ~GetDeviceAppUpdateFunnelEventsResponseBody() = default;
};
class GetDeviceAppUpdateFunnelEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetDeviceAppUpdateFunnelEventsResponseBody> body{};

  GetDeviceAppUpdateFunnelEventsResponse() {}

  explicit GetDeviceAppUpdateFunnelEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDeviceAppUpdateFunnelEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDeviceAppUpdateFunnelEventsResponseBody>(model1);
      }
    }
  }


  virtual ~GetDeviceAppUpdateFunnelEventsResponse() = default;
};
class GetNamespaceStatisticsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> dimensionType{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};

  GetNamespaceStatisticsDataRequest() {}

  explicit GetNamespaceStatisticsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (dimensionType) {
      res["DimensionType"] = boost::any(*dimensionType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("DimensionType") != m.end() && !m["DimensionType"].empty()) {
      dimensionType = make_shared<string>(boost::any_cast<string>(m["DimensionType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
  }


  virtual ~GetNamespaceStatisticsDataRequest() = default;
};
class GetNamespaceStatisticsDataResponseBodyStatisticsSeries : public Darabonba::Model {
public:
  shared_ptr<vector<long>> data{};
  shared_ptr<string> name{};

  GetNamespaceStatisticsDataResponseBodyStatisticsSeries() {}

  explicit GetNamespaceStatisticsDataResponseBodyStatisticsSeries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      data = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetNamespaceStatisticsDataResponseBodyStatisticsSeries() = default;
};
class GetNamespaceStatisticsDataResponseBodyStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<long>> categories{};
  shared_ptr<vector<GetNamespaceStatisticsDataResponseBodyStatisticsSeries>> series{};

  GetNamespaceStatisticsDataResponseBodyStatistics() {}

  explicit GetNamespaceStatisticsDataResponseBodyStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (series) {
      vector<boost::any> temp1;
      for(auto item1:*series){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Series"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      categories = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      if (typeid(vector<boost::any>) == m["Series"].type()) {
        vector<GetNamespaceStatisticsDataResponseBodyStatisticsSeries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Series"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNamespaceStatisticsDataResponseBodyStatisticsSeries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        series = make_shared<vector<GetNamespaceStatisticsDataResponseBodyStatisticsSeries>>(expect1);
      }
    }
  }


  virtual ~GetNamespaceStatisticsDataResponseBodyStatistics() = default;
};
class GetNamespaceStatisticsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetNamespaceStatisticsDataResponseBodyStatistics> statistics{};

  GetNamespaceStatisticsDataResponseBody() {}

  explicit GetNamespaceStatisticsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        GetNamespaceStatisticsDataResponseBodyStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<GetNamespaceStatisticsDataResponseBodyStatistics>(model1);
      }
    }
  }


  virtual ~GetNamespaceStatisticsDataResponseBody() = default;
};
class GetNamespaceStatisticsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetNamespaceStatisticsDataResponseBody> body{};

  GetNamespaceStatisticsDataResponse() {}

  explicit GetNamespaceStatisticsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNamespaceStatisticsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNamespaceStatisticsDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetNamespaceStatisticsDataResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ListDeviceBrandsResponse listDeviceBrandsWithOptions(shared_ptr<ListDeviceBrandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceBrandsResponse listDeviceBrands(shared_ptr<ListDeviceBrandsRequest> request);
  ListFunctionExecuteLogResponse listFunctionExecuteLogWithOptions(shared_ptr<ListFunctionExecuteLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFunctionExecuteLogResponse listFunctionExecuteLog(shared_ptr<ListFunctionExecuteLogRequest> request);
  ListDeviceModelsResponse listDeviceModelsWithOptions(shared_ptr<ListDeviceModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceModelsResponse listDeviceModels(shared_ptr<ListDeviceModelsRequest> request);
  ListMqttMessageLogsResponse listMqttMessageLogsWithOptions(shared_ptr<ListMqttMessageLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMqttMessageLogsResponse listMqttMessageLogs(shared_ptr<ListMqttMessageLogsRequest> request);
  DeleteNamespaceResponse deleteNamespaceWithOptions(shared_ptr<DeleteNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNamespaceResponse deleteNamespace(shared_ptr<DeleteNamespaceRequest> request);
  ListOfflineMessagesResponse listOfflineMessagesWithOptions(shared_ptr<ListOfflineMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOfflineMessagesResponse listOfflineMessages(shared_ptr<ListOfflineMessagesRequest> request);
  PushMessageResponse pushMessageWithOptions(shared_ptr<PushMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushMessageResponse pushMessage(shared_ptr<PushMessageRequest> request);
  DeleteCustomizedFilterResponse deleteCustomizedFilterWithOptions(shared_ptr<DeleteCustomizedFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomizedFilterResponse deleteCustomizedFilter(shared_ptr<DeleteCustomizedFilterRequest> request);
  DescribeMqttClientStatusResponse describeMqttClientStatusWithOptions(shared_ptr<DescribeMqttClientStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMqttClientStatusResponse describeMqttClientStatus(shared_ptr<DescribeMqttClientStatusRequest> request);
  DeleteDeviceResponse deleteDeviceWithOptions(shared_ptr<DeleteDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeviceResponse deleteDevice(shared_ptr<DeleteDeviceRequest> request);
  UpdateDeviceModelResponse updateDeviceModelWithOptions(shared_ptr<UpdateDeviceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDeviceModelResponse updateDeviceModel(shared_ptr<UpdateDeviceModelRequest> request);
  UpdateApiGatewayAppStatusResponse updateApiGatewayAppStatusWithOptions(shared_ptr<UpdateApiGatewayAppStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApiGatewayAppStatusResponse updateApiGatewayAppStatus(shared_ptr<UpdateApiGatewayAppStatusRequest> request);
  ListCameraShootingAttachmentsResponse listCameraShootingAttachmentsWithOptions(shared_ptr<ListCameraShootingAttachmentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCameraShootingAttachmentsResponse listCameraShootingAttachments(shared_ptr<ListCameraShootingAttachmentsRequest> request);
  ListAssistHistoriesResponse listAssistHistoriesWithOptions(shared_ptr<ListAssistHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAssistHistoriesResponse listAssistHistories(shared_ptr<ListAssistHistoriesRequest> request);
  GetDeviceSystemUpdateFunnelEventsResponse getDeviceSystemUpdateFunnelEventsWithOptions(shared_ptr<GetDeviceSystemUpdateFunnelEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceSystemUpdateFunnelEventsResponse getDeviceSystemUpdateFunnelEvents(shared_ptr<GetDeviceSystemUpdateFunnelEventsRequest> request);
  DeleteAllCustomizedFiltersResponse deleteAllCustomizedFiltersWithOptions(shared_ptr<DeleteAllCustomizedFiltersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllCustomizedFiltersResponse deleteAllCustomizedFilters(shared_ptr<DeleteAllCustomizedFiltersRequest> request);
  GenerateAssistFileUploadUrlResponse generateAssistFileUploadUrlWithOptions(shared_ptr<GenerateAssistFileUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateAssistFileUploadUrlResponse generateAssistFileUploadUrl(shared_ptr<GenerateAssistFileUploadUrlRequest> request);
  DescribeAssistWSServerAddressResponse describeAssistWSServerAddressWithOptions(shared_ptr<DescribeAssistWSServerAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssistWSServerAddressResponse describeAssistWSServerAddress(shared_ptr<DescribeAssistWSServerAddressRequest> request);
  FindPrepublishesByVersionIdResponse findPrepublishesByVersionIdWithOptions(shared_ptr<FindPrepublishesByVersionIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindPrepublishesByVersionIdResponse findPrepublishesByVersionId(shared_ptr<FindPrepublishesByVersionIdRequest> request);
  FindVersionMessagesResponse findVersionMessagesWithOptions(shared_ptr<FindVersionMessagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionMessagesResponse findVersionMessages(shared_ptr<FindVersionMessagesRequest> request);
  UpdateUpstreamAppServerResponse updateUpstreamAppServerWithOptions(shared_ptr<UpdateUpstreamAppServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUpstreamAppServerResponse updateUpstreamAppServer(shared_ptr<UpdateUpstreamAppServerRequest> request);
  GetVehicleTrackResponse getVehicleTrackWithOptions(shared_ptr<GetVehicleTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVehicleTrackResponse getVehicleTrack(shared_ptr<GetVehicleTrackRequest> request);
  CreateVersionTestResponse createVersionTestWithOptions(shared_ptr<CreateVersionTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVersionTestResponse createVersionTest(shared_ptr<CreateVersionTestRequest> request);
  ListDeployedFunctionsResponse listDeployedFunctionsWithOptions(shared_ptr<ListDeployedFunctionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeployedFunctionsResponse listDeployedFunctions(shared_ptr<ListDeployedFunctionsRequest> request);
  ListDeviceModelResponse listDeviceModelWithOptions(shared_ptr<ListDeviceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceModelResponse listDeviceModel(shared_ptr<ListDeviceModelRequest> request);
  CreateSchemaSubscribeResponse createSchemaSubscribeWithOptions(shared_ptr<CreateSchemaSubscribeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSchemaSubscribeResponse createSchemaSubscribe(shared_ptr<CreateSchemaSubscribeRequest> request);
  DescribeAssistRTMPServerAddressResponse describeAssistRTMPServerAddressWithOptions(shared_ptr<DescribeAssistRTMPServerAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssistRTMPServerAddressResponse describeAssistRTMPServerAddress(shared_ptr<DescribeAssistRTMPServerAddressRequest> request);
  DeleteShadowSchemaResponse deleteShadowSchemaWithOptions(shared_ptr<DeleteShadowSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteShadowSchemaResponse deleteShadowSchema(shared_ptr<DeleteShadowSchemaRequest> request);
  DescribeProjectAppSecurityResponse describeProjectAppSecurityWithOptions(shared_ptr<DescribeProjectAppSecurityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectAppSecurityResponse describeProjectAppSecurity(shared_ptr<DescribeProjectAppSecurityRequest> request);
  CreateDeviceBrandResponse createDeviceBrandWithOptions(shared_ptr<CreateDeviceBrandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceBrandResponse createDeviceBrand(shared_ptr<CreateDeviceBrandRequest> request);
  CreateMqttRootTopicResponse createMqttRootTopicWithOptions(shared_ptr<CreateMqttRootTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMqttRootTopicResponse createMqttRootTopic(shared_ptr<CreateMqttRootTopicRequest> request);
  DelayPublishOsVersionResponse delayPublishOsVersionWithOptions(shared_ptr<DelayPublishOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DelayPublishOsVersionResponse delayPublishOsVersion(shared_ptr<DelayPublishOsVersionRequest> request);
  ListPreChecksResponse listPreChecksWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPreChecksResponse listPreChecks();
  ListAppsResponse listAppsWithOptions(shared_ptr<ListAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAppsResponse listApps(shared_ptr<ListAppsRequest> request);
  DeleteCameraShootingRecordResponse deleteCameraShootingRecordWithOptions(shared_ptr<DeleteCameraShootingRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCameraShootingRecordResponse deleteCameraShootingRecord(shared_ptr<DeleteCameraShootingRecordRequest> request);
  DescribeDeviceResponse describeDeviceWithOptions(shared_ptr<DescribeDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceResponse describeDevice(shared_ptr<DescribeDeviceRequest> request);
  AddVersionGroupDevicesResponse addVersionGroupDevicesWithOptions(shared_ptr<AddVersionGroupDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVersionGroupDevicesResponse addVersionGroupDevices(shared_ptr<AddVersionGroupDevicesRequest> request);
  ListProjectAppsResponse listProjectAppsWithOptions(shared_ptr<ListProjectAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectAppsResponse listProjectApps(shared_ptr<ListProjectAppsRequest> request);
  ConnectAssistDeviceResponse connectAssistDeviceWithOptions(shared_ptr<ConnectAssistDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConnectAssistDeviceResponse connectAssistDevice(shared_ptr<ConnectAssistDeviceRequest> request);
  ListApiGatewayAppsResponse listApiGatewayAppsWithOptions(shared_ptr<ListApiGatewayAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApiGatewayAppsResponse listApiGatewayApps(shared_ptr<ListApiGatewayAppsRequest> request);
  DeleteRpcServiceResponse deleteRpcServiceWithOptions(shared_ptr<DeleteRpcServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRpcServiceResponse deleteRpcService(shared_ptr<DeleteRpcServiceRequest> request);
  FindPrepublishPassedDevicesResponse findPrepublishPassedDevicesWithOptions(shared_ptr<FindPrepublishPassedDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindPrepublishPassedDevicesResponse findPrepublishPassedDevices(shared_ptr<FindPrepublishPassedDevicesRequest> request);
  DeleteVersionBlackDevicesByIdResponse deleteVersionBlackDevicesByIdWithOptions(shared_ptr<DeleteVersionBlackDevicesByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionBlackDevicesByIdResponse deleteVersionBlackDevicesById(shared_ptr<DeleteVersionBlackDevicesByIdRequest> request);
  DescribeOpenAccountResponse describeOpenAccountWithOptions(shared_ptr<DescribeOpenAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOpenAccountResponse describeOpenAccount(shared_ptr<DescribeOpenAccountRequest> request);
  FindCustomizedFiltersResponse findCustomizedFiltersWithOptions(shared_ptr<FindCustomizedFiltersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindCustomizedFiltersResponse findCustomizedFilters(shared_ptr<FindCustomizedFiltersRequest> request);
  DeployFunctionFileResponse deployFunctionFileWithOptions(shared_ptr<DeployFunctionFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployFunctionFileResponse deployFunctionFile(shared_ptr<DeployFunctionFileRequest> request);
  ListAssistActionDetailsResponse listAssistActionDetailsWithOptions(shared_ptr<ListAssistActionDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAssistActionDetailsResponse listAssistActionDetails(shared_ptr<ListAssistActionDetailsRequest> request);
  DescribeMqttTopicSubscriptionResponse describeMqttTopicSubscriptionWithOptions(shared_ptr<DescribeMqttTopicSubscriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMqttTopicSubscriptionResponse describeMqttTopicSubscription(shared_ptr<DescribeMqttTopicSubscriptionRequest> request);
  PushVersionMessageResponse pushVersionMessageWithOptions(shared_ptr<PushVersionMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushVersionMessageResponse pushVersionMessage(shared_ptr<PushVersionMessageRequest> request);
  CountDeviceModelsResponse countDeviceModelsWithOptions(shared_ptr<CountDeviceModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountDeviceModelsResponse countDeviceModels(shared_ptr<CountDeviceModelsRequest> request);
  CreateDeviceResponse createDeviceWithOptions(shared_ptr<CreateDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceResponse createDevice(shared_ptr<CreateDeviceRequest> request);
  CreateNamespaceResponse createNamespaceWithOptions(shared_ptr<CreateNamespaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNamespaceResponse createNamespace(shared_ptr<CreateNamespaceRequest> request);
  FindVersionDeviceGroupsResponse findVersionDeviceGroupsWithOptions(shared_ptr<FindVersionDeviceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionDeviceGroupsResponse findVersionDeviceGroups(shared_ptr<FindVersionDeviceGroupsRequest> request);
  ExecuteRemoteCommandResponse executeRemoteCommandWithOptions(shared_ptr<ExecuteRemoteCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteRemoteCommandResponse executeRemoteCommand(shared_ptr<ExecuteRemoteCommandRequest> request);
  CreateVersionDeviceGroupResponse createVersionDeviceGroupWithOptions(shared_ptr<CreateVersionDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVersionDeviceGroupResponse createVersionDeviceGroup(shared_ptr<CreateVersionDeviceGroupRequest> request);
  DescribeAssistReportResponse describeAssistReportWithOptions(shared_ptr<DescribeAssistReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAssistReportResponse describeAssistReport(shared_ptr<DescribeAssistReportRequest> request);
  ListConnectLogsResponse listConnectLogsWithOptions(shared_ptr<ListConnectLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConnectLogsResponse listConnectLogs(shared_ptr<ListConnectLogsRequest> request);
  ListClientPluginsResponse listClientPluginsWithOptions(shared_ptr<ListClientPluginsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientPluginsResponse listClientPlugins(shared_ptr<ListClientPluginsRequest> request);
  DescribeShadowSchemaResponse describeShadowSchemaWithOptions(shared_ptr<DescribeShadowSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeShadowSchemaResponse describeShadowSchema(shared_ptr<DescribeShadowSchemaRequest> request);
  FindVersionBlackDevicesResponse findVersionBlackDevicesWithOptions(shared_ptr<FindVersionBlackDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionBlackDevicesResponse findVersionBlackDevices(shared_ptr<FindVersionBlackDevicesRequest> request);
  ListFunctionFilesResponse listFunctionFilesWithOptions(shared_ptr<ListFunctionFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFunctionFilesResponse listFunctionFiles(shared_ptr<ListFunctionFilesRequest> request);
  UpdateNamespaceDataResponse updateNamespaceDataWithOptions(shared_ptr<UpdateNamespaceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNamespaceDataResponse updateNamespaceData(shared_ptr<UpdateNamespaceDataRequest> request);
  ListEdgeDevicesResponse listEdgeDevicesWithOptions(shared_ptr<ListEdgeDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEdgeDevicesResponse listEdgeDevices(shared_ptr<ListEdgeDevicesRequest> request);
  DeleteCustomizedPropertyResponse deleteCustomizedPropertyWithOptions(shared_ptr<DeleteCustomizedPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomizedPropertyResponse deleteCustomizedProperty(shared_ptr<DeleteCustomizedPropertyRequest> request);
  UpdateAppVersionReleaseNoteResponse updateAppVersionReleaseNoteWithOptions(shared_ptr<UpdateAppVersionReleaseNoteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppVersionReleaseNoteResponse updateAppVersionReleaseNote(shared_ptr<UpdateAppVersionReleaseNoteRequest> request);
  CreateTriggerResponse createTriggerWithOptions(shared_ptr<CreateTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTriggerResponse createTrigger(shared_ptr<CreateTriggerRequest> request);
  DiagnosisVersionResponse diagnosisVersionWithOptions(shared_ptr<DiagnosisVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiagnosisVersionResponse diagnosisVersion(shared_ptr<DiagnosisVersionRequest> request);
  ListShadowSchemaDeviceModelsResponse listShadowSchemaDeviceModelsWithOptions(shared_ptr<ListShadowSchemaDeviceModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListShadowSchemaDeviceModelsResponse listShadowSchemaDeviceModels(shared_ptr<ListShadowSchemaDeviceModelsRequest> request);
  PushConfigInfoResponse pushConfigInfoWithOptions(shared_ptr<PushConfigInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushConfigInfoResponse pushConfigInfo(shared_ptr<PushConfigInfoRequest> request);
  GenerateOssUploadMetaResponse generateOssUploadMetaWithOptions(shared_ptr<GenerateOssUploadMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOssUploadMetaResponse generateOssUploadMeta(shared_ptr<GenerateOssUploadMetaRequest> request);
  AddVersionBlackDevicesResponse addVersionBlackDevicesWithOptions(shared_ptr<AddVersionBlackDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVersionBlackDevicesResponse addVersionBlackDevices(shared_ptr<AddVersionBlackDevicesRequest> request);
  DescribeCustomizedFilterResponse describeCustomizedFilterWithOptions(shared_ptr<DescribeCustomizedFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomizedFilterResponse describeCustomizedFilter(shared_ptr<DescribeCustomizedFilterRequest> request);
  DescribeDeviceIdByOuterInfoResponse describeDeviceIdByOuterInfoWithOptions(shared_ptr<DescribeDeviceIdByOuterInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceIdByOuterInfoResponse describeDeviceIdByOuterInfo(shared_ptr<DescribeDeviceIdByOuterInfoRequest> request);
  CreateAppVersionResponse createAppVersionWithOptions(shared_ptr<CreateAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppVersionResponse createAppVersion(shared_ptr<CreateAppVersionRequest> request);
  CountActivatedOrNewRegistrationDeviceResponse countActivatedOrNewRegistrationDeviceWithOptions(shared_ptr<CountActivatedOrNewRegistrationDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountActivatedOrNewRegistrationDeviceResponse countActivatedOrNewRegistrationDevice(shared_ptr<CountActivatedOrNewRegistrationDeviceRequest> request);
  ListDevicesResponse listDevicesWithOptions(shared_ptr<ListDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDevicesResponse listDevices(shared_ptr<ListDevicesRequest> request);
  FindVersionTestsResponse findVersionTestsWithOptions(shared_ptr<FindVersionTestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionTestsResponse findVersionTests(shared_ptr<FindVersionTestsRequest> request);
  PublishOsVersionResponse publishOsVersionWithOptions(shared_ptr<PublishOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishOsVersionResponse publishOsVersion(shared_ptr<PublishOsVersionRequest> request);
  CreateUpstreamAppKeyRelationsResponse createUpstreamAppKeyRelationsWithOptions(shared_ptr<CreateUpstreamAppKeyRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUpstreamAppKeyRelationsResponse createUpstreamAppKeyRelations(shared_ptr<CreateUpstreamAppKeyRelationsRequest> request);
  UpdateOsVersionReleaseNoteResponse updateOsVersionReleaseNoteWithOptions(shared_ptr<UpdateOsVersionReleaseNoteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsVersionReleaseNoteResponse updateOsVersionReleaseNote(shared_ptr<UpdateOsVersionReleaseNoteRequest> request);
  PublishAppVersionResponse publishAppVersionWithOptions(shared_ptr<PublishAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishAppVersionResponse publishAppVersion(shared_ptr<PublishAppVersionRequest> request);
  PublishMqttMessageResponse publishMqttMessageWithOptions(shared_ptr<PublishMqttMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishMqttMessageResponse publishMqttMessage(shared_ptr<PublishMqttMessageRequest> request);
  DeleteVersionGroupDeviceResponse deleteVersionGroupDeviceWithOptions(shared_ptr<DeleteVersionGroupDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionGroupDeviceResponse deleteVersionGroupDevice(shared_ptr<DeleteVersionGroupDeviceRequest> request);
  DeleteFunctionFileResponse deleteFunctionFileWithOptions(shared_ptr<DeleteFunctionFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFunctionFileResponse deleteFunctionFile(shared_ptr<DeleteFunctionFileRequest> request);
  AddVersionWhiteDevicesResponse addVersionWhiteDevicesWithOptions(shared_ptr<AddVersionWhiteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVersionWhiteDevicesResponse addVersionWhiteDevices(shared_ptr<AddVersionWhiteDevicesRequest> request);
  ListAssistHistoryDetailsResponse listAssistHistoryDetailsWithOptions(shared_ptr<ListAssistHistoryDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAssistHistoryDetailsResponse listAssistHistoryDetails(shared_ptr<ListAssistHistoryDetailsRequest> request);
  CreateCustomizedFilterResponse createCustomizedFilterWithOptions(shared_ptr<CreateCustomizedFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomizedFilterResponse createCustomizedFilter(shared_ptr<CreateCustomizedFilterRequest> request);
  DeleteUpstreamAppKeyRelationResponse deleteUpstreamAppKeyRelationWithOptions(shared_ptr<DeleteUpstreamAppKeyRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUpstreamAppKeyRelationResponse deleteUpstreamAppKeyRelation(shared_ptr<DeleteUpstreamAppKeyRelationRequest> request);
  DescribeAppVersionResponse describeAppVersionWithOptions(shared_ptr<DescribeAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppVersionResponse describeAppVersion(shared_ptr<DescribeAppVersionRequest> request);
  ListVehicleResponse listVehicleWithOptions(shared_ptr<ListVehicleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVehicleResponse listVehicle(shared_ptr<ListVehicleRequest> request);
  ExecuteCameraShootingCommandResponse executeCameraShootingCommandWithOptions(shared_ptr<ExecuteCameraShootingCommandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteCameraShootingCommandResponse executeCameraShootingCommand(shared_ptr<ExecuteCameraShootingCommandRequest> request);
  DeleteVersionDeviceGroupResponse deleteVersionDeviceGroupWithOptions(shared_ptr<DeleteVersionDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionDeviceGroupResponse deleteVersionDeviceGroup(shared_ptr<DeleteVersionDeviceGroupRequest> request);
  ListFunctionFilesByProjectIdResponse listFunctionFilesByProjectIdWithOptions(shared_ptr<ListFunctionFilesByProjectIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFunctionFilesByProjectIdResponse listFunctionFilesByProjectId(shared_ptr<ListFunctionFilesByProjectIdRequest> request);
  FindVersionWhiteDevicesResponse findVersionWhiteDevicesWithOptions(shared_ptr<FindVersionWhiteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionWhiteDevicesResponse findVersionWhiteDevices(shared_ptr<FindVersionWhiteDevicesRequest> request);
  CreateUpstreamAppServerResponse createUpstreamAppServerWithOptions(shared_ptr<CreateUpstreamAppServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUpstreamAppServerResponse createUpstreamAppServer(shared_ptr<CreateUpstreamAppServerRequest> request);
  DescribeVersionDeviceGroupResponse describeVersionDeviceGroupWithOptions(shared_ptr<DescribeVersionDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVersionDeviceGroupResponse describeVersionDeviceGroup(shared_ptr<DescribeVersionDeviceGroupRequest> request);
  UpdateAppVersionResponse updateAppVersionWithOptions(shared_ptr<UpdateAppVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppVersionResponse updateAppVersion(shared_ptr<UpdateAppVersionRequest> request);
  CreateCustomizedPropertyResponse createCustomizedPropertyWithOptions(shared_ptr<CreateCustomizedPropertyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomizedPropertyResponse createCustomizedProperty(shared_ptr<CreateCustomizedPropertyRequest> request);
  ListSchemaSubscribesResponse listSchemaSubscribesWithOptions(shared_ptr<ListSchemaSubscribesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSchemaSubscribesResponse listSchemaSubscribes(shared_ptr<ListSchemaSubscribesRequest> request);
  UpdateSchemaSubscribeResponse updateSchemaSubscribeWithOptions(shared_ptr<UpdateSchemaSubscribeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSchemaSubscribeResponse updateSchemaSubscribe(shared_ptr<UpdateSchemaSubscribeRequest> request);
  DeleteAllVersionGroupDevicesResponse deleteAllVersionGroupDevicesWithOptions(shared_ptr<DeleteAllVersionGroupDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllVersionGroupDevicesResponse deleteAllVersionGroupDevices(shared_ptr<DeleteAllVersionGroupDevicesRequest> request);
  DeleteVersionWhiteDevicesByIdResponse deleteVersionWhiteDevicesByIdWithOptions(shared_ptr<DeleteVersionWhiteDevicesByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionWhiteDevicesByIdResponse deleteVersionWhiteDevicesById(shared_ptr<DeleteVersionWhiteDevicesByIdRequest> request);
  UpdateOsVersionResponse updateOsVersionWithOptions(shared_ptr<UpdateOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsVersionResponse updateOsVersion(shared_ptr<UpdateOsVersionRequest> request);
  GenerateOssPostPolicyResponse generateOssPostPolicyWithOptions(shared_ptr<GenerateOssPostPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateOssPostPolicyResponse generateOssPostPolicy(shared_ptr<GenerateOssPostPolicyRequest> request);
  FindVersionGroupDevicesResponse findVersionGroupDevicesWithOptions(shared_ptr<FindVersionGroupDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionGroupDevicesResponse findVersionGroupDevices(shared_ptr<FindVersionGroupDevicesRequest> request);
  DeleteOpenAccountResponse deleteOpenAccountWithOptions(shared_ptr<DeleteOpenAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOpenAccountResponse deleteOpenAccount(shared_ptr<DeleteOpenAccountRequest> request);
  DescribeDefaultSchemaResponse describeDefaultSchemaWithOptions(shared_ptr<DescribeDefaultSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDefaultSchemaResponse describeDefaultSchema(shared_ptr<DescribeDefaultSchemaRequest> request);
  ListUpstreamAppServersResponse listUpstreamAppServersWithOptions(shared_ptr<ListUpstreamAppServersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamAppServersResponse listUpstreamAppServers(shared_ptr<ListUpstreamAppServersRequest> request);
  DeleteVersionTestResponse deleteVersionTestWithOptions(shared_ptr<DeleteVersionTestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionTestResponse deleteVersionTest(shared_ptr<DeleteVersionTestRequest> request);
  CreateUpstreamAppKeyRelationResponse createUpstreamAppKeyRelationWithOptions(shared_ptr<CreateUpstreamAppKeyRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUpstreamAppKeyRelationResponse createUpstreamAppKeyRelation(shared_ptr<CreateUpstreamAppKeyRelationRequest> request);
  FindAppVersionsResponse findAppVersionsWithOptions(shared_ptr<FindAppVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindAppVersionsResponse findAppVersions(shared_ptr<FindAppVersionsRequest> request);
  ListMqttRootTopicsResponse listMqttRootTopicsWithOptions(shared_ptr<ListMqttRootTopicsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMqttRootTopicsResponse listMqttRootTopics(shared_ptr<ListMqttRootTopicsRequest> request);
  ListAssistDevicesResponse listAssistDevicesWithOptions(shared_ptr<ListAssistDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAssistDevicesResponse listAssistDevices(shared_ptr<ListAssistDevicesRequest> request);
  DeleteUpstreamAppServerResponse deleteUpstreamAppServerWithOptions(shared_ptr<DeleteUpstreamAppServerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUpstreamAppServerResponse deleteUpstreamAppServer(shared_ptr<DeleteUpstreamAppServerRequest> request);
  UpdateVersionDeviceGroupResponse updateVersionDeviceGroupWithOptions(shared_ptr<UpdateVersionDeviceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVersionDeviceGroupResponse updateVersionDeviceGroup(shared_ptr<UpdateVersionDeviceGroupRequest> request);
  ListOpenAccountsResponse listOpenAccountsWithOptions(shared_ptr<ListOpenAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOpenAccountsResponse listOpenAccounts(shared_ptr<ListOpenAccountsRequest> request);
  UpdateOsVersionStatusResponse updateOsVersionStatusWithOptions(shared_ptr<UpdateOsVersionStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsVersionStatusResponse updateOsVersionStatus(shared_ptr<UpdateOsVersionStatusRequest> request);
  CountProjectsResponse countProjectsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountProjectsResponse countProjects();
  ListCommercialVehicleDevicesResponse listCommercialVehicleDevicesWithOptions(shared_ptr<ListCommercialVehicleDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCommercialVehicleDevicesResponse listCommercialVehicleDevices(shared_ptr<ListCommercialVehicleDevicesRequest> request);
  ListMessageReceiversResponse listMessageReceiversWithOptions(shared_ptr<ListMessageReceiversRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageReceiversResponse listMessageReceivers(shared_ptr<ListMessageReceiversRequest> request);
  CountDevicesResponse countDevicesWithOptions(shared_ptr<CountDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountDevicesResponse countDevices(shared_ptr<CountDevicesRequest> request);
  UpdateOsBlackWhiteVersionsResponse updateOsBlackWhiteVersionsWithOptions(shared_ptr<UpdateOsBlackWhiteVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsBlackWhiteVersionsResponse updateOsBlackWhiteVersions(shared_ptr<UpdateOsBlackWhiteVersionsRequest> request);
  GetNamespaceDataResponse getNamespaceDataWithOptions(shared_ptr<GetNamespaceDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNamespaceDataResponse getNamespaceData(shared_ptr<GetNamespaceDataRequest> request);
  UpdateOsVersionRemarkResponse updateOsVersionRemarkWithOptions(shared_ptr<UpdateOsVersionRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOsVersionRemarkResponse updateOsVersionRemark(shared_ptr<UpdateOsVersionRemarkRequest> request);
  QueryPrepublishPassedDeviceCountResponse queryPrepublishPassedDeviceCountWithOptions(shared_ptr<QueryPrepublishPassedDeviceCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryPrepublishPassedDeviceCountResponse queryPrepublishPassedDeviceCount(shared_ptr<QueryPrepublishPassedDeviceCountRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<CreateProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<CreateProjectRequest> request);
  ListNamespacesResponse listNamespacesWithOptions(shared_ptr<ListNamespacesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNamespacesResponse listNamespaces(shared_ptr<ListNamespacesRequest> request);
  ListSupportFeaturesResponse listSupportFeaturesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSupportFeaturesResponse listSupportFeatures();
  DeleteMqttRootTopicResponse deleteMqttRootTopicWithOptions(shared_ptr<DeleteMqttRootTopicRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMqttRootTopicResponse deleteMqttRootTopic(shared_ptr<DeleteMqttRootTopicRequest> request);
  DeleteVersionGroupDeviceByIdResponse deleteVersionGroupDeviceByIdWithOptions(shared_ptr<DeleteVersionGroupDeviceByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionGroupDeviceByIdResponse deleteVersionGroupDeviceById(shared_ptr<DeleteVersionGroupDeviceByIdRequest> request);
  ListClientPluginVersionsResponse listClientPluginVersionsWithOptions(shared_ptr<ListClientPluginVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientPluginVersionsResponse listClientPluginVersions(shared_ptr<ListClientPluginVersionsRequest> request);
  FindVersionMessageSendRecordsResponse findVersionMessageSendRecordsWithOptions(shared_ptr<FindVersionMessageSendRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindVersionMessageSendRecordsResponse findVersionMessageSendRecords(shared_ptr<FindVersionMessageSendRecordsRequest> request);
  GenerateSysAppDownloadInfoResponse generateSysAppDownloadInfoWithOptions(shared_ptr<GenerateSysAppDownloadInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateSysAppDownloadInfoResponse generateSysAppDownloadInfo(shared_ptr<GenerateSysAppDownloadInfoRequest> request);
  DeleteTriggerResponse deleteTriggerWithOptions(shared_ptr<DeleteTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTriggerResponse deleteTrigger(shared_ptr<DeleteTriggerRequest> request);
  DescribeDeviceInfoResponse describeDeviceInfoWithOptions(shared_ptr<DescribeDeviceInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceInfoResponse describeDeviceInfo(shared_ptr<DescribeDeviceInfoRequest> request);
  CreateDeviceModelResponse createDeviceModelWithOptions(shared_ptr<CreateDeviceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDeviceModelResponse createDeviceModel(shared_ptr<CreateDeviceModelRequest> request);
  UpdateAppVersionStatusResponse updateAppVersionStatusWithOptions(shared_ptr<UpdateAppVersionStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppVersionStatusResponse updateAppVersionStatus(shared_ptr<UpdateAppVersionStatusRequest> request);
  UpdateShadowSchemaResponse updateShadowSchemaWithOptions(shared_ptr<UpdateShadowSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateShadowSchemaResponse updateShadowSchema(shared_ptr<UpdateShadowSchemaRequest> request);
  DescribeDeviceShadowResponse describeDeviceShadowWithOptions(shared_ptr<DescribeDeviceShadowRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceShadowResponse describeDeviceShadow(shared_ptr<DescribeDeviceShadowRequest> request);
  ListTriggersResponse listTriggersWithOptions(shared_ptr<ListTriggersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTriggersResponse listTriggers(shared_ptr<ListTriggersRequest> request);
  UpdateCustomizedFilterResponse updateCustomizedFilterWithOptions(shared_ptr<UpdateCustomizedFilterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomizedFilterResponse updateCustomizedFilter(shared_ptr<UpdateCustomizedFilterRequest> request);
  CreateVersionPrepublishResponse createVersionPrepublishWithOptions(shared_ptr<CreateVersionPrepublishRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVersionPrepublishResponse createVersionPrepublish(shared_ptr<CreateVersionPrepublishRequest> request);
  UpdateAppVersionRemarkResponse updateAppVersionRemarkWithOptions(shared_ptr<UpdateAppVersionRemarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppVersionRemarkResponse updateAppVersionRemark(shared_ptr<UpdateAppVersionRemarkRequest> request);
  DescribeDeviceModelResponse describeDeviceModelWithOptions(shared_ptr<DescribeDeviceModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceModelResponse describeDeviceModel(shared_ptr<DescribeDeviceModelRequest> request);
  ListDeviceTypesResponse listDeviceTypesWithOptions(shared_ptr<ListDeviceTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeviceTypesResponse listDeviceTypes(shared_ptr<ListDeviceTypesRequest> request);
  GenerateSdkDownloadInfoResponse generateSdkDownloadInfoWithOptions(shared_ptr<GenerateSdkDownloadInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateSdkDownloadInfoResponse generateSdkDownloadInfo(shared_ptr<GenerateSdkDownloadInfoRequest> request);
  ExecuteVehicleControlResponse executeVehicleControlWithOptions(shared_ptr<ExecuteVehicleControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteVehicleControlResponse executeVehicleControl(shared_ptr<ExecuteVehicleControlRequest> request);
  DescribeApiGatewayAppSecurityResponse describeApiGatewayAppSecurityWithOptions(shared_ptr<DescribeApiGatewayAppSecurityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGatewayAppSecurityResponse describeApiGatewayAppSecurity(shared_ptr<DescribeApiGatewayAppSecurityRequest> request);
  DescribeDeviceOnlineInfoResponse describeDeviceOnlineInfoWithOptions(shared_ptr<DescribeDeviceOnlineInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceOnlineInfoResponse describeDeviceOnlineInfo(shared_ptr<DescribeDeviceOnlineInfoRequest> request);
  CreateRpcServiceResponse createRpcServiceWithOptions(shared_ptr<CreateRpcServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRpcServiceResponse createRpcService(shared_ptr<CreateRpcServiceRequest> request);
  DeleteVersionWhiteDevicesResponse deleteVersionWhiteDevicesWithOptions(shared_ptr<DeleteVersionWhiteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionWhiteDevicesResponse deleteVersionWhiteDevices(shared_ptr<DeleteVersionWhiteDevicesRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects();
  GenerateFunctionFileUploadMetaResponse generateFunctionFileUploadMetaWithOptions(shared_ptr<GenerateFunctionFileUploadMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateFunctionFileUploadMetaResponse generateFunctionFileUploadMeta(shared_ptr<GenerateFunctionFileUploadMetaRequest> request);
  DescribeProjectResponse describeProjectWithOptions(shared_ptr<DescribeProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectResponse describeProject(shared_ptr<DescribeProjectRequest> request);
  DescribeMqttMessageResponse describeMqttMessageWithOptions(shared_ptr<DescribeMqttMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMqttMessageResponse describeMqttMessage(shared_ptr<DescribeMqttMessageRequest> request);
  ListCameraShootingRecordsResponse listCameraShootingRecordsWithOptions(shared_ptr<ListCameraShootingRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCameraShootingRecordsResponse listCameraShootingRecords(shared_ptr<ListCameraShootingRecordsRequest> request);
  DeleteVersionBlackDevicesResponse deleteVersionBlackDevicesWithOptions(shared_ptr<DeleteVersionBlackDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionBlackDevicesResponse deleteVersionBlackDevices(shared_ptr<DeleteVersionBlackDevicesRequest> request);
  DescribeOsVersionResponse describeOsVersionWithOptions(shared_ptr<DescribeOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOsVersionResponse describeOsVersion(shared_ptr<DescribeOsVersionRequest> request);
  ListRpcServicesResponse listRpcServicesWithOptions(shared_ptr<ListRpcServicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRpcServicesResponse listRpcServices(shared_ptr<ListRpcServicesRequest> request);
  DeleteSchemaSubscribeResponse deleteSchemaSubscribeWithOptions(shared_ptr<DeleteSchemaSubscribeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSchemaSubscribeResponse deleteSchemaSubscribe(shared_ptr<DeleteSchemaSubscribeRequest> request);
  AddUploadedFunctionFileInfoResponse addUploadedFunctionFileInfoWithOptions(shared_ptr<AddUploadedFunctionFileInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUploadedFunctionFileInfoResponse addUploadedFunctionFileInfo(shared_ptr<AddUploadedFunctionFileInfoRequest> request);
  CreateProjectAppResponse createProjectAppWithOptions(shared_ptr<CreateProjectAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectAppResponse createProjectApp(shared_ptr<CreateProjectAppRequest> request);
  ListServicesResponse listServicesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServicesResponse listServices();
  FindOsVersionsResponse findOsVersionsWithOptions(shared_ptr<FindOsVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindOsVersionsResponse findOsVersions(shared_ptr<FindOsVersionsRequest> request);
  UpdateVersionPrepublishActiveStatusResponse updateVersionPrepublishActiveStatusWithOptions(shared_ptr<UpdateVersionPrepublishActiveStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateVersionPrepublishActiveStatusResponse updateVersionPrepublishActiveStatus(shared_ptr<UpdateVersionPrepublishActiveStatusRequest> request);
  CreateOsVersionResponse createOsVersionWithOptions(shared_ptr<CreateOsVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOsVersionResponse createOsVersion(shared_ptr<CreateOsVersionRequest> request);
  CountDeviceBrandsResponse countDeviceBrandsWithOptions(shared_ptr<CountDeviceBrandsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountDeviceBrandsResponse countDeviceBrands(shared_ptr<CountDeviceBrandsRequest> request);
  DescribeDeviceBrandResponse describeDeviceBrandWithOptions(shared_ptr<DescribeDeviceBrandRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceBrandResponse describeDeviceBrand(shared_ptr<DescribeDeviceBrandRequest> request);
  CreateShadowSchemaResponse createShadowSchemaWithOptions(shared_ptr<CreateShadowSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateShadowSchemaResponse createShadowSchema(shared_ptr<CreateShadowSchemaRequest> request);
  DescribeDeviceValiditySchemaResponse describeDeviceValiditySchemaWithOptions(shared_ptr<DescribeDeviceValiditySchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceValiditySchemaResponse describeDeviceValiditySchema(shared_ptr<DescribeDeviceValiditySchemaRequest> request);
  GetOssUploadMetaResponse getOssUploadMetaWithOptions(shared_ptr<GetOssUploadMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOssUploadMetaResponse getOssUploadMeta(shared_ptr<GetOssUploadMetaRequest> request);
  ListUpstreamAppKeyRelationsResponse listUpstreamAppKeyRelationsWithOptions(shared_ptr<ListUpstreamAppKeyRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUpstreamAppKeyRelationsResponse listUpstreamAppKeyRelations(shared_ptr<ListUpstreamAppKeyRelationsRequest> request);
  ListShadowSchemasResponse listShadowSchemasWithOptions(shared_ptr<ListShadowSchemasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListShadowSchemasResponse listShadowSchemas(shared_ptr<ListShadowSchemasRequest> request);
  DeleteProjectAppResponse deleteProjectAppWithOptions(shared_ptr<DeleteProjectAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectAppResponse deleteProjectApp(shared_ptr<DeleteProjectAppRequest> request);
  CountYunIdInfoResponse countYunIdInfoWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CountYunIdInfoResponse countYunIdInfo();
  FindPrepublishesByParentIdResponse findPrepublishesByParentIdWithOptions(shared_ptr<FindPrepublishesByParentIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindPrepublishesByParentIdResponse findPrepublishesByParentId(shared_ptr<FindPrepublishesByParentIdRequest> request);
  GetVehicleControlResultResponse getVehicleControlResultWithOptions(shared_ptr<GetVehicleControlResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVehicleControlResultResponse getVehicleControlResult(shared_ptr<GetVehicleControlResultRequest> request);
  UpdateTriggerResponse updateTriggerWithOptions(shared_ptr<UpdateTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTriggerResponse updateTrigger(shared_ptr<UpdateTriggerRequest> request);
  ListClientSdksResponse listClientSdksWithOptions(shared_ptr<ListClientSdksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListClientSdksResponse listClientSdks(shared_ptr<ListClientSdksRequest> request);
  ListVersionDeviceGroupsResponse listVersionDeviceGroupsWithOptions(shared_ptr<ListVersionDeviceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVersionDeviceGroupsResponse listVersionDeviceGroups(shared_ptr<ListVersionDeviceGroupsRequest> request);
  GetCommercialVehicleDeviceResponse getCommercialVehicleDeviceWithOptions(shared_ptr<GetCommercialVehicleDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCommercialVehicleDeviceResponse getCommercialVehicleDevice(shared_ptr<GetCommercialVehicleDeviceRequest> request);
  SubmitAssistReportResponse submitAssistReportWithOptions(shared_ptr<SubmitAssistReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitAssistReportResponse submitAssistReport(shared_ptr<SubmitAssistReportRequest> request);
  DeleteVersionAllBlackDevicesResponse deleteVersionAllBlackDevicesWithOptions(shared_ptr<DeleteVersionAllBlackDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionAllBlackDevicesResponse deleteVersionAllBlackDevices(shared_ptr<DeleteVersionAllBlackDevicesRequest> request);
  ListOpenAccountLinksResponse listOpenAccountLinksWithOptions(shared_ptr<ListOpenAccountLinksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOpenAccountLinksResponse listOpenAccountLinks(shared_ptr<ListOpenAccountLinksRequest> request);
  AddVersionWhiteDevicesByDeviceGroupsResponse addVersionWhiteDevicesByDeviceGroupsWithOptions(shared_ptr<AddVersionWhiteDevicesByDeviceGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddVersionWhiteDevicesByDeviceGroupsResponse addVersionWhiteDevicesByDeviceGroups(shared_ptr<AddVersionWhiteDevicesByDeviceGroupsRequest> request);
  FindCustomizedPropertiesResponse findCustomizedPropertiesWithOptions(shared_ptr<FindCustomizedPropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FindCustomizedPropertiesResponse findCustomizedProperties(shared_ptr<FindCustomizedPropertiesRequest> request);
  ListMessageAcksResponse listMessageAcksWithOptions(shared_ptr<ListMessageAcksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMessageAcksResponse listMessageAcks(shared_ptr<ListMessageAcksRequest> request);
  GetCommercialVehicleTrackResponse getCommercialVehicleTrackWithOptions(shared_ptr<GetCommercialVehicleTrackRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCommercialVehicleTrackResponse getCommercialVehicleTrack(shared_ptr<GetCommercialVehicleTrackRequest> request);
  ListHostDevicesResponse listHostDevicesWithOptions(shared_ptr<ListHostDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHostDevicesResponse listHostDevices(shared_ptr<ListHostDevicesRequest> request);
  ListMqttClientSubscriptionsResponse listMqttClientSubscriptionsWithOptions(shared_ptr<ListMqttClientSubscriptionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMqttClientSubscriptionsResponse listMqttClientSubscriptions(shared_ptr<ListMqttClientSubscriptionsRequest> request);
  InvokeFunctionResponse invokeFunctionWithOptions(shared_ptr<InvokeFunctionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InvokeFunctionResponse invokeFunction(shared_ptr<InvokeFunctionRequest> request);
  DeleteVersionAllWhiteDevicesResponse deleteVersionAllWhiteDevicesWithOptions(shared_ptr<DeleteVersionAllWhiteDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVersionAllWhiteDevicesResponse deleteVersionAllWhiteDevices(shared_ptr<DeleteVersionAllWhiteDevicesRequest> request);
  DescribeMessageResponse describeMessageWithOptions(shared_ptr<DescribeMessageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMessageResponse describeMessage(shared_ptr<DescribeMessageRequest> request);
  UpdateProjectResponse updateProjectWithOptions(shared_ptr<UpdateProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectResponse updateProject(shared_ptr<UpdateProjectRequest> request);
  UpdateAppBlackWhiteVersionsResponse updateAppBlackWhiteVersionsWithOptions(shared_ptr<UpdateAppBlackWhiteVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAppBlackWhiteVersionsResponse updateAppBlackWhiteVersions(shared_ptr<UpdateAppBlackWhiteVersionsRequest> request);
  GetDeviceAppUpdateFunnelEventsResponse getDeviceAppUpdateFunnelEventsWithOptions(shared_ptr<GetDeviceAppUpdateFunnelEventsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDeviceAppUpdateFunnelEventsResponse getDeviceAppUpdateFunnelEvents(shared_ptr<GetDeviceAppUpdateFunnelEventsRequest> request);
  GetNamespaceStatisticsDataResponse getNamespaceStatisticsDataWithOptions(shared_ptr<GetNamespaceStatisticsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNamespaceStatisticsDataResponse getNamespaceStatisticsData(shared_ptr<GetNamespaceStatisticsDataRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Iovcc20180501

#endif
