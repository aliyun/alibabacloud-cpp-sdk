// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_EIAM20211201_H_
#define ALIBABACLOUD_EIAM20211201_H_

#include <alibabacloud/open_api.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Eiam20211201 {
class AddUserToOrganizationalUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<string> userId{};

  AddUserToOrganizationalUnitsRequest() {}

  explicit AddUserToOrganizationalUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddUserToOrganizationalUnitsRequest() = default;
};
class AddUserToOrganizationalUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUserToOrganizationalUnitsResponseBody() {}

  explicit AddUserToOrganizationalUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUserToOrganizationalUnitsResponseBody() = default;
};
class AddUserToOrganizationalUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUserToOrganizationalUnitsResponseBody> body{};

  AddUserToOrganizationalUnitsResponse() {}

  explicit AddUserToOrganizationalUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUserToOrganizationalUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUserToOrganizationalUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~AddUserToOrganizationalUnitsResponse() = default;
};
class AddUsersToGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userIds{};

  AddUsersToGroupRequest() {}

  explicit AddUsersToGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddUsersToGroupRequest() = default;
};
class AddUsersToGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddUsersToGroupResponseBody() {}

  explicit AddUsersToGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUsersToGroupResponseBody() = default;
};
class AddUsersToGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUsersToGroupResponseBody> body{};

  AddUsersToGroupResponse() {}

  explicit AddUsersToGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUsersToGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUsersToGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUsersToGroupResponse() = default;
};
class AuthorizeApplicationToGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> instanceId{};

  AuthorizeApplicationToGroupsRequest() {}

  explicit AuthorizeApplicationToGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AuthorizeApplicationToGroupsRequest() = default;
};
class AuthorizeApplicationToGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeApplicationToGroupsResponseBody() {}

  explicit AuthorizeApplicationToGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeApplicationToGroupsResponseBody() = default;
};
class AuthorizeApplicationToGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeApplicationToGroupsResponseBody> body{};

  AuthorizeApplicationToGroupsResponse() {}

  explicit AuthorizeApplicationToGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeApplicationToGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeApplicationToGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeApplicationToGroupsResponse() = default;
};
class AuthorizeApplicationToOrganizationalUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};

  AuthorizeApplicationToOrganizationalUnitsRequest() {}

  explicit AuthorizeApplicationToOrganizationalUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AuthorizeApplicationToOrganizationalUnitsRequest() = default;
};
class AuthorizeApplicationToOrganizationalUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeApplicationToOrganizationalUnitsResponseBody() {}

  explicit AuthorizeApplicationToOrganizationalUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeApplicationToOrganizationalUnitsResponseBody() = default;
};
class AuthorizeApplicationToOrganizationalUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeApplicationToOrganizationalUnitsResponseBody> body{};

  AuthorizeApplicationToOrganizationalUnitsResponse() {}

  explicit AuthorizeApplicationToOrganizationalUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeApplicationToOrganizationalUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeApplicationToOrganizationalUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeApplicationToOrganizationalUnitsResponse() = default;
};
class AuthorizeApplicationToUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userIds{};

  AuthorizeApplicationToUsersRequest() {}

  explicit AuthorizeApplicationToUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AuthorizeApplicationToUsersRequest() = default;
};
class AuthorizeApplicationToUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AuthorizeApplicationToUsersResponseBody() {}

  explicit AuthorizeApplicationToUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AuthorizeApplicationToUsersResponseBody() = default;
};
class AuthorizeApplicationToUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AuthorizeApplicationToUsersResponseBody> body{};

  AuthorizeApplicationToUsersResponse() {}

  explicit AuthorizeApplicationToUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AuthorizeApplicationToUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AuthorizeApplicationToUsersResponseBody>(model1);
      }
    }
  }


  virtual ~AuthorizeApplicationToUsersResponse() = default;
};
class CreateApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationSourceType{};
  shared_ptr<string> applicationTemplateId{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> ssoType{};

  CreateApplicationRequest() {}

  explicit CreateApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationSourceType) {
      res["ApplicationSourceType"] = boost::any(*applicationSourceType);
    }
    if (applicationTemplateId) {
      res["ApplicationTemplateId"] = boost::any(*applicationTemplateId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (ssoType) {
      res["SsoType"] = boost::any(*ssoType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationSourceType") != m.end() && !m["ApplicationSourceType"].empty()) {
      applicationSourceType = make_shared<string>(boost::any_cast<string>(m["ApplicationSourceType"]));
    }
    if (m.find("ApplicationTemplateId") != m.end() && !m["ApplicationTemplateId"].empty()) {
      applicationTemplateId = make_shared<string>(boost::any_cast<string>(m["ApplicationTemplateId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("SsoType") != m.end() && !m["SsoType"].empty()) {
      ssoType = make_shared<string>(boost::any_cast<string>(m["SsoType"]));
    }
  }


  virtual ~CreateApplicationRequest() = default;
};
class CreateApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> requestId{};

  CreateApplicationResponseBody() {}

  explicit CreateApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApplicationResponseBody() = default;
};
class CreateApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationResponseBody> body{};

  CreateApplicationResponse() {}

  explicit CreateApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationResponse() = default;
};
class CreateApplicationClientSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  CreateApplicationClientSecretRequest() {}

  explicit CreateApplicationClientSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateApplicationClientSecretRequest() = default;
};
class CreateApplicationClientSecretResponseBodyApplicationClientSecret : public Darabonba::Model {
public:
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> secretId{};

  CreateApplicationClientSecretResponseBodyApplicationClientSecret() {}

  explicit CreateApplicationClientSecretResponseBodyApplicationClientSecret(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
  }


  virtual ~CreateApplicationClientSecretResponseBodyApplicationClientSecret() = default;
};
class CreateApplicationClientSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateApplicationClientSecretResponseBodyApplicationClientSecret> applicationClientSecret{};
  shared_ptr<string> requestId{};

  CreateApplicationClientSecretResponseBody() {}

  explicit CreateApplicationClientSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationClientSecret) {
      res["ApplicationClientSecret"] = applicationClientSecret ? boost::any(applicationClientSecret->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationClientSecret") != m.end() && !m["ApplicationClientSecret"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationClientSecret"].type()) {
        CreateApplicationClientSecretResponseBodyApplicationClientSecret model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationClientSecret"]));
        applicationClientSecret = make_shared<CreateApplicationClientSecretResponseBodyApplicationClientSecret>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApplicationClientSecretResponseBody() = default;
};
class CreateApplicationClientSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationClientSecretResponseBody> body{};

  CreateApplicationClientSecretResponse() {}

  explicit CreateApplicationClientSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationClientSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationClientSecretResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationClientSecretResponse() = default;
};
class CreateConditionalAccessPolicyRequestConditionsConfigApplications : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeApplications{};
  shared_ptr<vector<string>> includeApplications{};

  CreateConditionalAccessPolicyRequestConditionsConfigApplications() {}

  explicit CreateConditionalAccessPolicyRequestConditionsConfigApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeApplications) {
      res["ExcludeApplications"] = boost::any(*excludeApplications);
    }
    if (includeApplications) {
      res["IncludeApplications"] = boost::any(*includeApplications);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeApplications") != m.end() && !m["ExcludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeApplications = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeApplications") != m.end() && !m["IncludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeApplications = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateConditionalAccessPolicyRequestConditionsConfigApplications() = default;
};
class CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeNetworkZones{};
  shared_ptr<vector<string>> includeNetworkZones{};

  CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones() {}

  explicit CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeNetworkZones) {
      res["ExcludeNetworkZones"] = boost::any(*excludeNetworkZones);
    }
    if (includeNetworkZones) {
      res["IncludeNetworkZones"] = boost::any(*includeNetworkZones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeNetworkZones") != m.end() && !m["ExcludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeNetworkZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeNetworkZones") != m.end() && !m["IncludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeNetworkZones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones() = default;
};
class CreateConditionalAccessPolicyRequestConditionsConfigUsers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeGroups{};
  shared_ptr<vector<string>> excludeOrganizationalUnits{};
  shared_ptr<vector<string>> excludeUsers{};
  shared_ptr<vector<string>> includeGroups{};
  shared_ptr<vector<string>> includeOrganizationalUnits{};
  shared_ptr<vector<string>> includeUsers{};

  CreateConditionalAccessPolicyRequestConditionsConfigUsers() {}

  explicit CreateConditionalAccessPolicyRequestConditionsConfigUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeGroups) {
      res["ExcludeGroups"] = boost::any(*excludeGroups);
    }
    if (excludeOrganizationalUnits) {
      res["ExcludeOrganizationalUnits"] = boost::any(*excludeOrganizationalUnits);
    }
    if (excludeUsers) {
      res["ExcludeUsers"] = boost::any(*excludeUsers);
    }
    if (includeGroups) {
      res["IncludeGroups"] = boost::any(*includeGroups);
    }
    if (includeOrganizationalUnits) {
      res["IncludeOrganizationalUnits"] = boost::any(*includeOrganizationalUnits);
    }
    if (includeUsers) {
      res["IncludeUsers"] = boost::any(*includeUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeGroups") != m.end() && !m["ExcludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeOrganizationalUnits") != m.end() && !m["ExcludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeUsers") != m.end() && !m["ExcludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeGroups") != m.end() && !m["IncludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeOrganizationalUnits") != m.end() && !m["IncludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeUsers") != m.end() && !m["IncludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateConditionalAccessPolicyRequestConditionsConfigUsers() = default;
};
class CreateConditionalAccessPolicyRequestConditionsConfig : public Darabonba::Model {
public:
  shared_ptr<CreateConditionalAccessPolicyRequestConditionsConfigApplications> applications{};
  shared_ptr<CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones> networkZones{};
  shared_ptr<CreateConditionalAccessPolicyRequestConditionsConfigUsers> users{};

  CreateConditionalAccessPolicyRequestConditionsConfig() {}

  explicit CreateConditionalAccessPolicyRequestConditionsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkZones) {
      res["NetworkZones"] = networkZones ? boost::any(networkZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        CreateConditionalAccessPolicyRequestConditionsConfigApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<CreateConditionalAccessPolicyRequestConditionsConfigApplications>(model1);
      }
    }
    if (m.find("NetworkZones") != m.end() && !m["NetworkZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkZones"].type()) {
        CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkZones"]));
        networkZones = make_shared<CreateConditionalAccessPolicyRequestConditionsConfigNetworkZones>(model1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        CreateConditionalAccessPolicyRequestConditionsConfigUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<CreateConditionalAccessPolicyRequestConditionsConfigUsers>(model1);
      }
    }
  }


  virtual ~CreateConditionalAccessPolicyRequestConditionsConfig() = default;
};
class CreateConditionalAccessPolicyRequestDecisionConfig : public Darabonba::Model {
public:
  shared_ptr<string> activeSessionReuseStatus{};
  shared_ptr<string> effect{};
  shared_ptr<long> mfaAuthenticationIntervalSeconds{};
  shared_ptr<vector<string>> mfaAuthenticationMethods{};
  shared_ptr<string> mfaType{};

  CreateConditionalAccessPolicyRequestDecisionConfig() {}

  explicit CreateConditionalAccessPolicyRequestDecisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionReuseStatus) {
      res["ActiveSessionReuseStatus"] = boost::any(*activeSessionReuseStatus);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (mfaAuthenticationIntervalSeconds) {
      res["MfaAuthenticationIntervalSeconds"] = boost::any(*mfaAuthenticationIntervalSeconds);
    }
    if (mfaAuthenticationMethods) {
      res["MfaAuthenticationMethods"] = boost::any(*mfaAuthenticationMethods);
    }
    if (mfaType) {
      res["MfaType"] = boost::any(*mfaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionReuseStatus") != m.end() && !m["ActiveSessionReuseStatus"].empty()) {
      activeSessionReuseStatus = make_shared<string>(boost::any_cast<string>(m["ActiveSessionReuseStatus"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("MfaAuthenticationIntervalSeconds") != m.end() && !m["MfaAuthenticationIntervalSeconds"].empty()) {
      mfaAuthenticationIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["MfaAuthenticationIntervalSeconds"]));
    }
    if (m.find("MfaAuthenticationMethods") != m.end() && !m["MfaAuthenticationMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MfaAuthenticationMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MfaAuthenticationMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mfaAuthenticationMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MfaType") != m.end() && !m["MfaType"].empty()) {
      mfaType = make_shared<string>(boost::any_cast<string>(m["MfaType"]));
    }
  }


  virtual ~CreateConditionalAccessPolicyRequestDecisionConfig() = default;
};
class CreateConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> conditionalAccessPolicyName{};
  shared_ptr<string> conditionalAccessPolicyType{};
  shared_ptr<CreateConditionalAccessPolicyRequestConditionsConfig> conditionsConfig{};
  shared_ptr<CreateConditionalAccessPolicyRequestDecisionConfig> decisionConfig{};
  shared_ptr<string> decisionType{};
  shared_ptr<string> description{};
  shared_ptr<string> evaluateAt{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> priority{};

  CreateConditionalAccessPolicyRequest() {}

  explicit CreateConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (conditionalAccessPolicyName) {
      res["ConditionalAccessPolicyName"] = boost::any(*conditionalAccessPolicyName);
    }
    if (conditionalAccessPolicyType) {
      res["ConditionalAccessPolicyType"] = boost::any(*conditionalAccessPolicyType);
    }
    if (conditionsConfig) {
      res["ConditionsConfig"] = conditionsConfig ? boost::any(conditionsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionConfig) {
      res["DecisionConfig"] = decisionConfig ? boost::any(decisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionType) {
      res["DecisionType"] = boost::any(*decisionType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (evaluateAt) {
      res["EvaluateAt"] = boost::any(*evaluateAt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConditionalAccessPolicyName") != m.end() && !m["ConditionalAccessPolicyName"].empty()) {
      conditionalAccessPolicyName = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyName"]));
    }
    if (m.find("ConditionalAccessPolicyType") != m.end() && !m["ConditionalAccessPolicyType"].empty()) {
      conditionalAccessPolicyType = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyType"]));
    }
    if (m.find("ConditionsConfig") != m.end() && !m["ConditionsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionsConfig"].type()) {
        CreateConditionalAccessPolicyRequestConditionsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionsConfig"]));
        conditionsConfig = make_shared<CreateConditionalAccessPolicyRequestConditionsConfig>(model1);
      }
    }
    if (m.find("DecisionConfig") != m.end() && !m["DecisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DecisionConfig"].type()) {
        CreateConditionalAccessPolicyRequestDecisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DecisionConfig"]));
        decisionConfig = make_shared<CreateConditionalAccessPolicyRequestDecisionConfig>(model1);
      }
    }
    if (m.find("DecisionType") != m.end() && !m["DecisionType"].empty()) {
      decisionType = make_shared<string>(boost::any_cast<string>(m["DecisionType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EvaluateAt") != m.end() && !m["EvaluateAt"].empty()) {
      evaluateAt = make_shared<string>(boost::any_cast<string>(m["EvaluateAt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~CreateConditionalAccessPolicyRequest() = default;
};
class CreateConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> requestId{};

  CreateConditionalAccessPolicyResponseBody() {}

  explicit CreateConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateConditionalAccessPolicyResponseBody() = default;
};
class CreateConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConditionalAccessPolicyResponseBody> body{};

  CreateConditionalAccessPolicyResponse() {}

  explicit CreateConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConditionalAccessPolicyResponse() = default;
};
class CreateDomainRequestFiling : public Darabonba::Model {
public:
  shared_ptr<string> icpNumber{};

  CreateDomainRequestFiling() {}

  explicit CreateDomainRequestFiling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icpNumber) {
      res["IcpNumber"] = boost::any(*icpNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IcpNumber") != m.end() && !m["IcpNumber"].empty()) {
      icpNumber = make_shared<string>(boost::any_cast<string>(m["IcpNumber"]));
    }
  }


  virtual ~CreateDomainRequestFiling() = default;
};
class CreateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<CreateDomainRequestFiling> filing{};
  shared_ptr<string> instanceId{};

  CreateDomainRequest() {}

  explicit CreateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (filing) {
      res["Filing"] = filing ? boost::any(filing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Filing") != m.end() && !m["Filing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filing"].type()) {
        CreateDomainRequestFiling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filing"]));
        filing = make_shared<CreateDomainRequestFiling>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateDomainRequest() = default;
};
class CreateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> requestId{};

  CreateDomainResponseBody() {}

  explicit CreateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDomainResponseBody() = default;
};
class CreateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDomainResponseBody> body{};

  CreateDomainResponse() {}

  explicit CreateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDomainResponse() = default;
};
class CreateDomainProxyTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};

  CreateDomainProxyTokenRequest() {}

  explicit CreateDomainProxyTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateDomainProxyTokenRequest() = default;
};
class CreateDomainProxyTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> requestId{};

  CreateDomainProxyTokenResponseBody() {}

  explicit CreateDomainProxyTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDomainProxyTokenResponseBody() = default;
};
class CreateDomainProxyTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDomainProxyTokenResponseBody> body{};

  CreateDomainProxyTokenResponse() {}

  explicit CreateDomainProxyTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDomainProxyTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDomainProxyTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDomainProxyTokenResponse() = default;
};
class CreateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupExternalId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};

  CreateGroupRequest() {}

  explicit CreateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupExternalId) {
      res["GroupExternalId"] = boost::any(*groupExternalId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupExternalId") != m.end() && !m["GroupExternalId"].empty()) {
      groupExternalId = make_shared<string>(boost::any_cast<string>(m["GroupExternalId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateGroupRequest() = default;
};
class CreateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};

  CreateGroupResponseBody() {}

  explicit CreateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateGroupResponseBody() = default;
};
class CreateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateGroupResponseBody> body{};

  CreateGroupResponse() {}

  explicit CreateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateGroupResponse() = default;
};
class CreateIdentityProviderRequestAuthnConfig : public Darabonba::Model {
public:
  shared_ptr<string> authnStatus{};
  shared_ptr<string> autoUpdatePasswordStatus{};

  CreateIdentityProviderRequestAuthnConfig() {}

  explicit CreateIdentityProviderRequestAuthnConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnStatus) {
      res["AuthnStatus"] = boost::any(*authnStatus);
    }
    if (autoUpdatePasswordStatus) {
      res["AutoUpdatePasswordStatus"] = boost::any(*autoUpdatePasswordStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnStatus") != m.end() && !m["AuthnStatus"].empty()) {
      authnStatus = make_shared<string>(boost::any_cast<string>(m["AuthnStatus"]));
    }
    if (m.find("AutoUpdatePasswordStatus") != m.end() && !m["AutoUpdatePasswordStatus"].empty()) {
      autoUpdatePasswordStatus = make_shared<string>(boost::any_cast<string>(m["AutoUpdatePasswordStatus"]));
    }
  }


  virtual ~CreateIdentityProviderRequestAuthnConfig() = default;
};
class CreateIdentityProviderRequestAutoCreateUserConfig : public Darabonba::Model {
public:
  shared_ptr<string> autoCreateUserStatus{};
  shared_ptr<vector<string>> targetOrganizationalUnitIds{};

  CreateIdentityProviderRequestAutoCreateUserConfig() {}

  explicit CreateIdentityProviderRequestAutoCreateUserConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoCreateUserStatus) {
      res["AutoCreateUserStatus"] = boost::any(*autoCreateUserStatus);
    }
    if (targetOrganizationalUnitIds) {
      res["TargetOrganizationalUnitIds"] = boost::any(*targetOrganizationalUnitIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoCreateUserStatus") != m.end() && !m["AutoCreateUserStatus"].empty()) {
      autoCreateUserStatus = make_shared<string>(boost::any_cast<string>(m["AutoCreateUserStatus"]));
    }
    if (m.find("TargetOrganizationalUnitIds") != m.end() && !m["TargetOrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetOrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetOrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetOrganizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateIdentityProviderRequestAutoCreateUserConfig() = default;
};
class CreateIdentityProviderRequestAutoUpdateUserConfig : public Darabonba::Model {
public:
  shared_ptr<string> autoUpdateUserStatus{};

  CreateIdentityProviderRequestAutoUpdateUserConfig() {}

  explicit CreateIdentityProviderRequestAutoUpdateUserConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoUpdateUserStatus) {
      res["AutoUpdateUserStatus"] = boost::any(*autoUpdateUserStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoUpdateUserStatus") != m.end() && !m["AutoUpdateUserStatus"].empty()) {
      autoUpdateUserStatus = make_shared<string>(boost::any_cast<string>(m["AutoUpdateUserStatus"]));
    }
  }


  virtual ~CreateIdentityProviderRequestAutoUpdateUserConfig() = default;
};
class CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions : public Darabonba::Model {
public:
  shared_ptr<string> expressionMappingType{};
  shared_ptr<string> sourceValueExpression{};
  shared_ptr<string> targetField{};
  shared_ptr<string> targetFieldDescription{};

  CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions() {}

  explicit CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressionMappingType) {
      res["ExpressionMappingType"] = boost::any(*expressionMappingType);
    }
    if (sourceValueExpression) {
      res["SourceValueExpression"] = boost::any(*sourceValueExpression);
    }
    if (targetField) {
      res["TargetField"] = boost::any(*targetField);
    }
    if (targetFieldDescription) {
      res["TargetFieldDescription"] = boost::any(*targetFieldDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpressionMappingType") != m.end() && !m["ExpressionMappingType"].empty()) {
      expressionMappingType = make_shared<string>(boost::any_cast<string>(m["ExpressionMappingType"]));
    }
    if (m.find("SourceValueExpression") != m.end() && !m["SourceValueExpression"].empty()) {
      sourceValueExpression = make_shared<string>(boost::any_cast<string>(m["SourceValueExpression"]));
    }
    if (m.find("TargetField") != m.end() && !m["TargetField"].empty()) {
      targetField = make_shared<string>(boost::any_cast<string>(m["TargetField"]));
    }
    if (m.find("TargetFieldDescription") != m.end() && !m["TargetFieldDescription"].empty()) {
      targetFieldDescription = make_shared<string>(boost::any_cast<string>(m["TargetFieldDescription"]));
    }
  }


  virtual ~CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions() = default;
};
class CreateIdentityProviderRequestBindingConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions>> autoMatchUserProfileExpressions{};
  shared_ptr<string> autoMatchUserStatus{};
  shared_ptr<string> mappingBindingStatus{};

  CreateIdentityProviderRequestBindingConfig() {}

  explicit CreateIdentityProviderRequestBindingConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoMatchUserProfileExpressions) {
      vector<boost::any> temp1;
      for(auto item1:*autoMatchUserProfileExpressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AutoMatchUserProfileExpressions"] = boost::any(temp1);
    }
    if (autoMatchUserStatus) {
      res["AutoMatchUserStatus"] = boost::any(*autoMatchUserStatus);
    }
    if (mappingBindingStatus) {
      res["MappingBindingStatus"] = boost::any(*mappingBindingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoMatchUserProfileExpressions") != m.end() && !m["AutoMatchUserProfileExpressions"].empty()) {
      if (typeid(vector<boost::any>) == m["AutoMatchUserProfileExpressions"].type()) {
        vector<CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AutoMatchUserProfileExpressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        autoMatchUserProfileExpressions = make_shared<vector<CreateIdentityProviderRequestBindingConfigAutoMatchUserProfileExpressions>>(expect1);
      }
    }
    if (m.find("AutoMatchUserStatus") != m.end() && !m["AutoMatchUserStatus"].empty()) {
      autoMatchUserStatus = make_shared<string>(boost::any_cast<string>(m["AutoMatchUserStatus"]));
    }
    if (m.find("MappingBindingStatus") != m.end() && !m["MappingBindingStatus"].empty()) {
      mappingBindingStatus = make_shared<string>(boost::any_cast<string>(m["MappingBindingStatus"]));
    }
  }


  virtual ~CreateIdentityProviderRequestBindingConfig() = default;
};
class CreateIdentityProviderRequestDingtalkAppConfig : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> corpId{};
  shared_ptr<string> dingtalkVersion{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> verificationToken{};

  CreateIdentityProviderRequestDingtalkAppConfig() {}

  explicit CreateIdentityProviderRequestDingtalkAppConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (dingtalkVersion) {
      res["DingtalkVersion"] = boost::any(*dingtalkVersion);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("DingtalkVersion") != m.end() && !m["DingtalkVersion"].empty()) {
      dingtalkVersion = make_shared<string>(boost::any_cast<string>(m["DingtalkVersion"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~CreateIdentityProviderRequestDingtalkAppConfig() = default;
};
class CreateIdentityProviderRequestLarkConfig : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> enterpriseNumber{};
  shared_ptr<string> verificationToken{};

  CreateIdentityProviderRequestLarkConfig() {}

  explicit CreateIdentityProviderRequestLarkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (enterpriseNumber) {
      res["EnterpriseNumber"] = boost::any(*enterpriseNumber);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("EnterpriseNumber") != m.end() && !m["EnterpriseNumber"].empty()) {
      enterpriseNumber = make_shared<string>(boost::any_cast<string>(m["EnterpriseNumber"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~CreateIdentityProviderRequestLarkConfig() = default;
};
class CreateIdentityProviderRequestLdapConfig : public Darabonba::Model {
public:
  shared_ptr<string> administratorPassword{};
  shared_ptr<string> administratorUsername{};
  shared_ptr<string> certificateFingerprintStatus{};
  shared_ptr<vector<string>> certificateFingerprints{};
  shared_ptr<string> groupMemberAttributeName{};
  shared_ptr<string> groupObjectClass{};
  shared_ptr<string> groupObjectClassCustomFilter{};
  shared_ptr<string> ldapProtocol{};
  shared_ptr<string> ldapServerHost{};
  shared_ptr<long> ldapServerPort{};
  shared_ptr<string> organizationUnitObjectClass{};
  shared_ptr<string> startTlsStatus{};
  shared_ptr<string> userLoginIdentifier{};
  shared_ptr<string> userObjectClass{};
  shared_ptr<string> userObjectClassCustomFilter{};

  CreateIdentityProviderRequestLdapConfig() {}

  explicit CreateIdentityProviderRequestLdapConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administratorPassword) {
      res["AdministratorPassword"] = boost::any(*administratorPassword);
    }
    if (administratorUsername) {
      res["AdministratorUsername"] = boost::any(*administratorUsername);
    }
    if (certificateFingerprintStatus) {
      res["CertificateFingerprintStatus"] = boost::any(*certificateFingerprintStatus);
    }
    if (certificateFingerprints) {
      res["CertificateFingerprints"] = boost::any(*certificateFingerprints);
    }
    if (groupMemberAttributeName) {
      res["GroupMemberAttributeName"] = boost::any(*groupMemberAttributeName);
    }
    if (groupObjectClass) {
      res["GroupObjectClass"] = boost::any(*groupObjectClass);
    }
    if (groupObjectClassCustomFilter) {
      res["GroupObjectClassCustomFilter"] = boost::any(*groupObjectClassCustomFilter);
    }
    if (ldapProtocol) {
      res["LdapProtocol"] = boost::any(*ldapProtocol);
    }
    if (ldapServerHost) {
      res["LdapServerHost"] = boost::any(*ldapServerHost);
    }
    if (ldapServerPort) {
      res["LdapServerPort"] = boost::any(*ldapServerPort);
    }
    if (organizationUnitObjectClass) {
      res["OrganizationUnitObjectClass"] = boost::any(*organizationUnitObjectClass);
    }
    if (startTlsStatus) {
      res["StartTlsStatus"] = boost::any(*startTlsStatus);
    }
    if (userLoginIdentifier) {
      res["UserLoginIdentifier"] = boost::any(*userLoginIdentifier);
    }
    if (userObjectClass) {
      res["UserObjectClass"] = boost::any(*userObjectClass);
    }
    if (userObjectClassCustomFilter) {
      res["UserObjectClassCustomFilter"] = boost::any(*userObjectClassCustomFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdministratorPassword") != m.end() && !m["AdministratorPassword"].empty()) {
      administratorPassword = make_shared<string>(boost::any_cast<string>(m["AdministratorPassword"]));
    }
    if (m.find("AdministratorUsername") != m.end() && !m["AdministratorUsername"].empty()) {
      administratorUsername = make_shared<string>(boost::any_cast<string>(m["AdministratorUsername"]));
    }
    if (m.find("CertificateFingerprintStatus") != m.end() && !m["CertificateFingerprintStatus"].empty()) {
      certificateFingerprintStatus = make_shared<string>(boost::any_cast<string>(m["CertificateFingerprintStatus"]));
    }
    if (m.find("CertificateFingerprints") != m.end() && !m["CertificateFingerprints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CertificateFingerprints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CertificateFingerprints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      certificateFingerprints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupMemberAttributeName") != m.end() && !m["GroupMemberAttributeName"].empty()) {
      groupMemberAttributeName = make_shared<string>(boost::any_cast<string>(m["GroupMemberAttributeName"]));
    }
    if (m.find("GroupObjectClass") != m.end() && !m["GroupObjectClass"].empty()) {
      groupObjectClass = make_shared<string>(boost::any_cast<string>(m["GroupObjectClass"]));
    }
    if (m.find("GroupObjectClassCustomFilter") != m.end() && !m["GroupObjectClassCustomFilter"].empty()) {
      groupObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["GroupObjectClassCustomFilter"]));
    }
    if (m.find("LdapProtocol") != m.end() && !m["LdapProtocol"].empty()) {
      ldapProtocol = make_shared<string>(boost::any_cast<string>(m["LdapProtocol"]));
    }
    if (m.find("LdapServerHost") != m.end() && !m["LdapServerHost"].empty()) {
      ldapServerHost = make_shared<string>(boost::any_cast<string>(m["LdapServerHost"]));
    }
    if (m.find("LdapServerPort") != m.end() && !m["LdapServerPort"].empty()) {
      ldapServerPort = make_shared<long>(boost::any_cast<long>(m["LdapServerPort"]));
    }
    if (m.find("OrganizationUnitObjectClass") != m.end() && !m["OrganizationUnitObjectClass"].empty()) {
      organizationUnitObjectClass = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitObjectClass"]));
    }
    if (m.find("StartTlsStatus") != m.end() && !m["StartTlsStatus"].empty()) {
      startTlsStatus = make_shared<string>(boost::any_cast<string>(m["StartTlsStatus"]));
    }
    if (m.find("UserLoginIdentifier") != m.end() && !m["UserLoginIdentifier"].empty()) {
      userLoginIdentifier = make_shared<string>(boost::any_cast<string>(m["UserLoginIdentifier"]));
    }
    if (m.find("UserObjectClass") != m.end() && !m["UserObjectClass"].empty()) {
      userObjectClass = make_shared<string>(boost::any_cast<string>(m["UserObjectClass"]));
    }
    if (m.find("UserObjectClassCustomFilter") != m.end() && !m["UserObjectClassCustomFilter"].empty()) {
      userObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["UserObjectClassCustomFilter"]));
    }
  }


  virtual ~CreateIdentityProviderRequestLdapConfig() = default;
};
class CreateIdentityProviderRequestOidcConfigAuthnParam : public Darabonba::Model {
public:
  shared_ptr<string> authnMethod{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};

  CreateIdentityProviderRequestOidcConfigAuthnParam() {}

  explicit CreateIdentityProviderRequestOidcConfigAuthnParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnMethod) {
      res["AuthnMethod"] = boost::any(*authnMethod);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnMethod") != m.end() && !m["AuthnMethod"].empty()) {
      authnMethod = make_shared<string>(boost::any_cast<string>(m["AuthnMethod"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
  }


  virtual ~CreateIdentityProviderRequestOidcConfigAuthnParam() = default;
};
class CreateIdentityProviderRequestOidcConfigEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> authorizationEndpoint{};
  shared_ptr<string> issuer{};
  shared_ptr<string> jwksUri{};
  shared_ptr<string> tokenEndpoint{};
  shared_ptr<string> userinfoEndpoint{};

  CreateIdentityProviderRequestOidcConfigEndpointConfig() {}

  explicit CreateIdentityProviderRequestOidcConfigEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationEndpoint) {
      res["AuthorizationEndpoint"] = boost::any(*authorizationEndpoint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (jwksUri) {
      res["JwksUri"] = boost::any(*jwksUri);
    }
    if (tokenEndpoint) {
      res["TokenEndpoint"] = boost::any(*tokenEndpoint);
    }
    if (userinfoEndpoint) {
      res["UserinfoEndpoint"] = boost::any(*userinfoEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationEndpoint") != m.end() && !m["AuthorizationEndpoint"].empty()) {
      authorizationEndpoint = make_shared<string>(boost::any_cast<string>(m["AuthorizationEndpoint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("JwksUri") != m.end() && !m["JwksUri"].empty()) {
      jwksUri = make_shared<string>(boost::any_cast<string>(m["JwksUri"]));
    }
    if (m.find("TokenEndpoint") != m.end() && !m["TokenEndpoint"].empty()) {
      tokenEndpoint = make_shared<string>(boost::any_cast<string>(m["TokenEndpoint"]));
    }
    if (m.find("UserinfoEndpoint") != m.end() && !m["UserinfoEndpoint"].empty()) {
      userinfoEndpoint = make_shared<string>(boost::any_cast<string>(m["UserinfoEndpoint"]));
    }
  }


  virtual ~CreateIdentityProviderRequestOidcConfigEndpointConfig() = default;
};
class CreateIdentityProviderRequestOidcConfig : public Darabonba::Model {
public:
  shared_ptr<CreateIdentityProviderRequestOidcConfigAuthnParam> authnParam{};
  shared_ptr<CreateIdentityProviderRequestOidcConfigEndpointConfig> endpointConfig{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<string> grantType{};
  shared_ptr<string> pkceChallengeMethod{};
  shared_ptr<bool> pkceRequired{};

  CreateIdentityProviderRequestOidcConfig() {}

  explicit CreateIdentityProviderRequestOidcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnParam) {
      res["AuthnParam"] = authnParam ? boost::any(authnParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endpointConfig) {
      res["EndpointConfig"] = endpointConfig ? boost::any(endpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (pkceChallengeMethod) {
      res["PkceChallengeMethod"] = boost::any(*pkceChallengeMethod);
    }
    if (pkceRequired) {
      res["PkceRequired"] = boost::any(*pkceRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnParam") != m.end() && !m["AuthnParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnParam"].type()) {
        CreateIdentityProviderRequestOidcConfigAuthnParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnParam"]));
        authnParam = make_shared<CreateIdentityProviderRequestOidcConfigAuthnParam>(model1);
      }
    }
    if (m.find("EndpointConfig") != m.end() && !m["EndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndpointConfig"].type()) {
        CreateIdentityProviderRequestOidcConfigEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndpointConfig"]));
        endpointConfig = make_shared<CreateIdentityProviderRequestOidcConfigEndpointConfig>(model1);
      }
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("PkceChallengeMethod") != m.end() && !m["PkceChallengeMethod"].empty()) {
      pkceChallengeMethod = make_shared<string>(boost::any_cast<string>(m["PkceChallengeMethod"]));
    }
    if (m.find("PkceRequired") != m.end() && !m["PkceRequired"].empty()) {
      pkceRequired = make_shared<bool>(boost::any_cast<bool>(m["PkceRequired"]));
    }
  }


  virtual ~CreateIdentityProviderRequestOidcConfig() = default;
};
class CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig : public Darabonba::Model {
public:
  shared_ptr<string> periodicSyncCron{};
  shared_ptr<vector<long>> periodicSyncTimes{};
  shared_ptr<string> periodicSyncType{};

  CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig() {}

  explicit CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodicSyncCron) {
      res["PeriodicSyncCron"] = boost::any(*periodicSyncCron);
    }
    if (periodicSyncTimes) {
      res["PeriodicSyncTimes"] = boost::any(*periodicSyncTimes);
    }
    if (periodicSyncType) {
      res["PeriodicSyncType"] = boost::any(*periodicSyncType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodicSyncCron") != m.end() && !m["PeriodicSyncCron"].empty()) {
      periodicSyncCron = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncCron"]));
    }
    if (m.find("PeriodicSyncTimes") != m.end() && !m["PeriodicSyncTimes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PeriodicSyncTimes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PeriodicSyncTimes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      periodicSyncTimes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PeriodicSyncType") != m.end() && !m["PeriodicSyncType"].empty()) {
      periodicSyncType = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncType"]));
    }
  }


  virtual ~CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig() = default;
};
class CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig() {}

  explicit CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig() = default;
};
class CreateIdentityProviderRequestUdPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> groupSyncStatus{};
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig> periodicSyncConfig{};
  shared_ptr<string> periodicSyncStatus{};
  shared_ptr<CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig> udSyncScopeConfig{};

  CreateIdentityProviderRequestUdPullConfig() {}

  explicit CreateIdentityProviderRequestUdPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupSyncStatus) {
      res["GroupSyncStatus"] = boost::any(*groupSyncStatus);
    }
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (periodicSyncConfig) {
      res["PeriodicSyncConfig"] = periodicSyncConfig ? boost::any(periodicSyncConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodicSyncStatus) {
      res["PeriodicSyncStatus"] = boost::any(*periodicSyncStatus);
    }
    if (udSyncScopeConfig) {
      res["UdSyncScopeConfig"] = udSyncScopeConfig ? boost::any(udSyncScopeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupSyncStatus") != m.end() && !m["GroupSyncStatus"].empty()) {
      groupSyncStatus = make_shared<string>(boost::any_cast<string>(m["GroupSyncStatus"]));
    }
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("PeriodicSyncConfig") != m.end() && !m["PeriodicSyncConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PeriodicSyncConfig"].type()) {
        CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PeriodicSyncConfig"]));
        periodicSyncConfig = make_shared<CreateIdentityProviderRequestUdPullConfigPeriodicSyncConfig>(model1);
      }
    }
    if (m.find("PeriodicSyncStatus") != m.end() && !m["PeriodicSyncStatus"].empty()) {
      periodicSyncStatus = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncStatus"]));
    }
    if (m.find("UdSyncScopeConfig") != m.end() && !m["UdSyncScopeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdSyncScopeConfig"].type()) {
        CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdSyncScopeConfig"]));
        udSyncScopeConfig = make_shared<CreateIdentityProviderRequestUdPullConfigUdSyncScopeConfig>(model1);
      }
    }
  }


  virtual ~CreateIdentityProviderRequestUdPullConfig() = default;
};
class CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs() {}

  explicit CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs() = default;
};
class CreateIdentityProviderRequestUdPushConfig : public Darabonba::Model {
public:
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<string> periodicSyncStatus{};
  shared_ptr<vector<CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs>> udSyncScopeConfigs{};

  CreateIdentityProviderRequestUdPushConfig() {}

  explicit CreateIdentityProviderRequestUdPushConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (periodicSyncStatus) {
      res["PeriodicSyncStatus"] = boost::any(*periodicSyncStatus);
    }
    if (udSyncScopeConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*udSyncScopeConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UdSyncScopeConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("PeriodicSyncStatus") != m.end() && !m["PeriodicSyncStatus"].empty()) {
      periodicSyncStatus = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncStatus"]));
    }
    if (m.find("UdSyncScopeConfigs") != m.end() && !m["UdSyncScopeConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["UdSyncScopeConfigs"].type()) {
        vector<CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UdSyncScopeConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        udSyncScopeConfigs = make_shared<vector<CreateIdentityProviderRequestUdPushConfigUdSyncScopeConfigs>>(expect1);
      }
    }
  }


  virtual ~CreateIdentityProviderRequestUdPushConfig() = default;
};
class CreateIdentityProviderRequestWeComConfig : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> authorizeCallbackDomain{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpSecret{};
  shared_ptr<string> trustableDomain{};

  CreateIdentityProviderRequestWeComConfig() {}

  explicit CreateIdentityProviderRequestWeComConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (authorizeCallbackDomain) {
      res["AuthorizeCallbackDomain"] = boost::any(*authorizeCallbackDomain);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (corpSecret) {
      res["CorpSecret"] = boost::any(*corpSecret);
    }
    if (trustableDomain) {
      res["TrustableDomain"] = boost::any(*trustableDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AuthorizeCallbackDomain") != m.end() && !m["AuthorizeCallbackDomain"].empty()) {
      authorizeCallbackDomain = make_shared<string>(boost::any_cast<string>(m["AuthorizeCallbackDomain"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CorpSecret") != m.end() && !m["CorpSecret"].empty()) {
      corpSecret = make_shared<string>(boost::any_cast<string>(m["CorpSecret"]));
    }
    if (m.find("TrustableDomain") != m.end() && !m["TrustableDomain"].empty()) {
      trustableDomain = make_shared<string>(boost::any_cast<string>(m["TrustableDomain"]));
    }
  }


  virtual ~CreateIdentityProviderRequestWeComConfig() = default;
};
class CreateIdentityProviderRequest : public Darabonba::Model {
public:
  shared_ptr<CreateIdentityProviderRequestAuthnConfig> authnConfig{};
  shared_ptr<CreateIdentityProviderRequestAutoCreateUserConfig> autoCreateUserConfig{};
  shared_ptr<CreateIdentityProviderRequestAutoUpdateUserConfig> autoUpdateUserConfig{};
  shared_ptr<CreateIdentityProviderRequestBindingConfig> bindingConfig{};
  shared_ptr<string> clientToken{};
  shared_ptr<CreateIdentityProviderRequestDingtalkAppConfig> dingtalkAppConfig{};
  shared_ptr<string> identityProviderName{};
  shared_ptr<string> identityProviderType{};
  shared_ptr<string> instanceId{};
  shared_ptr<CreateIdentityProviderRequestLarkConfig> larkConfig{};
  shared_ptr<CreateIdentityProviderRequestLdapConfig> ldapConfig{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<CreateIdentityProviderRequestOidcConfig> oidcConfig{};
  shared_ptr<CreateIdentityProviderRequestUdPullConfig> udPullConfig{};
  shared_ptr<CreateIdentityProviderRequestUdPushConfig> udPushConfig{};
  shared_ptr<CreateIdentityProviderRequestWeComConfig> weComConfig{};

  CreateIdentityProviderRequest() {}

  explicit CreateIdentityProviderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnConfig) {
      res["AuthnConfig"] = authnConfig ? boost::any(authnConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoCreateUserConfig) {
      res["AutoCreateUserConfig"] = autoCreateUserConfig ? boost::any(autoCreateUserConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (autoUpdateUserConfig) {
      res["AutoUpdateUserConfig"] = autoUpdateUserConfig ? boost::any(autoUpdateUserConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bindingConfig) {
      res["BindingConfig"] = bindingConfig ? boost::any(bindingConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dingtalkAppConfig) {
      res["DingtalkAppConfig"] = dingtalkAppConfig ? boost::any(dingtalkAppConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (identityProviderName) {
      res["IdentityProviderName"] = boost::any(*identityProviderName);
    }
    if (identityProviderType) {
      res["IdentityProviderType"] = boost::any(*identityProviderType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (larkConfig) {
      res["LarkConfig"] = larkConfig ? boost::any(larkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ldapConfig) {
      res["LdapConfig"] = ldapConfig ? boost::any(ldapConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (oidcConfig) {
      res["OidcConfig"] = oidcConfig ? boost::any(oidcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udPullConfig) {
      res["UdPullConfig"] = udPullConfig ? boost::any(udPullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udPushConfig) {
      res["UdPushConfig"] = udPushConfig ? boost::any(udPushConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (weComConfig) {
      res["WeComConfig"] = weComConfig ? boost::any(weComConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnConfig") != m.end() && !m["AuthnConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnConfig"].type()) {
        CreateIdentityProviderRequestAuthnConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnConfig"]));
        authnConfig = make_shared<CreateIdentityProviderRequestAuthnConfig>(model1);
      }
    }
    if (m.find("AutoCreateUserConfig") != m.end() && !m["AutoCreateUserConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoCreateUserConfig"].type()) {
        CreateIdentityProviderRequestAutoCreateUserConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoCreateUserConfig"]));
        autoCreateUserConfig = make_shared<CreateIdentityProviderRequestAutoCreateUserConfig>(model1);
      }
    }
    if (m.find("AutoUpdateUserConfig") != m.end() && !m["AutoUpdateUserConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["AutoUpdateUserConfig"].type()) {
        CreateIdentityProviderRequestAutoUpdateUserConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AutoUpdateUserConfig"]));
        autoUpdateUserConfig = make_shared<CreateIdentityProviderRequestAutoUpdateUserConfig>(model1);
      }
    }
    if (m.find("BindingConfig") != m.end() && !m["BindingConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BindingConfig"].type()) {
        CreateIdentityProviderRequestBindingConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BindingConfig"]));
        bindingConfig = make_shared<CreateIdentityProviderRequestBindingConfig>(model1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DingtalkAppConfig") != m.end() && !m["DingtalkAppConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DingtalkAppConfig"].type()) {
        CreateIdentityProviderRequestDingtalkAppConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DingtalkAppConfig"]));
        dingtalkAppConfig = make_shared<CreateIdentityProviderRequestDingtalkAppConfig>(model1);
      }
    }
    if (m.find("IdentityProviderName") != m.end() && !m["IdentityProviderName"].empty()) {
      identityProviderName = make_shared<string>(boost::any_cast<string>(m["IdentityProviderName"]));
    }
    if (m.find("IdentityProviderType") != m.end() && !m["IdentityProviderType"].empty()) {
      identityProviderType = make_shared<string>(boost::any_cast<string>(m["IdentityProviderType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LarkConfig") != m.end() && !m["LarkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LarkConfig"].type()) {
        CreateIdentityProviderRequestLarkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LarkConfig"]));
        larkConfig = make_shared<CreateIdentityProviderRequestLarkConfig>(model1);
      }
    }
    if (m.find("LdapConfig") != m.end() && !m["LdapConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LdapConfig"].type()) {
        CreateIdentityProviderRequestLdapConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LdapConfig"]));
        ldapConfig = make_shared<CreateIdentityProviderRequestLdapConfig>(model1);
      }
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("OidcConfig") != m.end() && !m["OidcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OidcConfig"].type()) {
        CreateIdentityProviderRequestOidcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OidcConfig"]));
        oidcConfig = make_shared<CreateIdentityProviderRequestOidcConfig>(model1);
      }
    }
    if (m.find("UdPullConfig") != m.end() && !m["UdPullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdPullConfig"].type()) {
        CreateIdentityProviderRequestUdPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdPullConfig"]));
        udPullConfig = make_shared<CreateIdentityProviderRequestUdPullConfig>(model1);
      }
    }
    if (m.find("UdPushConfig") != m.end() && !m["UdPushConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdPushConfig"].type()) {
        CreateIdentityProviderRequestUdPushConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdPushConfig"]));
        udPushConfig = make_shared<CreateIdentityProviderRequestUdPushConfig>(model1);
      }
    }
    if (m.find("WeComConfig") != m.end() && !m["WeComConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WeComConfig"].type()) {
        CreateIdentityProviderRequestWeComConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WeComConfig"]));
        weComConfig = make_shared<CreateIdentityProviderRequestWeComConfig>(model1);
      }
    }
  }


  virtual ~CreateIdentityProviderRequest() = default;
};
class CreateIdentityProviderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> requestId{};

  CreateIdentityProviderResponseBody() {}

  explicit CreateIdentityProviderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIdentityProviderResponseBody() = default;
};
class CreateIdentityProviderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIdentityProviderResponseBody> body{};

  CreateIdentityProviderResponse() {}

  explicit CreateIdentityProviderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIdentityProviderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIdentityProviderResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIdentityProviderResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateNetworkAccessEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointName{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcRegionId{};

  CreateNetworkAccessEndpointRequest() {}

  explicit CreateNetworkAccessEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointName) {
      res["NetworkAccessEndpointName"] = boost::any(*networkAccessEndpointName);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointName") != m.end() && !m["NetworkAccessEndpointName"].empty()) {
      networkAccessEndpointName = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointName"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
  }


  virtual ~CreateNetworkAccessEndpointRequest() = default;
};
class CreateNetworkAccessEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<string> requestId{};

  CreateNetworkAccessEndpointResponseBody() {}

  explicit CreateNetworkAccessEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateNetworkAccessEndpointResponseBody() = default;
};
class CreateNetworkAccessEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNetworkAccessEndpointResponseBody> body{};

  CreateNetworkAccessEndpointResponse() {}

  explicit CreateNetworkAccessEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNetworkAccessEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNetworkAccessEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNetworkAccessEndpointResponse() = default;
};
class CreateOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitExternalId{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<string> parentId{};

  CreateOrganizationalUnitRequest() {}

  explicit CreateOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitExternalId) {
      res["OrganizationalUnitExternalId"] = boost::any(*organizationalUnitExternalId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitExternalId") != m.end() && !m["OrganizationalUnitExternalId"].empty()) {
      organizationalUnitExternalId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitExternalId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~CreateOrganizationalUnitRequest() = default;
};
class CreateOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> requestId{};

  CreateOrganizationalUnitResponseBody() {}

  explicit CreateOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOrganizationalUnitResponseBody() = default;
};
class CreateOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrganizationalUnitResponseBody> body{};

  CreateOrganizationalUnitResponse() {}

  explicit CreateOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrganizationalUnitResponse() = default;
};
class CreateUserRequestCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};

  CreateUserRequestCustomFields() {}

  explicit CreateUserRequestCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
  }


  virtual ~CreateUserRequestCustomFields() = default;
};
class CreateUserRequestPasswordInitializationConfig : public Darabonba::Model {
public:
  shared_ptr<string> passwordForcedUpdateStatus{};
  shared_ptr<string> passwordInitializationPolicyPriority{};
  shared_ptr<string> passwordInitializationType{};
  shared_ptr<vector<string>> userNotificationChannels{};

  CreateUserRequestPasswordInitializationConfig() {}

  explicit CreateUserRequestPasswordInitializationConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordForcedUpdateStatus) {
      res["PasswordForcedUpdateStatus"] = boost::any(*passwordForcedUpdateStatus);
    }
    if (passwordInitializationPolicyPriority) {
      res["PasswordInitializationPolicyPriority"] = boost::any(*passwordInitializationPolicyPriority);
    }
    if (passwordInitializationType) {
      res["PasswordInitializationType"] = boost::any(*passwordInitializationType);
    }
    if (userNotificationChannels) {
      res["UserNotificationChannels"] = boost::any(*userNotificationChannels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordForcedUpdateStatus") != m.end() && !m["PasswordForcedUpdateStatus"].empty()) {
      passwordForcedUpdateStatus = make_shared<string>(boost::any_cast<string>(m["PasswordForcedUpdateStatus"]));
    }
    if (m.find("PasswordInitializationPolicyPriority") != m.end() && !m["PasswordInitializationPolicyPriority"].empty()) {
      passwordInitializationPolicyPriority = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationPolicyPriority"]));
    }
    if (m.find("PasswordInitializationType") != m.end() && !m["PasswordInitializationType"].empty()) {
      passwordInitializationType = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationType"]));
    }
    if (m.find("UserNotificationChannels") != m.end() && !m["UserNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userNotificationChannels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateUserRequestPasswordInitializationConfig() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateUserRequestCustomFields>> customFields{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<bool> emailVerified{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<string> password{};
  shared_ptr<CreateUserRequestPasswordInitializationConfig> passwordInitializationConfig{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<bool> phoneNumberVerified{};
  shared_ptr<string> phoneRegion{};
  shared_ptr<string> primaryOrganizationalUnitId{};
  shared_ptr<string> userExternalId{};
  shared_ptr<string> username{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomFields"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (emailVerified) {
      res["EmailVerified"] = boost::any(*emailVerified);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordInitializationConfig) {
      res["PasswordInitializationConfig"] = passwordInitializationConfig ? boost::any(passwordInitializationConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (phoneNumberVerified) {
      res["PhoneNumberVerified"] = boost::any(*phoneNumberVerified);
    }
    if (phoneRegion) {
      res["PhoneRegion"] = boost::any(*phoneRegion);
    }
    if (primaryOrganizationalUnitId) {
      res["PrimaryOrganizationalUnitId"] = boost::any(*primaryOrganizationalUnitId);
    }
    if (userExternalId) {
      res["UserExternalId"] = boost::any(*userExternalId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomFields") != m.end() && !m["CustomFields"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomFields"].type()) {
        vector<CreateUserRequestCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateUserRequestCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<CreateUserRequestCustomFields>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EmailVerified") != m.end() && !m["EmailVerified"].empty()) {
      emailVerified = make_shared<bool>(boost::any_cast<bool>(m["EmailVerified"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordInitializationConfig") != m.end() && !m["PasswordInitializationConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PasswordInitializationConfig"].type()) {
        CreateUserRequestPasswordInitializationConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PasswordInitializationConfig"]));
        passwordInitializationConfig = make_shared<CreateUserRequestPasswordInitializationConfig>(model1);
      }
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PhoneNumberVerified") != m.end() && !m["PhoneNumberVerified"].empty()) {
      phoneNumberVerified = make_shared<bool>(boost::any_cast<bool>(m["PhoneNumberVerified"]));
    }
    if (m.find("PhoneRegion") != m.end() && !m["PhoneRegion"].empty()) {
      phoneRegion = make_shared<string>(boost::any_cast<string>(m["PhoneRegion"]));
    }
    if (m.find("PrimaryOrganizationalUnitId") != m.end() && !m["PrimaryOrganizationalUnitId"].empty()) {
      primaryOrganizationalUnitId = make_shared<string>(boost::any_cast<string>(m["PrimaryOrganizationalUnitId"]));
    }
    if (m.find("UserExternalId") != m.end() && !m["UserExternalId"].empty()) {
      userExternalId = make_shared<string>(boost::any_cast<string>(m["UserExternalId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> userId{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class DeleteApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  DeleteApplicationRequest() {}

  explicit DeleteApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteApplicationRequest() = default;
};
class DeleteApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationResponseBody() {}

  explicit DeleteApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationResponseBody() = default;
};
class DeleteApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationResponseBody> body{};

  DeleteApplicationResponse() {}

  explicit DeleteApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationResponse() = default;
};
class DeleteApplicationClientSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> secretId{};

  DeleteApplicationClientSecretRequest() {}

  explicit DeleteApplicationClientSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
  }


  virtual ~DeleteApplicationClientSecretRequest() = default;
};
class DeleteApplicationClientSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationClientSecretResponseBody() {}

  explicit DeleteApplicationClientSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationClientSecretResponseBody() = default;
};
class DeleteApplicationClientSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationClientSecretResponseBody> body{};

  DeleteApplicationClientSecretResponse() {}

  explicit DeleteApplicationClientSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationClientSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationClientSecretResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationClientSecretResponse() = default;
};
class DeleteConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> instanceId{};

  DeleteConditionalAccessPolicyRequest() {}

  explicit DeleteConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteConditionalAccessPolicyRequest() = default;
};
class DeleteConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteConditionalAccessPolicyResponseBody() {}

  explicit DeleteConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteConditionalAccessPolicyResponseBody() = default;
};
class DeleteConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConditionalAccessPolicyResponseBody> body{};

  DeleteConditionalAccessPolicyResponse() {}

  explicit DeleteConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConditionalAccessPolicyResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteDomainProxyTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};

  DeleteDomainProxyTokenRequest() {}

  explicit DeleteDomainProxyTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteDomainProxyTokenRequest() = default;
};
class DeleteDomainProxyTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainProxyTokenResponseBody() {}

  explicit DeleteDomainProxyTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainProxyTokenResponseBody() = default;
};
class DeleteDomainProxyTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainProxyTokenResponseBody> body{};

  DeleteDomainProxyTokenResponse() {}

  explicit DeleteDomainProxyTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainProxyTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainProxyTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainProxyTokenResponse() = default;
};
class DeleteGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};

  DeleteGroupRequest() {}

  explicit DeleteGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteGroupRequest() = default;
};
class DeleteGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteGroupResponseBody() {}

  explicit DeleteGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteGroupResponseBody() = default;
};
class DeleteGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGroupResponseBody> body{};

  DeleteGroupResponse() {}

  explicit DeleteGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGroupResponse() = default;
};
class DeleteIdentityProviderRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> instanceId{};

  DeleteIdentityProviderRequest() {}

  explicit DeleteIdentityProviderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteIdentityProviderRequest() = default;
};
class DeleteIdentityProviderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIdentityProviderResponseBody() {}

  explicit DeleteIdentityProviderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIdentityProviderResponseBody() = default;
};
class DeleteIdentityProviderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIdentityProviderResponseBody> body{};

  DeleteIdentityProviderResponse() {}

  explicit DeleteIdentityProviderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIdentityProviderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIdentityProviderResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIdentityProviderResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteNetworkAccessEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};

  DeleteNetworkAccessEndpointRequest() {}

  explicit DeleteNetworkAccessEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
  }


  virtual ~DeleteNetworkAccessEndpointRequest() = default;
};
class DeleteNetworkAccessEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteNetworkAccessEndpointResponseBody() {}

  explicit DeleteNetworkAccessEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteNetworkAccessEndpointResponseBody() = default;
};
class DeleteNetworkAccessEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteNetworkAccessEndpointResponseBody> body{};

  DeleteNetworkAccessEndpointResponse() {}

  explicit DeleteNetworkAccessEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteNetworkAccessEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteNetworkAccessEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteNetworkAccessEndpointResponse() = default;
};
class DeleteOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};

  DeleteOrganizationalUnitRequest() {}

  explicit DeleteOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~DeleteOrganizationalUnitRequest() = default;
};
class DeleteOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOrganizationalUnitResponseBody() {}

  explicit DeleteOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOrganizationalUnitResponseBody() = default;
};
class DeleteOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOrganizationalUnitResponseBody> body{};

  DeleteOrganizationalUnitResponse() {}

  explicit DeleteOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOrganizationalUnitResponse() = default;
};
class DeleteOrganizationalUnitChildrenRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};

  DeleteOrganizationalUnitChildrenRequest() {}

  explicit DeleteOrganizationalUnitChildrenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~DeleteOrganizationalUnitChildrenRequest() = default;
};
class DeleteOrganizationalUnitChildrenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteOrganizationalUnitChildrenResponseBody() {}

  explicit DeleteOrganizationalUnitChildrenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteOrganizationalUnitChildrenResponseBody() = default;
};
class DeleteOrganizationalUnitChildrenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteOrganizationalUnitChildrenResponseBody> body{};

  DeleteOrganizationalUnitChildrenResponse() {}

  explicit DeleteOrganizationalUnitChildrenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteOrganizationalUnitChildrenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteOrganizationalUnitChildrenResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteOrganizationalUnitChildrenResponse() = default;
};
class DeleteUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  DeleteUserRequest() {}

  explicit DeleteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DeleteUserRequest() = default;
};
class DeleteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserResponseBody() {}

  explicit DeleteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteUserResponseBody() = default;
};
class DeleteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserResponseBody> body{};

  DeleteUserResponse() {}

  explicit DeleteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserResponse() = default;
};
class DisableApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  DisableApplicationRequest() {}

  explicit DisableApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableApplicationRequest() = default;
};
class DisableApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationResponseBody() {}

  explicit DisableApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationResponseBody() = default;
};
class DisableApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationResponseBody> body{};

  DisableApplicationResponse() {}

  explicit DisableApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationResponse() = default;
};
class DisableApplicationApiInvokeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  DisableApplicationApiInvokeRequest() {}

  explicit DisableApplicationApiInvokeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableApplicationApiInvokeRequest() = default;
};
class DisableApplicationApiInvokeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationApiInvokeResponseBody() {}

  explicit DisableApplicationApiInvokeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationApiInvokeResponseBody() = default;
};
class DisableApplicationApiInvokeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationApiInvokeResponseBody> body{};

  DisableApplicationApiInvokeResponse() {}

  explicit DisableApplicationApiInvokeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationApiInvokeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationApiInvokeResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationApiInvokeResponse() = default;
};
class DisableApplicationClientSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> secretId{};

  DisableApplicationClientSecretRequest() {}

  explicit DisableApplicationClientSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
  }


  virtual ~DisableApplicationClientSecretRequest() = default;
};
class DisableApplicationClientSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationClientSecretResponseBody() {}

  explicit DisableApplicationClientSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationClientSecretResponseBody() = default;
};
class DisableApplicationClientSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationClientSecretResponseBody> body{};

  DisableApplicationClientSecretResponse() {}

  explicit DisableApplicationClientSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationClientSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationClientSecretResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationClientSecretResponse() = default;
};
class DisableApplicationProvisioningRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  DisableApplicationProvisioningRequest() {}

  explicit DisableApplicationProvisioningRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableApplicationProvisioningRequest() = default;
};
class DisableApplicationProvisioningResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationProvisioningResponseBody() {}

  explicit DisableApplicationProvisioningResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationProvisioningResponseBody() = default;
};
class DisableApplicationProvisioningResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationProvisioningResponseBody> body{};

  DisableApplicationProvisioningResponse() {}

  explicit DisableApplicationProvisioningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationProvisioningResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationProvisioningResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationProvisioningResponse() = default;
};
class DisableApplicationSsoRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  DisableApplicationSsoRequest() {}

  explicit DisableApplicationSsoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableApplicationSsoRequest() = default;
};
class DisableApplicationSsoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationSsoResponseBody() {}

  explicit DisableApplicationSsoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationSsoResponseBody() = default;
};
class DisableApplicationSsoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationSsoResponseBody> body{};

  DisableApplicationSsoResponse() {}

  explicit DisableApplicationSsoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationSsoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationSsoResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationSsoResponse() = default;
};
class DisableConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> instanceId{};

  DisableConditionalAccessPolicyRequest() {}

  explicit DisableConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableConditionalAccessPolicyRequest() = default;
};
class DisableConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableConditionalAccessPolicyResponseBody() {}

  explicit DisableConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableConditionalAccessPolicyResponseBody() = default;
};
class DisableConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableConditionalAccessPolicyResponseBody> body{};

  DisableConditionalAccessPolicyResponse() {}

  explicit DisableConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DisableConditionalAccessPolicyResponse() = default;
};
class DisableDomainProxyTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};

  DisableDomainProxyTokenRequest() {}

  explicit DisableDomainProxyTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableDomainProxyTokenRequest() = default;
};
class DisableDomainProxyTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableDomainProxyTokenResponseBody() {}

  explicit DisableDomainProxyTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableDomainProxyTokenResponseBody() = default;
};
class DisableDomainProxyTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableDomainProxyTokenResponseBody> body{};

  DisableDomainProxyTokenResponse() {}

  explicit DisableDomainProxyTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableDomainProxyTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableDomainProxyTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DisableDomainProxyTokenResponse() = default;
};
class DisableIdentityProviderUdPullRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> instanceId{};

  DisableIdentityProviderUdPullRequest() {}

  explicit DisableIdentityProviderUdPullRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableIdentityProviderUdPullRequest() = default;
};
class DisableIdentityProviderUdPullResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableIdentityProviderUdPullResponseBody() {}

  explicit DisableIdentityProviderUdPullResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableIdentityProviderUdPullResponseBody() = default;
};
class DisableIdentityProviderUdPullResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableIdentityProviderUdPullResponseBody> body{};

  DisableIdentityProviderUdPullResponse() {}

  explicit DisableIdentityProviderUdPullResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableIdentityProviderUdPullResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableIdentityProviderUdPullResponseBody>(model1);
      }
    }
  }


  virtual ~DisableIdentityProviderUdPullResponse() = default;
};
class DisableInitDomainAutoRedirectRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DisableInitDomainAutoRedirectRequest() {}

  explicit DisableInitDomainAutoRedirectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DisableInitDomainAutoRedirectRequest() = default;
};
class DisableInitDomainAutoRedirectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableInitDomainAutoRedirectResponseBody() {}

  explicit DisableInitDomainAutoRedirectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableInitDomainAutoRedirectResponseBody() = default;
};
class DisableInitDomainAutoRedirectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableInitDomainAutoRedirectResponseBody> body{};

  DisableInitDomainAutoRedirectResponse() {}

  explicit DisableInitDomainAutoRedirectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableInitDomainAutoRedirectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableInitDomainAutoRedirectResponseBody>(model1);
      }
    }
  }


  virtual ~DisableInitDomainAutoRedirectResponse() = default;
};
class DisableUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  DisableUserRequest() {}

  explicit DisableUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DisableUserRequest() = default;
};
class DisableUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableUserResponseBody() {}

  explicit DisableUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableUserResponseBody() = default;
};
class DisableUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableUserResponseBody> body{};

  DisableUserResponse() {}

  explicit DisableUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableUserResponseBody>(model1);
      }
    }
  }


  virtual ~DisableUserResponse() = default;
};
class EnableApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  EnableApplicationRequest() {}

  explicit EnableApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableApplicationRequest() = default;
};
class EnableApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationResponseBody() {}

  explicit EnableApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationResponseBody() = default;
};
class EnableApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationResponseBody> body{};

  EnableApplicationResponse() {}

  explicit EnableApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationResponse() = default;
};
class EnableApplicationApiInvokeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  EnableApplicationApiInvokeRequest() {}

  explicit EnableApplicationApiInvokeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableApplicationApiInvokeRequest() = default;
};
class EnableApplicationApiInvokeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationApiInvokeResponseBody() {}

  explicit EnableApplicationApiInvokeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationApiInvokeResponseBody() = default;
};
class EnableApplicationApiInvokeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationApiInvokeResponseBody> body{};

  EnableApplicationApiInvokeResponse() {}

  explicit EnableApplicationApiInvokeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationApiInvokeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationApiInvokeResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationApiInvokeResponse() = default;
};
class EnableApplicationClientSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> secretId{};

  EnableApplicationClientSecretRequest() {}

  explicit EnableApplicationClientSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
  }


  virtual ~EnableApplicationClientSecretRequest() = default;
};
class EnableApplicationClientSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationClientSecretResponseBody() {}

  explicit EnableApplicationClientSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationClientSecretResponseBody() = default;
};
class EnableApplicationClientSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationClientSecretResponseBody> body{};

  EnableApplicationClientSecretResponse() {}

  explicit EnableApplicationClientSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationClientSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationClientSecretResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationClientSecretResponse() = default;
};
class EnableApplicationProvisioningRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  EnableApplicationProvisioningRequest() {}

  explicit EnableApplicationProvisioningRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableApplicationProvisioningRequest() = default;
};
class EnableApplicationProvisioningResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationProvisioningResponseBody() {}

  explicit EnableApplicationProvisioningResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationProvisioningResponseBody() = default;
};
class EnableApplicationProvisioningResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationProvisioningResponseBody> body{};

  EnableApplicationProvisioningResponse() {}

  explicit EnableApplicationProvisioningResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationProvisioningResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationProvisioningResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationProvisioningResponse() = default;
};
class EnableApplicationSsoRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  EnableApplicationSsoRequest() {}

  explicit EnableApplicationSsoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableApplicationSsoRequest() = default;
};
class EnableApplicationSsoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationSsoResponseBody() {}

  explicit EnableApplicationSsoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationSsoResponseBody() = default;
};
class EnableApplicationSsoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationSsoResponseBody> body{};

  EnableApplicationSsoResponse() {}

  explicit EnableApplicationSsoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationSsoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationSsoResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationSsoResponse() = default;
};
class EnableConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> instanceId{};

  EnableConditionalAccessPolicyRequest() {}

  explicit EnableConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableConditionalAccessPolicyRequest() = default;
};
class EnableConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableConditionalAccessPolicyResponseBody() {}

  explicit EnableConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableConditionalAccessPolicyResponseBody() = default;
};
class EnableConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableConditionalAccessPolicyResponseBody> body{};

  EnableConditionalAccessPolicyResponse() {}

  explicit EnableConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~EnableConditionalAccessPolicyResponse() = default;
};
class EnableDomainProxyTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};

  EnableDomainProxyTokenRequest() {}

  explicit EnableDomainProxyTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableDomainProxyTokenRequest() = default;
};
class EnableDomainProxyTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableDomainProxyTokenResponseBody() {}

  explicit EnableDomainProxyTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableDomainProxyTokenResponseBody() = default;
};
class EnableDomainProxyTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableDomainProxyTokenResponseBody> body{};

  EnableDomainProxyTokenResponse() {}

  explicit EnableDomainProxyTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableDomainProxyTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableDomainProxyTokenResponseBody>(model1);
      }
    }
  }


  virtual ~EnableDomainProxyTokenResponse() = default;
};
class EnableIdentityProviderUdPullRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> instanceId{};

  EnableIdentityProviderUdPullRequest() {}

  explicit EnableIdentityProviderUdPullRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableIdentityProviderUdPullRequest() = default;
};
class EnableIdentityProviderUdPullResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableIdentityProviderUdPullResponseBody() {}

  explicit EnableIdentityProviderUdPullResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableIdentityProviderUdPullResponseBody() = default;
};
class EnableIdentityProviderUdPullResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableIdentityProviderUdPullResponseBody> body{};

  EnableIdentityProviderUdPullResponse() {}

  explicit EnableIdentityProviderUdPullResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableIdentityProviderUdPullResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableIdentityProviderUdPullResponseBody>(model1);
      }
    }
  }


  virtual ~EnableIdentityProviderUdPullResponse() = default;
};
class EnableInitDomainAutoRedirectRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  EnableInitDomainAutoRedirectRequest() {}

  explicit EnableInitDomainAutoRedirectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~EnableInitDomainAutoRedirectRequest() = default;
};
class EnableInitDomainAutoRedirectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableInitDomainAutoRedirectResponseBody() {}

  explicit EnableInitDomainAutoRedirectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableInitDomainAutoRedirectResponseBody() = default;
};
class EnableInitDomainAutoRedirectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableInitDomainAutoRedirectResponseBody> body{};

  EnableInitDomainAutoRedirectResponse() {}

  explicit EnableInitDomainAutoRedirectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableInitDomainAutoRedirectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableInitDomainAutoRedirectResponseBody>(model1);
      }
    }
  }


  virtual ~EnableInitDomainAutoRedirectResponse() = default;
};
class EnableUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  EnableUserRequest() {}

  explicit EnableUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EnableUserRequest() = default;
};
class EnableUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableUserResponseBody() {}

  explicit EnableUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableUserResponseBody() = default;
};
class EnableUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableUserResponseBody> body{};

  EnableUserResponse() {}

  explicit EnableUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableUserResponseBody>(model1);
      }
    }
  }


  virtual ~EnableUserResponse() = default;
};
class GetApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  GetApplicationRequest() {}

  explicit GetApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetApplicationRequest() = default;
};
class GetApplicationResponseBodyApplication : public Darabonba::Model {
public:
  shared_ptr<string> apiInvokeStatus{};
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationSourceType{};
  shared_ptr<string> applicationTemplateId{};
  shared_ptr<vector<string>> applicationVisibility{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> clientId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> customSubjectStatus{};
  shared_ptr<string> description{};
  shared_ptr<string> features{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> m2MClientStatus{};
  shared_ptr<string> managedServiceCode{};
  shared_ptr<string> resourceServerIdentifier{};
  shared_ptr<string> resourceServerStatus{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> ssoType{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  GetApplicationResponseBodyApplication() {}

  explicit GetApplicationResponseBodyApplication(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInvokeStatus) {
      res["ApiInvokeStatus"] = boost::any(*apiInvokeStatus);
    }
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationSourceType) {
      res["ApplicationSourceType"] = boost::any(*applicationSourceType);
    }
    if (applicationTemplateId) {
      res["ApplicationTemplateId"] = boost::any(*applicationTemplateId);
    }
    if (applicationVisibility) {
      res["ApplicationVisibility"] = boost::any(*applicationVisibility);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customSubjectStatus) {
      res["CustomSubjectStatus"] = boost::any(*customSubjectStatus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (m2MClientStatus) {
      res["M2MClientStatus"] = boost::any(*m2MClientStatus);
    }
    if (managedServiceCode) {
      res["ManagedServiceCode"] = boost::any(*managedServiceCode);
    }
    if (resourceServerIdentifier) {
      res["ResourceServerIdentifier"] = boost::any(*resourceServerIdentifier);
    }
    if (resourceServerStatus) {
      res["ResourceServerStatus"] = boost::any(*resourceServerStatus);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (ssoType) {
      res["SsoType"] = boost::any(*ssoType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInvokeStatus") != m.end() && !m["ApiInvokeStatus"].empty()) {
      apiInvokeStatus = make_shared<string>(boost::any_cast<string>(m["ApiInvokeStatus"]));
    }
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationSourceType") != m.end() && !m["ApplicationSourceType"].empty()) {
      applicationSourceType = make_shared<string>(boost::any_cast<string>(m["ApplicationSourceType"]));
    }
    if (m.find("ApplicationTemplateId") != m.end() && !m["ApplicationTemplateId"].empty()) {
      applicationTemplateId = make_shared<string>(boost::any_cast<string>(m["ApplicationTemplateId"]));
    }
    if (m.find("ApplicationVisibility") != m.end() && !m["ApplicationVisibility"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationVisibility"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationVisibility"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationVisibility = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomSubjectStatus") != m.end() && !m["CustomSubjectStatus"].empty()) {
      customSubjectStatus = make_shared<string>(boost::any_cast<string>(m["CustomSubjectStatus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      features = make_shared<string>(boost::any_cast<string>(m["Features"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("M2MClientStatus") != m.end() && !m["M2MClientStatus"].empty()) {
      m2MClientStatus = make_shared<string>(boost::any_cast<string>(m["M2MClientStatus"]));
    }
    if (m.find("ManagedServiceCode") != m.end() && !m["ManagedServiceCode"].empty()) {
      managedServiceCode = make_shared<string>(boost::any_cast<string>(m["ManagedServiceCode"]));
    }
    if (m.find("ResourceServerIdentifier") != m.end() && !m["ResourceServerIdentifier"].empty()) {
      resourceServerIdentifier = make_shared<string>(boost::any_cast<string>(m["ResourceServerIdentifier"]));
    }
    if (m.find("ResourceServerStatus") != m.end() && !m["ResourceServerStatus"].empty()) {
      resourceServerStatus = make_shared<string>(boost::any_cast<string>(m["ResourceServerStatus"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("SsoType") != m.end() && !m["SsoType"].empty()) {
      ssoType = make_shared<string>(boost::any_cast<string>(m["SsoType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetApplicationResponseBodyApplication() = default;
};
class GetApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationResponseBodyApplication> application{};
  shared_ptr<string> requestId{};

  GetApplicationResponseBody() {}

  explicit GetApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (application) {
      res["Application"] = application ? boost::any(application->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Application") != m.end() && !m["Application"].empty()) {
      if (typeid(map<string, boost::any>) == m["Application"].type()) {
        GetApplicationResponseBodyApplication model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Application"]));
        application = make_shared<GetApplicationResponseBodyApplication>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationResponseBody() = default;
};
class GetApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationResponseBody> body{};

  GetApplicationResponse() {}

  explicit GetApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationResponse() = default;
};
class GetApplicationGrantScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  GetApplicationGrantScopeRequest() {}

  explicit GetApplicationGrantScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetApplicationGrantScopeRequest() = default;
};
class GetApplicationGrantScopeResponseBodyApplicationGrantScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> grantScopes{};

  GetApplicationGrantScopeResponseBodyApplicationGrantScope() {}

  explicit GetApplicationGrantScopeResponseBodyApplicationGrantScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetApplicationGrantScopeResponseBodyApplicationGrantScope() = default;
};
class GetApplicationGrantScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationGrantScopeResponseBodyApplicationGrantScope> applicationGrantScope{};
  shared_ptr<string> requestId{};

  GetApplicationGrantScopeResponseBody() {}

  explicit GetApplicationGrantScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationGrantScope) {
      res["ApplicationGrantScope"] = applicationGrantScope ? boost::any(applicationGrantScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationGrantScope") != m.end() && !m["ApplicationGrantScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationGrantScope"].type()) {
        GetApplicationGrantScopeResponseBodyApplicationGrantScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationGrantScope"]));
        applicationGrantScope = make_shared<GetApplicationGrantScopeResponseBodyApplicationGrantScope>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationGrantScopeResponseBody() = default;
};
class GetApplicationGrantScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationGrantScopeResponseBody> body{};

  GetApplicationGrantScopeResponse() {}

  explicit GetApplicationGrantScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationGrantScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationGrantScopeResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationGrantScopeResponse() = default;
};
class GetApplicationProvisioningConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  GetApplicationProvisioningConfigRequest() {}

  explicit GetApplicationProvisioningConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigRequest() = default;
};
class GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> encryptKey{};
  shared_ptr<bool> encryptRequired{};
  shared_ptr<vector<string>> listenEventScopes{};

  GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig() {}

  explicit GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (encryptRequired) {
      res["EncryptRequired"] = boost::any(*encryptRequired);
    }
    if (listenEventScopes) {
      res["ListenEventScopes"] = boost::any(*listenEventScopes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("EncryptRequired") != m.end() && !m["EncryptRequired"].empty()) {
      encryptRequired = make_shared<bool>(boost::any_cast<bool>(m["EncryptRequired"]));
    }
    if (m.find("ListenEventScopes") != m.end() && !m["ListenEventScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListenEventScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListenEventScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listenEventScopes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig() = default;
};
class GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> authnMethod{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> tokenEndpoint{};

  GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam() {}

  explicit GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (authnMethod) {
      res["AuthnMethod"] = boost::any(*authnMethod);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    if (tokenEndpoint) {
      res["TokenEndpoint"] = boost::any(*tokenEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AuthnMethod") != m.end() && !m["AuthnMethod"].empty()) {
      authnMethod = make_shared<string>(boost::any_cast<string>(m["AuthnMethod"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
    if (m.find("TokenEndpoint") != m.end() && !m["TokenEndpoint"].empty()) {
      tokenEndpoint = make_shared<string>(boost::any_cast<string>(m["TokenEndpoint"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam() = default;
};
class GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> authnMode{};
  shared_ptr<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam> authnParam{};
  shared_ptr<string> grantType{};

  GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration() {}

  explicit GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnMode) {
      res["AuthnMode"] = boost::any(*authnMode);
    }
    if (authnParam) {
      res["AuthnParam"] = authnParam ? boost::any(authnParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnMode") != m.end() && !m["AuthnMode"].empty()) {
      authnMode = make_shared<string>(boost::any_cast<string>(m["AuthnMode"]));
    }
    if (m.find("AuthnParam") != m.end() && !m["AuthnParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnParam"].type()) {
        GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnParam"]));
        authnParam = make_shared<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfigurationAuthnParam>(model1);
      }
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration() = default;
};
class GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration> authnConfiguration{};
  shared_ptr<vector<string>> fullPushScopes{};
  shared_ptr<vector<string>> provisioningActions{};
  shared_ptr<string> scimBaseUrl{};

  GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig() {}

  explicit GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnConfiguration) {
      res["AuthnConfiguration"] = authnConfiguration ? boost::any(authnConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullPushScopes) {
      res["FullPushScopes"] = boost::any(*fullPushScopes);
    }
    if (provisioningActions) {
      res["ProvisioningActions"] = boost::any(*provisioningActions);
    }
    if (scimBaseUrl) {
      res["ScimBaseUrl"] = boost::any(*scimBaseUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnConfiguration") != m.end() && !m["AuthnConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnConfiguration"].type()) {
        GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnConfiguration"]));
        authnConfiguration = make_shared<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfigAuthnConfiguration>(model1);
      }
    }
    if (m.find("FullPushScopes") != m.end() && !m["FullPushScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FullPushScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FullPushScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fullPushScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProvisioningActions") != m.end() && !m["ProvisioningActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProvisioningActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProvisioningActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      provisioningActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScimBaseUrl") != m.end() && !m["ScimBaseUrl"].empty()) {
      scimBaseUrl = make_shared<string>(boost::any_cast<string>(m["ScimBaseUrl"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig() = default;
};
class GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig> callbackProvisioningConfig{};
  shared_ptr<string> configOperateMode{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> provisionJwksEndpoint{};
  shared_ptr<bool> provisionPassword{};
  shared_ptr<string> provisionProtocolType{};
  shared_ptr<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig> scimProvisioningConfig{};
  shared_ptr<string> status{};

  GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig() {}

  explicit GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (callbackProvisioningConfig) {
      res["CallbackProvisioningConfig"] = callbackProvisioningConfig ? boost::any(callbackProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (configOperateMode) {
      res["ConfigOperateMode"] = boost::any(*configOperateMode);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (provisionJwksEndpoint) {
      res["ProvisionJwksEndpoint"] = boost::any(*provisionJwksEndpoint);
    }
    if (provisionPassword) {
      res["ProvisionPassword"] = boost::any(*provisionPassword);
    }
    if (provisionProtocolType) {
      res["ProvisionProtocolType"] = boost::any(*provisionProtocolType);
    }
    if (scimProvisioningConfig) {
      res["ScimProvisioningConfig"] = scimProvisioningConfig ? boost::any(scimProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("CallbackProvisioningConfig") != m.end() && !m["CallbackProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallbackProvisioningConfig"].type()) {
        GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallbackProvisioningConfig"]));
        callbackProvisioningConfig = make_shared<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigCallbackProvisioningConfig>(model1);
      }
    }
    if (m.find("ConfigOperateMode") != m.end() && !m["ConfigOperateMode"].empty()) {
      configOperateMode = make_shared<string>(boost::any_cast<string>(m["ConfigOperateMode"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProvisionJwksEndpoint") != m.end() && !m["ProvisionJwksEndpoint"].empty()) {
      provisionJwksEndpoint = make_shared<string>(boost::any_cast<string>(m["ProvisionJwksEndpoint"]));
    }
    if (m.find("ProvisionPassword") != m.end() && !m["ProvisionPassword"].empty()) {
      provisionPassword = make_shared<bool>(boost::any_cast<bool>(m["ProvisionPassword"]));
    }
    if (m.find("ProvisionProtocolType") != m.end() && !m["ProvisionProtocolType"].empty()) {
      provisionProtocolType = make_shared<string>(boost::any_cast<string>(m["ProvisionProtocolType"]));
    }
    if (m.find("ScimProvisioningConfig") != m.end() && !m["ScimProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScimProvisioningConfig"].type()) {
        GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScimProvisioningConfig"]));
        scimProvisioningConfig = make_shared<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfigScimProvisioningConfig>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig() = default;
};
class GetApplicationProvisioningConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig> applicationProvisioningConfig{};
  shared_ptr<string> requestId{};

  GetApplicationProvisioningConfigResponseBody() {}

  explicit GetApplicationProvisioningConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationProvisioningConfig) {
      res["ApplicationProvisioningConfig"] = applicationProvisioningConfig ? boost::any(applicationProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationProvisioningConfig") != m.end() && !m["ApplicationProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationProvisioningConfig"].type()) {
        GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationProvisioningConfig"]));
        applicationProvisioningConfig = make_shared<GetApplicationProvisioningConfigResponseBodyApplicationProvisioningConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationProvisioningConfigResponseBody() = default;
};
class GetApplicationProvisioningConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationProvisioningConfigResponseBody> body{};

  GetApplicationProvisioningConfigResponse() {}

  explicit GetApplicationProvisioningConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationProvisioningConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationProvisioningConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationProvisioningConfigResponse() = default;
};
class GetApplicationProvisioningScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  GetApplicationProvisioningScopeRequest() {}

  explicit GetApplicationProvisioningScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetApplicationProvisioningScopeRequest() = default;
};
class GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<long> maxQuota{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<long> usedQuota{};

  GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope() {}

  explicit GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (maxQuota) {
      res["MaxQuota"] = boost::any(*maxQuota);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (usedQuota) {
      res["UsedQuota"] = boost::any(*usedQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxQuota") != m.end() && !m["MaxQuota"].empty()) {
      maxQuota = make_shared<long>(boost::any_cast<long>(m["MaxQuota"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UsedQuota") != m.end() && !m["UsedQuota"].empty()) {
      usedQuota = make_shared<long>(boost::any_cast<long>(m["UsedQuota"]));
    }
  }


  virtual ~GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope() = default;
};
class GetApplicationProvisioningScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope> applicationProvisioningScope{};
  shared_ptr<string> requestId{};

  GetApplicationProvisioningScopeResponseBody() {}

  explicit GetApplicationProvisioningScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationProvisioningScope) {
      res["ApplicationProvisioningScope"] = applicationProvisioningScope ? boost::any(applicationProvisioningScope->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationProvisioningScope") != m.end() && !m["ApplicationProvisioningScope"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationProvisioningScope"].type()) {
        GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationProvisioningScope"]));
        applicationProvisioningScope = make_shared<GetApplicationProvisioningScopeResponseBodyApplicationProvisioningScope>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationProvisioningScopeResponseBody() = default;
};
class GetApplicationProvisioningScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationProvisioningScopeResponseBody> body{};

  GetApplicationProvisioningScopeResponse() {}

  explicit GetApplicationProvisioningScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationProvisioningScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationProvisioningScopeResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationProvisioningScopeResponse() = default;
};
class GetApplicationSsoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  GetApplicationSsoConfigRequest() {}

  explicit GetApplicationSsoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetApplicationSsoConfigRequest() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims : public Darabonba::Model {
public:
  shared_ptr<string> claimName{};
  shared_ptr<string> claimValueExpression{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (claimName) {
      res["ClaimName"] = boost::any(*claimName);
    }
    if (claimValueExpression) {
      res["ClaimValueExpression"] = boost::any(*claimValueExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClaimName") != m.end() && !m["ClaimName"].empty()) {
      claimName = make_shared<string>(boost::any_cast<string>(m["ClaimName"]));
    }
    if (m.find("ClaimValueExpression") != m.end() && !m["ClaimValueExpression"].empty()) {
      claimValueExpression = make_shared<string>(boost::any_cast<string>(m["ClaimValueExpression"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig : public Darabonba::Model {
public:
  shared_ptr<long> accessTokenEffectiveTime{};
  shared_ptr<long> codeEffectiveTime{};
  shared_ptr<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims>> customClaims{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<vector<string>> grantTypes{};
  shared_ptr<long> idTokenEffectiveTime{};
  shared_ptr<string> passwordAuthenticationSourceId{};
  shared_ptr<bool> passwordTotpMfaRequired{};
  shared_ptr<vector<string>> pkceChallengeMethods{};
  shared_ptr<bool> pkceRequired{};
  shared_ptr<vector<string>> postLogoutRedirectUris{};
  shared_ptr<vector<string>> redirectUris{};
  shared_ptr<long> refreshTokenEffective{};
  shared_ptr<vector<string>> responseTypes{};
  shared_ptr<string> subjectIdExpression{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTokenEffectiveTime) {
      res["AccessTokenEffectiveTime"] = boost::any(*accessTokenEffectiveTime);
    }
    if (codeEffectiveTime) {
      res["CodeEffectiveTime"] = boost::any(*codeEffectiveTime);
    }
    if (customClaims) {
      vector<boost::any> temp1;
      for(auto item1:*customClaims){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomClaims"] = boost::any(temp1);
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (grantTypes) {
      res["GrantTypes"] = boost::any(*grantTypes);
    }
    if (idTokenEffectiveTime) {
      res["IdTokenEffectiveTime"] = boost::any(*idTokenEffectiveTime);
    }
    if (passwordAuthenticationSourceId) {
      res["PasswordAuthenticationSourceId"] = boost::any(*passwordAuthenticationSourceId);
    }
    if (passwordTotpMfaRequired) {
      res["PasswordTotpMfaRequired"] = boost::any(*passwordTotpMfaRequired);
    }
    if (pkceChallengeMethods) {
      res["PkceChallengeMethods"] = boost::any(*pkceChallengeMethods);
    }
    if (pkceRequired) {
      res["PkceRequired"] = boost::any(*pkceRequired);
    }
    if (postLogoutRedirectUris) {
      res["PostLogoutRedirectUris"] = boost::any(*postLogoutRedirectUris);
    }
    if (redirectUris) {
      res["RedirectUris"] = boost::any(*redirectUris);
    }
    if (refreshTokenEffective) {
      res["RefreshTokenEffective"] = boost::any(*refreshTokenEffective);
    }
    if (responseTypes) {
      res["ResponseTypes"] = boost::any(*responseTypes);
    }
    if (subjectIdExpression) {
      res["SubjectIdExpression"] = boost::any(*subjectIdExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTokenEffectiveTime") != m.end() && !m["AccessTokenEffectiveTime"].empty()) {
      accessTokenEffectiveTime = make_shared<long>(boost::any_cast<long>(m["AccessTokenEffectiveTime"]));
    }
    if (m.find("CodeEffectiveTime") != m.end() && !m["CodeEffectiveTime"].empty()) {
      codeEffectiveTime = make_shared<long>(boost::any_cast<long>(m["CodeEffectiveTime"]));
    }
    if (m.find("CustomClaims") != m.end() && !m["CustomClaims"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomClaims"].type()) {
        vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomClaims"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customClaims = make_shared<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfigCustomClaims>>(expect1);
      }
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GrantTypes") != m.end() && !m["GrantTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IdTokenEffectiveTime") != m.end() && !m["IdTokenEffectiveTime"].empty()) {
      idTokenEffectiveTime = make_shared<long>(boost::any_cast<long>(m["IdTokenEffectiveTime"]));
    }
    if (m.find("PasswordAuthenticationSourceId") != m.end() && !m["PasswordAuthenticationSourceId"].empty()) {
      passwordAuthenticationSourceId = make_shared<string>(boost::any_cast<string>(m["PasswordAuthenticationSourceId"]));
    }
    if (m.find("PasswordTotpMfaRequired") != m.end() && !m["PasswordTotpMfaRequired"].empty()) {
      passwordTotpMfaRequired = make_shared<bool>(boost::any_cast<bool>(m["PasswordTotpMfaRequired"]));
    }
    if (m.find("PkceChallengeMethods") != m.end() && !m["PkceChallengeMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PkceChallengeMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PkceChallengeMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pkceChallengeMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PkceRequired") != m.end() && !m["PkceRequired"].empty()) {
      pkceRequired = make_shared<bool>(boost::any_cast<bool>(m["PkceRequired"]));
    }
    if (m.find("PostLogoutRedirectUris") != m.end() && !m["PostLogoutRedirectUris"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PostLogoutRedirectUris"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PostLogoutRedirectUris"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      postLogoutRedirectUris = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUris") != m.end() && !m["RedirectUris"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RedirectUris"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RedirectUris"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      redirectUris = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RefreshTokenEffective") != m.end() && !m["RefreshTokenEffective"].empty()) {
      refreshTokenEffective = make_shared<long>(boost::any_cast<long>(m["RefreshTokenEffective"]));
    }
    if (m.find("ResponseTypes") != m.end() && !m["ResponseTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResponseTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResponseTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      responseTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubjectIdExpression") != m.end() && !m["SubjectIdExpression"].empty()) {
      subjectIdExpression = make_shared<string>(boost::any_cast<string>(m["SubjectIdExpression"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain : public Darabonba::Model {
public:
  shared_ptr<string> oauth2AuthorizationEndpoint{};
  shared_ptr<string> oauth2DeviceAuthorizationEndpoint{};
  shared_ptr<string> oauth2RevokeEndpoint{};
  shared_ptr<string> oauth2TokenEndpoint{};
  shared_ptr<string> oauth2UserinfoEndpoint{};
  shared_ptr<string> oidcIssuer{};
  shared_ptr<string> oidcJwksEndpoint{};
  shared_ptr<string> oidcLogoutEndpoint{};
  shared_ptr<string> samlMetaEndpoint{};
  shared_ptr<string> samlSsoEndpoint{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (oauth2AuthorizationEndpoint) {
      res["Oauth2AuthorizationEndpoint"] = boost::any(*oauth2AuthorizationEndpoint);
    }
    if (oauth2DeviceAuthorizationEndpoint) {
      res["Oauth2DeviceAuthorizationEndpoint"] = boost::any(*oauth2DeviceAuthorizationEndpoint);
    }
    if (oauth2RevokeEndpoint) {
      res["Oauth2RevokeEndpoint"] = boost::any(*oauth2RevokeEndpoint);
    }
    if (oauth2TokenEndpoint) {
      res["Oauth2TokenEndpoint"] = boost::any(*oauth2TokenEndpoint);
    }
    if (oauth2UserinfoEndpoint) {
      res["Oauth2UserinfoEndpoint"] = boost::any(*oauth2UserinfoEndpoint);
    }
    if (oidcIssuer) {
      res["OidcIssuer"] = boost::any(*oidcIssuer);
    }
    if (oidcJwksEndpoint) {
      res["OidcJwksEndpoint"] = boost::any(*oidcJwksEndpoint);
    }
    if (oidcLogoutEndpoint) {
      res["OidcLogoutEndpoint"] = boost::any(*oidcLogoutEndpoint);
    }
    if (samlMetaEndpoint) {
      res["SamlMetaEndpoint"] = boost::any(*samlMetaEndpoint);
    }
    if (samlSsoEndpoint) {
      res["SamlSsoEndpoint"] = boost::any(*samlSsoEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Oauth2AuthorizationEndpoint") != m.end() && !m["Oauth2AuthorizationEndpoint"].empty()) {
      oauth2AuthorizationEndpoint = make_shared<string>(boost::any_cast<string>(m["Oauth2AuthorizationEndpoint"]));
    }
    if (m.find("Oauth2DeviceAuthorizationEndpoint") != m.end() && !m["Oauth2DeviceAuthorizationEndpoint"].empty()) {
      oauth2DeviceAuthorizationEndpoint = make_shared<string>(boost::any_cast<string>(m["Oauth2DeviceAuthorizationEndpoint"]));
    }
    if (m.find("Oauth2RevokeEndpoint") != m.end() && !m["Oauth2RevokeEndpoint"].empty()) {
      oauth2RevokeEndpoint = make_shared<string>(boost::any_cast<string>(m["Oauth2RevokeEndpoint"]));
    }
    if (m.find("Oauth2TokenEndpoint") != m.end() && !m["Oauth2TokenEndpoint"].empty()) {
      oauth2TokenEndpoint = make_shared<string>(boost::any_cast<string>(m["Oauth2TokenEndpoint"]));
    }
    if (m.find("Oauth2UserinfoEndpoint") != m.end() && !m["Oauth2UserinfoEndpoint"].empty()) {
      oauth2UserinfoEndpoint = make_shared<string>(boost::any_cast<string>(m["Oauth2UserinfoEndpoint"]));
    }
    if (m.find("OidcIssuer") != m.end() && !m["OidcIssuer"].empty()) {
      oidcIssuer = make_shared<string>(boost::any_cast<string>(m["OidcIssuer"]));
    }
    if (m.find("OidcJwksEndpoint") != m.end() && !m["OidcJwksEndpoint"].empty()) {
      oidcJwksEndpoint = make_shared<string>(boost::any_cast<string>(m["OidcJwksEndpoint"]));
    }
    if (m.find("OidcLogoutEndpoint") != m.end() && !m["OidcLogoutEndpoint"].empty()) {
      oidcLogoutEndpoint = make_shared<string>(boost::any_cast<string>(m["OidcLogoutEndpoint"]));
    }
    if (m.find("SamlMetaEndpoint") != m.end() && !m["SamlMetaEndpoint"].empty()) {
      samlMetaEndpoint = make_shared<string>(boost::any_cast<string>(m["SamlMetaEndpoint"]));
    }
    if (m.find("SamlSsoEndpoint") != m.end() && !m["SamlSsoEndpoint"].empty()) {
      samlSsoEndpoint = make_shared<string>(boost::any_cast<string>(m["SamlSsoEndpoint"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValueExpression{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValueExpression) {
      res["AttributeValueExpression"] = boost::any(*attributeValueExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValueExpression") != m.end() && !m["AttributeValueExpression"].empty()) {
      attributeValueExpression = make_shared<string>(boost::any_cast<string>(m["AttributeValueExpression"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> relayState{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (relayState) {
      res["RelayState"] = boost::any(*relayState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("RelayState") != m.end() && !m["RelayState"].empty()) {
      relayState = make_shared<string>(boost::any_cast<string>(m["RelayState"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig : public Darabonba::Model {
public:
  shared_ptr<bool> assertionSigned{};
  shared_ptr<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements>> attributeStatements{};
  shared_ptr<string> defaultRelayState{};
  shared_ptr<string> idPEntityId{};
  shared_ptr<string> nameIdFormat{};
  shared_ptr<string> nameIdValueExpression{};
  shared_ptr<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates>> optionalRelayStates{};
  shared_ptr<bool> responseSigned{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> spEntityId{};
  shared_ptr<string> spSsoAcsUrl{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertionSigned) {
      res["AssertionSigned"] = boost::any(*assertionSigned);
    }
    if (attributeStatements) {
      vector<boost::any> temp1;
      for(auto item1:*attributeStatements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeStatements"] = boost::any(temp1);
    }
    if (defaultRelayState) {
      res["DefaultRelayState"] = boost::any(*defaultRelayState);
    }
    if (idPEntityId) {
      res["IdPEntityId"] = boost::any(*idPEntityId);
    }
    if (nameIdFormat) {
      res["NameIdFormat"] = boost::any(*nameIdFormat);
    }
    if (nameIdValueExpression) {
      res["NameIdValueExpression"] = boost::any(*nameIdValueExpression);
    }
    if (optionalRelayStates) {
      vector<boost::any> temp1;
      for(auto item1:*optionalRelayStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OptionalRelayStates"] = boost::any(temp1);
    }
    if (responseSigned) {
      res["ResponseSigned"] = boost::any(*responseSigned);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (spEntityId) {
      res["SpEntityId"] = boost::any(*spEntityId);
    }
    if (spSsoAcsUrl) {
      res["SpSsoAcsUrl"] = boost::any(*spSsoAcsUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssertionSigned") != m.end() && !m["AssertionSigned"].empty()) {
      assertionSigned = make_shared<bool>(boost::any_cast<bool>(m["AssertionSigned"]));
    }
    if (m.find("AttributeStatements") != m.end() && !m["AttributeStatements"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeStatements"].type()) {
        vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeStatements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeStatements = make_shared<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigAttributeStatements>>(expect1);
      }
    }
    if (m.find("DefaultRelayState") != m.end() && !m["DefaultRelayState"].empty()) {
      defaultRelayState = make_shared<string>(boost::any_cast<string>(m["DefaultRelayState"]));
    }
    if (m.find("IdPEntityId") != m.end() && !m["IdPEntityId"].empty()) {
      idPEntityId = make_shared<string>(boost::any_cast<string>(m["IdPEntityId"]));
    }
    if (m.find("NameIdFormat") != m.end() && !m["NameIdFormat"].empty()) {
      nameIdFormat = make_shared<string>(boost::any_cast<string>(m["NameIdFormat"]));
    }
    if (m.find("NameIdValueExpression") != m.end() && !m["NameIdValueExpression"].empty()) {
      nameIdValueExpression = make_shared<string>(boost::any_cast<string>(m["NameIdValueExpression"]));
    }
    if (m.find("OptionalRelayStates") != m.end() && !m["OptionalRelayStates"].empty()) {
      if (typeid(vector<boost::any>) == m["OptionalRelayStates"].type()) {
        vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OptionalRelayStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        optionalRelayStates = make_shared<vector<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfigOptionalRelayStates>>(expect1);
      }
    }
    if (m.find("ResponseSigned") != m.end() && !m["ResponseSigned"].empty()) {
      responseSigned = make_shared<bool>(boost::any_cast<bool>(m["ResponseSigned"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("SpEntityId") != m.end() && !m["SpEntityId"].empty()) {
      spEntityId = make_shared<string>(boost::any_cast<string>(m["SpEntityId"]));
    }
    if (m.find("SpSsoAcsUrl") != m.end() && !m["SpSsoAcsUrl"].empty()) {
      spSsoAcsUrl = make_shared<string>(boost::any_cast<string>(m["SpSsoAcsUrl"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig() = default;
};
class GetApplicationSsoConfigResponseBodyApplicationSsoConfig : public Darabonba::Model {
public:
  shared_ptr<string> initLoginType{};
  shared_ptr<string> initLoginUrl{};
  shared_ptr<GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig> oidcSsoConfig{};
  shared_ptr<GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain> protocolEndpointDomain{};
  shared_ptr<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig> samlSsoConfig{};
  shared_ptr<string> ssoStatus{};

  GetApplicationSsoConfigResponseBodyApplicationSsoConfig() {}

  explicit GetApplicationSsoConfigResponseBodyApplicationSsoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (initLoginType) {
      res["InitLoginType"] = boost::any(*initLoginType);
    }
    if (initLoginUrl) {
      res["InitLoginUrl"] = boost::any(*initLoginUrl);
    }
    if (oidcSsoConfig) {
      res["OidcSsoConfig"] = oidcSsoConfig ? boost::any(oidcSsoConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (protocolEndpointDomain) {
      res["ProtocolEndpointDomain"] = protocolEndpointDomain ? boost::any(protocolEndpointDomain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (samlSsoConfig) {
      res["SamlSsoConfig"] = samlSsoConfig ? boost::any(samlSsoConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ssoStatus) {
      res["SsoStatus"] = boost::any(*ssoStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InitLoginType") != m.end() && !m["InitLoginType"].empty()) {
      initLoginType = make_shared<string>(boost::any_cast<string>(m["InitLoginType"]));
    }
    if (m.find("InitLoginUrl") != m.end() && !m["InitLoginUrl"].empty()) {
      initLoginUrl = make_shared<string>(boost::any_cast<string>(m["InitLoginUrl"]));
    }
    if (m.find("OidcSsoConfig") != m.end() && !m["OidcSsoConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OidcSsoConfig"].type()) {
        GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OidcSsoConfig"]));
        oidcSsoConfig = make_shared<GetApplicationSsoConfigResponseBodyApplicationSsoConfigOidcSsoConfig>(model1);
      }
    }
    if (m.find("ProtocolEndpointDomain") != m.end() && !m["ProtocolEndpointDomain"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProtocolEndpointDomain"].type()) {
        GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProtocolEndpointDomain"]));
        protocolEndpointDomain = make_shared<GetApplicationSsoConfigResponseBodyApplicationSsoConfigProtocolEndpointDomain>(model1);
      }
    }
    if (m.find("SamlSsoConfig") != m.end() && !m["SamlSsoConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamlSsoConfig"].type()) {
        GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamlSsoConfig"]));
        samlSsoConfig = make_shared<GetApplicationSsoConfigResponseBodyApplicationSsoConfigSamlSsoConfig>(model1);
      }
    }
    if (m.find("SsoStatus") != m.end() && !m["SsoStatus"].empty()) {
      ssoStatus = make_shared<string>(boost::any_cast<string>(m["SsoStatus"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBodyApplicationSsoConfig() = default;
};
class GetApplicationSsoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetApplicationSsoConfigResponseBodyApplicationSsoConfig> applicationSsoConfig{};
  shared_ptr<string> requestId{};

  GetApplicationSsoConfigResponseBody() {}

  explicit GetApplicationSsoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationSsoConfig) {
      res["ApplicationSsoConfig"] = applicationSsoConfig ? boost::any(applicationSsoConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationSsoConfig") != m.end() && !m["ApplicationSsoConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationSsoConfig"].type()) {
        GetApplicationSsoConfigResponseBodyApplicationSsoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationSsoConfig"]));
        applicationSsoConfig = make_shared<GetApplicationSsoConfigResponseBodyApplicationSsoConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetApplicationSsoConfigResponseBody() = default;
};
class GetApplicationSsoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetApplicationSsoConfigResponseBody> body{};

  GetApplicationSsoConfigResponse() {}

  explicit GetApplicationSsoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetApplicationSsoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetApplicationSsoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetApplicationSsoConfigResponse() = default;
};
class GetConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> instanceId{};

  GetConditionalAccessPolicyRequest() {}

  explicit GetConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetConditionalAccessPolicyRequest() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeApplications{};
  shared_ptr<vector<string>> includeApplications{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeApplications) {
      res["ExcludeApplications"] = boost::any(*excludeApplications);
    }
    if (includeApplications) {
      res["IncludeApplications"] = boost::any(*includeApplications);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeApplications") != m.end() && !m["ExcludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeApplications = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeApplications") != m.end() && !m["IncludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeApplications = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeNetworkZones{};
  shared_ptr<vector<string>> includeNetworkZones{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeNetworkZones) {
      res["ExcludeNetworkZones"] = boost::any(*excludeNetworkZones);
    }
    if (includeNetworkZones) {
      res["IncludeNetworkZones"] = boost::any(*includeNetworkZones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeNetworkZones") != m.end() && !m["ExcludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeNetworkZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeNetworkZones") != m.end() && !m["IncludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeNetworkZones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeGroups{};
  shared_ptr<vector<string>> excludeOrganizationalUnits{};
  shared_ptr<vector<string>> excludeUsers{};
  shared_ptr<vector<string>> includeGroups{};
  shared_ptr<vector<string>> includeOrganizationalUnits{};
  shared_ptr<vector<string>> includeUsers{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeGroups) {
      res["ExcludeGroups"] = boost::any(*excludeGroups);
    }
    if (excludeOrganizationalUnits) {
      res["ExcludeOrganizationalUnits"] = boost::any(*excludeOrganizationalUnits);
    }
    if (excludeUsers) {
      res["ExcludeUsers"] = boost::any(*excludeUsers);
    }
    if (includeGroups) {
      res["IncludeGroups"] = boost::any(*includeGroups);
    }
    if (includeOrganizationalUnits) {
      res["IncludeOrganizationalUnits"] = boost::any(*includeOrganizationalUnits);
    }
    if (includeUsers) {
      res["IncludeUsers"] = boost::any(*includeUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeGroups") != m.end() && !m["ExcludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeOrganizationalUnits") != m.end() && !m["ExcludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeUsers") != m.end() && !m["ExcludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeGroups") != m.end() && !m["IncludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeOrganizationalUnits") != m.end() && !m["IncludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeUsers") != m.end() && !m["IncludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig : public Darabonba::Model {
public:
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications> applications{};
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones> networkZones{};
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers> users{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkZones) {
      res["NetworkZones"] = networkZones ? boost::any(networkZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigApplications>(model1);
      }
    }
    if (m.find("NetworkZones") != m.end() && !m["NetworkZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkZones"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkZones"]));
        networkZones = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigNetworkZones>(model1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfigUsers>(model1);
      }
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig : public Darabonba::Model {
public:
  shared_ptr<string> activeSessionReuseStatus{};
  shared_ptr<string> effect{};
  shared_ptr<long> mfaAuthenticationIntervalSeconds{};
  shared_ptr<vector<string>> mfaAuthenticationMethods{};
  shared_ptr<string> mfaType{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionReuseStatus) {
      res["ActiveSessionReuseStatus"] = boost::any(*activeSessionReuseStatus);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (mfaAuthenticationIntervalSeconds) {
      res["MfaAuthenticationIntervalSeconds"] = boost::any(*mfaAuthenticationIntervalSeconds);
    }
    if (mfaAuthenticationMethods) {
      res["MfaAuthenticationMethods"] = boost::any(*mfaAuthenticationMethods);
    }
    if (mfaType) {
      res["MfaType"] = boost::any(*mfaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionReuseStatus") != m.end() && !m["ActiveSessionReuseStatus"].empty()) {
      activeSessionReuseStatus = make_shared<string>(boost::any_cast<string>(m["ActiveSessionReuseStatus"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("MfaAuthenticationIntervalSeconds") != m.end() && !m["MfaAuthenticationIntervalSeconds"].empty()) {
      mfaAuthenticationIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["MfaAuthenticationIntervalSeconds"]));
    }
    if (m.find("MfaAuthenticationMethods") != m.end() && !m["MfaAuthenticationMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MfaAuthenticationMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MfaAuthenticationMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mfaAuthenticationMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MfaType") != m.end() && !m["MfaType"].empty()) {
      mfaType = make_shared<string>(boost::any_cast<string>(m["MfaType"]));
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig() = default;
};
class GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> conditionalAccessPolicyName{};
  shared_ptr<string> conditionalAccessPolicyType{};
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig> conditionsConfig{};
  shared_ptr<long> createTime{};
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig> decisionConfig{};
  shared_ptr<string> decisionType{};
  shared_ptr<string> description{};
  shared_ptr<string> evaluateAt{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUpdatedTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};

  GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy() {}

  explicit GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (conditionalAccessPolicyName) {
      res["ConditionalAccessPolicyName"] = boost::any(*conditionalAccessPolicyName);
    }
    if (conditionalAccessPolicyType) {
      res["ConditionalAccessPolicyType"] = boost::any(*conditionalAccessPolicyType);
    }
    if (conditionsConfig) {
      res["ConditionsConfig"] = conditionsConfig ? boost::any(conditionsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (decisionConfig) {
      res["DecisionConfig"] = decisionConfig ? boost::any(decisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionType) {
      res["DecisionType"] = boost::any(*decisionType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (evaluateAt) {
      res["EvaluateAt"] = boost::any(*evaluateAt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUpdatedTime) {
      res["LastUpdatedTime"] = boost::any(*lastUpdatedTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("ConditionalAccessPolicyName") != m.end() && !m["ConditionalAccessPolicyName"].empty()) {
      conditionalAccessPolicyName = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyName"]));
    }
    if (m.find("ConditionalAccessPolicyType") != m.end() && !m["ConditionalAccessPolicyType"].empty()) {
      conditionalAccessPolicyType = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyType"]));
    }
    if (m.find("ConditionsConfig") != m.end() && !m["ConditionsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionsConfig"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionsConfig"]));
        conditionsConfig = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyConditionsConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DecisionConfig") != m.end() && !m["DecisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DecisionConfig"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DecisionConfig"]));
        decisionConfig = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicyDecisionConfig>(model1);
      }
    }
    if (m.find("DecisionType") != m.end() && !m["DecisionType"].empty()) {
      decisionType = make_shared<string>(boost::any_cast<string>(m["DecisionType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EvaluateAt") != m.end() && !m["EvaluateAt"].empty()) {
      evaluateAt = make_shared<string>(boost::any_cast<string>(m["EvaluateAt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUpdatedTime") != m.end() && !m["LastUpdatedTime"].empty()) {
      lastUpdatedTime = make_shared<long>(boost::any_cast<long>(m["LastUpdatedTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy() = default;
};
class GetConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy> conditionalAccessPolicy{};
  shared_ptr<string> requestId{};

  GetConditionalAccessPolicyResponseBody() {}

  explicit GetConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicy) {
      res["ConditionalAccessPolicy"] = conditionalAccessPolicy ? boost::any(conditionalAccessPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicy") != m.end() && !m["ConditionalAccessPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionalAccessPolicy"].type()) {
        GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionalAccessPolicy"]));
        conditionalAccessPolicy = make_shared<GetConditionalAccessPolicyResponseBodyConditionalAccessPolicy>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConditionalAccessPolicyResponseBody() = default;
};
class GetConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConditionalAccessPolicyResponseBody> body{};

  GetConditionalAccessPolicyResponse() {}

  explicit GetConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~GetConditionalAccessPolicyResponse() = default;
};
class GetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};

  GetDomainRequest() {}

  explicit GetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDomainRequest() = default;
};
class GetDomainResponseBodyDomainFiling : public Darabonba::Model {
public:
  shared_ptr<string> icpNumber{};

  GetDomainResponseBodyDomainFiling() {}

  explicit GetDomainResponseBodyDomainFiling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icpNumber) {
      res["IcpNumber"] = boost::any(*icpNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IcpNumber") != m.end() && !m["IcpNumber"].empty()) {
      icpNumber = make_shared<string>(boost::any_cast<string>(m["IcpNumber"]));
    }
  }


  virtual ~GetDomainResponseBodyDomainFiling() = default;
};
class GetDomainResponseBodyDomain : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<bool> defaultDomain{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainType{};
  shared_ptr<GetDomainResponseBodyDomainFiling> filing{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lockMode{};
  shared_ptr<long> updateTime{};

  GetDomainResponseBodyDomain() {}

  explicit GetDomainResponseBodyDomain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (filing) {
      res["Filing"] = filing ? boost::any(filing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<bool>(boost::any_cast<bool>(m["DefaultDomain"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("Filing") != m.end() && !m["Filing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filing"].type()) {
        GetDomainResponseBodyDomainFiling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filing"]));
        filing = make_shared<GetDomainResponseBodyDomainFiling>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetDomainResponseBodyDomain() = default;
};
class GetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDomainResponseBodyDomain> domain{};
  shared_ptr<string> requestId{};

  GetDomainResponseBody() {}

  explicit GetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = domain ? boost::any(domain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domain"].type()) {
        GetDomainResponseBodyDomain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domain"]));
        domain = make_shared<GetDomainResponseBodyDomain>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDomainResponseBody() = default;
};
class GetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDomainResponseBody> body{};

  GetDomainResponse() {}

  explicit GetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~GetDomainResponse() = default;
};
class GetDomainDnsChallengeRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> instanceId{};

  GetDomainDnsChallengeRequest() {}

  explicit GetDomainDnsChallengeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDomainDnsChallengeRequest() = default;
};
class GetDomainDnsChallengeResponseBodyDomainDnsChallenge : public Darabonba::Model {
public:
  shared_ptr<string> dnsChallengeName{};
  shared_ptr<string> dnsChallengeValue{};
  shared_ptr<string> dnsType{};

  GetDomainDnsChallengeResponseBodyDomainDnsChallenge() {}

  explicit GetDomainDnsChallengeResponseBodyDomainDnsChallenge(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnsChallengeName) {
      res["DnsChallengeName"] = boost::any(*dnsChallengeName);
    }
    if (dnsChallengeValue) {
      res["DnsChallengeValue"] = boost::any(*dnsChallengeValue);
    }
    if (dnsType) {
      res["DnsType"] = boost::any(*dnsType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnsChallengeName") != m.end() && !m["DnsChallengeName"].empty()) {
      dnsChallengeName = make_shared<string>(boost::any_cast<string>(m["DnsChallengeName"]));
    }
    if (m.find("DnsChallengeValue") != m.end() && !m["DnsChallengeValue"].empty()) {
      dnsChallengeValue = make_shared<string>(boost::any_cast<string>(m["DnsChallengeValue"]));
    }
    if (m.find("DnsType") != m.end() && !m["DnsType"].empty()) {
      dnsType = make_shared<string>(boost::any_cast<string>(m["DnsType"]));
    }
  }


  virtual ~GetDomainDnsChallengeResponseBodyDomainDnsChallenge() = default;
};
class GetDomainDnsChallengeResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetDomainDnsChallengeResponseBodyDomainDnsChallenge> domainDnsChallenge{};
  shared_ptr<string> requestId{};

  GetDomainDnsChallengeResponseBody() {}

  explicit GetDomainDnsChallengeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainDnsChallenge) {
      res["DomainDnsChallenge"] = domainDnsChallenge ? boost::any(domainDnsChallenge->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainDnsChallenge") != m.end() && !m["DomainDnsChallenge"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainDnsChallenge"].type()) {
        GetDomainDnsChallengeResponseBodyDomainDnsChallenge model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainDnsChallenge"]));
        domainDnsChallenge = make_shared<GetDomainDnsChallengeResponseBodyDomainDnsChallenge>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDomainDnsChallengeResponseBody() = default;
};
class GetDomainDnsChallengeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDomainDnsChallengeResponseBody> body{};

  GetDomainDnsChallengeResponse() {}

  explicit GetDomainDnsChallengeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDomainDnsChallengeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDomainDnsChallengeResponseBody>(model1);
      }
    }
  }


  virtual ~GetDomainDnsChallengeResponse() = default;
};
class GetForgetPasswordConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetForgetPasswordConfigurationRequest() {}

  explicit GetForgetPasswordConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetForgetPasswordConfigurationRequest() = default;
};
class GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<string>> authenticationChannels{};
  shared_ptr<bool> enable{};
  shared_ptr<bool> enableEmail{};
  shared_ptr<bool> enableSms{};
  shared_ptr<string> forgetPasswordStatus{};

  GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration() {}

  explicit GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authenticationChannels) {
      res["AuthenticationChannels"] = boost::any(*authenticationChannels);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (enableEmail) {
      res["EnableEmail"] = boost::any(*enableEmail);
    }
    if (enableSms) {
      res["EnableSms"] = boost::any(*enableSms);
    }
    if (forgetPasswordStatus) {
      res["ForgetPasswordStatus"] = boost::any(*forgetPasswordStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthenticationChannels") != m.end() && !m["AuthenticationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthenticationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthenticationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authenticationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("EnableEmail") != m.end() && !m["EnableEmail"].empty()) {
      enableEmail = make_shared<bool>(boost::any_cast<bool>(m["EnableEmail"]));
    }
    if (m.find("EnableSms") != m.end() && !m["EnableSms"].empty()) {
      enableSms = make_shared<bool>(boost::any_cast<bool>(m["EnableSms"]));
    }
    if (m.find("ForgetPasswordStatus") != m.end() && !m["ForgetPasswordStatus"].empty()) {
      forgetPasswordStatus = make_shared<string>(boost::any_cast<string>(m["ForgetPasswordStatus"]));
    }
  }


  virtual ~GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration() = default;
};
class GetForgetPasswordConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration> openForgetPasswordConfiguration{};
  shared_ptr<string> requestId{};

  GetForgetPasswordConfigurationResponseBody() {}

  explicit GetForgetPasswordConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openForgetPasswordConfiguration) {
      res["OpenForgetPasswordConfiguration"] = openForgetPasswordConfiguration ? boost::any(openForgetPasswordConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpenForgetPasswordConfiguration") != m.end() && !m["OpenForgetPasswordConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenForgetPasswordConfiguration"].type()) {
        GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenForgetPasswordConfiguration"]));
        openForgetPasswordConfiguration = make_shared<GetForgetPasswordConfigurationResponseBodyOpenForgetPasswordConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetForgetPasswordConfigurationResponseBody() = default;
};
class GetForgetPasswordConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetForgetPasswordConfigurationResponseBody> body{};

  GetForgetPasswordConfigurationResponse() {}

  explicit GetForgetPasswordConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetForgetPasswordConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetForgetPasswordConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetForgetPasswordConfigurationResponse() = default;
};
class GetGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};

  GetGroupRequest() {}

  explicit GetGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetGroupRequest() = default;
};
class GetGroupResponseBodyGroup : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupExternalId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupSourceId{};
  shared_ptr<string> groupSourceType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> updateTime{};

  GetGroupResponseBodyGroup() {}

  explicit GetGroupResponseBodyGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupExternalId) {
      res["GroupExternalId"] = boost::any(*groupExternalId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupSourceId) {
      res["GroupSourceId"] = boost::any(*groupSourceId);
    }
    if (groupSourceType) {
      res["GroupSourceType"] = boost::any(*groupSourceType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupExternalId") != m.end() && !m["GroupExternalId"].empty()) {
      groupExternalId = make_shared<string>(boost::any_cast<string>(m["GroupExternalId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupSourceId") != m.end() && !m["GroupSourceId"].empty()) {
      groupSourceId = make_shared<string>(boost::any_cast<string>(m["GroupSourceId"]));
    }
    if (m.find("GroupSourceType") != m.end() && !m["GroupSourceType"].empty()) {
      groupSourceType = make_shared<string>(boost::any_cast<string>(m["GroupSourceType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetGroupResponseBodyGroup() = default;
};
class GetGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetGroupResponseBodyGroup> group{};
  shared_ptr<string> requestId{};

  GetGroupResponseBody() {}

  explicit GetGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (group) {
      res["Group"] = group ? boost::any(group->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Group") != m.end() && !m["Group"].empty()) {
      if (typeid(map<string, boost::any>) == m["Group"].type()) {
        GetGroupResponseBodyGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Group"]));
        group = make_shared<GetGroupResponseBodyGroup>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetGroupResponseBody() = default;
};
class GetGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetGroupResponseBody> body{};

  GetGroupResponse() {}

  explicit GetGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetGroupResponse() = default;
};
class GetIdentityProviderRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> instanceId{};

  GetIdentityProviderRequest() {}

  explicit GetIdentityProviderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetIdentityProviderRequest() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> corpId{};
  shared_ptr<string> dingtalkVersion{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> verificationToken{};

  GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (dingtalkVersion) {
      res["DingtalkVersion"] = boost::any(*dingtalkVersion);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("DingtalkVersion") != m.end() && !m["DingtalkVersion"].empty()) {
      dingtalkVersion = make_shared<string>(boost::any_cast<string>(m["DingtalkVersion"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds : public Darabonba::Model {
public:
  shared_ptr<string> deptId{};
  shared_ptr<string> deptName{};

  GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptId) {
      res["DeptId"] = boost::any(*deptId);
    }
    if (deptName) {
      res["DeptName"] = boost::any(*deptName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptId") != m.end() && !m["DeptId"].empty()) {
      deptId = make_shared<string>(boost::any_cast<string>(m["DeptId"]));
    }
    if (m.find("DeptName") != m.end() && !m["DeptName"].empty()) {
      deptName = make_shared<string>(boost::any_cast<string>(m["DeptName"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> userId{};

  GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds>> authedDepartmentIds{};
  shared_ptr<vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers>> authedUsers{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpName{};

  GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authedDepartmentIds) {
      vector<boost::any> temp1;
      for(auto item1:*authedDepartmentIds){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthedDepartmentIds"] = boost::any(temp1);
    }
    if (authedUsers) {
      vector<boost::any> temp1;
      for(auto item1:*authedUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthedUsers"] = boost::any(temp1);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (corpName) {
      res["CorpName"] = boost::any(*corpName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthedDepartmentIds") != m.end() && !m["AuthedDepartmentIds"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthedDepartmentIds"].type()) {
        vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthedDepartmentIds"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authedDepartmentIds = make_shared<vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedDepartmentIds>>(expect1);
      }
    }
    if (m.find("AuthedUsers") != m.end() && !m["AuthedUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthedUsers"].type()) {
        vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthedUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authedUsers = make_shared<vector<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfigAuthedUsers>>(expect1);
      }
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CorpName") != m.end() && !m["CorpName"].empty()) {
      corpName = make_shared<string>(boost::any_cast<string>(m["CorpName"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> enterpriseNumber{};
  shared_ptr<string> verificationToken{};

  GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (enterpriseNumber) {
      res["EnterpriseNumber"] = boost::any(*enterpriseNumber);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("EnterpriseNumber") != m.end() && !m["EnterpriseNumber"].empty()) {
      enterpriseNumber = make_shared<string>(boost::any_cast<string>(m["EnterpriseNumber"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig : public Darabonba::Model {
public:
  shared_ptr<string> administratorPassword{};
  shared_ptr<string> administratorUsername{};
  shared_ptr<string> certificateFingerprintStatus{};
  shared_ptr<vector<string>> certificateFingerprints{};
  shared_ptr<string> ldapProtocol{};
  shared_ptr<string> ldapServerHost{};
  shared_ptr<long> ldapServerPort{};
  shared_ptr<string> startTlsStatus{};

  GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administratorPassword) {
      res["AdministratorPassword"] = boost::any(*administratorPassword);
    }
    if (administratorUsername) {
      res["AdministratorUsername"] = boost::any(*administratorUsername);
    }
    if (certificateFingerprintStatus) {
      res["CertificateFingerprintStatus"] = boost::any(*certificateFingerprintStatus);
    }
    if (certificateFingerprints) {
      res["CertificateFingerprints"] = boost::any(*certificateFingerprints);
    }
    if (ldapProtocol) {
      res["LdapProtocol"] = boost::any(*ldapProtocol);
    }
    if (ldapServerHost) {
      res["LdapServerHost"] = boost::any(*ldapServerHost);
    }
    if (ldapServerPort) {
      res["LdapServerPort"] = boost::any(*ldapServerPort);
    }
    if (startTlsStatus) {
      res["StartTlsStatus"] = boost::any(*startTlsStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdministratorPassword") != m.end() && !m["AdministratorPassword"].empty()) {
      administratorPassword = make_shared<string>(boost::any_cast<string>(m["AdministratorPassword"]));
    }
    if (m.find("AdministratorUsername") != m.end() && !m["AdministratorUsername"].empty()) {
      administratorUsername = make_shared<string>(boost::any_cast<string>(m["AdministratorUsername"]));
    }
    if (m.find("CertificateFingerprintStatus") != m.end() && !m["CertificateFingerprintStatus"].empty()) {
      certificateFingerprintStatus = make_shared<string>(boost::any_cast<string>(m["CertificateFingerprintStatus"]));
    }
    if (m.find("CertificateFingerprints") != m.end() && !m["CertificateFingerprints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CertificateFingerprints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CertificateFingerprints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      certificateFingerprints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LdapProtocol") != m.end() && !m["LdapProtocol"].empty()) {
      ldapProtocol = make_shared<string>(boost::any_cast<string>(m["LdapProtocol"]));
    }
    if (m.find("LdapServerHost") != m.end() && !m["LdapServerHost"].empty()) {
      ldapServerHost = make_shared<string>(boost::any_cast<string>(m["LdapServerHost"]));
    }
    if (m.find("LdapServerPort") != m.end() && !m["LdapServerPort"].empty()) {
      ldapServerPort = make_shared<long>(boost::any_cast<long>(m["LdapServerPort"]));
    }
    if (m.find("StartTlsStatus") != m.end() && !m["StartTlsStatus"].empty()) {
      startTlsStatus = make_shared<string>(boost::any_cast<string>(m["StartTlsStatus"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam : public Darabonba::Model {
public:
  shared_ptr<string> authnMethod{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};

  GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnMethod) {
      res["AuthnMethod"] = boost::any(*authnMethod);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnMethod") != m.end() && !m["AuthnMethod"].empty()) {
      authnMethod = make_shared<string>(boost::any_cast<string>(m["AuthnMethod"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> authorizationEndpoint{};
  shared_ptr<string> issuer{};
  shared_ptr<string> jwksUri{};
  shared_ptr<string> tokenEndpoint{};
  shared_ptr<string> userinfoEndpoint{};

  GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationEndpoint) {
      res["AuthorizationEndpoint"] = boost::any(*authorizationEndpoint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (jwksUri) {
      res["JwksUri"] = boost::any(*jwksUri);
    }
    if (tokenEndpoint) {
      res["TokenEndpoint"] = boost::any(*tokenEndpoint);
    }
    if (userinfoEndpoint) {
      res["UserinfoEndpoint"] = boost::any(*userinfoEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationEndpoint") != m.end() && !m["AuthorizationEndpoint"].empty()) {
      authorizationEndpoint = make_shared<string>(boost::any_cast<string>(m["AuthorizationEndpoint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("JwksUri") != m.end() && !m["JwksUri"].empty()) {
      jwksUri = make_shared<string>(boost::any_cast<string>(m["JwksUri"]));
    }
    if (m.find("TokenEndpoint") != m.end() && !m["TokenEndpoint"].empty()) {
      tokenEndpoint = make_shared<string>(boost::any_cast<string>(m["TokenEndpoint"]));
    }
    if (m.find("UserinfoEndpoint") != m.end() && !m["UserinfoEndpoint"].empty()) {
      userinfoEndpoint = make_shared<string>(boost::any_cast<string>(m["UserinfoEndpoint"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig : public Darabonba::Model {
public:
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam> authnParam{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig> endpointConfig{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<string> grantType{};
  shared_ptr<string> pkceChallengeMethod{};
  shared_ptr<bool> pkceRequired{};

  GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnParam) {
      res["AuthnParam"] = authnParam ? boost::any(authnParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endpointConfig) {
      res["EndpointConfig"] = endpointConfig ? boost::any(endpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (pkceChallengeMethod) {
      res["PkceChallengeMethod"] = boost::any(*pkceChallengeMethod);
    }
    if (pkceRequired) {
      res["PkceRequired"] = boost::any(*pkceRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnParam") != m.end() && !m["AuthnParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnParam"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnParam"]));
        authnParam = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigAuthnParam>(model1);
      }
    }
    if (m.find("EndpointConfig") != m.end() && !m["EndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndpointConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndpointConfig"]));
        endpointConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfigEndpointConfig>(model1);
      }
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("PkceChallengeMethod") != m.end() && !m["PkceChallengeMethod"].empty()) {
      pkceChallengeMethod = make_shared<string>(boost::any_cast<string>(m["PkceChallengeMethod"]));
    }
    if (m.find("PkceRequired") != m.end() && !m["PkceRequired"].empty()) {
      pkceRequired = make_shared<bool>(boost::any_cast<bool>(m["PkceRequired"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> groupSyncStatus{};
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig> udSyncScopeConfig{};

  GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupSyncStatus) {
      res["GroupSyncStatus"] = boost::any(*groupSyncStatus);
    }
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (udSyncScopeConfig) {
      res["UdSyncScopeConfig"] = udSyncScopeConfig ? boost::any(udSyncScopeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupSyncStatus") != m.end() && !m["GroupSyncStatus"].empty()) {
      groupSyncStatus = make_shared<string>(boost::any_cast<string>(m["GroupSyncStatus"]));
    }
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("UdSyncScopeConfig") != m.end() && !m["UdSyncScopeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdSyncScopeConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdSyncScopeConfig"]));
        udSyncScopeConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfigUdSyncScopeConfig>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig : public Darabonba::Model {
public:
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<vector<GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs>> udSyncScopeConfigs{};

  GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (udSyncScopeConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*udSyncScopeConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UdSyncScopeConfigs"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("UdSyncScopeConfigs") != m.end() && !m["UdSyncScopeConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["UdSyncScopeConfigs"].type()) {
        vector<GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UdSyncScopeConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        udSyncScopeConfigs = make_shared<vector<GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfigUdSyncScopeConfigs>>(expect1);
      }
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> authorizeCallbackDomain{};
  shared_ptr<string> corpId{};
  shared_ptr<string> corpSecret{};
  shared_ptr<string> trustableDomain{};

  GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (authorizeCallbackDomain) {
      res["AuthorizeCallbackDomain"] = boost::any(*authorizeCallbackDomain);
    }
    if (corpId) {
      res["CorpId"] = boost::any(*corpId);
    }
    if (corpSecret) {
      res["CorpSecret"] = boost::any(*corpSecret);
    }
    if (trustableDomain) {
      res["TrustableDomain"] = boost::any(*trustableDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AuthorizeCallbackDomain") != m.end() && !m["AuthorizeCallbackDomain"].empty()) {
      authorizeCallbackDomain = make_shared<string>(boost::any_cast<string>(m["AuthorizeCallbackDomain"]));
    }
    if (m.find("CorpId") != m.end() && !m["CorpId"].empty()) {
      corpId = make_shared<string>(boost::any_cast<string>(m["CorpId"]));
    }
    if (m.find("CorpSecret") != m.end() && !m["CorpSecret"].empty()) {
      corpSecret = make_shared<string>(boost::any_cast<string>(m["CorpSecret"]));
    }
    if (m.find("TrustableDomain") != m.end() && !m["TrustableDomain"].empty()) {
      trustableDomain = make_shared<string>(boost::any_cast<string>(m["TrustableDomain"]));
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig() = default;
};
class GetIdentityProviderResponseBodyIdentityProviderDetail : public Darabonba::Model {
public:
  shared_ptr<string> advancedStatus{};
  shared_ptr<string> authnSourceSupplier{};
  shared_ptr<string> authnSourceType{};
  shared_ptr<string> authnStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig> dingtalkAppConfig{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig> dingtalkProvisioningConfig{};
  shared_ptr<string> identityProviderExternalId{};
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> identityProviderName{};
  shared_ptr<string> identityProviderType{};
  shared_ptr<string> instanceId{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig> larkConfig{};
  shared_ptr<string> lastStatusCheckJobResult{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig> ldapConfig{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig> oidcConfig{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig> udPullConfig{};
  shared_ptr<string> udPullStatus{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig> udPushConfig{};
  shared_ptr<string> udPushStatus{};
  shared_ptr<long> updateTime{};
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig> weComConfig{};

  GetIdentityProviderResponseBodyIdentityProviderDetail() {}

  explicit GetIdentityProviderResponseBodyIdentityProviderDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedStatus) {
      res["AdvancedStatus"] = boost::any(*advancedStatus);
    }
    if (authnSourceSupplier) {
      res["AuthnSourceSupplier"] = boost::any(*authnSourceSupplier);
    }
    if (authnSourceType) {
      res["AuthnSourceType"] = boost::any(*authnSourceType);
    }
    if (authnStatus) {
      res["AuthnStatus"] = boost::any(*authnStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dingtalkAppConfig) {
      res["DingtalkAppConfig"] = dingtalkAppConfig ? boost::any(dingtalkAppConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dingtalkProvisioningConfig) {
      res["DingtalkProvisioningConfig"] = dingtalkProvisioningConfig ? boost::any(dingtalkProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (identityProviderExternalId) {
      res["IdentityProviderExternalId"] = boost::any(*identityProviderExternalId);
    }
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (identityProviderName) {
      res["IdentityProviderName"] = boost::any(*identityProviderName);
    }
    if (identityProviderType) {
      res["IdentityProviderType"] = boost::any(*identityProviderType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (larkConfig) {
      res["LarkConfig"] = larkConfig ? boost::any(larkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lastStatusCheckJobResult) {
      res["LastStatusCheckJobResult"] = boost::any(*lastStatusCheckJobResult);
    }
    if (ldapConfig) {
      res["LdapConfig"] = ldapConfig ? boost::any(ldapConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (oidcConfig) {
      res["OidcConfig"] = oidcConfig ? boost::any(oidcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udPullConfig) {
      res["UdPullConfig"] = udPullConfig ? boost::any(udPullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udPullStatus) {
      res["UdPullStatus"] = boost::any(*udPullStatus);
    }
    if (udPushConfig) {
      res["UdPushConfig"] = udPushConfig ? boost::any(udPushConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udPushStatus) {
      res["UdPushStatus"] = boost::any(*udPushStatus);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (weComConfig) {
      res["WeComConfig"] = weComConfig ? boost::any(weComConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedStatus") != m.end() && !m["AdvancedStatus"].empty()) {
      advancedStatus = make_shared<string>(boost::any_cast<string>(m["AdvancedStatus"]));
    }
    if (m.find("AuthnSourceSupplier") != m.end() && !m["AuthnSourceSupplier"].empty()) {
      authnSourceSupplier = make_shared<string>(boost::any_cast<string>(m["AuthnSourceSupplier"]));
    }
    if (m.find("AuthnSourceType") != m.end() && !m["AuthnSourceType"].empty()) {
      authnSourceType = make_shared<string>(boost::any_cast<string>(m["AuthnSourceType"]));
    }
    if (m.find("AuthnStatus") != m.end() && !m["AuthnStatus"].empty()) {
      authnStatus = make_shared<string>(boost::any_cast<string>(m["AuthnStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DingtalkAppConfig") != m.end() && !m["DingtalkAppConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DingtalkAppConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DingtalkAppConfig"]));
        dingtalkAppConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkAppConfig>(model1);
      }
    }
    if (m.find("DingtalkProvisioningConfig") != m.end() && !m["DingtalkProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DingtalkProvisioningConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DingtalkProvisioningConfig"]));
        dingtalkProvisioningConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailDingtalkProvisioningConfig>(model1);
      }
    }
    if (m.find("IdentityProviderExternalId") != m.end() && !m["IdentityProviderExternalId"].empty()) {
      identityProviderExternalId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderExternalId"]));
    }
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("IdentityProviderName") != m.end() && !m["IdentityProviderName"].empty()) {
      identityProviderName = make_shared<string>(boost::any_cast<string>(m["IdentityProviderName"]));
    }
    if (m.find("IdentityProviderType") != m.end() && !m["IdentityProviderType"].empty()) {
      identityProviderType = make_shared<string>(boost::any_cast<string>(m["IdentityProviderType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LarkConfig") != m.end() && !m["LarkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LarkConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LarkConfig"]));
        larkConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailLarkConfig>(model1);
      }
    }
    if (m.find("LastStatusCheckJobResult") != m.end() && !m["LastStatusCheckJobResult"].empty()) {
      lastStatusCheckJobResult = make_shared<string>(boost::any_cast<string>(m["LastStatusCheckJobResult"]));
    }
    if (m.find("LdapConfig") != m.end() && !m["LdapConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LdapConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LdapConfig"]));
        ldapConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailLdapConfig>(model1);
      }
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("OidcConfig") != m.end() && !m["OidcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OidcConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OidcConfig"]));
        oidcConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailOidcConfig>(model1);
      }
    }
    if (m.find("UdPullConfig") != m.end() && !m["UdPullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdPullConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdPullConfig"]));
        udPullConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailUdPullConfig>(model1);
      }
    }
    if (m.find("UdPullStatus") != m.end() && !m["UdPullStatus"].empty()) {
      udPullStatus = make_shared<string>(boost::any_cast<string>(m["UdPullStatus"]));
    }
    if (m.find("UdPushConfig") != m.end() && !m["UdPushConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdPushConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdPushConfig"]));
        udPushConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailUdPushConfig>(model1);
      }
    }
    if (m.find("UdPushStatus") != m.end() && !m["UdPushStatus"].empty()) {
      udPushStatus = make_shared<string>(boost::any_cast<string>(m["UdPushStatus"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("WeComConfig") != m.end() && !m["WeComConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WeComConfig"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WeComConfig"]));
        weComConfig = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetailWeComConfig>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderResponseBodyIdentityProviderDetail() = default;
};
class GetIdentityProviderResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIdentityProviderResponseBodyIdentityProviderDetail> identityProviderDetail{};
  shared_ptr<string> requestId{};

  GetIdentityProviderResponseBody() {}

  explicit GetIdentityProviderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderDetail) {
      res["IdentityProviderDetail"] = identityProviderDetail ? boost::any(identityProviderDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderDetail") != m.end() && !m["IdentityProviderDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["IdentityProviderDetail"].type()) {
        GetIdentityProviderResponseBodyIdentityProviderDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IdentityProviderDetail"]));
        identityProviderDetail = make_shared<GetIdentityProviderResponseBodyIdentityProviderDetail>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIdentityProviderResponseBody() = default;
};
class GetIdentityProviderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIdentityProviderResponseBody> body{};

  GetIdentityProviderResponse() {}

  explicit GetIdentityProviderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIdentityProviderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIdentityProviderResponseBody>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderResponse() = default;
};
class GetIdentityProviderUdPullConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> instanceId{};

  GetIdentityProviderUdPullConfigurationRequest() {}

  explicit GetIdentityProviderUdPullConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationRequest() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> groupMemberAttributeName{};
  shared_ptr<string> groupObjectClass{};
  shared_ptr<string> groupObjectClassCustomFilter{};
  shared_ptr<string> organizationUnitObjectClass{};
  shared_ptr<string> userObjectClass{};
  shared_ptr<string> userObjectClassCustomFilter{};

  GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMemberAttributeName) {
      res["GroupMemberAttributeName"] = boost::any(*groupMemberAttributeName);
    }
    if (groupObjectClass) {
      res["GroupObjectClass"] = boost::any(*groupObjectClass);
    }
    if (groupObjectClassCustomFilter) {
      res["GroupObjectClassCustomFilter"] = boost::any(*groupObjectClassCustomFilter);
    }
    if (organizationUnitObjectClass) {
      res["OrganizationUnitObjectClass"] = boost::any(*organizationUnitObjectClass);
    }
    if (userObjectClass) {
      res["UserObjectClass"] = boost::any(*userObjectClass);
    }
    if (userObjectClassCustomFilter) {
      res["UserObjectClassCustomFilter"] = boost::any(*userObjectClassCustomFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMemberAttributeName") != m.end() && !m["GroupMemberAttributeName"].empty()) {
      groupMemberAttributeName = make_shared<string>(boost::any_cast<string>(m["GroupMemberAttributeName"]));
    }
    if (m.find("GroupObjectClass") != m.end() && !m["GroupObjectClass"].empty()) {
      groupObjectClass = make_shared<string>(boost::any_cast<string>(m["GroupObjectClass"]));
    }
    if (m.find("GroupObjectClassCustomFilter") != m.end() && !m["GroupObjectClassCustomFilter"].empty()) {
      groupObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["GroupObjectClassCustomFilter"]));
    }
    if (m.find("OrganizationUnitObjectClass") != m.end() && !m["OrganizationUnitObjectClass"].empty()) {
      organizationUnitObjectClass = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitObjectClass"]));
    }
    if (m.find("UserObjectClass") != m.end() && !m["UserObjectClass"].empty()) {
      userObjectClass = make_shared<string>(boost::any_cast<string>(m["UserObjectClass"]));
    }
    if (m.find("UserObjectClassCustomFilter") != m.end() && !m["UserObjectClassCustomFilter"].empty()) {
      userObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["UserObjectClassCustomFilter"]));
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig : public Darabonba::Model {
public:
  shared_ptr<string> periodicSyncCron{};
  shared_ptr<long> periodicSyncTimes{};
  shared_ptr<string> periodicSyncType{};

  GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodicSyncCron) {
      res["PeriodicSyncCron"] = boost::any(*periodicSyncCron);
    }
    if (periodicSyncTimes) {
      res["PeriodicSyncTimes"] = boost::any(*periodicSyncTimes);
    }
    if (periodicSyncType) {
      res["PeriodicSyncType"] = boost::any(*periodicSyncType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodicSyncCron") != m.end() && !m["PeriodicSyncCron"].empty()) {
      periodicSyncCron = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncCron"]));
    }
    if (m.find("PeriodicSyncTimes") != m.end() && !m["PeriodicSyncTimes"].empty()) {
      periodicSyncTimes = make_shared<long>(boost::any_cast<long>(m["PeriodicSyncTimes"]));
    }
    if (m.find("PeriodicSyncType") != m.end() && !m["PeriodicSyncType"].empty()) {
      periodicSyncType = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncType"]));
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule : public Darabonba::Model {
public:
  shared_ptr<long> groupDeletedThreshold{};
  shared_ptr<long> organizationalUnitDeletedThreshold{};
  shared_ptr<long> userDeletedThreshold{};

  GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDeletedThreshold) {
      res["GroupDeletedThreshold"] = boost::any(*groupDeletedThreshold);
    }
    if (organizationalUnitDeletedThreshold) {
      res["OrganizationalUnitDeletedThreshold"] = boost::any(*organizationalUnitDeletedThreshold);
    }
    if (userDeletedThreshold) {
      res["UserDeletedThreshold"] = boost::any(*userDeletedThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDeletedThreshold") != m.end() && !m["GroupDeletedThreshold"].empty()) {
      groupDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["GroupDeletedThreshold"]));
    }
    if (m.find("OrganizationalUnitDeletedThreshold") != m.end() && !m["OrganizationalUnitDeletedThreshold"].empty()) {
      organizationalUnitDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["OrganizationalUnitDeletedThreshold"]));
    }
    if (m.find("UserDeletedThreshold") != m.end() && !m["UserDeletedThreshold"].empty()) {
      userDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["UserDeletedThreshold"]));
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> groupSyncStatus{};
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig> ldapUdPullConfig{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig> periodicSyncConfig{};
  shared_ptr<string> periodicSyncStatus{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule> pullProtectedRule{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig> udSyncScopeConfig{};

  GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupSyncStatus) {
      res["GroupSyncStatus"] = boost::any(*groupSyncStatus);
    }
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ldapUdPullConfig) {
      res["LdapUdPullConfig"] = ldapUdPullConfig ? boost::any(ldapUdPullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodicSyncConfig) {
      res["PeriodicSyncConfig"] = periodicSyncConfig ? boost::any(periodicSyncConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodicSyncStatus) {
      res["PeriodicSyncStatus"] = boost::any(*periodicSyncStatus);
    }
    if (pullProtectedRule) {
      res["PullProtectedRule"] = pullProtectedRule ? boost::any(pullProtectedRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udSyncScopeConfig) {
      res["UdSyncScopeConfig"] = udSyncScopeConfig ? boost::any(udSyncScopeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupSyncStatus") != m.end() && !m["GroupSyncStatus"].empty()) {
      groupSyncStatus = make_shared<string>(boost::any_cast<string>(m["GroupSyncStatus"]));
    }
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LdapUdPullConfig") != m.end() && !m["LdapUdPullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LdapUdPullConfig"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LdapUdPullConfig"]));
        ldapUdPullConfig = make_shared<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationLdapUdPullConfig>(model1);
      }
    }
    if (m.find("PeriodicSyncConfig") != m.end() && !m["PeriodicSyncConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PeriodicSyncConfig"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PeriodicSyncConfig"]));
        periodicSyncConfig = make_shared<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPeriodicSyncConfig>(model1);
      }
    }
    if (m.find("PeriodicSyncStatus") != m.end() && !m["PeriodicSyncStatus"].empty()) {
      periodicSyncStatus = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncStatus"]));
    }
    if (m.find("PullProtectedRule") != m.end() && !m["PullProtectedRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PullProtectedRule"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PullProtectedRule"]));
        pullProtectedRule = make_shared<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationPullProtectedRule>(model1);
      }
    }
    if (m.find("UdSyncScopeConfig") != m.end() && !m["UdSyncScopeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdSyncScopeConfig"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdSyncScopeConfig"]));
        udSyncScopeConfig = make_shared<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfigurationUdSyncScopeConfig>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration() = default;
};
class GetIdentityProviderUdPullConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration> udPullConfiguration{};

  GetIdentityProviderUdPullConfigurationResponseBody() {}

  explicit GetIdentityProviderUdPullConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (udPullConfiguration) {
      res["UdPullConfiguration"] = udPullConfiguration ? boost::any(udPullConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UdPullConfiguration") != m.end() && !m["UdPullConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdPullConfiguration"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdPullConfiguration"]));
        udPullConfiguration = make_shared<GetIdentityProviderUdPullConfigurationResponseBodyUdPullConfiguration>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponseBody() = default;
};
class GetIdentityProviderUdPullConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIdentityProviderUdPullConfigurationResponseBody> body{};

  GetIdentityProviderUdPullConfigurationResponse() {}

  explicit GetIdentityProviderUdPullConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIdentityProviderUdPullConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIdentityProviderUdPullConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetIdentityProviderUdPullConfigurationResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyInstanceDefaultEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<string> status{};

  GetInstanceResponseBodyInstanceDefaultEndpoint() {}

  explicit GetInstanceResponseBodyInstanceDefaultEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstanceDefaultEndpoint() = default;
};
class GetInstanceResponseBodyInstanceDomainConfig : public Darabonba::Model {
public:
  shared_ptr<string> defaultDomain{};
  shared_ptr<string> initDomain{};
  shared_ptr<string> initDomainAutoRedirectStatus{};

  GetInstanceResponseBodyInstanceDomainConfig() {}

  explicit GetInstanceResponseBodyInstanceDomainConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (initDomain) {
      res["InitDomain"] = boost::any(*initDomain);
    }
    if (initDomainAutoRedirectStatus) {
      res["InitDomainAutoRedirectStatus"] = boost::any(*initDomainAutoRedirectStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<string>(boost::any_cast<string>(m["DefaultDomain"]));
    }
    if (m.find("InitDomain") != m.end() && !m["InitDomain"].empty()) {
      initDomain = make_shared<string>(boost::any_cast<string>(m["InitDomain"]));
    }
    if (m.find("InitDomainAutoRedirectStatus") != m.end() && !m["InitDomainAutoRedirectStatus"].empty()) {
      initDomainAutoRedirectStatus = make_shared<string>(boost::any_cast<string>(m["InitDomainAutoRedirectStatus"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstanceDomainConfig() = default;
};
class GetInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<GetInstanceResponseBodyInstanceDefaultEndpoint> defaultEndpoint{};
  shared_ptr<string> description{};
  shared_ptr<GetInstanceResponseBodyInstanceDomainConfig> domainConfig{};
  shared_ptr<vector<string>> egressAddresses{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  GetInstanceResponseBodyInstance() {}

  explicit GetInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultEndpoint) {
      res["DefaultEndpoint"] = defaultEndpoint ? boost::any(defaultEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainConfig) {
      res["DomainConfig"] = domainConfig ? boost::any(domainConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (egressAddresses) {
      res["EgressAddresses"] = boost::any(*egressAddresses);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DefaultEndpoint") != m.end() && !m["DefaultEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultEndpoint"].type()) {
        GetInstanceResponseBodyInstanceDefaultEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultEndpoint"]));
        defaultEndpoint = make_shared<GetInstanceResponseBodyInstanceDefaultEndpoint>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainConfig") != m.end() && !m["DomainConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainConfig"].type()) {
        GetInstanceResponseBodyInstanceDomainConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainConfig"]));
        domainConfig = make_shared<GetInstanceResponseBodyInstanceDomainConfig>(model1);
      }
    }
    if (m.find("EgressAddresses") != m.end() && !m["EgressAddresses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EgressAddresses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EgressAddresses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      egressAddresses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetInstanceResponseBodyInstance() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceResponseBodyInstance> instance{};
  shared_ptr<string> requestId{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        GetInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<GetInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetInstanceLicenseRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceLicenseRequest() {}

  explicit GetInstanceLicenseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceLicenseRequest() = default;
};
class GetInstanceLicenseResponseBodyLicense : public Darabonba::Model {
public:
  shared_ptr<string> edition{};
  shared_ptr<long> endTime{};
  shared_ptr<string> licenseChargeType{};
  shared_ptr<string> licenseConfigJson{};
  shared_ptr<long> licenseCreateTime{};
  shared_ptr<string> licenseId{};
  shared_ptr<string> licenseStatus{};
  shared_ptr<string> purchaseChannel{};
  shared_ptr<string> purchaseInstanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> userQuota{};

  GetInstanceLicenseResponseBodyLicense() {}

  explicit GetInstanceLicenseResponseBodyLicense(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edition) {
      res["Edition"] = boost::any(*edition);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (licenseChargeType) {
      res["LicenseChargeType"] = boost::any(*licenseChargeType);
    }
    if (licenseConfigJson) {
      res["LicenseConfigJson"] = boost::any(*licenseConfigJson);
    }
    if (licenseCreateTime) {
      res["LicenseCreateTime"] = boost::any(*licenseCreateTime);
    }
    if (licenseId) {
      res["LicenseId"] = boost::any(*licenseId);
    }
    if (licenseStatus) {
      res["LicenseStatus"] = boost::any(*licenseStatus);
    }
    if (purchaseChannel) {
      res["PurchaseChannel"] = boost::any(*purchaseChannel);
    }
    if (purchaseInstanceId) {
      res["PurchaseInstanceId"] = boost::any(*purchaseInstanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (userQuota) {
      res["UserQuota"] = boost::any(*userQuota);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Edition") != m.end() && !m["Edition"].empty()) {
      edition = make_shared<string>(boost::any_cast<string>(m["Edition"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("LicenseChargeType") != m.end() && !m["LicenseChargeType"].empty()) {
      licenseChargeType = make_shared<string>(boost::any_cast<string>(m["LicenseChargeType"]));
    }
    if (m.find("LicenseConfigJson") != m.end() && !m["LicenseConfigJson"].empty()) {
      licenseConfigJson = make_shared<string>(boost::any_cast<string>(m["LicenseConfigJson"]));
    }
    if (m.find("LicenseCreateTime") != m.end() && !m["LicenseCreateTime"].empty()) {
      licenseCreateTime = make_shared<long>(boost::any_cast<long>(m["LicenseCreateTime"]));
    }
    if (m.find("LicenseId") != m.end() && !m["LicenseId"].empty()) {
      licenseId = make_shared<string>(boost::any_cast<string>(m["LicenseId"]));
    }
    if (m.find("LicenseStatus") != m.end() && !m["LicenseStatus"].empty()) {
      licenseStatus = make_shared<string>(boost::any_cast<string>(m["LicenseStatus"]));
    }
    if (m.find("PurchaseChannel") != m.end() && !m["PurchaseChannel"].empty()) {
      purchaseChannel = make_shared<string>(boost::any_cast<string>(m["PurchaseChannel"]));
    }
    if (m.find("PurchaseInstanceId") != m.end() && !m["PurchaseInstanceId"].empty()) {
      purchaseInstanceId = make_shared<string>(boost::any_cast<string>(m["PurchaseInstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("UserQuota") != m.end() && !m["UserQuota"].empty()) {
      userQuota = make_shared<long>(boost::any_cast<long>(m["UserQuota"]));
    }
  }


  virtual ~GetInstanceLicenseResponseBodyLicense() = default;
};
class GetInstanceLicenseResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetInstanceLicenseResponseBodyLicense> license{};
  shared_ptr<string> requestId{};

  GetInstanceLicenseResponseBody() {}

  explicit GetInstanceLicenseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (license) {
      res["License"] = license ? boost::any(license->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("License") != m.end() && !m["License"].empty()) {
      if (typeid(map<string, boost::any>) == m["License"].type()) {
        GetInstanceLicenseResponseBodyLicense model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["License"]));
        license = make_shared<GetInstanceLicenseResponseBodyLicense>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceLicenseResponseBody() = default;
};
class GetInstanceLicenseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceLicenseResponseBody> body{};

  GetInstanceLicenseResponse() {}

  explicit GetInstanceLicenseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceLicenseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceLicenseResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceLicenseResponse() = default;
};
class GetNetworkAccessEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};

  GetNetworkAccessEndpointRequest() {}

  explicit GetNetworkAccessEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
  }


  virtual ~GetNetworkAccessEndpointRequest() = default;
};
class GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<string>> egressPrivateIpAddresses{};
  shared_ptr<vector<string>> egressPublicIpAddresses{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<string> networkAccessEndpointName{};
  shared_ptr<string> networkAccessEndpointType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcRegionId{};

  GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint() {}

  explicit GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (egressPrivateIpAddresses) {
      res["EgressPrivateIpAddresses"] = boost::any(*egressPrivateIpAddresses);
    }
    if (egressPublicIpAddresses) {
      res["EgressPublicIpAddresses"] = boost::any(*egressPublicIpAddresses);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (networkAccessEndpointName) {
      res["NetworkAccessEndpointName"] = boost::any(*networkAccessEndpointName);
    }
    if (networkAccessEndpointType) {
      res["NetworkAccessEndpointType"] = boost::any(*networkAccessEndpointType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("EgressPrivateIpAddresses") != m.end() && !m["EgressPrivateIpAddresses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EgressPrivateIpAddresses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EgressPrivateIpAddresses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      egressPrivateIpAddresses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EgressPublicIpAddresses") != m.end() && !m["EgressPublicIpAddresses"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EgressPublicIpAddresses"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EgressPublicIpAddresses"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      egressPublicIpAddresses = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("NetworkAccessEndpointName") != m.end() && !m["NetworkAccessEndpointName"].empty()) {
      networkAccessEndpointName = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointName"]));
    }
    if (m.find("NetworkAccessEndpointType") != m.end() && !m["NetworkAccessEndpointType"].empty()) {
      networkAccessEndpointType = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
  }


  virtual ~GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint() = default;
};
class GetNetworkAccessEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint> networkAccessEndpoint{};
  shared_ptr<string> requestId{};

  GetNetworkAccessEndpointResponseBody() {}

  explicit GetNetworkAccessEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAccessEndpoint) {
      res["NetworkAccessEndpoint"] = networkAccessEndpoint ? boost::any(networkAccessEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAccessEndpoint") != m.end() && !m["NetworkAccessEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkAccessEndpoint"].type()) {
        GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkAccessEndpoint"]));
        networkAccessEndpoint = make_shared<GetNetworkAccessEndpointResponseBodyNetworkAccessEndpoint>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNetworkAccessEndpointResponseBody() = default;
};
class GetNetworkAccessEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNetworkAccessEndpointResponseBody> body{};

  GetNetworkAccessEndpointResponse() {}

  explicit GetNetworkAccessEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNetworkAccessEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNetworkAccessEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~GetNetworkAccessEndpointResponse() = default;
};
class GetOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};

  GetOrganizationalUnitRequest() {}

  explicit GetOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~GetOrganizationalUnitRequest() = default;
};
class GetOrganizationalUnitResponseBodyOrganizationalUnit : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> leaf{};
  shared_ptr<string> organizationalUnitExternalId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<string> organizationalUnitSourceId{};
  shared_ptr<string> organizationalUnitSourceType{};
  shared_ptr<string> parentId{};
  shared_ptr<long> updateTime{};

  GetOrganizationalUnitResponseBodyOrganizationalUnit() {}

  explicit GetOrganizationalUnitResponseBodyOrganizationalUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (leaf) {
      res["Leaf"] = boost::any(*leaf);
    }
    if (organizationalUnitExternalId) {
      res["OrganizationalUnitExternalId"] = boost::any(*organizationalUnitExternalId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (organizationalUnitSourceId) {
      res["OrganizationalUnitSourceId"] = boost::any(*organizationalUnitSourceId);
    }
    if (organizationalUnitSourceType) {
      res["OrganizationalUnitSourceType"] = boost::any(*organizationalUnitSourceType);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Leaf") != m.end() && !m["Leaf"].empty()) {
      leaf = make_shared<bool>(boost::any_cast<bool>(m["Leaf"]));
    }
    if (m.find("OrganizationalUnitExternalId") != m.end() && !m["OrganizationalUnitExternalId"].empty()) {
      organizationalUnitExternalId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitExternalId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("OrganizationalUnitSourceId") != m.end() && !m["OrganizationalUnitSourceId"].empty()) {
      organizationalUnitSourceId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitSourceId"]));
    }
    if (m.find("OrganizationalUnitSourceType") != m.end() && !m["OrganizationalUnitSourceType"].empty()) {
      organizationalUnitSourceType = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitSourceType"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetOrganizationalUnitResponseBodyOrganizationalUnit() = default;
};
class GetOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetOrganizationalUnitResponseBodyOrganizationalUnit> organizationalUnit{};
  shared_ptr<string> requestId{};

  GetOrganizationalUnitResponseBody() {}

  explicit GetOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnit) {
      res["OrganizationalUnit"] = organizationalUnit ? boost::any(organizationalUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnit") != m.end() && !m["OrganizationalUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrganizationalUnit"].type()) {
        GetOrganizationalUnitResponseBodyOrganizationalUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrganizationalUnit"]));
        organizationalUnit = make_shared<GetOrganizationalUnitResponseBodyOrganizationalUnit>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetOrganizationalUnitResponseBody() = default;
};
class GetOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOrganizationalUnitResponseBody> body{};

  GetOrganizationalUnitResponse() {}

  explicit GetOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~GetOrganizationalUnitResponse() = default;
};
class GetPasswordComplexityConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetPasswordComplexityConfigurationRequest() {}

  explicit GetPasswordComplexityConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetPasswordComplexityConfigurationRequest() = default;
};
class GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules : public Darabonba::Model {
public:
  shared_ptr<string> passwordCheckType{};

  GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules() {}

  explicit GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordCheckType) {
      res["PasswordCheckType"] = boost::any(*passwordCheckType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordCheckType") != m.end() && !m["PasswordCheckType"].empty()) {
      passwordCheckType = make_shared<string>(boost::any_cast<string>(m["PasswordCheckType"]));
    }
  }


  virtual ~GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules() = default;
};
class GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules>> passwordComplexityRules{};
  shared_ptr<long> passwordMinLength{};

  GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration() {}

  explicit GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordComplexityRules) {
      vector<boost::any> temp1;
      for(auto item1:*passwordComplexityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PasswordComplexityRules"] = boost::any(temp1);
    }
    if (passwordMinLength) {
      res["PasswordMinLength"] = boost::any(*passwordMinLength);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordComplexityRules") != m.end() && !m["PasswordComplexityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PasswordComplexityRules"].type()) {
        vector<GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PasswordComplexityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passwordComplexityRules = make_shared<vector<GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfigurationPasswordComplexityRules>>(expect1);
      }
    }
    if (m.find("PasswordMinLength") != m.end() && !m["PasswordMinLength"].empty()) {
      passwordMinLength = make_shared<long>(boost::any_cast<long>(m["PasswordMinLength"]));
    }
  }


  virtual ~GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration() = default;
};
class GetPasswordComplexityConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration> passwordComplexityConfiguration{};
  shared_ptr<string> requestId{};

  GetPasswordComplexityConfigurationResponseBody() {}

  explicit GetPasswordComplexityConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordComplexityConfiguration) {
      res["PasswordComplexityConfiguration"] = passwordComplexityConfiguration ? boost::any(passwordComplexityConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordComplexityConfiguration") != m.end() && !m["PasswordComplexityConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PasswordComplexityConfiguration"].type()) {
        GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PasswordComplexityConfiguration"]));
        passwordComplexityConfiguration = make_shared<GetPasswordComplexityConfigurationResponseBodyPasswordComplexityConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPasswordComplexityConfigurationResponseBody() = default;
};
class GetPasswordComplexityConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPasswordComplexityConfigurationResponseBody> body{};

  GetPasswordComplexityConfigurationResponse() {}

  explicit GetPasswordComplexityConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPasswordComplexityConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPasswordComplexityConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPasswordComplexityConfigurationResponse() = default;
};
class GetPasswordExpirationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetPasswordExpirationConfigurationRequest() {}

  explicit GetPasswordExpirationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetPasswordExpirationConfigurationRequest() = default;
};
class GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration : public Darabonba::Model {
public:
  shared_ptr<vector<string>> effectiveAuthenticationSourceIds{};
  shared_ptr<string> passwordExpirationAction{};
  shared_ptr<vector<string>> passwordExpirationNotificationChannels{};
  shared_ptr<long> passwordExpirationNotificationDuration{};
  shared_ptr<string> passwordExpirationNotificationStatus{};
  shared_ptr<string> passwordExpirationStatus{};
  shared_ptr<long> passwordForcedUpdateDuration{};
  shared_ptr<long> passwordValidMaxDay{};

  GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration() {}

  explicit GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveAuthenticationSourceIds) {
      res["EffectiveAuthenticationSourceIds"] = boost::any(*effectiveAuthenticationSourceIds);
    }
    if (passwordExpirationAction) {
      res["PasswordExpirationAction"] = boost::any(*passwordExpirationAction);
    }
    if (passwordExpirationNotificationChannels) {
      res["PasswordExpirationNotificationChannels"] = boost::any(*passwordExpirationNotificationChannels);
    }
    if (passwordExpirationNotificationDuration) {
      res["PasswordExpirationNotificationDuration"] = boost::any(*passwordExpirationNotificationDuration);
    }
    if (passwordExpirationNotificationStatus) {
      res["PasswordExpirationNotificationStatus"] = boost::any(*passwordExpirationNotificationStatus);
    }
    if (passwordExpirationStatus) {
      res["PasswordExpirationStatus"] = boost::any(*passwordExpirationStatus);
    }
    if (passwordForcedUpdateDuration) {
      res["PasswordForcedUpdateDuration"] = boost::any(*passwordForcedUpdateDuration);
    }
    if (passwordValidMaxDay) {
      res["PasswordValidMaxDay"] = boost::any(*passwordValidMaxDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveAuthenticationSourceIds") != m.end() && !m["EffectiveAuthenticationSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EffectiveAuthenticationSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EffectiveAuthenticationSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      effectiveAuthenticationSourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PasswordExpirationAction") != m.end() && !m["PasswordExpirationAction"].empty()) {
      passwordExpirationAction = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationAction"]));
    }
    if (m.find("PasswordExpirationNotificationChannels") != m.end() && !m["PasswordExpirationNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PasswordExpirationNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PasswordExpirationNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passwordExpirationNotificationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PasswordExpirationNotificationDuration") != m.end() && !m["PasswordExpirationNotificationDuration"].empty()) {
      passwordExpirationNotificationDuration = make_shared<long>(boost::any_cast<long>(m["PasswordExpirationNotificationDuration"]));
    }
    if (m.find("PasswordExpirationNotificationStatus") != m.end() && !m["PasswordExpirationNotificationStatus"].empty()) {
      passwordExpirationNotificationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationNotificationStatus"]));
    }
    if (m.find("PasswordExpirationStatus") != m.end() && !m["PasswordExpirationStatus"].empty()) {
      passwordExpirationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationStatus"]));
    }
    if (m.find("PasswordForcedUpdateDuration") != m.end() && !m["PasswordForcedUpdateDuration"].empty()) {
      passwordForcedUpdateDuration = make_shared<long>(boost::any_cast<long>(m["PasswordForcedUpdateDuration"]));
    }
    if (m.find("PasswordValidMaxDay") != m.end() && !m["PasswordValidMaxDay"].empty()) {
      passwordValidMaxDay = make_shared<long>(boost::any_cast<long>(m["PasswordValidMaxDay"]));
    }
  }


  virtual ~GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration() = default;
};
class GetPasswordExpirationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration> passwordExpirationConfiguration{};
  shared_ptr<string> requestId{};

  GetPasswordExpirationConfigurationResponseBody() {}

  explicit GetPasswordExpirationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordExpirationConfiguration) {
      res["PasswordExpirationConfiguration"] = passwordExpirationConfiguration ? boost::any(passwordExpirationConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordExpirationConfiguration") != m.end() && !m["PasswordExpirationConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PasswordExpirationConfiguration"].type()) {
        GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PasswordExpirationConfiguration"]));
        passwordExpirationConfiguration = make_shared<GetPasswordExpirationConfigurationResponseBodyPasswordExpirationConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPasswordExpirationConfigurationResponseBody() = default;
};
class GetPasswordExpirationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPasswordExpirationConfigurationResponseBody> body{};

  GetPasswordExpirationConfigurationResponse() {}

  explicit GetPasswordExpirationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPasswordExpirationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPasswordExpirationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPasswordExpirationConfigurationResponse() = default;
};
class GetPasswordHistoryConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetPasswordHistoryConfigurationRequest() {}

  explicit GetPasswordHistoryConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetPasswordHistoryConfigurationRequest() = default;
};
class GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> passwordHistoryMaxRetention{};
  shared_ptr<string> passwordHistoryStatus{};

  GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration() {}

  explicit GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordHistoryMaxRetention) {
      res["PasswordHistoryMaxRetention"] = boost::any(*passwordHistoryMaxRetention);
    }
    if (passwordHistoryStatus) {
      res["PasswordHistoryStatus"] = boost::any(*passwordHistoryStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordHistoryMaxRetention") != m.end() && !m["PasswordHistoryMaxRetention"].empty()) {
      passwordHistoryMaxRetention = make_shared<long>(boost::any_cast<long>(m["PasswordHistoryMaxRetention"]));
    }
    if (m.find("PasswordHistoryStatus") != m.end() && !m["PasswordHistoryStatus"].empty()) {
      passwordHistoryStatus = make_shared<string>(boost::any_cast<string>(m["PasswordHistoryStatus"]));
    }
  }


  virtual ~GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration() = default;
};
class GetPasswordHistoryConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration> passwordHistoryConfiguration{};
  shared_ptr<string> requestId{};

  GetPasswordHistoryConfigurationResponseBody() {}

  explicit GetPasswordHistoryConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordHistoryConfiguration) {
      res["PasswordHistoryConfiguration"] = passwordHistoryConfiguration ? boost::any(passwordHistoryConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordHistoryConfiguration") != m.end() && !m["PasswordHistoryConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PasswordHistoryConfiguration"].type()) {
        GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PasswordHistoryConfiguration"]));
        passwordHistoryConfiguration = make_shared<GetPasswordHistoryConfigurationResponseBodyPasswordHistoryConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPasswordHistoryConfigurationResponseBody() = default;
};
class GetPasswordHistoryConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPasswordHistoryConfigurationResponseBody> body{};

  GetPasswordHistoryConfigurationResponse() {}

  explicit GetPasswordHistoryConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPasswordHistoryConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPasswordHistoryConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPasswordHistoryConfigurationResponse() = default;
};
class GetPasswordInitializationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetPasswordInitializationConfigurationRequest() {}

  explicit GetPasswordInitializationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetPasswordInitializationConfigurationRequest() = default;
};
class GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> passwordForcedUpdateStatus{};
  shared_ptr<vector<string>> passwordInitializationNotificationChannels{};
  shared_ptr<string> passwordInitializationStatus{};
  shared_ptr<string> passwordInitializationType{};

  GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration() {}

  explicit GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordForcedUpdateStatus) {
      res["PasswordForcedUpdateStatus"] = boost::any(*passwordForcedUpdateStatus);
    }
    if (passwordInitializationNotificationChannels) {
      res["PasswordInitializationNotificationChannels"] = boost::any(*passwordInitializationNotificationChannels);
    }
    if (passwordInitializationStatus) {
      res["PasswordInitializationStatus"] = boost::any(*passwordInitializationStatus);
    }
    if (passwordInitializationType) {
      res["PasswordInitializationType"] = boost::any(*passwordInitializationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordForcedUpdateStatus") != m.end() && !m["PasswordForcedUpdateStatus"].empty()) {
      passwordForcedUpdateStatus = make_shared<string>(boost::any_cast<string>(m["PasswordForcedUpdateStatus"]));
    }
    if (m.find("PasswordInitializationNotificationChannels") != m.end() && !m["PasswordInitializationNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PasswordInitializationNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PasswordInitializationNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passwordInitializationNotificationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PasswordInitializationStatus") != m.end() && !m["PasswordInitializationStatus"].empty()) {
      passwordInitializationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationStatus"]));
    }
    if (m.find("PasswordInitializationType") != m.end() && !m["PasswordInitializationType"].empty()) {
      passwordInitializationType = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationType"]));
    }
  }


  virtual ~GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration() = default;
};
class GetPasswordInitializationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration> passwordInitializationConfiguration{};
  shared_ptr<string> requestId{};

  GetPasswordInitializationConfigurationResponseBody() {}

  explicit GetPasswordInitializationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordInitializationConfiguration) {
      res["PasswordInitializationConfiguration"] = passwordInitializationConfiguration ? boost::any(passwordInitializationConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordInitializationConfiguration") != m.end() && !m["PasswordInitializationConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["PasswordInitializationConfiguration"].type()) {
        GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PasswordInitializationConfiguration"]));
        passwordInitializationConfiguration = make_shared<GetPasswordInitializationConfigurationResponseBodyPasswordInitializationConfiguration>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetPasswordInitializationConfigurationResponseBody() = default;
};
class GetPasswordInitializationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPasswordInitializationConfigurationResponseBody> body{};

  GetPasswordInitializationConfigurationResponse() {}

  explicit GetPasswordInitializationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPasswordInitializationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPasswordInitializationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetPasswordInitializationConfigurationResponse() = default;
};
class GetRootOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetRootOrganizationalUnitRequest() {}

  explicit GetRootOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetRootOrganizationalUnitRequest() = default;
};
class GetRootOrganizationalUnitResponseBodyOrganizationalUnit : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<long> updateTime{};

  GetRootOrganizationalUnitResponseBodyOrganizationalUnit() {}

  explicit GetRootOrganizationalUnitResponseBodyOrganizationalUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~GetRootOrganizationalUnitResponseBodyOrganizationalUnit() = default;
};
class GetRootOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRootOrganizationalUnitResponseBodyOrganizationalUnit> organizationalUnit{};
  shared_ptr<string> requestId{};

  GetRootOrganizationalUnitResponseBody() {}

  explicit GetRootOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnit) {
      res["OrganizationalUnit"] = organizationalUnit ? boost::any(organizationalUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnit") != m.end() && !m["OrganizationalUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrganizationalUnit"].type()) {
        GetRootOrganizationalUnitResponseBodyOrganizationalUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrganizationalUnit"]));
        organizationalUnit = make_shared<GetRootOrganizationalUnitResponseBodyOrganizationalUnit>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRootOrganizationalUnitResponseBody() = default;
};
class GetRootOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRootOrganizationalUnitResponseBody> body{};

  GetRootOrganizationalUnitResponse() {}

  explicit GetRootOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRootOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRootOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~GetRootOrganizationalUnitResponse() = default;
};
class GetSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> synchronizationJobId{};

  GetSynchronizationJobRequest() {}

  explicit GetSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~GetSynchronizationJobRequest() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics : public Darabonba::Model {
public:
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded> binded{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated> created{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted> deleted{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed> pushed{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame> same{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated> updated{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics : public Darabonba::Model {
public:
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded> binded{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated> created{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted> deleted{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed> pushed{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame> same{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated> updated{};

  GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics : public Darabonba::Model {
public:
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded> binded{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated> created{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted> deleted{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed> pushed{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame> same{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated> updated{};

  GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics : public Darabonba::Model {
public:
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded> binded{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated> created{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted> deleted{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed> pushed{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame> same{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated> updated{};

  GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJobResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics> groupMemberStatistics{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics> groupStatistics{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics> organizationalUnitStatistics{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics> userStatistics{};

  GetSynchronizationJobResponseBodySynchronizationJobResult() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJobResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupMemberStatistics) {
      res["GroupMemberStatistics"] = groupMemberStatistics ? boost::any(groupMemberStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupStatistics) {
      res["GroupStatistics"] = groupStatistics ? boost::any(groupStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizationalUnitStatistics) {
      res["OrganizationalUnitStatistics"] = organizationalUnitStatistics ? boost::any(organizationalUnitStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userStatistics) {
      res["UserStatistics"] = userStatistics ? boost::any(userStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupMemberStatistics") != m.end() && !m["GroupMemberStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupMemberStatistics"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupMemberStatistics"]));
        groupMemberStatistics = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupMemberStatistics>(model1);
      }
    }
    if (m.find("GroupStatistics") != m.end() && !m["GroupStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupStatistics"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupStatistics"]));
        groupStatistics = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultGroupStatistics>(model1);
      }
    }
    if (m.find("OrganizationalUnitStatistics") != m.end() && !m["OrganizationalUnitStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrganizationalUnitStatistics"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrganizationalUnitStatistics"]));
        organizationalUnitStatistics = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultOrganizationalUnitStatistics>(model1);
      }
    }
    if (m.find("UserStatistics") != m.end() && !m["UserStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserStatistics"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserStatistics"]));
        userStatistics = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResultUserStatistics>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJobResult() = default;
};
class GetSynchronizationJobResponseBodySynchronizationJob : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> endTime{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJobResult> result{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> triggerType{};

  GetSynchronizationJobResponseBodySynchronizationJob() {}

  explicit GetSynchronizationJobResponseBodySynchronizationJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJobResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetSynchronizationJobResponseBodySynchronizationJobResult>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~GetSynchronizationJobResponseBodySynchronizationJob() = default;
};
class GetSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetSynchronizationJobResponseBodySynchronizationJob> synchronizationJob{};

  GetSynchronizationJobResponseBody() {}

  explicit GetSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (synchronizationJob) {
      res["SynchronizationJob"] = synchronizationJob ? boost::any(synchronizationJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SynchronizationJob") != m.end() && !m["SynchronizationJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["SynchronizationJob"].type()) {
        GetSynchronizationJobResponseBodySynchronizationJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SynchronizationJob"]));
        synchronizationJob = make_shared<GetSynchronizationJobResponseBodySynchronizationJob>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponseBody() = default;
};
class GetSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSynchronizationJobResponseBody> body{};

  GetSynchronizationJobResponse() {}

  explicit GetSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~GetSynchronizationJobResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyUserCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};

  GetUserResponseBodyUserCustomFields() {}

  explicit GetUserResponseBodyUserCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
  }


  virtual ~GetUserResponseBodyUserCustomFields() = default;
};
class GetUserResponseBodyUserGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};

  GetUserResponseBodyUserGroups() {}

  explicit GetUserResponseBodyUserGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
  }


  virtual ~GetUserResponseBodyUserGroups() = default;
};
class GetUserResponseBodyUserOrganizationalUnits : public Darabonba::Model {
public:
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<bool> primary{};

  GetUserResponseBodyUserOrganizationalUnits() {}

  explicit GetUserResponseBodyUserOrganizationalUnits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
  }


  virtual ~GetUserResponseBodyUserOrganizationalUnits() = default;
};
class GetUserResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<long> accountExpireTime{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<GetUserResponseBodyUserCustomFields>> customFields{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<bool> emailVerified{};
  shared_ptr<vector<GetUserResponseBodyUserGroups>> groups{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lockExpireTime{};
  shared_ptr<vector<GetUserResponseBodyUserOrganizationalUnits>> organizationalUnits{};
  shared_ptr<long> passwordExpireTime{};
  shared_ptr<bool> passwordSet{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<bool> phoneNumberVerified{};
  shared_ptr<string> phoneRegion{};
  shared_ptr<string> preferredLanguage{};
  shared_ptr<string> primaryOrganizationalUnitId{};
  shared_ptr<long> registerTime{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userExternalId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userSourceId{};
  shared_ptr<string> userSourceType{};
  shared_ptr<string> username{};

  GetUserResponseBodyUser() {}

  explicit GetUserResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountExpireTime) {
      res["AccountExpireTime"] = boost::any(*accountExpireTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomFields"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (emailVerified) {
      res["EmailVerified"] = boost::any(*emailVerified);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lockExpireTime) {
      res["LockExpireTime"] = boost::any(*lockExpireTime);
    }
    if (organizationalUnits) {
      vector<boost::any> temp1;
      for(auto item1:*organizationalUnits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrganizationalUnits"] = boost::any(temp1);
    }
    if (passwordExpireTime) {
      res["PasswordExpireTime"] = boost::any(*passwordExpireTime);
    }
    if (passwordSet) {
      res["PasswordSet"] = boost::any(*passwordSet);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (phoneNumberVerified) {
      res["PhoneNumberVerified"] = boost::any(*phoneNumberVerified);
    }
    if (phoneRegion) {
      res["PhoneRegion"] = boost::any(*phoneRegion);
    }
    if (preferredLanguage) {
      res["PreferredLanguage"] = boost::any(*preferredLanguage);
    }
    if (primaryOrganizationalUnitId) {
      res["PrimaryOrganizationalUnitId"] = boost::any(*primaryOrganizationalUnitId);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userExternalId) {
      res["UserExternalId"] = boost::any(*userExternalId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userSourceId) {
      res["UserSourceId"] = boost::any(*userSourceId);
    }
    if (userSourceType) {
      res["UserSourceType"] = boost::any(*userSourceType);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountExpireTime") != m.end() && !m["AccountExpireTime"].empty()) {
      accountExpireTime = make_shared<long>(boost::any_cast<long>(m["AccountExpireTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CustomFields") != m.end() && !m["CustomFields"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomFields"].type()) {
        vector<GetUserResponseBodyUserCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUserCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<GetUserResponseBodyUserCustomFields>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EmailVerified") != m.end() && !m["EmailVerified"].empty()) {
      emailVerified = make_shared<bool>(boost::any_cast<bool>(m["EmailVerified"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<GetUserResponseBodyUserGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUserGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<GetUserResponseBodyUserGroups>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LockExpireTime") != m.end() && !m["LockExpireTime"].empty()) {
      lockExpireTime = make_shared<long>(boost::any_cast<long>(m["LockExpireTime"]));
    }
    if (m.find("OrganizationalUnits") != m.end() && !m["OrganizationalUnits"].empty()) {
      if (typeid(vector<boost::any>) == m["OrganizationalUnits"].type()) {
        vector<GetUserResponseBodyUserOrganizationalUnits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrganizationalUnits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyUserOrganizationalUnits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizationalUnits = make_shared<vector<GetUserResponseBodyUserOrganizationalUnits>>(expect1);
      }
    }
    if (m.find("PasswordExpireTime") != m.end() && !m["PasswordExpireTime"].empty()) {
      passwordExpireTime = make_shared<long>(boost::any_cast<long>(m["PasswordExpireTime"]));
    }
    if (m.find("PasswordSet") != m.end() && !m["PasswordSet"].empty()) {
      passwordSet = make_shared<bool>(boost::any_cast<bool>(m["PasswordSet"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PhoneNumberVerified") != m.end() && !m["PhoneNumberVerified"].empty()) {
      phoneNumberVerified = make_shared<bool>(boost::any_cast<bool>(m["PhoneNumberVerified"]));
    }
    if (m.find("PhoneRegion") != m.end() && !m["PhoneRegion"].empty()) {
      phoneRegion = make_shared<string>(boost::any_cast<string>(m["PhoneRegion"]));
    }
    if (m.find("PreferredLanguage") != m.end() && !m["PreferredLanguage"].empty()) {
      preferredLanguage = make_shared<string>(boost::any_cast<string>(m["PreferredLanguage"]));
    }
    if (m.find("PrimaryOrganizationalUnitId") != m.end() && !m["PrimaryOrganizationalUnitId"].empty()) {
      primaryOrganizationalUnitId = make_shared<string>(boost::any_cast<string>(m["PrimaryOrganizationalUnitId"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserExternalId") != m.end() && !m["UserExternalId"].empty()) {
      userExternalId = make_shared<string>(boost::any_cast<string>(m["UserExternalId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserSourceId") != m.end() && !m["UserSourceId"].empty()) {
      userSourceId = make_shared<string>(boost::any_cast<string>(m["UserSourceId"]));
    }
    if (m.find("UserSourceType") != m.end() && !m["UserSourceType"].empty()) {
      userSourceType = make_shared<string>(boost::any_cast<string>(m["UserSourceType"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetUserResponseBodyUser() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetUserResponseBodyUser> user{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserResponseBodyUser>(model1);
      }
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class ListApplicationClientSecretsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};

  ListApplicationClientSecretsRequest() {}

  explicit ListApplicationClientSecretsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListApplicationClientSecretsRequest() = default;
};
class ListApplicationClientSecretsResponseBodyApplicationClientSecrets : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUsedTime{};
  shared_ptr<string> secretId{};
  shared_ptr<string> status{};

  ListApplicationClientSecretsResponseBodyApplicationClientSecrets() {}

  explicit ListApplicationClientSecretsResponseBodyApplicationClientSecrets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUsedTime) {
      res["LastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUsedTime") != m.end() && !m["LastUsedTime"].empty()) {
      lastUsedTime = make_shared<long>(boost::any_cast<long>(m["LastUsedTime"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListApplicationClientSecretsResponseBodyApplicationClientSecrets() = default;
};
class ListApplicationClientSecretsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationClientSecretsResponseBodyApplicationClientSecrets>> applicationClientSecrets{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationClientSecretsResponseBody() {}

  explicit ListApplicationClientSecretsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationClientSecrets) {
      vector<boost::any> temp1;
      for(auto item1:*applicationClientSecrets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationClientSecrets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationClientSecrets") != m.end() && !m["ApplicationClientSecrets"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationClientSecrets"].type()) {
        vector<ListApplicationClientSecretsResponseBodyApplicationClientSecrets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationClientSecrets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationClientSecretsResponseBodyApplicationClientSecrets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationClientSecrets = make_shared<vector<ListApplicationClientSecretsResponseBodyApplicationClientSecrets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationClientSecretsResponseBody() = default;
};
class ListApplicationClientSecretsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationClientSecretsResponseBody> body{};

  ListApplicationClientSecretsResponse() {}

  explicit ListApplicationClientSecretsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationClientSecretsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationClientSecretsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationClientSecretsResponse() = default;
};
class ListApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationIds{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> m2MClientStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceServerStatus{};
  shared_ptr<string> ssoType{};
  shared_ptr<string> status{};

  ListApplicationsRequest() {}

  explicit ListApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationIds) {
      res["ApplicationIds"] = boost::any(*applicationIds);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (m2MClientStatus) {
      res["M2MClientStatus"] = boost::any(*m2MClientStatus);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceServerStatus) {
      res["ResourceServerStatus"] = boost::any(*resourceServerStatus);
    }
    if (ssoType) {
      res["SsoType"] = boost::any(*ssoType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationIds") != m.end() && !m["ApplicationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("M2MClientStatus") != m.end() && !m["M2MClientStatus"].empty()) {
      m2MClientStatus = make_shared<string>(boost::any_cast<string>(m["M2MClientStatus"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceServerStatus") != m.end() && !m["ResourceServerStatus"].empty()) {
      resourceServerStatus = make_shared<string>(boost::any_cast<string>(m["ResourceServerStatus"]));
    }
    if (m.find("SsoType") != m.end() && !m["SsoType"].empty()) {
      ssoType = make_shared<string>(boost::any_cast<string>(m["SsoType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListApplicationsRequest() = default;
};
class ListApplicationsResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> applicationName{};
  shared_ptr<string> applicationSourceType{};
  shared_ptr<string> applicationTemplateId{};
  shared_ptr<string> clientId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> features{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> managedServiceCode{};
  shared_ptr<bool> serviceManaged{};
  shared_ptr<string> ssoType{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ListApplicationsResponseBodyApplications() {}

  explicit ListApplicationsResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (applicationName) {
      res["ApplicationName"] = boost::any(*applicationName);
    }
    if (applicationSourceType) {
      res["ApplicationSourceType"] = boost::any(*applicationSourceType);
    }
    if (applicationTemplateId) {
      res["ApplicationTemplateId"] = boost::any(*applicationTemplateId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (features) {
      res["Features"] = boost::any(*features);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (managedServiceCode) {
      res["ManagedServiceCode"] = boost::any(*managedServiceCode);
    }
    if (serviceManaged) {
      res["ServiceManaged"] = boost::any(*serviceManaged);
    }
    if (ssoType) {
      res["SsoType"] = boost::any(*ssoType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ApplicationName") != m.end() && !m["ApplicationName"].empty()) {
      applicationName = make_shared<string>(boost::any_cast<string>(m["ApplicationName"]));
    }
    if (m.find("ApplicationSourceType") != m.end() && !m["ApplicationSourceType"].empty()) {
      applicationSourceType = make_shared<string>(boost::any_cast<string>(m["ApplicationSourceType"]));
    }
    if (m.find("ApplicationTemplateId") != m.end() && !m["ApplicationTemplateId"].empty()) {
      applicationTemplateId = make_shared<string>(boost::any_cast<string>(m["ApplicationTemplateId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      features = make_shared<string>(boost::any_cast<string>(m["Features"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("ManagedServiceCode") != m.end() && !m["ManagedServiceCode"].empty()) {
      managedServiceCode = make_shared<string>(boost::any_cast<string>(m["ManagedServiceCode"]));
    }
    if (m.find("ServiceManaged") != m.end() && !m["ServiceManaged"].empty()) {
      serviceManaged = make_shared<bool>(boost::any_cast<bool>(m["ServiceManaged"]));
    }
    if (m.find("SsoType") != m.end() && !m["SsoType"].empty()) {
      ssoType = make_shared<string>(boost::any_cast<string>(m["SsoType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListApplicationsResponseBodyApplications() = default;
};
class ListApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsResponseBodyApplications>> applications{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsResponseBody() {}

  explicit ListApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListApplicationsResponseBodyApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsResponseBodyApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListApplicationsResponseBodyApplications>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsResponseBody() = default;
};
class ListApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsResponseBody> body{};

  ListApplicationsResponse() {}

  explicit ListApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsResponse() = default;
};
class ListApplicationsForOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListApplicationsForOrganizationalUnitRequest() {}

  explicit ListApplicationsForOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationIds) {
      res["ApplicationIds"] = boost::any(*applicationIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationIds") != m.end() && !m["ApplicationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListApplicationsForOrganizationalUnitRequest() = default;
};
class ListApplicationsForOrganizationalUnitResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};

  ListApplicationsForOrganizationalUnitResponseBodyApplications() {}

  explicit ListApplicationsForOrganizationalUnitResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
  }


  virtual ~ListApplicationsForOrganizationalUnitResponseBodyApplications() = default;
};
class ListApplicationsForOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsForOrganizationalUnitResponseBodyApplications>> applications{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsForOrganizationalUnitResponseBody() {}

  explicit ListApplicationsForOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListApplicationsForOrganizationalUnitResponseBodyApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsForOrganizationalUnitResponseBodyApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListApplicationsForOrganizationalUnitResponseBodyApplications>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsForOrganizationalUnitResponseBody() = default;
};
class ListApplicationsForOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsForOrganizationalUnitResponseBody> body{};

  ListApplicationsForOrganizationalUnitResponse() {}

  explicit ListApplicationsForOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsForOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsForOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsForOrganizationalUnitResponse() = default;
};
class ListApplicationsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> applicationIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryMode{};
  shared_ptr<string> userId{};

  ListApplicationsForUserRequest() {}

  explicit ListApplicationsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationIds) {
      res["ApplicationIds"] = boost::any(*applicationIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queryMode) {
      res["QueryMode"] = boost::any(*queryMode);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationIds") != m.end() && !m["ApplicationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApplicationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApplicationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      applicationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueryMode") != m.end() && !m["QueryMode"].empty()) {
      queryMode = make_shared<string>(boost::any_cast<string>(m["QueryMode"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListApplicationsForUserRequest() = default;
};
class ListApplicationsForUserResponseBodyApplications : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<bool> hasDirectAuthorization{};
  shared_ptr<bool> hasInheritAuthorization{};

  ListApplicationsForUserResponseBodyApplications() {}

  explicit ListApplicationsForUserResponseBodyApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (hasDirectAuthorization) {
      res["HasDirectAuthorization"] = boost::any(*hasDirectAuthorization);
    }
    if (hasInheritAuthorization) {
      res["HasInheritAuthorization"] = boost::any(*hasInheritAuthorization);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("HasDirectAuthorization") != m.end() && !m["HasDirectAuthorization"].empty()) {
      hasDirectAuthorization = make_shared<bool>(boost::any_cast<bool>(m["HasDirectAuthorization"]));
    }
    if (m.find("HasInheritAuthorization") != m.end() && !m["HasInheritAuthorization"].empty()) {
      hasInheritAuthorization = make_shared<bool>(boost::any_cast<bool>(m["HasInheritAuthorization"]));
    }
  }


  virtual ~ListApplicationsForUserResponseBodyApplications() = default;
};
class ListApplicationsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationsForUserResponseBodyApplications>> applications{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationsForUserResponseBody() {}

  explicit ListApplicationsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      vector<boost::any> temp1;
      for(auto item1:*applications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Applications"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(vector<boost::any>) == m["Applications"].type()) {
        vector<ListApplicationsForUserResponseBodyApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Applications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationsForUserResponseBodyApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applications = make_shared<vector<ListApplicationsForUserResponseBodyApplications>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationsForUserResponseBody() = default;
};
class ListApplicationsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationsForUserResponseBody> body{};

  ListApplicationsForUserResponse() {}

  explicit ListApplicationsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationsForUserResponse() = default;
};
class ListConditionalAccessPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> previousToken{};

  ListConditionalAccessPoliciesRequest() {}

  explicit ListConditionalAccessPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (previousToken) {
      res["PreviousToken"] = boost::any(*previousToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PreviousToken") != m.end() && !m["PreviousToken"].empty()) {
      previousToken = make_shared<string>(boost::any_cast<string>(m["PreviousToken"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesRequest() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeApplications{};
  shared_ptr<vector<string>> includeApplications{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeApplications) {
      res["ExcludeApplications"] = boost::any(*excludeApplications);
    }
    if (includeApplications) {
      res["IncludeApplications"] = boost::any(*includeApplications);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeApplications") != m.end() && !m["ExcludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeApplications = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeApplications") != m.end() && !m["IncludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeApplications = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeNetworkZones{};
  shared_ptr<vector<string>> includeNetworkZones{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeNetworkZones) {
      res["ExcludeNetworkZones"] = boost::any(*excludeNetworkZones);
    }
    if (includeNetworkZones) {
      res["IncludeNetworkZones"] = boost::any(*includeNetworkZones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeNetworkZones") != m.end() && !m["ExcludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeNetworkZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeNetworkZones") != m.end() && !m["IncludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeNetworkZones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeGroups{};
  shared_ptr<vector<string>> excludeOrganizationalUnits{};
  shared_ptr<vector<string>> excludeUsers{};
  shared_ptr<vector<string>> includeGroups{};
  shared_ptr<vector<string>> includeOrganizationalUnits{};
  shared_ptr<vector<string>> includeUsers{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeGroups) {
      res["ExcludeGroups"] = boost::any(*excludeGroups);
    }
    if (excludeOrganizationalUnits) {
      res["ExcludeOrganizationalUnits"] = boost::any(*excludeOrganizationalUnits);
    }
    if (excludeUsers) {
      res["ExcludeUsers"] = boost::any(*excludeUsers);
    }
    if (includeGroups) {
      res["IncludeGroups"] = boost::any(*includeGroups);
    }
    if (includeOrganizationalUnits) {
      res["IncludeOrganizationalUnits"] = boost::any(*includeOrganizationalUnits);
    }
    if (includeUsers) {
      res["IncludeUsers"] = boost::any(*includeUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeGroups") != m.end() && !m["ExcludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeOrganizationalUnits") != m.end() && !m["ExcludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeUsers") != m.end() && !m["ExcludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeGroups") != m.end() && !m["IncludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeOrganizationalUnits") != m.end() && !m["IncludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeUsers") != m.end() && !m["IncludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig : public Darabonba::Model {
public:
  shared_ptr<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications> applications{};
  shared_ptr<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones> networkZones{};
  shared_ptr<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers> users{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkZones) {
      res["NetworkZones"] = networkZones ? boost::any(networkZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigApplications>(model1);
      }
    }
    if (m.find("NetworkZones") != m.end() && !m["NetworkZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkZones"].type()) {
        ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkZones"]));
        networkZones = make_shared<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones>(model1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfigUsers>(model1);
      }
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig : public Darabonba::Model {
public:
  shared_ptr<string> activeSessionReuseStatus{};
  shared_ptr<string> effect{};
  shared_ptr<long> mfaAuthenticationIntervalSeconds{};
  shared_ptr<vector<string>> mfaAuthenticationMethods{};
  shared_ptr<string> mfaType{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionReuseStatus) {
      res["ActiveSessionReuseStatus"] = boost::any(*activeSessionReuseStatus);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (mfaAuthenticationIntervalSeconds) {
      res["MfaAuthenticationIntervalSeconds"] = boost::any(*mfaAuthenticationIntervalSeconds);
    }
    if (mfaAuthenticationMethods) {
      res["MfaAuthenticationMethods"] = boost::any(*mfaAuthenticationMethods);
    }
    if (mfaType) {
      res["MfaType"] = boost::any(*mfaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionReuseStatus") != m.end() && !m["ActiveSessionReuseStatus"].empty()) {
      activeSessionReuseStatus = make_shared<string>(boost::any_cast<string>(m["ActiveSessionReuseStatus"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("MfaAuthenticationIntervalSeconds") != m.end() && !m["MfaAuthenticationIntervalSeconds"].empty()) {
      mfaAuthenticationIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["MfaAuthenticationIntervalSeconds"]));
    }
    if (m.find("MfaAuthenticationMethods") != m.end() && !m["MfaAuthenticationMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MfaAuthenticationMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MfaAuthenticationMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mfaAuthenticationMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MfaType") != m.end() && !m["MfaType"].empty()) {
      mfaType = make_shared<string>(boost::any_cast<string>(m["MfaType"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig() = default;
};
class ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> conditionalAccessPolicyName{};
  shared_ptr<string> conditionalAccessPolicyType{};
  shared_ptr<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig> conditionsConfig{};
  shared_ptr<long> createTime{};
  shared_ptr<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig> decisionConfig{};
  shared_ptr<string> decisionType{};
  shared_ptr<string> description{};
  shared_ptr<string> evaluateAt{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUpdatedTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};

  ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies() {}

  explicit ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (conditionalAccessPolicyName) {
      res["ConditionalAccessPolicyName"] = boost::any(*conditionalAccessPolicyName);
    }
    if (conditionalAccessPolicyType) {
      res["ConditionalAccessPolicyType"] = boost::any(*conditionalAccessPolicyType);
    }
    if (conditionsConfig) {
      res["ConditionsConfig"] = conditionsConfig ? boost::any(conditionsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (decisionConfig) {
      res["DecisionConfig"] = decisionConfig ? boost::any(decisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionType) {
      res["DecisionType"] = boost::any(*decisionType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (evaluateAt) {
      res["EvaluateAt"] = boost::any(*evaluateAt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUpdatedTime) {
      res["LastUpdatedTime"] = boost::any(*lastUpdatedTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("ConditionalAccessPolicyName") != m.end() && !m["ConditionalAccessPolicyName"].empty()) {
      conditionalAccessPolicyName = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyName"]));
    }
    if (m.find("ConditionalAccessPolicyType") != m.end() && !m["ConditionalAccessPolicyType"].empty()) {
      conditionalAccessPolicyType = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyType"]));
    }
    if (m.find("ConditionsConfig") != m.end() && !m["ConditionsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionsConfig"].type()) {
        ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionsConfig"]));
        conditionsConfig = make_shared<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesConditionsConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DecisionConfig") != m.end() && !m["DecisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DecisionConfig"].type()) {
        ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DecisionConfig"]));
        decisionConfig = make_shared<ListConditionalAccessPoliciesResponseBodyConditionalAccessPoliciesDecisionConfig>(model1);
      }
    }
    if (m.find("DecisionType") != m.end() && !m["DecisionType"].empty()) {
      decisionType = make_shared<string>(boost::any_cast<string>(m["DecisionType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EvaluateAt") != m.end() && !m["EvaluateAt"].empty()) {
      evaluateAt = make_shared<string>(boost::any_cast<string>(m["EvaluateAt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUpdatedTime") != m.end() && !m["LastUpdatedTime"].empty()) {
      lastUpdatedTime = make_shared<long>(boost::any_cast<long>(m["LastUpdatedTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies() = default;
};
class ListConditionalAccessPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies>> conditionalAccessPolicies{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> previousToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListConditionalAccessPoliciesResponseBody() {}

  explicit ListConditionalAccessPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*conditionalAccessPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionalAccessPolicies"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (previousToken) {
      res["PreviousToken"] = boost::any(*previousToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicies") != m.end() && !m["ConditionalAccessPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionalAccessPolicies"].type()) {
        vector<ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionalAccessPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionalAccessPolicies = make_shared<vector<ListConditionalAccessPoliciesResponseBodyConditionalAccessPolicies>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PreviousToken") != m.end() && !m["PreviousToken"].empty()) {
      previousToken = make_shared<string>(boost::any_cast<string>(m["PreviousToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesResponseBody() = default;
};
class ListConditionalAccessPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConditionalAccessPoliciesResponseBody> body{};

  ListConditionalAccessPoliciesResponse() {}

  explicit ListConditionalAccessPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConditionalAccessPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConditionalAccessPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListConditionalAccessPoliciesResponse() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkZoneId{};

  ListConditionalAccessPoliciesForNetworkZoneRequest() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkZoneId) {
      res["NetworkZoneId"] = boost::any(*networkZoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkZoneId") != m.end() && !m["NetworkZoneId"].empty()) {
      networkZoneId = make_shared<string>(boost::any_cast<string>(m["NetworkZoneId"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneRequest() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeApplications{};
  shared_ptr<vector<string>> includeApplications{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeApplications) {
      res["ExcludeApplications"] = boost::any(*excludeApplications);
    }
    if (includeApplications) {
      res["IncludeApplications"] = boost::any(*includeApplications);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeApplications") != m.end() && !m["ExcludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeApplications = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeApplications") != m.end() && !m["IncludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeApplications = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeNetworkZones{};
  shared_ptr<vector<string>> includeNetworkZones{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeNetworkZones) {
      res["ExcludeNetworkZones"] = boost::any(*excludeNetworkZones);
    }
    if (includeNetworkZones) {
      res["IncludeNetworkZones"] = boost::any(*includeNetworkZones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeNetworkZones") != m.end() && !m["ExcludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeNetworkZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeNetworkZones") != m.end() && !m["IncludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeNetworkZones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeGroups{};
  shared_ptr<vector<string>> excludeOrganizationalUnits{};
  shared_ptr<vector<string>> excludeUsers{};
  shared_ptr<vector<string>> includeGroups{};
  shared_ptr<vector<string>> includeOrganizationalUnits{};
  shared_ptr<vector<string>> includeUsers{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeGroups) {
      res["ExcludeGroups"] = boost::any(*excludeGroups);
    }
    if (excludeOrganizationalUnits) {
      res["ExcludeOrganizationalUnits"] = boost::any(*excludeOrganizationalUnits);
    }
    if (excludeUsers) {
      res["ExcludeUsers"] = boost::any(*excludeUsers);
    }
    if (includeGroups) {
      res["IncludeGroups"] = boost::any(*includeGroups);
    }
    if (includeOrganizationalUnits) {
      res["IncludeOrganizationalUnits"] = boost::any(*includeOrganizationalUnits);
    }
    if (includeUsers) {
      res["IncludeUsers"] = boost::any(*includeUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeGroups") != m.end() && !m["ExcludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeOrganizationalUnits") != m.end() && !m["ExcludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeUsers") != m.end() && !m["ExcludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeGroups") != m.end() && !m["IncludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeOrganizationalUnits") != m.end() && !m["IncludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeUsers") != m.end() && !m["IncludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig : public Darabonba::Model {
public:
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications> applications{};
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones> networkZones{};
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers> users{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkZones) {
      res["NetworkZones"] = networkZones ? boost::any(networkZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigApplications>(model1);
      }
    }
    if (m.find("NetworkZones") != m.end() && !m["NetworkZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkZones"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkZones"]));
        networkZones = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigNetworkZones>(model1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfigUsers>(model1);
      }
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig : public Darabonba::Model {
public:
  shared_ptr<string> activeSessionReuseStatus{};
  shared_ptr<string> effect{};
  shared_ptr<long> mfaAuthenticationIntervalSeconds{};
  shared_ptr<vector<string>> mfaAuthenticationMethods{};
  shared_ptr<string> mfaType{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionReuseStatus) {
      res["ActiveSessionReuseStatus"] = boost::any(*activeSessionReuseStatus);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (mfaAuthenticationIntervalSeconds) {
      res["MfaAuthenticationIntervalSeconds"] = boost::any(*mfaAuthenticationIntervalSeconds);
    }
    if (mfaAuthenticationMethods) {
      res["MfaAuthenticationMethods"] = boost::any(*mfaAuthenticationMethods);
    }
    if (mfaType) {
      res["MfaType"] = boost::any(*mfaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionReuseStatus") != m.end() && !m["ActiveSessionReuseStatus"].empty()) {
      activeSessionReuseStatus = make_shared<string>(boost::any_cast<string>(m["ActiveSessionReuseStatus"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("MfaAuthenticationIntervalSeconds") != m.end() && !m["MfaAuthenticationIntervalSeconds"].empty()) {
      mfaAuthenticationIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["MfaAuthenticationIntervalSeconds"]));
    }
    if (m.find("MfaAuthenticationMethods") != m.end() && !m["MfaAuthenticationMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MfaAuthenticationMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MfaAuthenticationMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mfaAuthenticationMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MfaType") != m.end() && !m["MfaType"].empty()) {
      mfaType = make_shared<string>(boost::any_cast<string>(m["MfaType"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies : public Darabonba::Model {
public:
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> conditionalAccessPolicyName{};
  shared_ptr<string> conditionalAccessPolicyType{};
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig> conditionsConfig{};
  shared_ptr<long> createTime{};
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig> decisionConfig{};
  shared_ptr<string> decisionType{};
  shared_ptr<string> description{};
  shared_ptr<string> evaluateAt{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUpdatedTime{};
  shared_ptr<long> priority{};
  shared_ptr<string> status{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (conditionalAccessPolicyName) {
      res["ConditionalAccessPolicyName"] = boost::any(*conditionalAccessPolicyName);
    }
    if (conditionalAccessPolicyType) {
      res["ConditionalAccessPolicyType"] = boost::any(*conditionalAccessPolicyType);
    }
    if (conditionsConfig) {
      res["ConditionsConfig"] = conditionsConfig ? boost::any(conditionsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (decisionConfig) {
      res["DecisionConfig"] = decisionConfig ? boost::any(decisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionType) {
      res["DecisionType"] = boost::any(*decisionType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (evaluateAt) {
      res["EvaluateAt"] = boost::any(*evaluateAt);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUpdatedTime) {
      res["LastUpdatedTime"] = boost::any(*lastUpdatedTime);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("ConditionalAccessPolicyName") != m.end() && !m["ConditionalAccessPolicyName"].empty()) {
      conditionalAccessPolicyName = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyName"]));
    }
    if (m.find("ConditionalAccessPolicyType") != m.end() && !m["ConditionalAccessPolicyType"].empty()) {
      conditionalAccessPolicyType = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyType"]));
    }
    if (m.find("ConditionsConfig") != m.end() && !m["ConditionsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionsConfig"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionsConfig"]));
        conditionsConfig = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesConditionsConfig>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DecisionConfig") != m.end() && !m["DecisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DecisionConfig"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DecisionConfig"]));
        decisionConfig = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPoliciesDecisionConfig>(model1);
      }
    }
    if (m.find("DecisionType") != m.end() && !m["DecisionType"].empty()) {
      decisionType = make_shared<string>(boost::any_cast<string>(m["DecisionType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EvaluateAt") != m.end() && !m["EvaluateAt"].empty()) {
      evaluateAt = make_shared<string>(boost::any_cast<string>(m["EvaluateAt"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUpdatedTime") != m.end() && !m["LastUpdatedTime"].empty()) {
      lastUpdatedTime = make_shared<long>(boost::any_cast<long>(m["LastUpdatedTime"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies>> conditionalAccessPolicies{};
  shared_ptr<string> requestId{};

  ListConditionalAccessPoliciesForNetworkZoneResponseBody() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditionalAccessPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*conditionalAccessPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConditionalAccessPolicies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConditionalAccessPolicies") != m.end() && !m["ConditionalAccessPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["ConditionalAccessPolicies"].type()) {
        vector<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConditionalAccessPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditionalAccessPolicies = make_shared<vector<ListConditionalAccessPoliciesForNetworkZoneResponseBodyConditionalAccessPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponseBody() = default;
};
class ListConditionalAccessPoliciesForNetworkZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConditionalAccessPoliciesForNetworkZoneResponseBody> body{};

  ListConditionalAccessPoliciesForNetworkZoneResponse() {}

  explicit ListConditionalAccessPoliciesForNetworkZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConditionalAccessPoliciesForNetworkZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConditionalAccessPoliciesForNetworkZoneResponseBody>(model1);
      }
    }
  }


  virtual ~ListConditionalAccessPoliciesForNetworkZoneResponse() = default;
};
class ListDomainProxyTokensRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};

  ListDomainProxyTokensRequest() {}

  explicit ListDomainProxyTokensRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListDomainProxyTokensRequest() = default;
};
class ListDomainProxyTokensResponseBodyDomainProxyTokens : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyToken{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUsedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ListDomainProxyTokensResponseBodyDomainProxyTokens() {}

  explicit ListDomainProxyTokensResponseBodyDomainProxyTokens(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyToken) {
      res["DomainProxyToken"] = boost::any(*domainProxyToken);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUsedTime) {
      res["LastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyToken") != m.end() && !m["DomainProxyToken"].empty()) {
      domainProxyToken = make_shared<string>(boost::any_cast<string>(m["DomainProxyToken"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUsedTime") != m.end() && !m["LastUsedTime"].empty()) {
      lastUsedTime = make_shared<long>(boost::any_cast<long>(m["LastUsedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListDomainProxyTokensResponseBodyDomainProxyTokens() = default;
};
class ListDomainProxyTokensResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDomainProxyTokensResponseBodyDomainProxyTokens>> domainProxyTokens{};
  shared_ptr<string> requestId{};

  ListDomainProxyTokensResponseBody() {}

  explicit ListDomainProxyTokensResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainProxyTokens) {
      vector<boost::any> temp1;
      for(auto item1:*domainProxyTokens){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainProxyTokens"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainProxyTokens") != m.end() && !m["DomainProxyTokens"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainProxyTokens"].type()) {
        vector<ListDomainProxyTokensResponseBodyDomainProxyTokens> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainProxyTokens"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDomainProxyTokensResponseBodyDomainProxyTokens model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainProxyTokens = make_shared<vector<ListDomainProxyTokensResponseBodyDomainProxyTokens>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDomainProxyTokensResponseBody() = default;
};
class ListDomainProxyTokensResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDomainProxyTokensResponseBody> body{};

  ListDomainProxyTokensResponse() {}

  explicit ListDomainProxyTokensResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDomainProxyTokensResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDomainProxyTokensResponseBody>(model1);
      }
    }
  }


  virtual ~ListDomainProxyTokensResponse() = default;
};
class ListDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListDomainsRequest() {}

  explicit ListDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListDomainsRequest() = default;
};
class ListDomainsResponseBodyDomainsFiling : public Darabonba::Model {
public:
  shared_ptr<string> icpNumber{};

  ListDomainsResponseBodyDomainsFiling() {}

  explicit ListDomainsResponseBodyDomainsFiling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (icpNumber) {
      res["IcpNumber"] = boost::any(*icpNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IcpNumber") != m.end() && !m["IcpNumber"].empty()) {
      icpNumber = make_shared<string>(boost::any_cast<string>(m["IcpNumber"]));
    }
  }


  virtual ~ListDomainsResponseBodyDomainsFiling() = default;
};
class ListDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<bool> defaultDomain{};
  shared_ptr<string> domain{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainType{};
  shared_ptr<ListDomainsResponseBodyDomainsFiling> filing{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lockMode{};
  shared_ptr<long> updateTime{};

  ListDomainsResponseBodyDomains() {}

  explicit ListDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainType) {
      res["DomainType"] = boost::any(*domainType);
    }
    if (filing) {
      res["Filing"] = filing ? boost::any(filing->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lockMode) {
      res["LockMode"] = boost::any(*lockMode);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<bool>(boost::any_cast<bool>(m["DefaultDomain"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainType") != m.end() && !m["DomainType"].empty()) {
      domainType = make_shared<string>(boost::any_cast<string>(m["DomainType"]));
    }
    if (m.find("Filing") != m.end() && !m["Filing"].empty()) {
      if (typeid(map<string, boost::any>) == m["Filing"].type()) {
        ListDomainsResponseBodyDomainsFiling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Filing"]));
        filing = make_shared<ListDomainsResponseBodyDomainsFiling>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LockMode") != m.end() && !m["LockMode"].empty()) {
      lockMode = make_shared<string>(boost::any_cast<string>(m["LockMode"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListDomainsResponseBodyDomains() = default;
};
class ListDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDomainsResponseBodyDomains>> domains{};
  shared_ptr<string> requestId{};

  ListDomainsResponseBody() {}

  explicit ListDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<ListDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<ListDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDomainsResponseBody() = default;
};
class ListDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDomainsResponseBody> body{};

  ListDomainsResponse() {}

  explicit ListDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDomainsResponse() = default;
};
class ListEiamInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<string> instanceRegionId{};

  ListEiamInstancesRequest() {}

  explicit ListEiamInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (instanceRegionId) {
      res["InstanceRegionId"] = boost::any(*instanceRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceRegionId") != m.end() && !m["InstanceRegionId"].empty()) {
      instanceRegionId = make_shared<string>(boost::any_cast<string>(m["InstanceRegionId"]));
    }
  }


  virtual ~ListEiamInstancesRequest() = default;
};
class ListEiamInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> developerAPIPrivateDomain{};
  shared_ptr<string> developerAPIPublicDomain{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceStatus{};
  shared_ptr<string> instanceVersion{};
  shared_ptr<string> openAPIPrivateDomain{};
  shared_ptr<string> openAPIPublicDomain{};
  shared_ptr<string> SSODomain{};
  shared_ptr<long> startTime{};

  ListEiamInstancesResponseBodyInstances() {}

  explicit ListEiamInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (developerAPIPrivateDomain) {
      res["DeveloperAPIPrivateDomain"] = boost::any(*developerAPIPrivateDomain);
    }
    if (developerAPIPublicDomain) {
      res["DeveloperAPIPublicDomain"] = boost::any(*developerAPIPublicDomain);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceStatus) {
      res["InstanceStatus"] = boost::any(*instanceStatus);
    }
    if (instanceVersion) {
      res["InstanceVersion"] = boost::any(*instanceVersion);
    }
    if (openAPIPrivateDomain) {
      res["OpenAPIPrivateDomain"] = boost::any(*openAPIPrivateDomain);
    }
    if (openAPIPublicDomain) {
      res["OpenAPIPublicDomain"] = boost::any(*openAPIPublicDomain);
    }
    if (SSODomain) {
      res["SSODomain"] = boost::any(*SSODomain);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DeveloperAPIPrivateDomain") != m.end() && !m["DeveloperAPIPrivateDomain"].empty()) {
      developerAPIPrivateDomain = make_shared<string>(boost::any_cast<string>(m["DeveloperAPIPrivateDomain"]));
    }
    if (m.find("DeveloperAPIPublicDomain") != m.end() && !m["DeveloperAPIPublicDomain"].empty()) {
      developerAPIPublicDomain = make_shared<string>(boost::any_cast<string>(m["DeveloperAPIPublicDomain"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceStatus") != m.end() && !m["InstanceStatus"].empty()) {
      instanceStatus = make_shared<string>(boost::any_cast<string>(m["InstanceStatus"]));
    }
    if (m.find("InstanceVersion") != m.end() && !m["InstanceVersion"].empty()) {
      instanceVersion = make_shared<string>(boost::any_cast<string>(m["InstanceVersion"]));
    }
    if (m.find("OpenAPIPrivateDomain") != m.end() && !m["OpenAPIPrivateDomain"].empty()) {
      openAPIPrivateDomain = make_shared<string>(boost::any_cast<string>(m["OpenAPIPrivateDomain"]));
    }
    if (m.find("OpenAPIPublicDomain") != m.end() && !m["OpenAPIPublicDomain"].empty()) {
      openAPIPublicDomain = make_shared<string>(boost::any_cast<string>(m["OpenAPIPublicDomain"]));
    }
    if (m.find("SSODomain") != m.end() && !m["SSODomain"].empty()) {
      SSODomain = make_shared<string>(boost::any_cast<string>(m["SSODomain"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListEiamInstancesResponseBodyInstances() = default;
};
class ListEiamInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEiamInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};

  ListEiamInstancesResponseBody() {}

  explicit ListEiamInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListEiamInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEiamInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListEiamInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEiamInstancesResponseBody() = default;
};
class ListEiamInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEiamInstancesResponseBody> body{};

  ListEiamInstancesResponse() {}

  explicit ListEiamInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEiamInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEiamInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEiamInstancesResponse() = default;
};
class ListEiamRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListEiamRegionsResponseBodyRegions() {}

  explicit ListEiamRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListEiamRegionsResponseBodyRegions() = default;
};
class ListEiamRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEiamRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListEiamRegionsResponseBody() {}

  explicit ListEiamRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListEiamRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEiamRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListEiamRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListEiamRegionsResponseBody() = default;
};
class ListEiamRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEiamRegionsResponseBody> body{};

  ListEiamRegionsResponse() {}

  explicit ListEiamRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEiamRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEiamRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEiamRegionsResponse() = default;
};
class ListGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupExternalId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupNameStartsWith{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGroupsRequest() {}

  explicit ListGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupExternalId) {
      res["GroupExternalId"] = boost::any(*groupExternalId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupNameStartsWith) {
      res["GroupNameStartsWith"] = boost::any(*groupNameStartsWith);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupExternalId") != m.end() && !m["GroupExternalId"].empty()) {
      groupExternalId = make_shared<string>(boost::any_cast<string>(m["GroupExternalId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupNameStartsWith") != m.end() && !m["GroupNameStartsWith"].empty()) {
      groupNameStartsWith = make_shared<string>(boost::any_cast<string>(m["GroupNameStartsWith"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGroupsRequest() = default;
};
class ListGroupsResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupExternalId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> groupSourceId{};
  shared_ptr<string> groupSourceType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> updateTime{};

  ListGroupsResponseBodyGroups() {}

  explicit ListGroupsResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupExternalId) {
      res["GroupExternalId"] = boost::any(*groupExternalId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (groupSourceId) {
      res["GroupSourceId"] = boost::any(*groupSourceId);
    }
    if (groupSourceType) {
      res["GroupSourceType"] = boost::any(*groupSourceType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupExternalId") != m.end() && !m["GroupExternalId"].empty()) {
      groupExternalId = make_shared<string>(boost::any_cast<string>(m["GroupExternalId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("GroupSourceId") != m.end() && !m["GroupSourceId"].empty()) {
      groupSourceId = make_shared<string>(boost::any_cast<string>(m["GroupSourceId"]));
    }
    if (m.find("GroupSourceType") != m.end() && !m["GroupSourceType"].empty()) {
      groupSourceType = make_shared<string>(boost::any_cast<string>(m["GroupSourceType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListGroupsResponseBodyGroups() = default;
};
class ListGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListGroupsResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListGroupsResponseBody() {}

  explicit ListGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<ListGroupsResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupsResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<ListGroupsResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListGroupsResponseBody() = default;
};
class ListGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupsResponseBody> body{};

  ListGroupsResponse() {}

  explicit ListGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupsResponse() = default;
};
class ListGroupsForApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListGroupsForApplicationRequest() {}

  explicit ListGroupsForApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListGroupsForApplicationRequest() = default;
};
class ListGroupsForApplicationResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};

  ListGroupsForApplicationResponseBodyGroups() {}

  explicit ListGroupsForApplicationResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~ListGroupsForApplicationResponseBodyGroups() = default;
};
class ListGroupsForApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListGroupsForApplicationResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListGroupsForApplicationResponseBody() {}

  explicit ListGroupsForApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<ListGroupsForApplicationResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupsForApplicationResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<ListGroupsForApplicationResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListGroupsForApplicationResponseBody() = default;
};
class ListGroupsForApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupsForApplicationResponseBody> body{};

  ListGroupsForApplicationResponse() {}

  explicit ListGroupsForApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupsForApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupsForApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupsForApplicationResponse() = default;
};
class ListGroupsForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userId{};

  ListGroupsForUserRequest() {}

  explicit ListGroupsForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListGroupsForUserRequest() = default;
};
class ListGroupsForUserResponseBodyGroups : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> groupMemberRelationSourceId{};
  shared_ptr<string> groupMemberRelationSourceType{};

  ListGroupsForUserResponseBodyGroups() {}

  explicit ListGroupsForUserResponseBodyGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupMemberRelationSourceId) {
      res["GroupMemberRelationSourceId"] = boost::any(*groupMemberRelationSourceId);
    }
    if (groupMemberRelationSourceType) {
      res["GroupMemberRelationSourceType"] = boost::any(*groupMemberRelationSourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupMemberRelationSourceId") != m.end() && !m["GroupMemberRelationSourceId"].empty()) {
      groupMemberRelationSourceId = make_shared<string>(boost::any_cast<string>(m["GroupMemberRelationSourceId"]));
    }
    if (m.find("GroupMemberRelationSourceType") != m.end() && !m["GroupMemberRelationSourceType"].empty()) {
      groupMemberRelationSourceType = make_shared<string>(boost::any_cast<string>(m["GroupMemberRelationSourceType"]));
    }
  }


  virtual ~ListGroupsForUserResponseBodyGroups() = default;
};
class ListGroupsForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListGroupsForUserResponseBodyGroups>> groups{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListGroupsForUserResponseBody() {}

  explicit ListGroupsForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<ListGroupsForUserResponseBodyGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListGroupsForUserResponseBodyGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<ListGroupsForUserResponseBodyGroups>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListGroupsForUserResponseBody() = default;
};
class ListGroupsForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListGroupsForUserResponseBody> body{};

  ListGroupsForUserResponse() {}

  explicit ListGroupsForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListGroupsForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListGroupsForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListGroupsForUserResponse() = default;
};
class ListIdentityProvidersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIdentityProvidersRequest() {}

  explicit ListIdentityProvidersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListIdentityProvidersRequest() = default;
};
class ListIdentityProvidersResponseBodyIdentityProviders : public Darabonba::Model {
public:
  shared_ptr<string> advancedStatus{};
  shared_ptr<string> authnSourceSupplier{};
  shared_ptr<string> authnSourceType{};
  shared_ptr<string> authnStatus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> identityProviderExternalId{};
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> identityProviderName{};
  shared_ptr<string> identityProviderType{};
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> lastStatusCheckJobResult{};
  shared_ptr<string> lockReason{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> periodicSyncStatus{};
  shared_ptr<string> udPullStatus{};
  shared_ptr<string> udPullTargetScope{};
  shared_ptr<string> udPushStatus{};
  shared_ptr<long> updateTime{};

  ListIdentityProvidersResponseBodyIdentityProviders() {}

  explicit ListIdentityProvidersResponseBodyIdentityProviders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedStatus) {
      res["AdvancedStatus"] = boost::any(*advancedStatus);
    }
    if (authnSourceSupplier) {
      res["AuthnSourceSupplier"] = boost::any(*authnSourceSupplier);
    }
    if (authnSourceType) {
      res["AuthnSourceType"] = boost::any(*authnSourceType);
    }
    if (authnStatus) {
      res["AuthnStatus"] = boost::any(*authnStatus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (identityProviderExternalId) {
      res["IdentityProviderExternalId"] = boost::any(*identityProviderExternalId);
    }
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (identityProviderName) {
      res["IdentityProviderName"] = boost::any(*identityProviderName);
    }
    if (identityProviderType) {
      res["IdentityProviderType"] = boost::any(*identityProviderType);
    }
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastStatusCheckJobResult) {
      res["LastStatusCheckJobResult"] = boost::any(*lastStatusCheckJobResult);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (periodicSyncStatus) {
      res["PeriodicSyncStatus"] = boost::any(*periodicSyncStatus);
    }
    if (udPullStatus) {
      res["UdPullStatus"] = boost::any(*udPullStatus);
    }
    if (udPullTargetScope) {
      res["UdPullTargetScope"] = boost::any(*udPullTargetScope);
    }
    if (udPushStatus) {
      res["UdPushStatus"] = boost::any(*udPushStatus);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdvancedStatus") != m.end() && !m["AdvancedStatus"].empty()) {
      advancedStatus = make_shared<string>(boost::any_cast<string>(m["AdvancedStatus"]));
    }
    if (m.find("AuthnSourceSupplier") != m.end() && !m["AuthnSourceSupplier"].empty()) {
      authnSourceSupplier = make_shared<string>(boost::any_cast<string>(m["AuthnSourceSupplier"]));
    }
    if (m.find("AuthnSourceType") != m.end() && !m["AuthnSourceType"].empty()) {
      authnSourceType = make_shared<string>(boost::any_cast<string>(m["AuthnSourceType"]));
    }
    if (m.find("AuthnStatus") != m.end() && !m["AuthnStatus"].empty()) {
      authnStatus = make_shared<string>(boost::any_cast<string>(m["AuthnStatus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IdentityProviderExternalId") != m.end() && !m["IdentityProviderExternalId"].empty()) {
      identityProviderExternalId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderExternalId"]));
    }
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("IdentityProviderName") != m.end() && !m["IdentityProviderName"].empty()) {
      identityProviderName = make_shared<string>(boost::any_cast<string>(m["IdentityProviderName"]));
    }
    if (m.find("IdentityProviderType") != m.end() && !m["IdentityProviderType"].empty()) {
      identityProviderType = make_shared<string>(boost::any_cast<string>(m["IdentityProviderType"]));
    }
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastStatusCheckJobResult") != m.end() && !m["LastStatusCheckJobResult"].empty()) {
      lastStatusCheckJobResult = make_shared<string>(boost::any_cast<string>(m["LastStatusCheckJobResult"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("PeriodicSyncStatus") != m.end() && !m["PeriodicSyncStatus"].empty()) {
      periodicSyncStatus = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncStatus"]));
    }
    if (m.find("UdPullStatus") != m.end() && !m["UdPullStatus"].empty()) {
      udPullStatus = make_shared<string>(boost::any_cast<string>(m["UdPullStatus"]));
    }
    if (m.find("UdPullTargetScope") != m.end() && !m["UdPullTargetScope"].empty()) {
      udPullTargetScope = make_shared<string>(boost::any_cast<string>(m["UdPullTargetScope"]));
    }
    if (m.find("UdPushStatus") != m.end() && !m["UdPushStatus"].empty()) {
      udPushStatus = make_shared<string>(boost::any_cast<string>(m["UdPushStatus"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListIdentityProvidersResponseBodyIdentityProviders() = default;
};
class ListIdentityProvidersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIdentityProvidersResponseBodyIdentityProviders>> identityProviders{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIdentityProvidersResponseBody() {}

  explicit ListIdentityProvidersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identityProviders) {
      vector<boost::any> temp1;
      for(auto item1:*identityProviders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IdentityProviders"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdentityProviders") != m.end() && !m["IdentityProviders"].empty()) {
      if (typeid(vector<boost::any>) == m["IdentityProviders"].type()) {
        vector<ListIdentityProvidersResponseBodyIdentityProviders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IdentityProviders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIdentityProvidersResponseBodyIdentityProviders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        identityProviders = make_shared<vector<ListIdentityProvidersResponseBodyIdentityProviders>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIdentityProvidersResponseBody() = default;
};
class ListIdentityProvidersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIdentityProvidersResponseBody> body{};

  ListIdentityProvidersResponse() {}

  explicit ListIdentityProvidersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIdentityProvidersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIdentityProvidersResponseBody>(model1);
      }
    }
  }


  virtual ~ListIdentityProvidersResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyInstancesDefaultEndpoint : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<string> status{};

  ListInstancesResponseBodyInstancesDefaultEndpoint() {}

  explicit ListInstancesResponseBodyInstancesDefaultEndpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstancesDefaultEndpoint() = default;
};
class ListInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<ListInstancesResponseBodyInstancesDefaultEndpoint> defaultEndpoint{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};

  ListInstancesResponseBodyInstances() {}

  explicit ListInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (defaultEndpoint) {
      res["DefaultEndpoint"] = defaultEndpoint ? boost::any(defaultEndpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DefaultEndpoint") != m.end() && !m["DefaultEndpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["DefaultEndpoint"].type()) {
        ListInstancesResponseBodyInstancesDefaultEndpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DefaultEndpoint"]));
        defaultEndpoint = make_shared<ListInstancesResponseBodyInstancesDefaultEndpoint>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesResponseBodyInstances() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<ListInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<ListInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions() {}

  explicit ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions() = default;
};
class ListNetworkAccessEndpointAvailableRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListNetworkAccessEndpointAvailableRegionsResponseBody() {}

  explicit ListNetworkAccessEndpointAvailableRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListNetworkAccessEndpointAvailableRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableRegionsResponseBody() = default;
};
class ListNetworkAccessEndpointAvailableRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworkAccessEndpointAvailableRegionsResponseBody> body{};

  ListNetworkAccessEndpointAvailableRegionsResponse() {}

  explicit ListNetworkAccessEndpointAvailableRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworkAccessEndpointAvailableRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworkAccessEndpointAvailableRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableRegionsResponse() = default;
};
class ListNetworkAccessEndpointAvailableZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> naeRegionId{};

  ListNetworkAccessEndpointAvailableZonesRequest() {}

  explicit ListNetworkAccessEndpointAvailableZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (naeRegionId) {
      res["NaeRegionId"] = boost::any(*naeRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NaeRegionId") != m.end() && !m["NaeRegionId"].empty()) {
      naeRegionId = make_shared<string>(boost::any_cast<string>(m["NaeRegionId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableZonesRequest() = default;
};
class ListNetworkAccessEndpointAvailableZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> zoneId{};

  ListNetworkAccessEndpointAvailableZonesResponseBodyZones() {}

  explicit ListNetworkAccessEndpointAvailableZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableZonesResponseBodyZones() = default;
};
class ListNetworkAccessEndpointAvailableZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNetworkAccessEndpointAvailableZonesResponseBodyZones>> zones{};

  ListNetworkAccessEndpointAvailableZonesResponseBody() {}

  explicit ListNetworkAccessEndpointAvailableZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      vector<boost::any> temp1;
      for(auto item1:*zones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<ListNetworkAccessEndpointAvailableZonesResponseBodyZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkAccessEndpointAvailableZonesResponseBodyZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zones = make_shared<vector<ListNetworkAccessEndpointAvailableZonesResponseBodyZones>>(expect1);
      }
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableZonesResponseBody() = default;
};
class ListNetworkAccessEndpointAvailableZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworkAccessEndpointAvailableZonesResponseBody> body{};

  ListNetworkAccessEndpointAvailableZonesResponse() {}

  explicit ListNetworkAccessEndpointAvailableZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworkAccessEndpointAvailableZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworkAccessEndpointAvailableZonesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworkAccessEndpointAvailableZonesResponse() = default;
};
class ListNetworkAccessEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> networkAccessEndpointStatus{};
  shared_ptr<string> networkAccessEndpointType{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcRegionId{};

  ListNetworkAccessEndpointsRequest() {}

  explicit ListNetworkAccessEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (networkAccessEndpointStatus) {
      res["NetworkAccessEndpointStatus"] = boost::any(*networkAccessEndpointStatus);
    }
    if (networkAccessEndpointType) {
      res["NetworkAccessEndpointType"] = boost::any(*networkAccessEndpointType);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NetworkAccessEndpointStatus") != m.end() && !m["NetworkAccessEndpointStatus"].empty()) {
      networkAccessEndpointStatus = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointStatus"]));
    }
    if (m.find("NetworkAccessEndpointType") != m.end() && !m["NetworkAccessEndpointType"].empty()) {
      networkAccessEndpointType = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointType"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointsRequest() = default;
};
class ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<string> networkAccessEndpointName{};
  shared_ptr<string> networkAccessEndpointType{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<vector<string>> vSwitchIds{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcRegionId{};

  ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints() {}

  explicit ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (networkAccessEndpointName) {
      res["NetworkAccessEndpointName"] = boost::any(*networkAccessEndpointName);
    }
    if (networkAccessEndpointType) {
      res["NetworkAccessEndpointType"] = boost::any(*networkAccessEndpointType);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vSwitchIds) {
      res["VSwitchIds"] = boost::any(*vSwitchIds);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcRegionId) {
      res["VpcRegionId"] = boost::any(*vpcRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("NetworkAccessEndpointName") != m.end() && !m["NetworkAccessEndpointName"].empty()) {
      networkAccessEndpointName = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointName"]));
    }
    if (m.find("NetworkAccessEndpointType") != m.end() && !m["NetworkAccessEndpointType"].empty()) {
      networkAccessEndpointType = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointType"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VSwitchIds") != m.end() && !m["VSwitchIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VSwitchIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VSwitchIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vSwitchIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcRegionId") != m.end() && !m["VpcRegionId"].empty()) {
      vpcRegionId = make_shared<string>(boost::any_cast<string>(m["VpcRegionId"]));
    }
  }


  virtual ~ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints() = default;
};
class ListNetworkAccessEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints>> networkAccessEndpoints{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListNetworkAccessEndpointsResponseBody() {}

  explicit ListNetworkAccessEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAccessEndpoints) {
      vector<boost::any> temp1;
      for(auto item1:*networkAccessEndpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkAccessEndpoints"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAccessEndpoints") != m.end() && !m["NetworkAccessEndpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkAccessEndpoints"].type()) {
        vector<ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkAccessEndpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkAccessEndpoints = make_shared<vector<ListNetworkAccessEndpointsResponseBodyNetworkAccessEndpoints>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNetworkAccessEndpointsResponseBody() = default;
};
class ListNetworkAccessEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworkAccessEndpointsResponseBody> body{};

  ListNetworkAccessEndpointsResponse() {}

  explicit ListNetworkAccessEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworkAccessEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworkAccessEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworkAccessEndpointsResponse() = default;
};
class ListNetworkAccessPathsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};

  ListNetworkAccessPathsRequest() {}

  explicit ListNetworkAccessPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
  }


  virtual ~ListNetworkAccessPathsRequest() = default;
};
class ListNetworkAccessPathsResponseBodyNetworkAccessPaths : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<string> networkAccessPathId{};
  shared_ptr<string> networkInterfaceId{};
  shared_ptr<string> privateIpAddress{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> vSwitchId{};

  ListNetworkAccessPathsResponseBodyNetworkAccessPaths() {}

  explicit ListNetworkAccessPathsResponseBodyNetworkAccessPaths(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (networkAccessPathId) {
      res["NetworkAccessPathId"] = boost::any(*networkAccessPathId);
    }
    if (networkInterfaceId) {
      res["NetworkInterfaceId"] = boost::any(*networkInterfaceId);
    }
    if (privateIpAddress) {
      res["PrivateIpAddress"] = boost::any(*privateIpAddress);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("NetworkAccessPathId") != m.end() && !m["NetworkAccessPathId"].empty()) {
      networkAccessPathId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessPathId"]));
    }
    if (m.find("NetworkInterfaceId") != m.end() && !m["NetworkInterfaceId"].empty()) {
      networkInterfaceId = make_shared<string>(boost::any_cast<string>(m["NetworkInterfaceId"]));
    }
    if (m.find("PrivateIpAddress") != m.end() && !m["PrivateIpAddress"].empty()) {
      privateIpAddress = make_shared<string>(boost::any_cast<string>(m["PrivateIpAddress"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
  }


  virtual ~ListNetworkAccessPathsResponseBodyNetworkAccessPaths() = default;
};
class ListNetworkAccessPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListNetworkAccessPathsResponseBodyNetworkAccessPaths>> networkAccessPaths{};
  shared_ptr<string> requestId{};

  ListNetworkAccessPathsResponseBody() {}

  explicit ListNetworkAccessPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkAccessPaths) {
      vector<boost::any> temp1;
      for(auto item1:*networkAccessPaths){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkAccessPaths"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkAccessPaths") != m.end() && !m["NetworkAccessPaths"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkAccessPaths"].type()) {
        vector<ListNetworkAccessPathsResponseBodyNetworkAccessPaths> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkAccessPaths"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNetworkAccessPathsResponseBodyNetworkAccessPaths model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkAccessPaths = make_shared<vector<ListNetworkAccessPathsResponseBodyNetworkAccessPaths>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListNetworkAccessPathsResponseBody() = default;
};
class ListNetworkAccessPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNetworkAccessPathsResponseBody> body{};

  ListNetworkAccessPathsResponse() {}

  explicit ListNetworkAccessPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNetworkAccessPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNetworkAccessPathsResponseBody>(model1);
      }
    }
  }


  virtual ~ListNetworkAccessPathsResponse() = default;
};
class ListOrganizationalUnitParentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};

  ListOrganizationalUnitParentsRequest() {}

  explicit ListOrganizationalUnitParentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~ListOrganizationalUnitParentsRequest() = default;
};
class ListOrganizationalUnitParentsResponseBodyParents : public Darabonba::Model {
public:
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> parentId{};

  ListOrganizationalUnitParentsResponseBodyParents() {}

  explicit ListOrganizationalUnitParentsResponseBodyParents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~ListOrganizationalUnitParentsResponseBodyParents() = default;
};
class ListOrganizationalUnitParentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOrganizationalUnitParentsResponseBodyParents>> parents{};
  shared_ptr<string> requestId{};

  ListOrganizationalUnitParentsResponseBody() {}

  explicit ListOrganizationalUnitParentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parents) {
      vector<boost::any> temp1;
      for(auto item1:*parents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Parents"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Parents") != m.end() && !m["Parents"].empty()) {
      if (typeid(vector<boost::any>) == m["Parents"].type()) {
        vector<ListOrganizationalUnitParentsResponseBodyParents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Parents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrganizationalUnitParentsResponseBodyParents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parents = make_shared<vector<ListOrganizationalUnitParentsResponseBodyParents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOrganizationalUnitParentsResponseBody() = default;
};
class ListOrganizationalUnitParentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrganizationalUnitParentsResponseBody> body{};

  ListOrganizationalUnitParentsResponse() {}

  explicit ListOrganizationalUnitParentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrganizationalUnitParentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrganizationalUnitParentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrganizationalUnitParentsResponse() = default;
};
class ListOrganizationalUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<string> organizationalUnitNameStartsWith{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> parentId{};

  ListOrganizationalUnitsRequest() {}

  explicit ListOrganizationalUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (organizationalUnitNameStartsWith) {
      res["OrganizationalUnitNameStartsWith"] = boost::any(*organizationalUnitNameStartsWith);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("OrganizationalUnitNameStartsWith") != m.end() && !m["OrganizationalUnitNameStartsWith"].empty()) {
      organizationalUnitNameStartsWith = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitNameStartsWith"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~ListOrganizationalUnitsRequest() = default;
};
class ListOrganizationalUnitsResponseBodyOrganizationalUnits : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> leaf{};
  shared_ptr<string> organizationalUnitExternalId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> organizationalUnitName{};
  shared_ptr<string> organizationalUnitSourceId{};
  shared_ptr<string> organizationalUnitSourceType{};
  shared_ptr<string> parentId{};
  shared_ptr<long> updateTime{};

  ListOrganizationalUnitsResponseBodyOrganizationalUnits() {}

  explicit ListOrganizationalUnitsResponseBodyOrganizationalUnits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (leaf) {
      res["Leaf"] = boost::any(*leaf);
    }
    if (organizationalUnitExternalId) {
      res["OrganizationalUnitExternalId"] = boost::any(*organizationalUnitExternalId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    if (organizationalUnitSourceId) {
      res["OrganizationalUnitSourceId"] = boost::any(*organizationalUnitSourceId);
    }
    if (organizationalUnitSourceType) {
      res["OrganizationalUnitSourceType"] = boost::any(*organizationalUnitSourceType);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Leaf") != m.end() && !m["Leaf"].empty()) {
      leaf = make_shared<bool>(boost::any_cast<bool>(m["Leaf"]));
    }
    if (m.find("OrganizationalUnitExternalId") != m.end() && !m["OrganizationalUnitExternalId"].empty()) {
      organizationalUnitExternalId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitExternalId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
    if (m.find("OrganizationalUnitSourceId") != m.end() && !m["OrganizationalUnitSourceId"].empty()) {
      organizationalUnitSourceId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitSourceId"]));
    }
    if (m.find("OrganizationalUnitSourceType") != m.end() && !m["OrganizationalUnitSourceType"].empty()) {
      organizationalUnitSourceType = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitSourceType"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ListOrganizationalUnitsResponseBodyOrganizationalUnits() = default;
};
class ListOrganizationalUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOrganizationalUnitsResponseBodyOrganizationalUnits>> organizationalUnits{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOrganizationalUnitsResponseBody() {}

  explicit ListOrganizationalUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnits) {
      vector<boost::any> temp1;
      for(auto item1:*organizationalUnits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrganizationalUnits"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnits") != m.end() && !m["OrganizationalUnits"].empty()) {
      if (typeid(vector<boost::any>) == m["OrganizationalUnits"].type()) {
        vector<ListOrganizationalUnitsResponseBodyOrganizationalUnits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrganizationalUnits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrganizationalUnitsResponseBodyOrganizationalUnits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizationalUnits = make_shared<vector<ListOrganizationalUnitsResponseBodyOrganizationalUnits>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOrganizationalUnitsResponseBody() = default;
};
class ListOrganizationalUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrganizationalUnitsResponseBody> body{};

  ListOrganizationalUnitsResponse() {}

  explicit ListOrganizationalUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrganizationalUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrganizationalUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrganizationalUnitsResponse() = default;
};
class ListOrganizationalUnitsForApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListOrganizationalUnitsForApplicationRequest() {}

  explicit ListOrganizationalUnitsForApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListOrganizationalUnitsForApplicationRequest() = default;
};
class ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits : public Darabonba::Model {
public:
  shared_ptr<string> organizationalUnitId{};

  ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits() {}

  explicit ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits() = default;
};
class ListOrganizationalUnitsForApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits>> organizationalUnits{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListOrganizationalUnitsForApplicationResponseBody() {}

  explicit ListOrganizationalUnitsForApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationalUnits) {
      vector<boost::any> temp1;
      for(auto item1:*organizationalUnits){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrganizationalUnits"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationalUnits") != m.end() && !m["OrganizationalUnits"].empty()) {
      if (typeid(vector<boost::any>) == m["OrganizationalUnits"].type()) {
        vector<ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrganizationalUnits"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizationalUnits = make_shared<vector<ListOrganizationalUnitsForApplicationResponseBodyOrganizationalUnits>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOrganizationalUnitsForApplicationResponseBody() = default;
};
class ListOrganizationalUnitsForApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOrganizationalUnitsForApplicationResponseBody> body{};

  ListOrganizationalUnitsForApplicationResponse() {}

  explicit ListOrganizationalUnitsForApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOrganizationalUnitsForApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOrganizationalUnitsForApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListOrganizationalUnitsForApplicationResponse() = default;
};
class ListRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  ListRegionsResponseBodyRegions() {}

  explicit ListRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListRegionsResponseBodyRegions() = default;
};
class ListRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListRegionsResponseBody() {}

  explicit ListRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRegionsResponseBody() = default;
};
class ListRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRegionsResponseBody> body{};

  ListRegionsResponse() {}

  explicit ListRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRegionsResponse() = default;
};
class ListSynchronizationJobsRequestFilters : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<vector<string>> values{};

  ListSynchronizationJobsRequestFilters() {}

  explicit ListSynchronizationJobsRequestFilters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListSynchronizationJobsRequestFilters() = default;
};
class ListSynchronizationJobsRequest : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<ListSynchronizationJobsRequestFilters>> filters{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> targetIds{};
  shared_ptr<string> targetType{};

  ListSynchronizationJobsRequest() {}

  explicit ListSynchronizationJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filters) {
      vector<boost::any> temp1;
      for(auto item1:*filters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Filters"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetIds) {
      res["TargetIds"] = boost::any(*targetIds);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Filters") != m.end() && !m["Filters"].empty()) {
      if (typeid(vector<boost::any>) == m["Filters"].type()) {
        vector<ListSynchronizationJobsRequestFilters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Filters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSynchronizationJobsRequestFilters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filters = make_shared<vector<ListSynchronizationJobsRequestFilters>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetIds") != m.end() && !m["TargetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TargetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TargetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
  }


  virtual ~ListSynchronizationJobsRequest() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics : public Darabonba::Model {
public:
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded> binded{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated> created{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted> deleted{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed> pushed{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame> same{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated> updated{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics : public Darabonba::Model {
public:
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded> binded{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated> created{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted> deleted{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed> pushed{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame> same{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated> updated{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics : public Darabonba::Model {
public:
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded> binded{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated> created{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted> deleted{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed> pushed{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame> same{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated> updated{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsDeleted>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated : public Darabonba::Model {
public:
  shared_ptr<long> failed{};
  shared_ptr<long> skipped{};
  shared_ptr<long> success{};
  shared_ptr<long> total{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = boost::any(*failed);
    }
    if (skipped) {
      res["Skipped"] = boost::any(*skipped);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      failed = make_shared<long>(boost::any_cast<long>(m["Failed"]));
    }
    if (m.find("Skipped") != m.end() && !m["Skipped"].empty()) {
      skipped = make_shared<long>(boost::any_cast<long>(m["Skipped"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<long>(boost::any_cast<long>(m["Success"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics : public Darabonba::Model {
public:
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded> binded{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated> created{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted> deleted{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported> exported{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed> pushed{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame> same{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated> updated{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binded) {
      res["Binded"] = binded ? boost::any(binded->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (created) {
      res["Created"] = created ? boost::any(created->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deleted) {
      res["Deleted"] = deleted ? boost::any(deleted->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (exported) {
      res["Exported"] = exported ? boost::any(exported->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pushed) {
      res["Pushed"] = pushed ? boost::any(pushed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (same) {
      res["Same"] = same ? boost::any(same->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updated) {
      res["Updated"] = updated ? boost::any(updated->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binded") != m.end() && !m["Binded"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binded"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binded"]));
        binded = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsBinded>(model1);
      }
    }
    if (m.find("Created") != m.end() && !m["Created"].empty()) {
      if (typeid(map<string, boost::any>) == m["Created"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Created"]));
        created = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsCreated>(model1);
      }
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      if (typeid(map<string, boost::any>) == m["Deleted"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Deleted"]));
        deleted = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsDeleted>(model1);
      }
    }
    if (m.find("Exported") != m.end() && !m["Exported"].empty()) {
      if (typeid(map<string, boost::any>) == m["Exported"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Exported"]));
        exported = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsExported>(model1);
      }
    }
    if (m.find("Pushed") != m.end() && !m["Pushed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pushed"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pushed"]));
        pushed = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsPushed>(model1);
      }
    }
    if (m.find("Same") != m.end() && !m["Same"].empty()) {
      if (typeid(map<string, boost::any>) == m["Same"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Same"]));
        same = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsSame>(model1);
      }
    }
    if (m.find("Updated") != m.end() && !m["Updated"].empty()) {
      if (typeid(map<string, boost::any>) == m["Updated"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Updated"]));
        updated = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatisticsUpdated>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobsResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics> groupMemberStatistics{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics> groupStatistics{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics> organizationalUnitStatistics{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics> userStatistics{};

  ListSynchronizationJobsResponseBodySynchronizationJobsResult() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobsResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupMemberStatistics) {
      res["GroupMemberStatistics"] = groupMemberStatistics ? boost::any(groupMemberStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupStatistics) {
      res["GroupStatistics"] = groupStatistics ? boost::any(groupStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (organizationalUnitStatistics) {
      res["OrganizationalUnitStatistics"] = organizationalUnitStatistics ? boost::any(organizationalUnitStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userStatistics) {
      res["UserStatistics"] = userStatistics ? boost::any(userStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupMemberStatistics") != m.end() && !m["GroupMemberStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupMemberStatistics"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupMemberStatistics"]));
        groupMemberStatistics = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupMemberStatistics>(model1);
      }
    }
    if (m.find("GroupStatistics") != m.end() && !m["GroupStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupStatistics"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupStatistics"]));
        groupStatistics = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultGroupStatistics>(model1);
      }
    }
    if (m.find("OrganizationalUnitStatistics") != m.end() && !m["OrganizationalUnitStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrganizationalUnitStatistics"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrganizationalUnitStatistics"]));
        organizationalUnitStatistics = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultOrganizationalUnitStatistics>(model1);
      }
    }
    if (m.find("UserStatistics") != m.end() && !m["UserStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserStatistics"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserStatistics"]));
        userStatistics = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResultUserStatistics>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobsResult() = default;
};
class ListSynchronizationJobsResponseBodySynchronizationJobs : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> direction{};
  shared_ptr<long> endTime{};
  shared_ptr<ListSynchronizationJobsResponseBodySynchronizationJobsResult> result{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> synchronizationJobId{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<string> triggerType{};

  ListSynchronizationJobsResponseBodySynchronizationJobs() {}

  explicit ListSynchronizationJobsResponseBodySynchronizationJobs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (triggerType) {
      res["TriggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListSynchronizationJobsResponseBodySynchronizationJobsResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListSynchronizationJobsResponseBodySynchronizationJobsResult>(model1);
      }
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TriggerType") != m.end() && !m["TriggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["TriggerType"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBodySynchronizationJobs() = default;
};
class ListSynchronizationJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSynchronizationJobsResponseBodySynchronizationJobs>> synchronizationJobs{};
  shared_ptr<long> totalCount{};

  ListSynchronizationJobsResponseBody() {}

  explicit ListSynchronizationJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (synchronizationJobs) {
      vector<boost::any> temp1;
      for(auto item1:*synchronizationJobs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SynchronizationJobs"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SynchronizationJobs") != m.end() && !m["SynchronizationJobs"].empty()) {
      if (typeid(vector<boost::any>) == m["SynchronizationJobs"].type()) {
        vector<ListSynchronizationJobsResponseBodySynchronizationJobs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SynchronizationJobs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSynchronizationJobsResponseBodySynchronizationJobs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synchronizationJobs = make_shared<vector<ListSynchronizationJobsResponseBodySynchronizationJobs>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSynchronizationJobsResponseBody() = default;
};
class ListSynchronizationJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSynchronizationJobsResponseBody> body{};

  ListSynchronizationJobsResponse() {}

  explicit ListSynchronizationJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSynchronizationJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSynchronizationJobsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSynchronizationJobsResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayNameStartsWith{};
  shared_ptr<string> email{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> phoneRegion{};
  shared_ptr<string> status{};
  shared_ptr<string> userExternalId{};
  shared_ptr<vector<string>> userIds{};
  shared_ptr<string> userSourceId{};
  shared_ptr<string> userSourceType{};
  shared_ptr<string> usernameStartsWith{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayNameStartsWith) {
      res["DisplayNameStartsWith"] = boost::any(*displayNameStartsWith);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (phoneRegion) {
      res["PhoneRegion"] = boost::any(*phoneRegion);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userExternalId) {
      res["UserExternalId"] = boost::any(*userExternalId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    if (userSourceId) {
      res["UserSourceId"] = boost::any(*userSourceId);
    }
    if (userSourceType) {
      res["UserSourceType"] = boost::any(*userSourceType);
    }
    if (usernameStartsWith) {
      res["UsernameStartsWith"] = boost::any(*usernameStartsWith);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayNameStartsWith") != m.end() && !m["DisplayNameStartsWith"].empty()) {
      displayNameStartsWith = make_shared<string>(boost::any_cast<string>(m["DisplayNameStartsWith"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PhoneRegion") != m.end() && !m["PhoneRegion"].empty()) {
      phoneRegion = make_shared<string>(boost::any_cast<string>(m["PhoneRegion"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserExternalId") != m.end() && !m["UserExternalId"].empty()) {
      userExternalId = make_shared<string>(boost::any_cast<string>(m["UserExternalId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserSourceId") != m.end() && !m["UserSourceId"].empty()) {
      userSourceId = make_shared<string>(boost::any_cast<string>(m["UserSourceId"]));
    }
    if (m.find("UserSourceType") != m.end() && !m["UserSourceType"].empty()) {
      userSourceType = make_shared<string>(boost::any_cast<string>(m["UserSourceType"]));
    }
    if (m.find("UsernameStartsWith") != m.end() && !m["UsernameStartsWith"].empty()) {
      usernameStartsWith = make_shared<string>(boost::any_cast<string>(m["UsernameStartsWith"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<long> accountExpireTime{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<bool> emailVerified{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lockExpireTime{};
  shared_ptr<long> passwordExpireTime{};
  shared_ptr<bool> passwordSet{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<bool> phoneNumberVerified{};
  shared_ptr<string> phoneRegion{};
  shared_ptr<long> registerTime{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<string> userExternalId{};
  shared_ptr<string> userId{};
  shared_ptr<string> userSourceId{};
  shared_ptr<string> userSourceType{};
  shared_ptr<string> username{};

  ListUsersResponseBodyUsers() {}

  explicit ListUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountExpireTime) {
      res["AccountExpireTime"] = boost::any(*accountExpireTime);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (emailVerified) {
      res["EmailVerified"] = boost::any(*emailVerified);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lockExpireTime) {
      res["LockExpireTime"] = boost::any(*lockExpireTime);
    }
    if (passwordExpireTime) {
      res["PasswordExpireTime"] = boost::any(*passwordExpireTime);
    }
    if (passwordSet) {
      res["PasswordSet"] = boost::any(*passwordSet);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (phoneNumberVerified) {
      res["PhoneNumberVerified"] = boost::any(*phoneNumberVerified);
    }
    if (phoneRegion) {
      res["PhoneRegion"] = boost::any(*phoneRegion);
    }
    if (registerTime) {
      res["RegisterTime"] = boost::any(*registerTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userExternalId) {
      res["UserExternalId"] = boost::any(*userExternalId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userSourceId) {
      res["UserSourceId"] = boost::any(*userSourceId);
    }
    if (userSourceType) {
      res["UserSourceType"] = boost::any(*userSourceType);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountExpireTime") != m.end() && !m["AccountExpireTime"].empty()) {
      accountExpireTime = make_shared<long>(boost::any_cast<long>(m["AccountExpireTime"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EmailVerified") != m.end() && !m["EmailVerified"].empty()) {
      emailVerified = make_shared<bool>(boost::any_cast<bool>(m["EmailVerified"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LockExpireTime") != m.end() && !m["LockExpireTime"].empty()) {
      lockExpireTime = make_shared<long>(boost::any_cast<long>(m["LockExpireTime"]));
    }
    if (m.find("PasswordExpireTime") != m.end() && !m["PasswordExpireTime"].empty()) {
      passwordExpireTime = make_shared<long>(boost::any_cast<long>(m["PasswordExpireTime"]));
    }
    if (m.find("PasswordSet") != m.end() && !m["PasswordSet"].empty()) {
      passwordSet = make_shared<bool>(boost::any_cast<bool>(m["PasswordSet"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PhoneNumberVerified") != m.end() && !m["PhoneNumberVerified"].empty()) {
      phoneNumberVerified = make_shared<bool>(boost::any_cast<bool>(m["PhoneNumberVerified"]));
    }
    if (m.find("PhoneRegion") != m.end() && !m["PhoneRegion"].empty()) {
      phoneRegion = make_shared<string>(boost::any_cast<string>(m["PhoneRegion"]));
    }
    if (m.find("RegisterTime") != m.end() && !m["RegisterTime"].empty()) {
      registerTime = make_shared<long>(boost::any_cast<long>(m["RegisterTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserExternalId") != m.end() && !m["UserExternalId"].empty()) {
      userExternalId = make_shared<string>(boost::any_cast<string>(m["UserExternalId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserSourceId") != m.end() && !m["UserSourceId"].empty()) {
      userSourceId = make_shared<string>(boost::any_cast<string>(m["UserSourceId"]));
    }
    if (m.find("UserSourceType") != m.end() && !m["UserSourceType"].empty()) {
      userSourceType = make_shared<string>(boost::any_cast<string>(m["UserSourceType"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ListUsersResponseBodyUsers() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUsersResponseBodyUsers>> users{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListUsersResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListUsersResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class ListUsersForApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> userIds{};

  ListUsersForApplicationRequest() {}

  explicit ListUsersForApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUsersForApplicationRequest() = default;
};
class ListUsersForApplicationResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  ListUsersForApplicationResponseBodyUsers() {}

  explicit ListUsersForApplicationResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUsersForApplicationResponseBodyUsers() = default;
};
class ListUsersForApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUsersForApplicationResponseBodyUsers>> users{};

  ListUsersForApplicationResponseBody() {}

  explicit ListUsersForApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListUsersForApplicationResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersForApplicationResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListUsersForApplicationResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListUsersForApplicationResponseBody() = default;
};
class ListUsersForApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersForApplicationResponseBody> body{};

  ListUsersForApplicationResponse() {}

  explicit ListUsersForApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersForApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersForApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersForApplicationResponse() = default;
};
class ListUsersForGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> userIds{};

  ListUsersForGroupRequest() {}

  explicit ListUsersForGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUsersForGroupRequest() = default;
};
class ListUsersForGroupResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<string> groupMemberRelationSourceId{};
  shared_ptr<string> groupMemberRelationSourceType{};
  shared_ptr<string> userId{};

  ListUsersForGroupResponseBodyUsers() {}

  explicit ListUsersForGroupResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMemberRelationSourceId) {
      res["GroupMemberRelationSourceId"] = boost::any(*groupMemberRelationSourceId);
    }
    if (groupMemberRelationSourceType) {
      res["GroupMemberRelationSourceType"] = boost::any(*groupMemberRelationSourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMemberRelationSourceId") != m.end() && !m["GroupMemberRelationSourceId"].empty()) {
      groupMemberRelationSourceId = make_shared<string>(boost::any_cast<string>(m["GroupMemberRelationSourceId"]));
    }
    if (m.find("GroupMemberRelationSourceType") != m.end() && !m["GroupMemberRelationSourceType"].empty()) {
      groupMemberRelationSourceType = make_shared<string>(boost::any_cast<string>(m["GroupMemberRelationSourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUsersForGroupResponseBodyUsers() = default;
};
class ListUsersForGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUsersForGroupResponseBodyUsers>> users{};

  ListUsersForGroupResponseBody() {}

  explicit ListUsersForGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ListUsersForGroupResponseBodyUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersForGroupResponseBodyUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListUsersForGroupResponseBodyUsers>>(expect1);
      }
    }
  }


  virtual ~ListUsersForGroupResponseBody() = default;
};
class ListUsersForGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersForGroupResponseBody> body{};

  ListUsersForGroupResponse() {}

  explicit ListUsersForGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersForGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersForGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersForGroupResponse() = default;
};
class ObtainApplicationClientSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> secretId{};

  ObtainApplicationClientSecretRequest() {}

  explicit ObtainApplicationClientSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
  }


  virtual ~ObtainApplicationClientSecretRequest() = default;
};
class ObtainApplicationClientSecretResponseBodyApplicationClientSecret : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUsedTime{};
  shared_ptr<string> secretId{};
  shared_ptr<string> status{};

  ObtainApplicationClientSecretResponseBodyApplicationClientSecret() {}

  explicit ObtainApplicationClientSecretResponseBodyApplicationClientSecret(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUsedTime) {
      res["LastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (secretId) {
      res["SecretId"] = boost::any(*secretId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUsedTime") != m.end() && !m["LastUsedTime"].empty()) {
      lastUsedTime = make_shared<long>(boost::any_cast<long>(m["LastUsedTime"]));
    }
    if (m.find("SecretId") != m.end() && !m["SecretId"].empty()) {
      secretId = make_shared<string>(boost::any_cast<string>(m["SecretId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ObtainApplicationClientSecretResponseBodyApplicationClientSecret() = default;
};
class ObtainApplicationClientSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<ObtainApplicationClientSecretResponseBodyApplicationClientSecret> applicationClientSecret{};
  shared_ptr<string> requestId{};

  ObtainApplicationClientSecretResponseBody() {}

  explicit ObtainApplicationClientSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationClientSecret) {
      res["ApplicationClientSecret"] = applicationClientSecret ? boost::any(applicationClientSecret->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationClientSecret") != m.end() && !m["ApplicationClientSecret"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationClientSecret"].type()) {
        ObtainApplicationClientSecretResponseBodyApplicationClientSecret model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationClientSecret"]));
        applicationClientSecret = make_shared<ObtainApplicationClientSecretResponseBodyApplicationClientSecret>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ObtainApplicationClientSecretResponseBody() = default;
};
class ObtainApplicationClientSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ObtainApplicationClientSecretResponseBody> body{};

  ObtainApplicationClientSecretResponse() {}

  explicit ObtainApplicationClientSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ObtainApplicationClientSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ObtainApplicationClientSecretResponseBody>(model1);
      }
    }
  }


  virtual ~ObtainApplicationClientSecretResponse() = default;
};
class ObtainDomainProxyTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};

  ObtainDomainProxyTokenRequest() {}

  explicit ObtainDomainProxyTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ObtainDomainProxyTokenRequest() = default;
};
class ObtainDomainProxyTokenResponseBodyDomainProxyToken : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> domainId{};
  shared_ptr<string> domainProxyToken{};
  shared_ptr<string> domainProxyTokenId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> lastUsedTime{};
  shared_ptr<string> status{};
  shared_ptr<long> updateTime{};

  ObtainDomainProxyTokenResponseBodyDomainProxyToken() {}

  explicit ObtainDomainProxyTokenResponseBodyDomainProxyToken(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (domainProxyToken) {
      res["DomainProxyToken"] = boost::any(*domainProxyToken);
    }
    if (domainProxyTokenId) {
      res["DomainProxyTokenId"] = boost::any(*domainProxyTokenId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (lastUsedTime) {
      res["LastUsedTime"] = boost::any(*lastUsedTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("DomainProxyToken") != m.end() && !m["DomainProxyToken"].empty()) {
      domainProxyToken = make_shared<string>(boost::any_cast<string>(m["DomainProxyToken"]));
    }
    if (m.find("DomainProxyTokenId") != m.end() && !m["DomainProxyTokenId"].empty()) {
      domainProxyTokenId = make_shared<string>(boost::any_cast<string>(m["DomainProxyTokenId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LastUsedTime") != m.end() && !m["LastUsedTime"].empty()) {
      lastUsedTime = make_shared<long>(boost::any_cast<long>(m["LastUsedTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~ObtainDomainProxyTokenResponseBodyDomainProxyToken() = default;
};
class ObtainDomainProxyTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<ObtainDomainProxyTokenResponseBodyDomainProxyToken> domainProxyToken{};
  shared_ptr<string> requestId{};

  ObtainDomainProxyTokenResponseBody() {}

  explicit ObtainDomainProxyTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainProxyToken) {
      res["DomainProxyToken"] = domainProxyToken ? boost::any(domainProxyToken->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainProxyToken") != m.end() && !m["DomainProxyToken"].empty()) {
      if (typeid(map<string, boost::any>) == m["DomainProxyToken"].type()) {
        ObtainDomainProxyTokenResponseBodyDomainProxyToken model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DomainProxyToken"]));
        domainProxyToken = make_shared<ObtainDomainProxyTokenResponseBodyDomainProxyToken>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ObtainDomainProxyTokenResponseBody() = default;
};
class ObtainDomainProxyTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ObtainDomainProxyTokenResponseBody> body{};

  ObtainDomainProxyTokenResponse() {}

  explicit ObtainDomainProxyTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ObtainDomainProxyTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ObtainDomainProxyTokenResponseBody>(model1);
      }
    }
  }


  virtual ~ObtainDomainProxyTokenResponse() = default;
};
class RemoveUserFromOrganizationalUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<string> userId{};

  RemoveUserFromOrganizationalUnitsRequest() {}

  explicit RemoveUserFromOrganizationalUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemoveUserFromOrganizationalUnitsRequest() = default;
};
class RemoveUserFromOrganizationalUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveUserFromOrganizationalUnitsResponseBody() {}

  explicit RemoveUserFromOrganizationalUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUserFromOrganizationalUnitsResponseBody() = default;
};
class RemoveUserFromOrganizationalUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUserFromOrganizationalUnitsResponseBody> body{};

  RemoveUserFromOrganizationalUnitsResponse() {}

  explicit RemoveUserFromOrganizationalUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUserFromOrganizationalUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUserFromOrganizationalUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUserFromOrganizationalUnitsResponse() = default;
};
class RemoveUsersFromGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userIds{};

  RemoveUsersFromGroupRequest() {}

  explicit RemoveUsersFromGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveUsersFromGroupRequest() = default;
};
class RemoveUsersFromGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveUsersFromGroupResponseBody() {}

  explicit RemoveUsersFromGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUsersFromGroupResponseBody() = default;
};
class RemoveUsersFromGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersFromGroupResponseBody> body{};

  RemoveUsersFromGroupResponse() {}

  explicit RemoveUsersFromGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersFromGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersFromGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersFromGroupResponse() = default;
};
class RevokeApplicationFromGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> instanceId{};

  RevokeApplicationFromGroupsRequest() {}

  explicit RevokeApplicationFromGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RevokeApplicationFromGroupsRequest() = default;
};
class RevokeApplicationFromGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeApplicationFromGroupsResponseBody() {}

  explicit RevokeApplicationFromGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeApplicationFromGroupsResponseBody() = default;
};
class RevokeApplicationFromGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeApplicationFromGroupsResponseBody> body{};

  RevokeApplicationFromGroupsResponse() {}

  explicit RevokeApplicationFromGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeApplicationFromGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeApplicationFromGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeApplicationFromGroupsResponse() = default;
};
class RevokeApplicationFromOrganizationalUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};

  RevokeApplicationFromOrganizationalUnitsRequest() {}

  explicit RevokeApplicationFromOrganizationalUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RevokeApplicationFromOrganizationalUnitsRequest() = default;
};
class RevokeApplicationFromOrganizationalUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeApplicationFromOrganizationalUnitsResponseBody() {}

  explicit RevokeApplicationFromOrganizationalUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeApplicationFromOrganizationalUnitsResponseBody() = default;
};
class RevokeApplicationFromOrganizationalUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeApplicationFromOrganizationalUnitsResponseBody> body{};

  RevokeApplicationFromOrganizationalUnitsResponse() {}

  explicit RevokeApplicationFromOrganizationalUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeApplicationFromOrganizationalUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeApplicationFromOrganizationalUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeApplicationFromOrganizationalUnitsResponse() = default;
};
class RevokeApplicationFromUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> userIds{};

  RevokeApplicationFromUsersRequest() {}

  explicit RevokeApplicationFromUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RevokeApplicationFromUsersRequest() = default;
};
class RevokeApplicationFromUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeApplicationFromUsersResponseBody() {}

  explicit RevokeApplicationFromUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeApplicationFromUsersResponseBody() = default;
};
class RevokeApplicationFromUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeApplicationFromUsersResponseBody> body{};

  RevokeApplicationFromUsersResponse() {}

  explicit RevokeApplicationFromUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeApplicationFromUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeApplicationFromUsersResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeApplicationFromUsersResponse() = default;
};
class RunSynchronizationJobRequestSynchronizationScopeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<vector<string>> organizationalUnitIds{};
  shared_ptr<vector<string>> userIds{};

  RunSynchronizationJobRequestSynchronizationScopeConfig() {}

  explicit RunSynchronizationJobRequestSynchronizationScopeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    if (userIds) {
      res["UserIds"] = boost::any(*userIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIds") != m.end() && !m["UserIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunSynchronizationJobRequestSynchronizationScopeConfig() = default;
};
class RunSynchronizationJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> passwordInitialization{};
  shared_ptr<RunSynchronizationJobRequestSynchronizationScopeConfig> synchronizationScopeConfig{};
  shared_ptr<string> targetId{};
  shared_ptr<string> targetType{};
  shared_ptr<vector<string>> userIdentityTypes{};

  RunSynchronizationJobRequest() {}

  explicit RunSynchronizationJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passwordInitialization) {
      res["PasswordInitialization"] = boost::any(*passwordInitialization);
    }
    if (synchronizationScopeConfig) {
      res["SynchronizationScopeConfig"] = synchronizationScopeConfig ? boost::any(synchronizationScopeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetId) {
      res["TargetId"] = boost::any(*targetId);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (userIdentityTypes) {
      res["UserIdentityTypes"] = boost::any(*userIdentityTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PasswordInitialization") != m.end() && !m["PasswordInitialization"].empty()) {
      passwordInitialization = make_shared<bool>(boost::any_cast<bool>(m["PasswordInitialization"]));
    }
    if (m.find("SynchronizationScopeConfig") != m.end() && !m["SynchronizationScopeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SynchronizationScopeConfig"].type()) {
        RunSynchronizationJobRequestSynchronizationScopeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SynchronizationScopeConfig"]));
        synchronizationScopeConfig = make_shared<RunSynchronizationJobRequestSynchronizationScopeConfig>(model1);
      }
    }
    if (m.find("TargetId") != m.end() && !m["TargetId"].empty()) {
      targetId = make_shared<string>(boost::any_cast<string>(m["TargetId"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("UserIdentityTypes") != m.end() && !m["UserIdentityTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdentityTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdentityTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdentityTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RunSynchronizationJobRequest() = default;
};
class RunSynchronizationJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> synchronizationJobId{};

  RunSynchronizationJobResponseBody() {}

  explicit RunSynchronizationJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (synchronizationJobId) {
      res["SynchronizationJobId"] = boost::any(*synchronizationJobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SynchronizationJobId") != m.end() && !m["SynchronizationJobId"].empty()) {
      synchronizationJobId = make_shared<string>(boost::any_cast<string>(m["SynchronizationJobId"]));
    }
  }


  virtual ~RunSynchronizationJobResponseBody() = default;
};
class RunSynchronizationJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunSynchronizationJobResponseBody> body{};

  RunSynchronizationJobResponse() {}

  explicit RunSynchronizationJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunSynchronizationJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunSynchronizationJobResponseBody>(model1);
      }
    }
  }


  virtual ~RunSynchronizationJobResponse() = default;
};
class SetApplicationGrantScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<string> instanceId{};

  SetApplicationGrantScopeRequest() {}

  explicit SetApplicationGrantScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SetApplicationGrantScopeRequest() = default;
};
class SetApplicationGrantScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApplicationGrantScopeResponseBody() {}

  explicit SetApplicationGrantScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApplicationGrantScopeResponseBody() = default;
};
class SetApplicationGrantScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApplicationGrantScopeResponseBody> body{};

  SetApplicationGrantScopeResponse() {}

  explicit SetApplicationGrantScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApplicationGrantScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApplicationGrantScopeResponseBody>(model1);
      }
    }
  }


  virtual ~SetApplicationGrantScopeResponse() = default;
};
class SetApplicationProvisioningConfigRequestCallbackProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<string> callbackUrl{};
  shared_ptr<string> encryptKey{};
  shared_ptr<bool> encryptRequired{};
  shared_ptr<vector<string>> listenEventScopes{};

  SetApplicationProvisioningConfigRequestCallbackProvisioningConfig() {}

  explicit SetApplicationProvisioningConfigRequestCallbackProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callbackUrl) {
      res["CallbackUrl"] = boost::any(*callbackUrl);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (encryptRequired) {
      res["EncryptRequired"] = boost::any(*encryptRequired);
    }
    if (listenEventScopes) {
      res["ListenEventScopes"] = boost::any(*listenEventScopes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallbackUrl") != m.end() && !m["CallbackUrl"].empty()) {
      callbackUrl = make_shared<string>(boost::any_cast<string>(m["CallbackUrl"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("EncryptRequired") != m.end() && !m["EncryptRequired"].empty()) {
      encryptRequired = make_shared<bool>(boost::any_cast<bool>(m["EncryptRequired"]));
    }
    if (m.find("ListenEventScopes") != m.end() && !m["ListenEventScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ListenEventScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ListenEventScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      listenEventScopes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetApplicationProvisioningConfigRequestCallbackProvisioningConfig() = default;
};
class SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> authnMethod{};
  shared_ptr<string> clientId{};
  shared_ptr<string> clientSecret{};
  shared_ptr<string> tokenEndpoint{};

  SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam() {}

  explicit SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (authnMethod) {
      res["AuthnMethod"] = boost::any(*authnMethod);
    }
    if (clientId) {
      res["ClientId"] = boost::any(*clientId);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    if (tokenEndpoint) {
      res["TokenEndpoint"] = boost::any(*tokenEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AuthnMethod") != m.end() && !m["AuthnMethod"].empty()) {
      authnMethod = make_shared<string>(boost::any_cast<string>(m["AuthnMethod"]));
    }
    if (m.find("ClientId") != m.end() && !m["ClientId"].empty()) {
      clientId = make_shared<string>(boost::any_cast<string>(m["ClientId"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
    if (m.find("TokenEndpoint") != m.end() && !m["TokenEndpoint"].empty()) {
      tokenEndpoint = make_shared<string>(boost::any_cast<string>(m["TokenEndpoint"]));
    }
  }


  virtual ~SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam() = default;
};
class SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration : public Darabonba::Model {
public:
  shared_ptr<string> authnMode{};
  shared_ptr<SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam> authnParam{};
  shared_ptr<string> grantType{};

  SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration() {}

  explicit SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnMode) {
      res["AuthnMode"] = boost::any(*authnMode);
    }
    if (authnParam) {
      res["AuthnParam"] = authnParam ? boost::any(authnParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnMode") != m.end() && !m["AuthnMode"].empty()) {
      authnMode = make_shared<string>(boost::any_cast<string>(m["AuthnMode"]));
    }
    if (m.find("AuthnParam") != m.end() && !m["AuthnParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnParam"].type()) {
        SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnParam"]));
        authnParam = make_shared<SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfigurationAuthnParam>(model1);
      }
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
  }


  virtual ~SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration() = default;
};
class SetApplicationProvisioningConfigRequestScimProvisioningConfig : public Darabonba::Model {
public:
  shared_ptr<SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration> authnConfiguration{};
  shared_ptr<vector<string>> fullPushScopes{};
  shared_ptr<vector<string>> provisioningActions{};
  shared_ptr<string> scimBaseUrl{};

  SetApplicationProvisioningConfigRequestScimProvisioningConfig() {}

  explicit SetApplicationProvisioningConfigRequestScimProvisioningConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnConfiguration) {
      res["AuthnConfiguration"] = authnConfiguration ? boost::any(authnConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullPushScopes) {
      res["FullPushScopes"] = boost::any(*fullPushScopes);
    }
    if (provisioningActions) {
      res["ProvisioningActions"] = boost::any(*provisioningActions);
    }
    if (scimBaseUrl) {
      res["ScimBaseUrl"] = boost::any(*scimBaseUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnConfiguration") != m.end() && !m["AuthnConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnConfiguration"].type()) {
        SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnConfiguration"]));
        authnConfiguration = make_shared<SetApplicationProvisioningConfigRequestScimProvisioningConfigAuthnConfiguration>(model1);
      }
    }
    if (m.find("FullPushScopes") != m.end() && !m["FullPushScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FullPushScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FullPushScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fullPushScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProvisioningActions") != m.end() && !m["ProvisioningActions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProvisioningActions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProvisioningActions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      provisioningActions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScimBaseUrl") != m.end() && !m["ScimBaseUrl"].empty()) {
      scimBaseUrl = make_shared<string>(boost::any_cast<string>(m["ScimBaseUrl"]));
    }
  }


  virtual ~SetApplicationProvisioningConfigRequestScimProvisioningConfig() = default;
};
class SetApplicationProvisioningConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<SetApplicationProvisioningConfigRequestCallbackProvisioningConfig> callbackProvisioningConfig{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> provisionPassword{};
  shared_ptr<string> provisionProtocolType{};
  shared_ptr<SetApplicationProvisioningConfigRequestScimProvisioningConfig> scimProvisioningConfig{};

  SetApplicationProvisioningConfigRequest() {}

  explicit SetApplicationProvisioningConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (callbackProvisioningConfig) {
      res["CallbackProvisioningConfig"] = callbackProvisioningConfig ? boost::any(callbackProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (provisionPassword) {
      res["ProvisionPassword"] = boost::any(*provisionPassword);
    }
    if (provisionProtocolType) {
      res["ProvisionProtocolType"] = boost::any(*provisionProtocolType);
    }
    if (scimProvisioningConfig) {
      res["ScimProvisioningConfig"] = scimProvisioningConfig ? boost::any(scimProvisioningConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("CallbackProvisioningConfig") != m.end() && !m["CallbackProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallbackProvisioningConfig"].type()) {
        SetApplicationProvisioningConfigRequestCallbackProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallbackProvisioningConfig"]));
        callbackProvisioningConfig = make_shared<SetApplicationProvisioningConfigRequestCallbackProvisioningConfig>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ProvisionPassword") != m.end() && !m["ProvisionPassword"].empty()) {
      provisionPassword = make_shared<bool>(boost::any_cast<bool>(m["ProvisionPassword"]));
    }
    if (m.find("ProvisionProtocolType") != m.end() && !m["ProvisionProtocolType"].empty()) {
      provisionProtocolType = make_shared<string>(boost::any_cast<string>(m["ProvisionProtocolType"]));
    }
    if (m.find("ScimProvisioningConfig") != m.end() && !m["ScimProvisioningConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScimProvisioningConfig"].type()) {
        SetApplicationProvisioningConfigRequestScimProvisioningConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScimProvisioningConfig"]));
        scimProvisioningConfig = make_shared<SetApplicationProvisioningConfigRequestScimProvisioningConfig>(model1);
      }
    }
  }


  virtual ~SetApplicationProvisioningConfigRequest() = default;
};
class SetApplicationProvisioningConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApplicationProvisioningConfigResponseBody() {}

  explicit SetApplicationProvisioningConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApplicationProvisioningConfigResponseBody() = default;
};
class SetApplicationProvisioningConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApplicationProvisioningConfigResponseBody> body{};

  SetApplicationProvisioningConfigResponse() {}

  explicit SetApplicationProvisioningConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApplicationProvisioningConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApplicationProvisioningConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetApplicationProvisioningConfigResponse() = default;
};
class SetApplicationProvisioningScopeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<vector<string>> groupIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<string>> organizationalUnitIds{};

  SetApplicationProvisioningScopeRequest() {}

  explicit SetApplicationProvisioningScopeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (groupIds) {
      res["GroupIds"] = boost::any(*groupIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitIds) {
      res["OrganizationalUnitIds"] = boost::any(*organizationalUnitIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("GroupIds") != m.end() && !m["GroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      groupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitIds") != m.end() && !m["OrganizationalUnitIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrganizationalUnitIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrganizationalUnitIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      organizationalUnitIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SetApplicationProvisioningScopeRequest() = default;
};
class SetApplicationProvisioningScopeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApplicationProvisioningScopeResponseBody() {}

  explicit SetApplicationProvisioningScopeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApplicationProvisioningScopeResponseBody() = default;
};
class SetApplicationProvisioningScopeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApplicationProvisioningScopeResponseBody> body{};

  SetApplicationProvisioningScopeResponse() {}

  explicit SetApplicationProvisioningScopeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApplicationProvisioningScopeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApplicationProvisioningScopeResponseBody>(model1);
      }
    }
  }


  virtual ~SetApplicationProvisioningScopeResponse() = default;
};
class SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims : public Darabonba::Model {
public:
  shared_ptr<string> claimName{};
  shared_ptr<string> claimValueExpression{};

  SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims() {}

  explicit SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (claimName) {
      res["ClaimName"] = boost::any(*claimName);
    }
    if (claimValueExpression) {
      res["ClaimValueExpression"] = boost::any(*claimValueExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClaimName") != m.end() && !m["ClaimName"].empty()) {
      claimName = make_shared<string>(boost::any_cast<string>(m["ClaimName"]));
    }
    if (m.find("ClaimValueExpression") != m.end() && !m["ClaimValueExpression"].empty()) {
      claimValueExpression = make_shared<string>(boost::any_cast<string>(m["ClaimValueExpression"]));
    }
  }


  virtual ~SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims() = default;
};
class SetApplicationSsoConfigRequestOidcSsoConfig : public Darabonba::Model {
public:
  shared_ptr<long> accessTokenEffectiveTime{};
  shared_ptr<long> codeEffectiveTime{};
  shared_ptr<vector<SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims>> customClaims{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<vector<string>> grantTypes{};
  shared_ptr<long> idTokenEffectiveTime{};
  shared_ptr<string> passwordAuthenticationSourceId{};
  shared_ptr<bool> passwordTotpMfaRequired{};
  shared_ptr<vector<string>> pkceChallengeMethods{};
  shared_ptr<bool> pkceRequired{};
  shared_ptr<vector<string>> postLogoutRedirectUris{};
  shared_ptr<vector<string>> redirectUris{};
  shared_ptr<long> refreshTokenEffective{};
  shared_ptr<vector<string>> responseTypes{};
  shared_ptr<string> subjectIdExpression{};

  SetApplicationSsoConfigRequestOidcSsoConfig() {}

  explicit SetApplicationSsoConfigRequestOidcSsoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTokenEffectiveTime) {
      res["AccessTokenEffectiveTime"] = boost::any(*accessTokenEffectiveTime);
    }
    if (codeEffectiveTime) {
      res["CodeEffectiveTime"] = boost::any(*codeEffectiveTime);
    }
    if (customClaims) {
      vector<boost::any> temp1;
      for(auto item1:*customClaims){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomClaims"] = boost::any(temp1);
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (grantTypes) {
      res["GrantTypes"] = boost::any(*grantTypes);
    }
    if (idTokenEffectiveTime) {
      res["IdTokenEffectiveTime"] = boost::any(*idTokenEffectiveTime);
    }
    if (passwordAuthenticationSourceId) {
      res["PasswordAuthenticationSourceId"] = boost::any(*passwordAuthenticationSourceId);
    }
    if (passwordTotpMfaRequired) {
      res["PasswordTotpMfaRequired"] = boost::any(*passwordTotpMfaRequired);
    }
    if (pkceChallengeMethods) {
      res["PkceChallengeMethods"] = boost::any(*pkceChallengeMethods);
    }
    if (pkceRequired) {
      res["PkceRequired"] = boost::any(*pkceRequired);
    }
    if (postLogoutRedirectUris) {
      res["PostLogoutRedirectUris"] = boost::any(*postLogoutRedirectUris);
    }
    if (redirectUris) {
      res["RedirectUris"] = boost::any(*redirectUris);
    }
    if (refreshTokenEffective) {
      res["RefreshTokenEffective"] = boost::any(*refreshTokenEffective);
    }
    if (responseTypes) {
      res["ResponseTypes"] = boost::any(*responseTypes);
    }
    if (subjectIdExpression) {
      res["SubjectIdExpression"] = boost::any(*subjectIdExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTokenEffectiveTime") != m.end() && !m["AccessTokenEffectiveTime"].empty()) {
      accessTokenEffectiveTime = make_shared<long>(boost::any_cast<long>(m["AccessTokenEffectiveTime"]));
    }
    if (m.find("CodeEffectiveTime") != m.end() && !m["CodeEffectiveTime"].empty()) {
      codeEffectiveTime = make_shared<long>(boost::any_cast<long>(m["CodeEffectiveTime"]));
    }
    if (m.find("CustomClaims") != m.end() && !m["CustomClaims"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomClaims"].type()) {
        vector<SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomClaims"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customClaims = make_shared<vector<SetApplicationSsoConfigRequestOidcSsoConfigCustomClaims>>(expect1);
      }
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GrantTypes") != m.end() && !m["GrantTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IdTokenEffectiveTime") != m.end() && !m["IdTokenEffectiveTime"].empty()) {
      idTokenEffectiveTime = make_shared<long>(boost::any_cast<long>(m["IdTokenEffectiveTime"]));
    }
    if (m.find("PasswordAuthenticationSourceId") != m.end() && !m["PasswordAuthenticationSourceId"].empty()) {
      passwordAuthenticationSourceId = make_shared<string>(boost::any_cast<string>(m["PasswordAuthenticationSourceId"]));
    }
    if (m.find("PasswordTotpMfaRequired") != m.end() && !m["PasswordTotpMfaRequired"].empty()) {
      passwordTotpMfaRequired = make_shared<bool>(boost::any_cast<bool>(m["PasswordTotpMfaRequired"]));
    }
    if (m.find("PkceChallengeMethods") != m.end() && !m["PkceChallengeMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PkceChallengeMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PkceChallengeMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pkceChallengeMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PkceRequired") != m.end() && !m["PkceRequired"].empty()) {
      pkceRequired = make_shared<bool>(boost::any_cast<bool>(m["PkceRequired"]));
    }
    if (m.find("PostLogoutRedirectUris") != m.end() && !m["PostLogoutRedirectUris"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PostLogoutRedirectUris"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PostLogoutRedirectUris"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      postLogoutRedirectUris = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RedirectUris") != m.end() && !m["RedirectUris"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RedirectUris"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RedirectUris"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      redirectUris = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RefreshTokenEffective") != m.end() && !m["RefreshTokenEffective"].empty()) {
      refreshTokenEffective = make_shared<long>(boost::any_cast<long>(m["RefreshTokenEffective"]));
    }
    if (m.find("ResponseTypes") != m.end() && !m["ResponseTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResponseTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResponseTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      responseTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubjectIdExpression") != m.end() && !m["SubjectIdExpression"].empty()) {
      subjectIdExpression = make_shared<string>(boost::any_cast<string>(m["SubjectIdExpression"]));
    }
  }


  virtual ~SetApplicationSsoConfigRequestOidcSsoConfig() = default;
};
class SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements : public Darabonba::Model {
public:
  shared_ptr<string> attributeName{};
  shared_ptr<string> attributeValueExpression{};

  SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements() {}

  explicit SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attributeName) {
      res["AttributeName"] = boost::any(*attributeName);
    }
    if (attributeValueExpression) {
      res["AttributeValueExpression"] = boost::any(*attributeValueExpression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AttributeName") != m.end() && !m["AttributeName"].empty()) {
      attributeName = make_shared<string>(boost::any_cast<string>(m["AttributeName"]));
    }
    if (m.find("AttributeValueExpression") != m.end() && !m["AttributeValueExpression"].empty()) {
      attributeValueExpression = make_shared<string>(boost::any_cast<string>(m["AttributeValueExpression"]));
    }
  }


  virtual ~SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements() = default;
};
class SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> relayState{};

  SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates() {}

  explicit SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (relayState) {
      res["RelayState"] = boost::any(*relayState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("RelayState") != m.end() && !m["RelayState"].empty()) {
      relayState = make_shared<string>(boost::any_cast<string>(m["RelayState"]));
    }
  }


  virtual ~SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates() = default;
};
class SetApplicationSsoConfigRequestSamlSsoConfig : public Darabonba::Model {
public:
  shared_ptr<bool> assertionSigned{};
  shared_ptr<vector<SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements>> attributeStatements{};
  shared_ptr<string> defaultRelayState{};
  shared_ptr<string> idPEntityId{};
  shared_ptr<string> nameIdFormat{};
  shared_ptr<string> nameIdValueExpression{};
  shared_ptr<vector<SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates>> optionalRelayStates{};
  shared_ptr<bool> responseSigned{};
  shared_ptr<string> signatureAlgorithm{};
  shared_ptr<string> spEntityId{};
  shared_ptr<string> spSsoAcsUrl{};

  SetApplicationSsoConfigRequestSamlSsoConfig() {}

  explicit SetApplicationSsoConfigRequestSamlSsoConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assertionSigned) {
      res["AssertionSigned"] = boost::any(*assertionSigned);
    }
    if (attributeStatements) {
      vector<boost::any> temp1;
      for(auto item1:*attributeStatements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AttributeStatements"] = boost::any(temp1);
    }
    if (defaultRelayState) {
      res["DefaultRelayState"] = boost::any(*defaultRelayState);
    }
    if (idPEntityId) {
      res["IdPEntityId"] = boost::any(*idPEntityId);
    }
    if (nameIdFormat) {
      res["NameIdFormat"] = boost::any(*nameIdFormat);
    }
    if (nameIdValueExpression) {
      res["NameIdValueExpression"] = boost::any(*nameIdValueExpression);
    }
    if (optionalRelayStates) {
      vector<boost::any> temp1;
      for(auto item1:*optionalRelayStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OptionalRelayStates"] = boost::any(temp1);
    }
    if (responseSigned) {
      res["ResponseSigned"] = boost::any(*responseSigned);
    }
    if (signatureAlgorithm) {
      res["SignatureAlgorithm"] = boost::any(*signatureAlgorithm);
    }
    if (spEntityId) {
      res["SpEntityId"] = boost::any(*spEntityId);
    }
    if (spSsoAcsUrl) {
      res["SpSsoAcsUrl"] = boost::any(*spSsoAcsUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssertionSigned") != m.end() && !m["AssertionSigned"].empty()) {
      assertionSigned = make_shared<bool>(boost::any_cast<bool>(m["AssertionSigned"]));
    }
    if (m.find("AttributeStatements") != m.end() && !m["AttributeStatements"].empty()) {
      if (typeid(vector<boost::any>) == m["AttributeStatements"].type()) {
        vector<SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AttributeStatements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        attributeStatements = make_shared<vector<SetApplicationSsoConfigRequestSamlSsoConfigAttributeStatements>>(expect1);
      }
    }
    if (m.find("DefaultRelayState") != m.end() && !m["DefaultRelayState"].empty()) {
      defaultRelayState = make_shared<string>(boost::any_cast<string>(m["DefaultRelayState"]));
    }
    if (m.find("IdPEntityId") != m.end() && !m["IdPEntityId"].empty()) {
      idPEntityId = make_shared<string>(boost::any_cast<string>(m["IdPEntityId"]));
    }
    if (m.find("NameIdFormat") != m.end() && !m["NameIdFormat"].empty()) {
      nameIdFormat = make_shared<string>(boost::any_cast<string>(m["NameIdFormat"]));
    }
    if (m.find("NameIdValueExpression") != m.end() && !m["NameIdValueExpression"].empty()) {
      nameIdValueExpression = make_shared<string>(boost::any_cast<string>(m["NameIdValueExpression"]));
    }
    if (m.find("OptionalRelayStates") != m.end() && !m["OptionalRelayStates"].empty()) {
      if (typeid(vector<boost::any>) == m["OptionalRelayStates"].type()) {
        vector<SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OptionalRelayStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        optionalRelayStates = make_shared<vector<SetApplicationSsoConfigRequestSamlSsoConfigOptionalRelayStates>>(expect1);
      }
    }
    if (m.find("ResponseSigned") != m.end() && !m["ResponseSigned"].empty()) {
      responseSigned = make_shared<bool>(boost::any_cast<bool>(m["ResponseSigned"]));
    }
    if (m.find("SignatureAlgorithm") != m.end() && !m["SignatureAlgorithm"].empty()) {
      signatureAlgorithm = make_shared<string>(boost::any_cast<string>(m["SignatureAlgorithm"]));
    }
    if (m.find("SpEntityId") != m.end() && !m["SpEntityId"].empty()) {
      spEntityId = make_shared<string>(boost::any_cast<string>(m["SpEntityId"]));
    }
    if (m.find("SpSsoAcsUrl") != m.end() && !m["SpSsoAcsUrl"].empty()) {
      spSsoAcsUrl = make_shared<string>(boost::any_cast<string>(m["SpSsoAcsUrl"]));
    }
  }


  virtual ~SetApplicationSsoConfigRequestSamlSsoConfig() = default;
};
class SetApplicationSsoConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> initLoginType{};
  shared_ptr<string> initLoginUrl{};
  shared_ptr<string> instanceId{};
  shared_ptr<SetApplicationSsoConfigRequestOidcSsoConfig> oidcSsoConfig{};
  shared_ptr<SetApplicationSsoConfigRequestSamlSsoConfig> samlSsoConfig{};

  SetApplicationSsoConfigRequest() {}

  explicit SetApplicationSsoConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (initLoginType) {
      res["InitLoginType"] = boost::any(*initLoginType);
    }
    if (initLoginUrl) {
      res["InitLoginUrl"] = boost::any(*initLoginUrl);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (oidcSsoConfig) {
      res["OidcSsoConfig"] = oidcSsoConfig ? boost::any(oidcSsoConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (samlSsoConfig) {
      res["SamlSsoConfig"] = samlSsoConfig ? boost::any(samlSsoConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InitLoginType") != m.end() && !m["InitLoginType"].empty()) {
      initLoginType = make_shared<string>(boost::any_cast<string>(m["InitLoginType"]));
    }
    if (m.find("InitLoginUrl") != m.end() && !m["InitLoginUrl"].empty()) {
      initLoginUrl = make_shared<string>(boost::any_cast<string>(m["InitLoginUrl"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OidcSsoConfig") != m.end() && !m["OidcSsoConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OidcSsoConfig"].type()) {
        SetApplicationSsoConfigRequestOidcSsoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OidcSsoConfig"]));
        oidcSsoConfig = make_shared<SetApplicationSsoConfigRequestOidcSsoConfig>(model1);
      }
    }
    if (m.find("SamlSsoConfig") != m.end() && !m["SamlSsoConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["SamlSsoConfig"].type()) {
        SetApplicationSsoConfigRequestSamlSsoConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SamlSsoConfig"]));
        samlSsoConfig = make_shared<SetApplicationSsoConfigRequestSamlSsoConfig>(model1);
      }
    }
  }


  virtual ~SetApplicationSsoConfigRequest() = default;
};
class SetApplicationSsoConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApplicationSsoConfigResponseBody() {}

  explicit SetApplicationSsoConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApplicationSsoConfigResponseBody() = default;
};
class SetApplicationSsoConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApplicationSsoConfigResponseBody> body{};

  SetApplicationSsoConfigResponse() {}

  explicit SetApplicationSsoConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApplicationSsoConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApplicationSsoConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SetApplicationSsoConfigResponse() = default;
};
class SetDefaultDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainId{};
  shared_ptr<string> instanceId{};

  SetDefaultDomainRequest() {}

  explicit SetDefaultDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainId) {
      res["DomainId"] = boost::any(*domainId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainId") != m.end() && !m["DomainId"].empty()) {
      domainId = make_shared<string>(boost::any_cast<string>(m["DomainId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SetDefaultDomainRequest() = default;
};
class SetDefaultDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDefaultDomainResponseBody() {}

  explicit SetDefaultDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDefaultDomainResponseBody() = default;
};
class SetDefaultDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDefaultDomainResponseBody> body{};

  SetDefaultDomainResponse() {}

  explicit SetDefaultDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDefaultDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDefaultDomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetDefaultDomainResponse() = default;
};
class SetForgetPasswordConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> authenticationChannels{};
  shared_ptr<string> forgetPasswordStatus{};
  shared_ptr<string> instanceId{};

  SetForgetPasswordConfigurationRequest() {}

  explicit SetForgetPasswordConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authenticationChannels) {
      res["AuthenticationChannels"] = boost::any(*authenticationChannels);
    }
    if (forgetPasswordStatus) {
      res["ForgetPasswordStatus"] = boost::any(*forgetPasswordStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthenticationChannels") != m.end() && !m["AuthenticationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AuthenticationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AuthenticationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      authenticationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ForgetPasswordStatus") != m.end() && !m["ForgetPasswordStatus"].empty()) {
      forgetPasswordStatus = make_shared<string>(boost::any_cast<string>(m["ForgetPasswordStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SetForgetPasswordConfigurationRequest() = default;
};
class SetForgetPasswordConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetForgetPasswordConfigurationResponseBody() {}

  explicit SetForgetPasswordConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetForgetPasswordConfigurationResponseBody() = default;
};
class SetForgetPasswordConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetForgetPasswordConfigurationResponseBody> body{};

  SetForgetPasswordConfigurationResponse() {}

  explicit SetForgetPasswordConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetForgetPasswordConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetForgetPasswordConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetForgetPasswordConfigurationResponse() = default;
};
class SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig : public Darabonba::Model {
public:
  shared_ptr<string> groupMemberAttributeName{};
  shared_ptr<string> groupObjectClass{};
  shared_ptr<string> groupObjectClassCustomFilter{};
  shared_ptr<string> organizationUnitObjectClass{};
  shared_ptr<string> userObjectClass{};
  shared_ptr<string> userObjectClassCustomFilter{};

  SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig() {}

  explicit SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupMemberAttributeName) {
      res["GroupMemberAttributeName"] = boost::any(*groupMemberAttributeName);
    }
    if (groupObjectClass) {
      res["GroupObjectClass"] = boost::any(*groupObjectClass);
    }
    if (groupObjectClassCustomFilter) {
      res["GroupObjectClassCustomFilter"] = boost::any(*groupObjectClassCustomFilter);
    }
    if (organizationUnitObjectClass) {
      res["OrganizationUnitObjectClass"] = boost::any(*organizationUnitObjectClass);
    }
    if (userObjectClass) {
      res["UserObjectClass"] = boost::any(*userObjectClass);
    }
    if (userObjectClassCustomFilter) {
      res["UserObjectClassCustomFilter"] = boost::any(*userObjectClassCustomFilter);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupMemberAttributeName") != m.end() && !m["GroupMemberAttributeName"].empty()) {
      groupMemberAttributeName = make_shared<string>(boost::any_cast<string>(m["GroupMemberAttributeName"]));
    }
    if (m.find("GroupObjectClass") != m.end() && !m["GroupObjectClass"].empty()) {
      groupObjectClass = make_shared<string>(boost::any_cast<string>(m["GroupObjectClass"]));
    }
    if (m.find("GroupObjectClassCustomFilter") != m.end() && !m["GroupObjectClassCustomFilter"].empty()) {
      groupObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["GroupObjectClassCustomFilter"]));
    }
    if (m.find("OrganizationUnitObjectClass") != m.end() && !m["OrganizationUnitObjectClass"].empty()) {
      organizationUnitObjectClass = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitObjectClass"]));
    }
    if (m.find("UserObjectClass") != m.end() && !m["UserObjectClass"].empty()) {
      userObjectClass = make_shared<string>(boost::any_cast<string>(m["UserObjectClass"]));
    }
    if (m.find("UserObjectClassCustomFilter") != m.end() && !m["UserObjectClassCustomFilter"].empty()) {
      userObjectClassCustomFilter = make_shared<string>(boost::any_cast<string>(m["UserObjectClassCustomFilter"]));
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig() = default;
};
class SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig : public Darabonba::Model {
public:
  shared_ptr<string> periodicSyncCron{};
  shared_ptr<vector<long>> periodicSyncTimes{};
  shared_ptr<string> periodicSyncType{};

  SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig() {}

  explicit SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodicSyncCron) {
      res["PeriodicSyncCron"] = boost::any(*periodicSyncCron);
    }
    if (periodicSyncTimes) {
      res["PeriodicSyncTimes"] = boost::any(*periodicSyncTimes);
    }
    if (periodicSyncType) {
      res["PeriodicSyncType"] = boost::any(*periodicSyncType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodicSyncCron") != m.end() && !m["PeriodicSyncCron"].empty()) {
      periodicSyncCron = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncCron"]));
    }
    if (m.find("PeriodicSyncTimes") != m.end() && !m["PeriodicSyncTimes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PeriodicSyncTimes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PeriodicSyncTimes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      periodicSyncTimes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PeriodicSyncType") != m.end() && !m["PeriodicSyncType"].empty()) {
      periodicSyncType = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncType"]));
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig() = default;
};
class SetIdentityProviderUdPullConfigurationRequestPullProtectedRule : public Darabonba::Model {
public:
  shared_ptr<long> groupDeletedThreshold{};
  shared_ptr<long> organizationalUnitDeletedThreshold{};
  shared_ptr<long> userDeletedThreshold{};

  SetIdentityProviderUdPullConfigurationRequestPullProtectedRule() {}

  explicit SetIdentityProviderUdPullConfigurationRequestPullProtectedRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupDeletedThreshold) {
      res["GroupDeletedThreshold"] = boost::any(*groupDeletedThreshold);
    }
    if (organizationalUnitDeletedThreshold) {
      res["OrganizationalUnitDeletedThreshold"] = boost::any(*organizationalUnitDeletedThreshold);
    }
    if (userDeletedThreshold) {
      res["UserDeletedThreshold"] = boost::any(*userDeletedThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupDeletedThreshold") != m.end() && !m["GroupDeletedThreshold"].empty()) {
      groupDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["GroupDeletedThreshold"]));
    }
    if (m.find("OrganizationalUnitDeletedThreshold") != m.end() && !m["OrganizationalUnitDeletedThreshold"].empty()) {
      organizationalUnitDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["OrganizationalUnitDeletedThreshold"]));
    }
    if (m.find("UserDeletedThreshold") != m.end() && !m["UserDeletedThreshold"].empty()) {
      userDeletedThreshold = make_shared<long>(boost::any_cast<long>(m["UserDeletedThreshold"]));
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationRequestPullProtectedRule() = default;
};
class SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sourceScopes{};
  shared_ptr<string> targetScope{};

  SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig() {}

  explicit SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceScopes) {
      res["SourceScopes"] = boost::any(*sourceScopes);
    }
    if (targetScope) {
      res["TargetScope"] = boost::any(*targetScope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceScopes") != m.end() && !m["SourceScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TargetScope") != m.end() && !m["TargetScope"].empty()) {
      targetScope = make_shared<string>(boost::any_cast<string>(m["TargetScope"]));
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig() = default;
};
class SetIdentityProviderUdPullConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupSyncStatus{};
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> incrementalCallbackStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig> ldapUdPullConfig{};
  shared_ptr<SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig> periodicSyncConfig{};
  shared_ptr<string> periodicSyncStatus{};
  shared_ptr<SetIdentityProviderUdPullConfigurationRequestPullProtectedRule> pullProtectedRule{};
  shared_ptr<SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig> udSyncScopeConfig{};

  SetIdentityProviderUdPullConfigurationRequest() {}

  explicit SetIdentityProviderUdPullConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupSyncStatus) {
      res["GroupSyncStatus"] = boost::any(*groupSyncStatus);
    }
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (incrementalCallbackStatus) {
      res["IncrementalCallbackStatus"] = boost::any(*incrementalCallbackStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ldapUdPullConfig) {
      res["LdapUdPullConfig"] = ldapUdPullConfig ? boost::any(ldapUdPullConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodicSyncConfig) {
      res["PeriodicSyncConfig"] = periodicSyncConfig ? boost::any(periodicSyncConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (periodicSyncStatus) {
      res["PeriodicSyncStatus"] = boost::any(*periodicSyncStatus);
    }
    if (pullProtectedRule) {
      res["PullProtectedRule"] = pullProtectedRule ? boost::any(pullProtectedRule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (udSyncScopeConfig) {
      res["UdSyncScopeConfig"] = udSyncScopeConfig ? boost::any(udSyncScopeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupSyncStatus") != m.end() && !m["GroupSyncStatus"].empty()) {
      groupSyncStatus = make_shared<string>(boost::any_cast<string>(m["GroupSyncStatus"]));
    }
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("IncrementalCallbackStatus") != m.end() && !m["IncrementalCallbackStatus"].empty()) {
      incrementalCallbackStatus = make_shared<string>(boost::any_cast<string>(m["IncrementalCallbackStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LdapUdPullConfig") != m.end() && !m["LdapUdPullConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LdapUdPullConfig"].type()) {
        SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LdapUdPullConfig"]));
        ldapUdPullConfig = make_shared<SetIdentityProviderUdPullConfigurationRequestLdapUdPullConfig>(model1);
      }
    }
    if (m.find("PeriodicSyncConfig") != m.end() && !m["PeriodicSyncConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PeriodicSyncConfig"].type()) {
        SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PeriodicSyncConfig"]));
        periodicSyncConfig = make_shared<SetIdentityProviderUdPullConfigurationRequestPeriodicSyncConfig>(model1);
      }
    }
    if (m.find("PeriodicSyncStatus") != m.end() && !m["PeriodicSyncStatus"].empty()) {
      periodicSyncStatus = make_shared<string>(boost::any_cast<string>(m["PeriodicSyncStatus"]));
    }
    if (m.find("PullProtectedRule") != m.end() && !m["PullProtectedRule"].empty()) {
      if (typeid(map<string, boost::any>) == m["PullProtectedRule"].type()) {
        SetIdentityProviderUdPullConfigurationRequestPullProtectedRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PullProtectedRule"]));
        pullProtectedRule = make_shared<SetIdentityProviderUdPullConfigurationRequestPullProtectedRule>(model1);
      }
    }
    if (m.find("UdSyncScopeConfig") != m.end() && !m["UdSyncScopeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UdSyncScopeConfig"].type()) {
        SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UdSyncScopeConfig"]));
        udSyncScopeConfig = make_shared<SetIdentityProviderUdPullConfigurationRequestUdSyncScopeConfig>(model1);
      }
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationRequest() = default;
};
class SetIdentityProviderUdPullConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetIdentityProviderUdPullConfigurationResponseBody() {}

  explicit SetIdentityProviderUdPullConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationResponseBody() = default;
};
class SetIdentityProviderUdPullConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetIdentityProviderUdPullConfigurationResponseBody> body{};

  SetIdentityProviderUdPullConfigurationResponse() {}

  explicit SetIdentityProviderUdPullConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetIdentityProviderUdPullConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetIdentityProviderUdPullConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetIdentityProviderUdPullConfigurationResponse() = default;
};
class SetPasswordComplexityConfigurationRequestPasswordComplexityRules : public Darabonba::Model {
public:
  shared_ptr<string> passwordCheckType{};

  SetPasswordComplexityConfigurationRequestPasswordComplexityRules() {}

  explicit SetPasswordComplexityConfigurationRequestPasswordComplexityRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (passwordCheckType) {
      res["PasswordCheckType"] = boost::any(*passwordCheckType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PasswordCheckType") != m.end() && !m["PasswordCheckType"].empty()) {
      passwordCheckType = make_shared<string>(boost::any_cast<string>(m["PasswordCheckType"]));
    }
  }


  virtual ~SetPasswordComplexityConfigurationRequestPasswordComplexityRules() = default;
};
class SetPasswordComplexityConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<SetPasswordComplexityConfigurationRequestPasswordComplexityRules>> passwordComplexityRules{};
  shared_ptr<long> passwordMinLength{};

  SetPasswordComplexityConfigurationRequest() {}

  explicit SetPasswordComplexityConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passwordComplexityRules) {
      vector<boost::any> temp1;
      for(auto item1:*passwordComplexityRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PasswordComplexityRules"] = boost::any(temp1);
    }
    if (passwordMinLength) {
      res["PasswordMinLength"] = boost::any(*passwordMinLength);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PasswordComplexityRules") != m.end() && !m["PasswordComplexityRules"].empty()) {
      if (typeid(vector<boost::any>) == m["PasswordComplexityRules"].type()) {
        vector<SetPasswordComplexityConfigurationRequestPasswordComplexityRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PasswordComplexityRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetPasswordComplexityConfigurationRequestPasswordComplexityRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        passwordComplexityRules = make_shared<vector<SetPasswordComplexityConfigurationRequestPasswordComplexityRules>>(expect1);
      }
    }
    if (m.find("PasswordMinLength") != m.end() && !m["PasswordMinLength"].empty()) {
      passwordMinLength = make_shared<long>(boost::any_cast<long>(m["PasswordMinLength"]));
    }
  }


  virtual ~SetPasswordComplexityConfigurationRequest() = default;
};
class SetPasswordComplexityConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPasswordComplexityConfigurationResponseBody() {}

  explicit SetPasswordComplexityConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPasswordComplexityConfigurationResponseBody() = default;
};
class SetPasswordComplexityConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPasswordComplexityConfigurationResponseBody> body{};

  SetPasswordComplexityConfigurationResponse() {}

  explicit SetPasswordComplexityConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPasswordComplexityConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPasswordComplexityConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetPasswordComplexityConfigurationResponse() = default;
};
class SetPasswordExpirationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> effectiveAuthenticationSourceIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> passwordExpirationAction{};
  shared_ptr<vector<string>> passwordExpirationNotificationChannels{};
  shared_ptr<long> passwordExpirationNotificationDuration{};
  shared_ptr<string> passwordExpirationNotificationStatus{};
  shared_ptr<string> passwordExpirationStatus{};
  shared_ptr<long> passwordForcedUpdateDuration{};
  shared_ptr<long> passwordValidMaxDay{};

  SetPasswordExpirationConfigurationRequest() {}

  explicit SetPasswordExpirationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveAuthenticationSourceIds) {
      res["EffectiveAuthenticationSourceIds"] = boost::any(*effectiveAuthenticationSourceIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passwordExpirationAction) {
      res["PasswordExpirationAction"] = boost::any(*passwordExpirationAction);
    }
    if (passwordExpirationNotificationChannels) {
      res["PasswordExpirationNotificationChannels"] = boost::any(*passwordExpirationNotificationChannels);
    }
    if (passwordExpirationNotificationDuration) {
      res["PasswordExpirationNotificationDuration"] = boost::any(*passwordExpirationNotificationDuration);
    }
    if (passwordExpirationNotificationStatus) {
      res["PasswordExpirationNotificationStatus"] = boost::any(*passwordExpirationNotificationStatus);
    }
    if (passwordExpirationStatus) {
      res["PasswordExpirationStatus"] = boost::any(*passwordExpirationStatus);
    }
    if (passwordForcedUpdateDuration) {
      res["PasswordForcedUpdateDuration"] = boost::any(*passwordForcedUpdateDuration);
    }
    if (passwordValidMaxDay) {
      res["PasswordValidMaxDay"] = boost::any(*passwordValidMaxDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveAuthenticationSourceIds") != m.end() && !m["EffectiveAuthenticationSourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EffectiveAuthenticationSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EffectiveAuthenticationSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      effectiveAuthenticationSourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PasswordExpirationAction") != m.end() && !m["PasswordExpirationAction"].empty()) {
      passwordExpirationAction = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationAction"]));
    }
    if (m.find("PasswordExpirationNotificationChannels") != m.end() && !m["PasswordExpirationNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PasswordExpirationNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PasswordExpirationNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passwordExpirationNotificationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PasswordExpirationNotificationDuration") != m.end() && !m["PasswordExpirationNotificationDuration"].empty()) {
      passwordExpirationNotificationDuration = make_shared<long>(boost::any_cast<long>(m["PasswordExpirationNotificationDuration"]));
    }
    if (m.find("PasswordExpirationNotificationStatus") != m.end() && !m["PasswordExpirationNotificationStatus"].empty()) {
      passwordExpirationNotificationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationNotificationStatus"]));
    }
    if (m.find("PasswordExpirationStatus") != m.end() && !m["PasswordExpirationStatus"].empty()) {
      passwordExpirationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordExpirationStatus"]));
    }
    if (m.find("PasswordForcedUpdateDuration") != m.end() && !m["PasswordForcedUpdateDuration"].empty()) {
      passwordForcedUpdateDuration = make_shared<long>(boost::any_cast<long>(m["PasswordForcedUpdateDuration"]));
    }
    if (m.find("PasswordValidMaxDay") != m.end() && !m["PasswordValidMaxDay"].empty()) {
      passwordValidMaxDay = make_shared<long>(boost::any_cast<long>(m["PasswordValidMaxDay"]));
    }
  }


  virtual ~SetPasswordExpirationConfigurationRequest() = default;
};
class SetPasswordExpirationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPasswordExpirationConfigurationResponseBody() {}

  explicit SetPasswordExpirationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPasswordExpirationConfigurationResponseBody() = default;
};
class SetPasswordExpirationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPasswordExpirationConfigurationResponseBody> body{};

  SetPasswordExpirationConfigurationResponse() {}

  explicit SetPasswordExpirationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPasswordExpirationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPasswordExpirationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetPasswordExpirationConfigurationResponse() = default;
};
class SetPasswordHistoryConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> passwordHistoryMaxRetention{};
  shared_ptr<string> passwordHistoryStatus{};

  SetPasswordHistoryConfigurationRequest() {}

  explicit SetPasswordHistoryConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passwordHistoryMaxRetention) {
      res["PasswordHistoryMaxRetention"] = boost::any(*passwordHistoryMaxRetention);
    }
    if (passwordHistoryStatus) {
      res["PasswordHistoryStatus"] = boost::any(*passwordHistoryStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PasswordHistoryMaxRetention") != m.end() && !m["PasswordHistoryMaxRetention"].empty()) {
      passwordHistoryMaxRetention = make_shared<long>(boost::any_cast<long>(m["PasswordHistoryMaxRetention"]));
    }
    if (m.find("PasswordHistoryStatus") != m.end() && !m["PasswordHistoryStatus"].empty()) {
      passwordHistoryStatus = make_shared<string>(boost::any_cast<string>(m["PasswordHistoryStatus"]));
    }
  }


  virtual ~SetPasswordHistoryConfigurationRequest() = default;
};
class SetPasswordHistoryConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPasswordHistoryConfigurationResponseBody() {}

  explicit SetPasswordHistoryConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPasswordHistoryConfigurationResponseBody() = default;
};
class SetPasswordHistoryConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPasswordHistoryConfigurationResponseBody> body{};

  SetPasswordHistoryConfigurationResponse() {}

  explicit SetPasswordHistoryConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPasswordHistoryConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPasswordHistoryConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetPasswordHistoryConfigurationResponse() = default;
};
class SetPasswordInitializationConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> passwordForcedUpdateStatus{};
  shared_ptr<vector<string>> passwordInitializationNotificationChannels{};
  shared_ptr<string> passwordInitializationStatus{};
  shared_ptr<string> passwordInitializationType{};

  SetPasswordInitializationConfigurationRequest() {}

  explicit SetPasswordInitializationConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (passwordForcedUpdateStatus) {
      res["PasswordForcedUpdateStatus"] = boost::any(*passwordForcedUpdateStatus);
    }
    if (passwordInitializationNotificationChannels) {
      res["PasswordInitializationNotificationChannels"] = boost::any(*passwordInitializationNotificationChannels);
    }
    if (passwordInitializationStatus) {
      res["PasswordInitializationStatus"] = boost::any(*passwordInitializationStatus);
    }
    if (passwordInitializationType) {
      res["PasswordInitializationType"] = boost::any(*passwordInitializationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PasswordForcedUpdateStatus") != m.end() && !m["PasswordForcedUpdateStatus"].empty()) {
      passwordForcedUpdateStatus = make_shared<string>(boost::any_cast<string>(m["PasswordForcedUpdateStatus"]));
    }
    if (m.find("PasswordInitializationNotificationChannels") != m.end() && !m["PasswordInitializationNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PasswordInitializationNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PasswordInitializationNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      passwordInitializationNotificationChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PasswordInitializationStatus") != m.end() && !m["PasswordInitializationStatus"].empty()) {
      passwordInitializationStatus = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationStatus"]));
    }
    if (m.find("PasswordInitializationType") != m.end() && !m["PasswordInitializationType"].empty()) {
      passwordInitializationType = make_shared<string>(boost::any_cast<string>(m["PasswordInitializationType"]));
    }
  }


  virtual ~SetPasswordInitializationConfigurationRequest() = default;
};
class SetPasswordInitializationConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetPasswordInitializationConfigurationResponseBody() {}

  explicit SetPasswordInitializationConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetPasswordInitializationConfigurationResponseBody() = default;
};
class SetPasswordInitializationConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetPasswordInitializationConfigurationResponseBody> body{};

  SetPasswordInitializationConfigurationResponse() {}

  explicit SetPasswordInitializationConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetPasswordInitializationConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetPasswordInitializationConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~SetPasswordInitializationConfigurationResponse() = default;
};
class SetUserPrimaryOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> userId{};

  SetUserPrimaryOrganizationalUnitRequest() {}

  explicit SetUserPrimaryOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SetUserPrimaryOrganizationalUnitRequest() = default;
};
class SetUserPrimaryOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetUserPrimaryOrganizationalUnitResponseBody() {}

  explicit SetUserPrimaryOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetUserPrimaryOrganizationalUnitResponseBody() = default;
};
class SetUserPrimaryOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetUserPrimaryOrganizationalUnitResponseBody> body{};

  SetUserPrimaryOrganizationalUnitResponse() {}

  explicit SetUserPrimaryOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetUserPrimaryOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetUserPrimaryOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~SetUserPrimaryOrganizationalUnitResponse() = default;
};
class UnlockUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  UnlockUserRequest() {}

  explicit UnlockUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnlockUserRequest() = default;
};
class UnlockUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnlockUserResponseBody() {}

  explicit UnlockUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnlockUserResponseBody() = default;
};
class UnlockUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnlockUserResponseBody> body{};

  UnlockUserResponse() {}

  explicit UnlockUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockUserResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockUserResponse() = default;
};
class UpdateApplicationAuthorizationTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> instanceId{};

  UpdateApplicationAuthorizationTypeRequest() {}

  explicit UpdateApplicationAuthorizationTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateApplicationAuthorizationTypeRequest() = default;
};
class UpdateApplicationAuthorizationTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateApplicationAuthorizationTypeResponseBody() {}

  explicit UpdateApplicationAuthorizationTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationAuthorizationTypeResponseBody() = default;
};
class UpdateApplicationAuthorizationTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationAuthorizationTypeResponseBody> body{};

  UpdateApplicationAuthorizationTypeResponse() {}

  explicit UpdateApplicationAuthorizationTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationAuthorizationTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationAuthorizationTypeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationAuthorizationTypeResponse() = default;
};
class UpdateApplicationDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> applicationId{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};

  UpdateApplicationDescriptionRequest() {}

  explicit UpdateApplicationDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationId) {
      res["ApplicationId"] = boost::any(*applicationId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationId") != m.end() && !m["ApplicationId"].empty()) {
      applicationId = make_shared<string>(boost::any_cast<string>(m["ApplicationId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateApplicationDescriptionRequest() = default;
};
class UpdateApplicationDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateApplicationDescriptionResponseBody() {}

  explicit UpdateApplicationDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationDescriptionResponseBody() = default;
};
class UpdateApplicationDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationDescriptionResponseBody> body{};

  UpdateApplicationDescriptionResponse() {}

  explicit UpdateApplicationDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationDescriptionResponse() = default;
};
class UpdateConditionalAccessPolicyRequestConditionsConfigApplications : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeApplications{};
  shared_ptr<vector<string>> includeApplications{};

  UpdateConditionalAccessPolicyRequestConditionsConfigApplications() {}

  explicit UpdateConditionalAccessPolicyRequestConditionsConfigApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeApplications) {
      res["ExcludeApplications"] = boost::any(*excludeApplications);
    }
    if (includeApplications) {
      res["IncludeApplications"] = boost::any(*includeApplications);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeApplications") != m.end() && !m["ExcludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeApplications = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeApplications") != m.end() && !m["IncludeApplications"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeApplications"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeApplications"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeApplications = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequestConditionsConfigApplications() = default;
};
class UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeNetworkZones{};
  shared_ptr<vector<string>> includeNetworkZones{};

  UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones() {}

  explicit UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeNetworkZones) {
      res["ExcludeNetworkZones"] = boost::any(*excludeNetworkZones);
    }
    if (includeNetworkZones) {
      res["IncludeNetworkZones"] = boost::any(*includeNetworkZones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeNetworkZones") != m.end() && !m["ExcludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeNetworkZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeNetworkZones") != m.end() && !m["IncludeNetworkZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeNetworkZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeNetworkZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeNetworkZones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones() = default;
};
class UpdateConditionalAccessPolicyRequestConditionsConfigUsers : public Darabonba::Model {
public:
  shared_ptr<vector<string>> excludeGroups{};
  shared_ptr<vector<string>> excludeOrganizationalUnits{};
  shared_ptr<vector<string>> excludeUsers{};
  shared_ptr<vector<string>> includeGroups{};
  shared_ptr<vector<string>> includeOrganizationalUnits{};
  shared_ptr<vector<string>> includeUsers{};

  UpdateConditionalAccessPolicyRequestConditionsConfigUsers() {}

  explicit UpdateConditionalAccessPolicyRequestConditionsConfigUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (excludeGroups) {
      res["ExcludeGroups"] = boost::any(*excludeGroups);
    }
    if (excludeOrganizationalUnits) {
      res["ExcludeOrganizationalUnits"] = boost::any(*excludeOrganizationalUnits);
    }
    if (excludeUsers) {
      res["ExcludeUsers"] = boost::any(*excludeUsers);
    }
    if (includeGroups) {
      res["IncludeGroups"] = boost::any(*includeGroups);
    }
    if (includeOrganizationalUnits) {
      res["IncludeOrganizationalUnits"] = boost::any(*includeOrganizationalUnits);
    }
    if (includeUsers) {
      res["IncludeUsers"] = boost::any(*includeUsers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExcludeGroups") != m.end() && !m["ExcludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeOrganizationalUnits") != m.end() && !m["ExcludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExcludeUsers") != m.end() && !m["ExcludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ExcludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExcludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      excludeUsers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeGroups") != m.end() && !m["IncludeGroups"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeGroups"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeGroups"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeGroups = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeOrganizationalUnits") != m.end() && !m["IncludeOrganizationalUnits"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeOrganizationalUnits"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeOrganizationalUnits"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeOrganizationalUnits = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IncludeUsers") != m.end() && !m["IncludeUsers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IncludeUsers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IncludeUsers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      includeUsers = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequestConditionsConfigUsers() = default;
};
class UpdateConditionalAccessPolicyRequestConditionsConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateConditionalAccessPolicyRequestConditionsConfigApplications> applications{};
  shared_ptr<UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones> networkZones{};
  shared_ptr<UpdateConditionalAccessPolicyRequestConditionsConfigUsers> users{};

  UpdateConditionalAccessPolicyRequestConditionsConfig() {}

  explicit UpdateConditionalAccessPolicyRequestConditionsConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applications) {
      res["Applications"] = applications ? boost::any(applications->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkZones) {
      res["NetworkZones"] = networkZones ? boost::any(networkZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Applications") != m.end() && !m["Applications"].empty()) {
      if (typeid(map<string, boost::any>) == m["Applications"].type()) {
        UpdateConditionalAccessPolicyRequestConditionsConfigApplications model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Applications"]));
        applications = make_shared<UpdateConditionalAccessPolicyRequestConditionsConfigApplications>(model1);
      }
    }
    if (m.find("NetworkZones") != m.end() && !m["NetworkZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkZones"].type()) {
        UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkZones"]));
        networkZones = make_shared<UpdateConditionalAccessPolicyRequestConditionsConfigNetworkZones>(model1);
      }
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        UpdateConditionalAccessPolicyRequestConditionsConfigUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<UpdateConditionalAccessPolicyRequestConditionsConfigUsers>(model1);
      }
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequestConditionsConfig() = default;
};
class UpdateConditionalAccessPolicyRequestDecisionConfig : public Darabonba::Model {
public:
  shared_ptr<string> activeSessionReuseStatus{};
  shared_ptr<string> effect{};
  shared_ptr<long> mfaAuthenticationIntervalSeconds{};
  shared_ptr<vector<string>> mfaAuthenticationMethods{};
  shared_ptr<string> mfaType{};

  UpdateConditionalAccessPolicyRequestDecisionConfig() {}

  explicit UpdateConditionalAccessPolicyRequestDecisionConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeSessionReuseStatus) {
      res["ActiveSessionReuseStatus"] = boost::any(*activeSessionReuseStatus);
    }
    if (effect) {
      res["Effect"] = boost::any(*effect);
    }
    if (mfaAuthenticationIntervalSeconds) {
      res["MfaAuthenticationIntervalSeconds"] = boost::any(*mfaAuthenticationIntervalSeconds);
    }
    if (mfaAuthenticationMethods) {
      res["MfaAuthenticationMethods"] = boost::any(*mfaAuthenticationMethods);
    }
    if (mfaType) {
      res["MfaType"] = boost::any(*mfaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveSessionReuseStatus") != m.end() && !m["ActiveSessionReuseStatus"].empty()) {
      activeSessionReuseStatus = make_shared<string>(boost::any_cast<string>(m["ActiveSessionReuseStatus"]));
    }
    if (m.find("Effect") != m.end() && !m["Effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["Effect"]));
    }
    if (m.find("MfaAuthenticationIntervalSeconds") != m.end() && !m["MfaAuthenticationIntervalSeconds"].empty()) {
      mfaAuthenticationIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["MfaAuthenticationIntervalSeconds"]));
    }
    if (m.find("MfaAuthenticationMethods") != m.end() && !m["MfaAuthenticationMethods"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MfaAuthenticationMethods"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MfaAuthenticationMethods"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mfaAuthenticationMethods = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MfaType") != m.end() && !m["MfaType"].empty()) {
      mfaType = make_shared<string>(boost::any_cast<string>(m["MfaType"]));
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequestDecisionConfig() = default;
};
class UpdateConditionalAccessPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> conditionalAccessPolicyName{};
  shared_ptr<UpdateConditionalAccessPolicyRequestConditionsConfig> conditionsConfig{};
  shared_ptr<UpdateConditionalAccessPolicyRequestDecisionConfig> decisionConfig{};
  shared_ptr<string> decisionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> priority{};

  UpdateConditionalAccessPolicyRequest() {}

  explicit UpdateConditionalAccessPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (conditionalAccessPolicyName) {
      res["ConditionalAccessPolicyName"] = boost::any(*conditionalAccessPolicyName);
    }
    if (conditionsConfig) {
      res["ConditionsConfig"] = conditionsConfig ? boost::any(conditionsConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionConfig) {
      res["DecisionConfig"] = decisionConfig ? boost::any(decisionConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (decisionType) {
      res["DecisionType"] = boost::any(*decisionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("ConditionalAccessPolicyName") != m.end() && !m["ConditionalAccessPolicyName"].empty()) {
      conditionalAccessPolicyName = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyName"]));
    }
    if (m.find("ConditionsConfig") != m.end() && !m["ConditionsConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConditionsConfig"].type()) {
        UpdateConditionalAccessPolicyRequestConditionsConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConditionsConfig"]));
        conditionsConfig = make_shared<UpdateConditionalAccessPolicyRequestConditionsConfig>(model1);
      }
    }
    if (m.find("DecisionConfig") != m.end() && !m["DecisionConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DecisionConfig"].type()) {
        UpdateConditionalAccessPolicyRequestDecisionConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DecisionConfig"]));
        decisionConfig = make_shared<UpdateConditionalAccessPolicyRequestDecisionConfig>(model1);
      }
    }
    if (m.find("DecisionType") != m.end() && !m["DecisionType"].empty()) {
      decisionType = make_shared<string>(boost::any_cast<string>(m["DecisionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~UpdateConditionalAccessPolicyRequest() = default;
};
class UpdateConditionalAccessPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateConditionalAccessPolicyResponseBody() {}

  explicit UpdateConditionalAccessPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConditionalAccessPolicyResponseBody() = default;
};
class UpdateConditionalAccessPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConditionalAccessPolicyResponseBody> body{};

  UpdateConditionalAccessPolicyResponse() {}

  explicit UpdateConditionalAccessPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConditionalAccessPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConditionalAccessPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConditionalAccessPolicyResponse() = default;
};
class UpdateConditionalAccessPolicyDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> conditionalAccessPolicyId{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};

  UpdateConditionalAccessPolicyDescriptionRequest() {}

  explicit UpdateConditionalAccessPolicyDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (conditionalAccessPolicyId) {
      res["ConditionalAccessPolicyId"] = boost::any(*conditionalAccessPolicyId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ConditionalAccessPolicyId") != m.end() && !m["ConditionalAccessPolicyId"].empty()) {
      conditionalAccessPolicyId = make_shared<string>(boost::any_cast<string>(m["ConditionalAccessPolicyId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateConditionalAccessPolicyDescriptionRequest() = default;
};
class UpdateConditionalAccessPolicyDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateConditionalAccessPolicyDescriptionResponseBody() {}

  explicit UpdateConditionalAccessPolicyDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConditionalAccessPolicyDescriptionResponseBody() = default;
};
class UpdateConditionalAccessPolicyDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConditionalAccessPolicyDescriptionResponseBody> body{};

  UpdateConditionalAccessPolicyDescriptionResponse() {}

  explicit UpdateConditionalAccessPolicyDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConditionalAccessPolicyDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConditionalAccessPolicyDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConditionalAccessPolicyDescriptionResponse() = default;
};
class UpdateGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupExternalId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};

  UpdateGroupRequest() {}

  explicit UpdateGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupExternalId) {
      res["GroupExternalId"] = boost::any(*groupExternalId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupExternalId") != m.end() && !m["GroupExternalId"].empty()) {
      groupExternalId = make_shared<string>(boost::any_cast<string>(m["GroupExternalId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateGroupRequest() = default;
};
class UpdateGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGroupResponseBody() {}

  explicit UpdateGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGroupResponseBody() = default;
};
class UpdateGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGroupResponseBody> body{};

  UpdateGroupResponse() {}

  explicit UpdateGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGroupResponse() = default;
};
class UpdateGroupDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> instanceId{};

  UpdateGroupDescriptionRequest() {}

  explicit UpdateGroupDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateGroupDescriptionRequest() = default;
};
class UpdateGroupDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateGroupDescriptionResponseBody() {}

  explicit UpdateGroupDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateGroupDescriptionResponseBody() = default;
};
class UpdateGroupDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGroupDescriptionResponseBody> body{};

  UpdateGroupDescriptionResponse() {}

  explicit UpdateGroupDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGroupDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGroupDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGroupDescriptionResponse() = default;
};
class UpdateIdentityProviderRequestDingtalkAppConfig : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> verificationToken{};

  UpdateIdentityProviderRequestDingtalkAppConfig() {}

  explicit UpdateIdentityProviderRequestDingtalkAppConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestDingtalkAppConfig() = default;
};
class UpdateIdentityProviderRequestLarkConfig : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> encryptKey{};
  shared_ptr<string> verificationToken{};

  UpdateIdentityProviderRequestLarkConfig() {}

  explicit UpdateIdentityProviderRequestLarkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (encryptKey) {
      res["EncryptKey"] = boost::any(*encryptKey);
    }
    if (verificationToken) {
      res["VerificationToken"] = boost::any(*verificationToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("EncryptKey") != m.end() && !m["EncryptKey"].empty()) {
      encryptKey = make_shared<string>(boost::any_cast<string>(m["EncryptKey"]));
    }
    if (m.find("VerificationToken") != m.end() && !m["VerificationToken"].empty()) {
      verificationToken = make_shared<string>(boost::any_cast<string>(m["VerificationToken"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestLarkConfig() = default;
};
class UpdateIdentityProviderRequestLdapConfig : public Darabonba::Model {
public:
  shared_ptr<string> administratorPassword{};
  shared_ptr<string> administratorUsername{};
  shared_ptr<string> certificateFingerprintStatus{};
  shared_ptr<vector<string>> certificateFingerprints{};
  shared_ptr<string> ldapProtocol{};
  shared_ptr<string> ldapServerHost{};
  shared_ptr<long> ldapServerPort{};
  shared_ptr<string> startTlsStatus{};

  UpdateIdentityProviderRequestLdapConfig() {}

  explicit UpdateIdentityProviderRequestLdapConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (administratorPassword) {
      res["AdministratorPassword"] = boost::any(*administratorPassword);
    }
    if (administratorUsername) {
      res["AdministratorUsername"] = boost::any(*administratorUsername);
    }
    if (certificateFingerprintStatus) {
      res["CertificateFingerprintStatus"] = boost::any(*certificateFingerprintStatus);
    }
    if (certificateFingerprints) {
      res["CertificateFingerprints"] = boost::any(*certificateFingerprints);
    }
    if (ldapProtocol) {
      res["LdapProtocol"] = boost::any(*ldapProtocol);
    }
    if (ldapServerHost) {
      res["LdapServerHost"] = boost::any(*ldapServerHost);
    }
    if (ldapServerPort) {
      res["LdapServerPort"] = boost::any(*ldapServerPort);
    }
    if (startTlsStatus) {
      res["StartTlsStatus"] = boost::any(*startTlsStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdministratorPassword") != m.end() && !m["AdministratorPassword"].empty()) {
      administratorPassword = make_shared<string>(boost::any_cast<string>(m["AdministratorPassword"]));
    }
    if (m.find("AdministratorUsername") != m.end() && !m["AdministratorUsername"].empty()) {
      administratorUsername = make_shared<string>(boost::any_cast<string>(m["AdministratorUsername"]));
    }
    if (m.find("CertificateFingerprintStatus") != m.end() && !m["CertificateFingerprintStatus"].empty()) {
      certificateFingerprintStatus = make_shared<string>(boost::any_cast<string>(m["CertificateFingerprintStatus"]));
    }
    if (m.find("CertificateFingerprints") != m.end() && !m["CertificateFingerprints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CertificateFingerprints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CertificateFingerprints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      certificateFingerprints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LdapProtocol") != m.end() && !m["LdapProtocol"].empty()) {
      ldapProtocol = make_shared<string>(boost::any_cast<string>(m["LdapProtocol"]));
    }
    if (m.find("LdapServerHost") != m.end() && !m["LdapServerHost"].empty()) {
      ldapServerHost = make_shared<string>(boost::any_cast<string>(m["LdapServerHost"]));
    }
    if (m.find("LdapServerPort") != m.end() && !m["LdapServerPort"].empty()) {
      ldapServerPort = make_shared<long>(boost::any_cast<long>(m["LdapServerPort"]));
    }
    if (m.find("StartTlsStatus") != m.end() && !m["StartTlsStatus"].empty()) {
      startTlsStatus = make_shared<string>(boost::any_cast<string>(m["StartTlsStatus"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestLdapConfig() = default;
};
class UpdateIdentityProviderRequestOidcConfigAuthnParam : public Darabonba::Model {
public:
  shared_ptr<string> authnMethod{};
  shared_ptr<string> clientSecret{};

  UpdateIdentityProviderRequestOidcConfigAuthnParam() {}

  explicit UpdateIdentityProviderRequestOidcConfigAuthnParam(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnMethod) {
      res["AuthnMethod"] = boost::any(*authnMethod);
    }
    if (clientSecret) {
      res["ClientSecret"] = boost::any(*clientSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnMethod") != m.end() && !m["AuthnMethod"].empty()) {
      authnMethod = make_shared<string>(boost::any_cast<string>(m["AuthnMethod"]));
    }
    if (m.find("ClientSecret") != m.end() && !m["ClientSecret"].empty()) {
      clientSecret = make_shared<string>(boost::any_cast<string>(m["ClientSecret"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestOidcConfigAuthnParam() = default;
};
class UpdateIdentityProviderRequestOidcConfigEndpointConfig : public Darabonba::Model {
public:
  shared_ptr<string> authorizationEndpoint{};
  shared_ptr<string> issuer{};
  shared_ptr<string> jwksUri{};
  shared_ptr<string> tokenEndpoint{};
  shared_ptr<string> userinfoEndpoint{};

  UpdateIdentityProviderRequestOidcConfigEndpointConfig() {}

  explicit UpdateIdentityProviderRequestOidcConfigEndpointConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizationEndpoint) {
      res["AuthorizationEndpoint"] = boost::any(*authorizationEndpoint);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (jwksUri) {
      res["JwksUri"] = boost::any(*jwksUri);
    }
    if (tokenEndpoint) {
      res["TokenEndpoint"] = boost::any(*tokenEndpoint);
    }
    if (userinfoEndpoint) {
      res["UserinfoEndpoint"] = boost::any(*userinfoEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizationEndpoint") != m.end() && !m["AuthorizationEndpoint"].empty()) {
      authorizationEndpoint = make_shared<string>(boost::any_cast<string>(m["AuthorizationEndpoint"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("JwksUri") != m.end() && !m["JwksUri"].empty()) {
      jwksUri = make_shared<string>(boost::any_cast<string>(m["JwksUri"]));
    }
    if (m.find("TokenEndpoint") != m.end() && !m["TokenEndpoint"].empty()) {
      tokenEndpoint = make_shared<string>(boost::any_cast<string>(m["TokenEndpoint"]));
    }
    if (m.find("UserinfoEndpoint") != m.end() && !m["UserinfoEndpoint"].empty()) {
      userinfoEndpoint = make_shared<string>(boost::any_cast<string>(m["UserinfoEndpoint"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestOidcConfigEndpointConfig() = default;
};
class UpdateIdentityProviderRequestOidcConfig : public Darabonba::Model {
public:
  shared_ptr<UpdateIdentityProviderRequestOidcConfigAuthnParam> authnParam{};
  shared_ptr<UpdateIdentityProviderRequestOidcConfigEndpointConfig> endpointConfig{};
  shared_ptr<vector<string>> grantScopes{};
  shared_ptr<string> grantType{};
  shared_ptr<string> pkceChallengeMethod{};
  shared_ptr<bool> pkceRequired{};

  UpdateIdentityProviderRequestOidcConfig() {}

  explicit UpdateIdentityProviderRequestOidcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authnParam) {
      res["AuthnParam"] = authnParam ? boost::any(authnParam->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endpointConfig) {
      res["EndpointConfig"] = endpointConfig ? boost::any(endpointConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (grantScopes) {
      res["GrantScopes"] = boost::any(*grantScopes);
    }
    if (grantType) {
      res["GrantType"] = boost::any(*grantType);
    }
    if (pkceChallengeMethod) {
      res["PkceChallengeMethod"] = boost::any(*pkceChallengeMethod);
    }
    if (pkceRequired) {
      res["PkceRequired"] = boost::any(*pkceRequired);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthnParam") != m.end() && !m["AuthnParam"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthnParam"].type()) {
        UpdateIdentityProviderRequestOidcConfigAuthnParam model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthnParam"]));
        authnParam = make_shared<UpdateIdentityProviderRequestOidcConfigAuthnParam>(model1);
      }
    }
    if (m.find("EndpointConfig") != m.end() && !m["EndpointConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndpointConfig"].type()) {
        UpdateIdentityProviderRequestOidcConfigEndpointConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndpointConfig"]));
        endpointConfig = make_shared<UpdateIdentityProviderRequestOidcConfigEndpointConfig>(model1);
      }
    }
    if (m.find("GrantScopes") != m.end() && !m["GrantScopes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["GrantScopes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["GrantScopes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      grantScopes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("GrantType") != m.end() && !m["GrantType"].empty()) {
      grantType = make_shared<string>(boost::any_cast<string>(m["GrantType"]));
    }
    if (m.find("PkceChallengeMethod") != m.end() && !m["PkceChallengeMethod"].empty()) {
      pkceChallengeMethod = make_shared<string>(boost::any_cast<string>(m["PkceChallengeMethod"]));
    }
    if (m.find("PkceRequired") != m.end() && !m["PkceRequired"].empty()) {
      pkceRequired = make_shared<bool>(boost::any_cast<bool>(m["PkceRequired"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestOidcConfig() = default;
};
class UpdateIdentityProviderRequestWeComConfig : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> authorizeCallbackDomain{};
  shared_ptr<string> corpSecret{};
  shared_ptr<string> trustableDomain{};

  UpdateIdentityProviderRequestWeComConfig() {}

  explicit UpdateIdentityProviderRequestWeComConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (authorizeCallbackDomain) {
      res["AuthorizeCallbackDomain"] = boost::any(*authorizeCallbackDomain);
    }
    if (corpSecret) {
      res["CorpSecret"] = boost::any(*corpSecret);
    }
    if (trustableDomain) {
      res["TrustableDomain"] = boost::any(*trustableDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AuthorizeCallbackDomain") != m.end() && !m["AuthorizeCallbackDomain"].empty()) {
      authorizeCallbackDomain = make_shared<string>(boost::any_cast<string>(m["AuthorizeCallbackDomain"]));
    }
    if (m.find("CorpSecret") != m.end() && !m["CorpSecret"].empty()) {
      corpSecret = make_shared<string>(boost::any_cast<string>(m["CorpSecret"]));
    }
    if (m.find("TrustableDomain") != m.end() && !m["TrustableDomain"].empty()) {
      trustableDomain = make_shared<string>(boost::any_cast<string>(m["TrustableDomain"]));
    }
  }


  virtual ~UpdateIdentityProviderRequestWeComConfig() = default;
};
class UpdateIdentityProviderRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<UpdateIdentityProviderRequestDingtalkAppConfig> dingtalkAppConfig{};
  shared_ptr<string> identityProviderId{};
  shared_ptr<string> identityProviderName{};
  shared_ptr<string> instanceId{};
  shared_ptr<UpdateIdentityProviderRequestLarkConfig> larkConfig{};
  shared_ptr<UpdateIdentityProviderRequestLdapConfig> ldapConfig{};
  shared_ptr<string> logoUrl{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<UpdateIdentityProviderRequestOidcConfig> oidcConfig{};
  shared_ptr<UpdateIdentityProviderRequestWeComConfig> weComConfig{};

  UpdateIdentityProviderRequest() {}

  explicit UpdateIdentityProviderRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dingtalkAppConfig) {
      res["DingtalkAppConfig"] = dingtalkAppConfig ? boost::any(dingtalkAppConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (identityProviderId) {
      res["IdentityProviderId"] = boost::any(*identityProviderId);
    }
    if (identityProviderName) {
      res["IdentityProviderName"] = boost::any(*identityProviderName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (larkConfig) {
      res["LarkConfig"] = larkConfig ? boost::any(larkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ldapConfig) {
      res["LdapConfig"] = ldapConfig ? boost::any(ldapConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logoUrl) {
      res["LogoUrl"] = boost::any(*logoUrl);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (oidcConfig) {
      res["OidcConfig"] = oidcConfig ? boost::any(oidcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (weComConfig) {
      res["WeComConfig"] = weComConfig ? boost::any(weComConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DingtalkAppConfig") != m.end() && !m["DingtalkAppConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DingtalkAppConfig"].type()) {
        UpdateIdentityProviderRequestDingtalkAppConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DingtalkAppConfig"]));
        dingtalkAppConfig = make_shared<UpdateIdentityProviderRequestDingtalkAppConfig>(model1);
      }
    }
    if (m.find("IdentityProviderId") != m.end() && !m["IdentityProviderId"].empty()) {
      identityProviderId = make_shared<string>(boost::any_cast<string>(m["IdentityProviderId"]));
    }
    if (m.find("IdentityProviderName") != m.end() && !m["IdentityProviderName"].empty()) {
      identityProviderName = make_shared<string>(boost::any_cast<string>(m["IdentityProviderName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LarkConfig") != m.end() && !m["LarkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LarkConfig"].type()) {
        UpdateIdentityProviderRequestLarkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LarkConfig"]));
        larkConfig = make_shared<UpdateIdentityProviderRequestLarkConfig>(model1);
      }
    }
    if (m.find("LdapConfig") != m.end() && !m["LdapConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["LdapConfig"].type()) {
        UpdateIdentityProviderRequestLdapConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LdapConfig"]));
        ldapConfig = make_shared<UpdateIdentityProviderRequestLdapConfig>(model1);
      }
    }
    if (m.find("LogoUrl") != m.end() && !m["LogoUrl"].empty()) {
      logoUrl = make_shared<string>(boost::any_cast<string>(m["LogoUrl"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("OidcConfig") != m.end() && !m["OidcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OidcConfig"].type()) {
        UpdateIdentityProviderRequestOidcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OidcConfig"]));
        oidcConfig = make_shared<UpdateIdentityProviderRequestOidcConfig>(model1);
      }
    }
    if (m.find("WeComConfig") != m.end() && !m["WeComConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["WeComConfig"].type()) {
        UpdateIdentityProviderRequestWeComConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WeComConfig"]));
        weComConfig = make_shared<UpdateIdentityProviderRequestWeComConfig>(model1);
      }
    }
  }


  virtual ~UpdateIdentityProviderRequest() = default;
};
class UpdateIdentityProviderResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIdentityProviderResponseBody() {}

  explicit UpdateIdentityProviderResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIdentityProviderResponseBody() = default;
};
class UpdateIdentityProviderResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIdentityProviderResponseBody> body{};

  UpdateIdentityProviderResponse() {}

  explicit UpdateIdentityProviderResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIdentityProviderResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIdentityProviderResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIdentityProviderResponse() = default;
};
class UpdateInstanceDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};

  UpdateInstanceDescriptionRequest() {}

  explicit UpdateInstanceDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~UpdateInstanceDescriptionRequest() = default;
};
class UpdateInstanceDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateInstanceDescriptionResponseBody() {}

  explicit UpdateInstanceDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateInstanceDescriptionResponseBody() = default;
};
class UpdateInstanceDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceDescriptionResponseBody> body{};

  UpdateInstanceDescriptionResponse() {}

  explicit UpdateInstanceDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceDescriptionResponse() = default;
};
class UpdateNetworkAccessEndpointNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> networkAccessEndpointId{};
  shared_ptr<string> networkAccessEndpointName{};

  UpdateNetworkAccessEndpointNameRequest() {}

  explicit UpdateNetworkAccessEndpointNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (networkAccessEndpointId) {
      res["NetworkAccessEndpointId"] = boost::any(*networkAccessEndpointId);
    }
    if (networkAccessEndpointName) {
      res["NetworkAccessEndpointName"] = boost::any(*networkAccessEndpointName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NetworkAccessEndpointId") != m.end() && !m["NetworkAccessEndpointId"].empty()) {
      networkAccessEndpointId = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointId"]));
    }
    if (m.find("NetworkAccessEndpointName") != m.end() && !m["NetworkAccessEndpointName"].empty()) {
      networkAccessEndpointName = make_shared<string>(boost::any_cast<string>(m["NetworkAccessEndpointName"]));
    }
  }


  virtual ~UpdateNetworkAccessEndpointNameRequest() = default;
};
class UpdateNetworkAccessEndpointNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateNetworkAccessEndpointNameResponseBody() {}

  explicit UpdateNetworkAccessEndpointNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateNetworkAccessEndpointNameResponseBody() = default;
};
class UpdateNetworkAccessEndpointNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateNetworkAccessEndpointNameResponseBody> body{};

  UpdateNetworkAccessEndpointNameResponse() {}

  explicit UpdateNetworkAccessEndpointNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateNetworkAccessEndpointNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateNetworkAccessEndpointNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateNetworkAccessEndpointNameResponse() = default;
};
class UpdateOrganizationalUnitRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> organizationalUnitName{};

  UpdateOrganizationalUnitRequest() {}

  explicit UpdateOrganizationalUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (organizationalUnitName) {
      res["OrganizationalUnitName"] = boost::any(*organizationalUnitName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("OrganizationalUnitName") != m.end() && !m["OrganizationalUnitName"].empty()) {
      organizationalUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitName"]));
    }
  }


  virtual ~UpdateOrganizationalUnitRequest() = default;
};
class UpdateOrganizationalUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOrganizationalUnitResponseBody() {}

  explicit UpdateOrganizationalUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOrganizationalUnitResponseBody() = default;
};
class UpdateOrganizationalUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOrganizationalUnitResponseBody> body{};

  UpdateOrganizationalUnitResponse() {}

  explicit UpdateOrganizationalUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOrganizationalUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOrganizationalUnitResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOrganizationalUnitResponse() = default;
};
class UpdateOrganizationalUnitDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};

  UpdateOrganizationalUnitDescriptionRequest() {}

  explicit UpdateOrganizationalUnitDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
  }


  virtual ~UpdateOrganizationalUnitDescriptionRequest() = default;
};
class UpdateOrganizationalUnitDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOrganizationalUnitDescriptionResponseBody() {}

  explicit UpdateOrganizationalUnitDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOrganizationalUnitDescriptionResponseBody() = default;
};
class UpdateOrganizationalUnitDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOrganizationalUnitDescriptionResponseBody> body{};

  UpdateOrganizationalUnitDescriptionResponse() {}

  explicit UpdateOrganizationalUnitDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOrganizationalUnitDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOrganizationalUnitDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOrganizationalUnitDescriptionResponse() = default;
};
class UpdateOrganizationalUnitParentIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> organizationalUnitId{};
  shared_ptr<string> parentId{};

  UpdateOrganizationalUnitParentIdRequest() {}

  explicit UpdateOrganizationalUnitParentIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (organizationalUnitId) {
      res["OrganizationalUnitId"] = boost::any(*organizationalUnitId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrganizationalUnitId") != m.end() && !m["OrganizationalUnitId"].empty()) {
      organizationalUnitId = make_shared<string>(boost::any_cast<string>(m["OrganizationalUnitId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
  }


  virtual ~UpdateOrganizationalUnitParentIdRequest() = default;
};
class UpdateOrganizationalUnitParentIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateOrganizationalUnitParentIdResponseBody() {}

  explicit UpdateOrganizationalUnitParentIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateOrganizationalUnitParentIdResponseBody() = default;
};
class UpdateOrganizationalUnitParentIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateOrganizationalUnitParentIdResponseBody> body{};

  UpdateOrganizationalUnitParentIdResponse() {}

  explicit UpdateOrganizationalUnitParentIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateOrganizationalUnitParentIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateOrganizationalUnitParentIdResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateOrganizationalUnitParentIdResponse() = default;
};
class UpdateUserRequestCustomFields : public Darabonba::Model {
public:
  shared_ptr<string> fieldName{};
  shared_ptr<string> fieldValue{};
  shared_ptr<string> operation{};

  UpdateUserRequestCustomFields() {}

  explicit UpdateUserRequestCustomFields(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldName) {
      res["FieldName"] = boost::any(*fieldName);
    }
    if (fieldValue) {
      res["FieldValue"] = boost::any(*fieldValue);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldName") != m.end() && !m["FieldName"].empty()) {
      fieldName = make_shared<string>(boost::any_cast<string>(m["FieldName"]));
    }
    if (m.find("FieldValue") != m.end() && !m["FieldValue"].empty()) {
      fieldValue = make_shared<string>(boost::any_cast<string>(m["FieldValue"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
  }


  virtual ~UpdateUserRequestCustomFields() = default;
};
class UpdateUserRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateUserRequestCustomFields>> customFields{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<bool> emailVerified{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<bool> phoneNumberVerified{};
  shared_ptr<string> phoneRegion{};
  shared_ptr<string> userId{};
  shared_ptr<string> username{};

  UpdateUserRequest() {}

  explicit UpdateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customFields) {
      vector<boost::any> temp1;
      for(auto item1:*customFields){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomFields"] = boost::any(temp1);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (emailVerified) {
      res["EmailVerified"] = boost::any(*emailVerified);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (phoneNumberVerified) {
      res["PhoneNumberVerified"] = boost::any(*phoneNumberVerified);
    }
    if (phoneRegion) {
      res["PhoneRegion"] = boost::any(*phoneRegion);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomFields") != m.end() && !m["CustomFields"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomFields"].type()) {
        vector<UpdateUserRequestCustomFields> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomFields"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateUserRequestCustomFields model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customFields = make_shared<vector<UpdateUserRequestCustomFields>>(expect1);
      }
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("EmailVerified") != m.end() && !m["EmailVerified"].empty()) {
      emailVerified = make_shared<bool>(boost::any_cast<bool>(m["EmailVerified"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("PhoneNumberVerified") != m.end() && !m["PhoneNumberVerified"].empty()) {
      phoneNumberVerified = make_shared<bool>(boost::any_cast<bool>(m["PhoneNumberVerified"]));
    }
    if (m.find("PhoneRegion") != m.end() && !m["PhoneRegion"].empty()) {
      phoneRegion = make_shared<string>(boost::any_cast<string>(m["PhoneRegion"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~UpdateUserRequest() = default;
};
class UpdateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserResponseBody() {}

  explicit UpdateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUserResponseBody() = default;
};
class UpdateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserResponseBody> body{};

  UpdateUserResponse() {}

  explicit UpdateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserResponse() = default;
};
class UpdateUserDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  UpdateUserDescriptionRequest() {}

  explicit UpdateUserDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateUserDescriptionRequest() = default;
};
class UpdateUserDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserDescriptionResponseBody() {}

  explicit UpdateUserDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUserDescriptionResponseBody() = default;
};
class UpdateUserDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserDescriptionResponseBody> body{};

  UpdateUserDescriptionResponse() {}

  explicit UpdateUserDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserDescriptionResponse() = default;
};
class UpdateUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> passwordForcedUpdateStatus{};
  shared_ptr<string> userId{};
  shared_ptr<vector<string>> userNotificationChannels{};

  UpdateUserPasswordRequest() {}

  explicit UpdateUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (passwordForcedUpdateStatus) {
      res["PasswordForcedUpdateStatus"] = boost::any(*passwordForcedUpdateStatus);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userNotificationChannels) {
      res["UserNotificationChannels"] = boost::any(*userNotificationChannels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("PasswordForcedUpdateStatus") != m.end() && !m["PasswordForcedUpdateStatus"].empty()) {
      passwordForcedUpdateStatus = make_shared<string>(boost::any_cast<string>(m["PasswordForcedUpdateStatus"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserNotificationChannels") != m.end() && !m["UserNotificationChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserNotificationChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserNotificationChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userNotificationChannels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateUserPasswordRequest() = default;
};
class UpdateUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserPasswordResponseBody() {}

  explicit UpdateUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateUserPasswordResponseBody() = default;
};
class UpdateUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserPasswordResponseBody> body{};

  UpdateUserPasswordResponse() {}

  explicit UpdateUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserPasswordResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddUserToOrganizationalUnitsResponse addUserToOrganizationalUnitsWithOptions(shared_ptr<AddUserToOrganizationalUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUserToOrganizationalUnitsResponse addUserToOrganizationalUnits(shared_ptr<AddUserToOrganizationalUnitsRequest> request);
  AddUsersToGroupResponse addUsersToGroupWithOptions(shared_ptr<AddUsersToGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUsersToGroupResponse addUsersToGroup(shared_ptr<AddUsersToGroupRequest> request);
  AuthorizeApplicationToGroupsResponse authorizeApplicationToGroupsWithOptions(shared_ptr<AuthorizeApplicationToGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeApplicationToGroupsResponse authorizeApplicationToGroups(shared_ptr<AuthorizeApplicationToGroupsRequest> request);
  AuthorizeApplicationToOrganizationalUnitsResponse authorizeApplicationToOrganizationalUnitsWithOptions(shared_ptr<AuthorizeApplicationToOrganizationalUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeApplicationToOrganizationalUnitsResponse authorizeApplicationToOrganizationalUnits(shared_ptr<AuthorizeApplicationToOrganizationalUnitsRequest> request);
  AuthorizeApplicationToUsersResponse authorizeApplicationToUsersWithOptions(shared_ptr<AuthorizeApplicationToUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AuthorizeApplicationToUsersResponse authorizeApplicationToUsers(shared_ptr<AuthorizeApplicationToUsersRequest> request);
  CreateApplicationResponse createApplicationWithOptions(shared_ptr<CreateApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationResponse createApplication(shared_ptr<CreateApplicationRequest> request);
  CreateApplicationClientSecretResponse createApplicationClientSecretWithOptions(shared_ptr<CreateApplicationClientSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationClientSecretResponse createApplicationClientSecret(shared_ptr<CreateApplicationClientSecretRequest> request);
  CreateConditionalAccessPolicyResponse createConditionalAccessPolicyWithOptions(shared_ptr<CreateConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConditionalAccessPolicyResponse createConditionalAccessPolicy(shared_ptr<CreateConditionalAccessPolicyRequest> request);
  CreateDomainResponse createDomainWithOptions(shared_ptr<CreateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDomainResponse createDomain(shared_ptr<CreateDomainRequest> request);
  CreateDomainProxyTokenResponse createDomainProxyTokenWithOptions(shared_ptr<CreateDomainProxyTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDomainProxyTokenResponse createDomainProxyToken(shared_ptr<CreateDomainProxyTokenRequest> request);
  CreateGroupResponse createGroupWithOptions(shared_ptr<CreateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateGroupResponse createGroup(shared_ptr<CreateGroupRequest> request);
  CreateIdentityProviderResponse createIdentityProviderWithOptions(shared_ptr<CreateIdentityProviderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIdentityProviderResponse createIdentityProvider(shared_ptr<CreateIdentityProviderRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateNetworkAccessEndpointResponse createNetworkAccessEndpointWithOptions(shared_ptr<CreateNetworkAccessEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNetworkAccessEndpointResponse createNetworkAccessEndpoint(shared_ptr<CreateNetworkAccessEndpointRequest> request);
  CreateOrganizationalUnitResponse createOrganizationalUnitWithOptions(shared_ptr<CreateOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrganizationalUnitResponse createOrganizationalUnit(shared_ptr<CreateOrganizationalUnitRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  DeleteApplicationResponse deleteApplicationWithOptions(shared_ptr<DeleteApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationResponse deleteApplication(shared_ptr<DeleteApplicationRequest> request);
  DeleteApplicationClientSecretResponse deleteApplicationClientSecretWithOptions(shared_ptr<DeleteApplicationClientSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationClientSecretResponse deleteApplicationClientSecret(shared_ptr<DeleteApplicationClientSecretRequest> request);
  DeleteConditionalAccessPolicyResponse deleteConditionalAccessPolicyWithOptions(shared_ptr<DeleteConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConditionalAccessPolicyResponse deleteConditionalAccessPolicy(shared_ptr<DeleteConditionalAccessPolicyRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteDomainProxyTokenResponse deleteDomainProxyTokenWithOptions(shared_ptr<DeleteDomainProxyTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainProxyTokenResponse deleteDomainProxyToken(shared_ptr<DeleteDomainProxyTokenRequest> request);
  DeleteGroupResponse deleteGroupWithOptions(shared_ptr<DeleteGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGroupResponse deleteGroup(shared_ptr<DeleteGroupRequest> request);
  DeleteIdentityProviderResponse deleteIdentityProviderWithOptions(shared_ptr<DeleteIdentityProviderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIdentityProviderResponse deleteIdentityProvider(shared_ptr<DeleteIdentityProviderRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteNetworkAccessEndpointResponse deleteNetworkAccessEndpointWithOptions(shared_ptr<DeleteNetworkAccessEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteNetworkAccessEndpointResponse deleteNetworkAccessEndpoint(shared_ptr<DeleteNetworkAccessEndpointRequest> request);
  DeleteOrganizationalUnitResponse deleteOrganizationalUnitWithOptions(shared_ptr<DeleteOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOrganizationalUnitResponse deleteOrganizationalUnit(shared_ptr<DeleteOrganizationalUnitRequest> request);
  DeleteOrganizationalUnitChildrenResponse deleteOrganizationalUnitChildrenWithOptions(shared_ptr<DeleteOrganizationalUnitChildrenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteOrganizationalUnitChildrenResponse deleteOrganizationalUnitChildren(shared_ptr<DeleteOrganizationalUnitChildrenRequest> request);
  DeleteUserResponse deleteUserWithOptions(shared_ptr<DeleteUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserResponse deleteUser(shared_ptr<DeleteUserRequest> request);
  DisableApplicationResponse disableApplicationWithOptions(shared_ptr<DisableApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationResponse disableApplication(shared_ptr<DisableApplicationRequest> request);
  DisableApplicationApiInvokeResponse disableApplicationApiInvokeWithOptions(shared_ptr<DisableApplicationApiInvokeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationApiInvokeResponse disableApplicationApiInvoke(shared_ptr<DisableApplicationApiInvokeRequest> request);
  DisableApplicationClientSecretResponse disableApplicationClientSecretWithOptions(shared_ptr<DisableApplicationClientSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationClientSecretResponse disableApplicationClientSecret(shared_ptr<DisableApplicationClientSecretRequest> request);
  DisableApplicationProvisioningResponse disableApplicationProvisioningWithOptions(shared_ptr<DisableApplicationProvisioningRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationProvisioningResponse disableApplicationProvisioning(shared_ptr<DisableApplicationProvisioningRequest> request);
  DisableApplicationSsoResponse disableApplicationSsoWithOptions(shared_ptr<DisableApplicationSsoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationSsoResponse disableApplicationSso(shared_ptr<DisableApplicationSsoRequest> request);
  DisableConditionalAccessPolicyResponse disableConditionalAccessPolicyWithOptions(shared_ptr<DisableConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableConditionalAccessPolicyResponse disableConditionalAccessPolicy(shared_ptr<DisableConditionalAccessPolicyRequest> request);
  DisableDomainProxyTokenResponse disableDomainProxyTokenWithOptions(shared_ptr<DisableDomainProxyTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableDomainProxyTokenResponse disableDomainProxyToken(shared_ptr<DisableDomainProxyTokenRequest> request);
  DisableIdentityProviderUdPullResponse disableIdentityProviderUdPullWithOptions(shared_ptr<DisableIdentityProviderUdPullRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableIdentityProviderUdPullResponse disableIdentityProviderUdPull(shared_ptr<DisableIdentityProviderUdPullRequest> request);
  DisableInitDomainAutoRedirectResponse disableInitDomainAutoRedirectWithOptions(shared_ptr<DisableInitDomainAutoRedirectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableInitDomainAutoRedirectResponse disableInitDomainAutoRedirect(shared_ptr<DisableInitDomainAutoRedirectRequest> request);
  DisableUserResponse disableUserWithOptions(shared_ptr<DisableUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableUserResponse disableUser(shared_ptr<DisableUserRequest> request);
  EnableApplicationResponse enableApplicationWithOptions(shared_ptr<EnableApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationResponse enableApplication(shared_ptr<EnableApplicationRequest> request);
  EnableApplicationApiInvokeResponse enableApplicationApiInvokeWithOptions(shared_ptr<EnableApplicationApiInvokeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationApiInvokeResponse enableApplicationApiInvoke(shared_ptr<EnableApplicationApiInvokeRequest> request);
  EnableApplicationClientSecretResponse enableApplicationClientSecretWithOptions(shared_ptr<EnableApplicationClientSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationClientSecretResponse enableApplicationClientSecret(shared_ptr<EnableApplicationClientSecretRequest> request);
  EnableApplicationProvisioningResponse enableApplicationProvisioningWithOptions(shared_ptr<EnableApplicationProvisioningRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationProvisioningResponse enableApplicationProvisioning(shared_ptr<EnableApplicationProvisioningRequest> request);
  EnableApplicationSsoResponse enableApplicationSsoWithOptions(shared_ptr<EnableApplicationSsoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationSsoResponse enableApplicationSso(shared_ptr<EnableApplicationSsoRequest> request);
  EnableConditionalAccessPolicyResponse enableConditionalAccessPolicyWithOptions(shared_ptr<EnableConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableConditionalAccessPolicyResponse enableConditionalAccessPolicy(shared_ptr<EnableConditionalAccessPolicyRequest> request);
  EnableDomainProxyTokenResponse enableDomainProxyTokenWithOptions(shared_ptr<EnableDomainProxyTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableDomainProxyTokenResponse enableDomainProxyToken(shared_ptr<EnableDomainProxyTokenRequest> request);
  EnableIdentityProviderUdPullResponse enableIdentityProviderUdPullWithOptions(shared_ptr<EnableIdentityProviderUdPullRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableIdentityProviderUdPullResponse enableIdentityProviderUdPull(shared_ptr<EnableIdentityProviderUdPullRequest> request);
  EnableInitDomainAutoRedirectResponse enableInitDomainAutoRedirectWithOptions(shared_ptr<EnableInitDomainAutoRedirectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableInitDomainAutoRedirectResponse enableInitDomainAutoRedirect(shared_ptr<EnableInitDomainAutoRedirectRequest> request);
  EnableUserResponse enableUserWithOptions(shared_ptr<EnableUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableUserResponse enableUser(shared_ptr<EnableUserRequest> request);
  GetApplicationResponse getApplicationWithOptions(shared_ptr<GetApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationResponse getApplication(shared_ptr<GetApplicationRequest> request);
  GetApplicationGrantScopeResponse getApplicationGrantScopeWithOptions(shared_ptr<GetApplicationGrantScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationGrantScopeResponse getApplicationGrantScope(shared_ptr<GetApplicationGrantScopeRequest> request);
  GetApplicationProvisioningConfigResponse getApplicationProvisioningConfigWithOptions(shared_ptr<GetApplicationProvisioningConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationProvisioningConfigResponse getApplicationProvisioningConfig(shared_ptr<GetApplicationProvisioningConfigRequest> request);
  GetApplicationProvisioningScopeResponse getApplicationProvisioningScopeWithOptions(shared_ptr<GetApplicationProvisioningScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationProvisioningScopeResponse getApplicationProvisioningScope(shared_ptr<GetApplicationProvisioningScopeRequest> request);
  GetApplicationSsoConfigResponse getApplicationSsoConfigWithOptions(shared_ptr<GetApplicationSsoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetApplicationSsoConfigResponse getApplicationSsoConfig(shared_ptr<GetApplicationSsoConfigRequest> request);
  GetConditionalAccessPolicyResponse getConditionalAccessPolicyWithOptions(shared_ptr<GetConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConditionalAccessPolicyResponse getConditionalAccessPolicy(shared_ptr<GetConditionalAccessPolicyRequest> request);
  GetDomainResponse getDomainWithOptions(shared_ptr<GetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDomainResponse getDomain(shared_ptr<GetDomainRequest> request);
  GetDomainDnsChallengeResponse getDomainDnsChallengeWithOptions(shared_ptr<GetDomainDnsChallengeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDomainDnsChallengeResponse getDomainDnsChallenge(shared_ptr<GetDomainDnsChallengeRequest> request);
  GetForgetPasswordConfigurationResponse getForgetPasswordConfigurationWithOptions(shared_ptr<GetForgetPasswordConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetForgetPasswordConfigurationResponse getForgetPasswordConfiguration(shared_ptr<GetForgetPasswordConfigurationRequest> request);
  GetGroupResponse getGroupWithOptions(shared_ptr<GetGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetGroupResponse getGroup(shared_ptr<GetGroupRequest> request);
  GetIdentityProviderResponse getIdentityProviderWithOptions(shared_ptr<GetIdentityProviderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIdentityProviderResponse getIdentityProvider(shared_ptr<GetIdentityProviderRequest> request);
  GetIdentityProviderUdPullConfigurationResponse getIdentityProviderUdPullConfigurationWithOptions(shared_ptr<GetIdentityProviderUdPullConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIdentityProviderUdPullConfigurationResponse getIdentityProviderUdPullConfiguration(shared_ptr<GetIdentityProviderUdPullConfigurationRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetInstanceLicenseResponse getInstanceLicenseWithOptions(shared_ptr<GetInstanceLicenseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceLicenseResponse getInstanceLicense(shared_ptr<GetInstanceLicenseRequest> request);
  GetNetworkAccessEndpointResponse getNetworkAccessEndpointWithOptions(shared_ptr<GetNetworkAccessEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNetworkAccessEndpointResponse getNetworkAccessEndpoint(shared_ptr<GetNetworkAccessEndpointRequest> request);
  GetOrganizationalUnitResponse getOrganizationalUnitWithOptions(shared_ptr<GetOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOrganizationalUnitResponse getOrganizationalUnit(shared_ptr<GetOrganizationalUnitRequest> request);
  GetPasswordComplexityConfigurationResponse getPasswordComplexityConfigurationWithOptions(shared_ptr<GetPasswordComplexityConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPasswordComplexityConfigurationResponse getPasswordComplexityConfiguration(shared_ptr<GetPasswordComplexityConfigurationRequest> request);
  GetPasswordExpirationConfigurationResponse getPasswordExpirationConfigurationWithOptions(shared_ptr<GetPasswordExpirationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPasswordExpirationConfigurationResponse getPasswordExpirationConfiguration(shared_ptr<GetPasswordExpirationConfigurationRequest> request);
  GetPasswordHistoryConfigurationResponse getPasswordHistoryConfigurationWithOptions(shared_ptr<GetPasswordHistoryConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPasswordHistoryConfigurationResponse getPasswordHistoryConfiguration(shared_ptr<GetPasswordHistoryConfigurationRequest> request);
  GetPasswordInitializationConfigurationResponse getPasswordInitializationConfigurationWithOptions(shared_ptr<GetPasswordInitializationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPasswordInitializationConfigurationResponse getPasswordInitializationConfiguration(shared_ptr<GetPasswordInitializationConfigurationRequest> request);
  GetRootOrganizationalUnitResponse getRootOrganizationalUnitWithOptions(shared_ptr<GetRootOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRootOrganizationalUnitResponse getRootOrganizationalUnit(shared_ptr<GetRootOrganizationalUnitRequest> request);
  GetSynchronizationJobResponse getSynchronizationJobWithOptions(shared_ptr<GetSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSynchronizationJobResponse getSynchronizationJob(shared_ptr<GetSynchronizationJobRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  ListApplicationClientSecretsResponse listApplicationClientSecretsWithOptions(shared_ptr<ListApplicationClientSecretsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationClientSecretsResponse listApplicationClientSecrets(shared_ptr<ListApplicationClientSecretsRequest> request);
  ListApplicationsResponse listApplicationsWithOptions(shared_ptr<ListApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsResponse listApplications(shared_ptr<ListApplicationsRequest> request);
  ListApplicationsForOrganizationalUnitResponse listApplicationsForOrganizationalUnitWithOptions(shared_ptr<ListApplicationsForOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsForOrganizationalUnitResponse listApplicationsForOrganizationalUnit(shared_ptr<ListApplicationsForOrganizationalUnitRequest> request);
  ListApplicationsForUserResponse listApplicationsForUserWithOptions(shared_ptr<ListApplicationsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationsForUserResponse listApplicationsForUser(shared_ptr<ListApplicationsForUserRequest> request);
  ListConditionalAccessPoliciesResponse listConditionalAccessPoliciesWithOptions(shared_ptr<ListConditionalAccessPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConditionalAccessPoliciesResponse listConditionalAccessPolicies(shared_ptr<ListConditionalAccessPoliciesRequest> request);
  ListConditionalAccessPoliciesForNetworkZoneResponse listConditionalAccessPoliciesForNetworkZoneWithOptions(shared_ptr<ListConditionalAccessPoliciesForNetworkZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConditionalAccessPoliciesForNetworkZoneResponse listConditionalAccessPoliciesForNetworkZone(shared_ptr<ListConditionalAccessPoliciesForNetworkZoneRequest> request);
  ListDomainProxyTokensResponse listDomainProxyTokensWithOptions(shared_ptr<ListDomainProxyTokensRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDomainProxyTokensResponse listDomainProxyTokens(shared_ptr<ListDomainProxyTokensRequest> request);
  ListDomainsResponse listDomainsWithOptions(shared_ptr<ListDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDomainsResponse listDomains(shared_ptr<ListDomainsRequest> request);
  ListEiamInstancesResponse listEiamInstancesWithOptions(shared_ptr<ListEiamInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEiamInstancesResponse listEiamInstances(shared_ptr<ListEiamInstancesRequest> request);
  ListEiamRegionsResponse listEiamRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEiamRegionsResponse listEiamRegions();
  ListGroupsResponse listGroupsWithOptions(shared_ptr<ListGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupsResponse listGroups(shared_ptr<ListGroupsRequest> request);
  ListGroupsForApplicationResponse listGroupsForApplicationWithOptions(shared_ptr<ListGroupsForApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupsForApplicationResponse listGroupsForApplication(shared_ptr<ListGroupsForApplicationRequest> request);
  ListGroupsForUserResponse listGroupsForUserWithOptions(shared_ptr<ListGroupsForUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListGroupsForUserResponse listGroupsForUser(shared_ptr<ListGroupsForUserRequest> request);
  ListIdentityProvidersResponse listIdentityProvidersWithOptions(shared_ptr<ListIdentityProvidersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIdentityProvidersResponse listIdentityProviders(shared_ptr<ListIdentityProvidersRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListNetworkAccessEndpointAvailableRegionsResponse listNetworkAccessEndpointAvailableRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworkAccessEndpointAvailableRegionsResponse listNetworkAccessEndpointAvailableRegions();
  ListNetworkAccessEndpointAvailableZonesResponse listNetworkAccessEndpointAvailableZonesWithOptions(shared_ptr<ListNetworkAccessEndpointAvailableZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworkAccessEndpointAvailableZonesResponse listNetworkAccessEndpointAvailableZones(shared_ptr<ListNetworkAccessEndpointAvailableZonesRequest> request);
  ListNetworkAccessEndpointsResponse listNetworkAccessEndpointsWithOptions(shared_ptr<ListNetworkAccessEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworkAccessEndpointsResponse listNetworkAccessEndpoints(shared_ptr<ListNetworkAccessEndpointsRequest> request);
  ListNetworkAccessPathsResponse listNetworkAccessPathsWithOptions(shared_ptr<ListNetworkAccessPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNetworkAccessPathsResponse listNetworkAccessPaths(shared_ptr<ListNetworkAccessPathsRequest> request);
  ListOrganizationalUnitParentsResponse listOrganizationalUnitParentsWithOptions(shared_ptr<ListOrganizationalUnitParentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrganizationalUnitParentsResponse listOrganizationalUnitParents(shared_ptr<ListOrganizationalUnitParentsRequest> request);
  ListOrganizationalUnitsResponse listOrganizationalUnitsWithOptions(shared_ptr<ListOrganizationalUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrganizationalUnitsResponse listOrganizationalUnits(shared_ptr<ListOrganizationalUnitsRequest> request);
  ListOrganizationalUnitsForApplicationResponse listOrganizationalUnitsForApplicationWithOptions(shared_ptr<ListOrganizationalUnitsForApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOrganizationalUnitsForApplicationResponse listOrganizationalUnitsForApplication(shared_ptr<ListOrganizationalUnitsForApplicationRequest> request);
  ListRegionsResponse listRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRegionsResponse listRegions();
  ListSynchronizationJobsResponse listSynchronizationJobsWithOptions(shared_ptr<ListSynchronizationJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSynchronizationJobsResponse listSynchronizationJobs(shared_ptr<ListSynchronizationJobsRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  ListUsersForApplicationResponse listUsersForApplicationWithOptions(shared_ptr<ListUsersForApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersForApplicationResponse listUsersForApplication(shared_ptr<ListUsersForApplicationRequest> request);
  ListUsersForGroupResponse listUsersForGroupWithOptions(shared_ptr<ListUsersForGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersForGroupResponse listUsersForGroup(shared_ptr<ListUsersForGroupRequest> request);
  ObtainApplicationClientSecretResponse obtainApplicationClientSecretWithOptions(shared_ptr<ObtainApplicationClientSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ObtainApplicationClientSecretResponse obtainApplicationClientSecret(shared_ptr<ObtainApplicationClientSecretRequest> request);
  ObtainDomainProxyTokenResponse obtainDomainProxyTokenWithOptions(shared_ptr<ObtainDomainProxyTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ObtainDomainProxyTokenResponse obtainDomainProxyToken(shared_ptr<ObtainDomainProxyTokenRequest> request);
  RemoveUserFromOrganizationalUnitsResponse removeUserFromOrganizationalUnitsWithOptions(shared_ptr<RemoveUserFromOrganizationalUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUserFromOrganizationalUnitsResponse removeUserFromOrganizationalUnits(shared_ptr<RemoveUserFromOrganizationalUnitsRequest> request);
  RemoveUsersFromGroupResponse removeUsersFromGroupWithOptions(shared_ptr<RemoveUsersFromGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersFromGroupResponse removeUsersFromGroup(shared_ptr<RemoveUsersFromGroupRequest> request);
  RevokeApplicationFromGroupsResponse revokeApplicationFromGroupsWithOptions(shared_ptr<RevokeApplicationFromGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeApplicationFromGroupsResponse revokeApplicationFromGroups(shared_ptr<RevokeApplicationFromGroupsRequest> request);
  RevokeApplicationFromOrganizationalUnitsResponse revokeApplicationFromOrganizationalUnitsWithOptions(shared_ptr<RevokeApplicationFromOrganizationalUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeApplicationFromOrganizationalUnitsResponse revokeApplicationFromOrganizationalUnits(shared_ptr<RevokeApplicationFromOrganizationalUnitsRequest> request);
  RevokeApplicationFromUsersResponse revokeApplicationFromUsersWithOptions(shared_ptr<RevokeApplicationFromUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeApplicationFromUsersResponse revokeApplicationFromUsers(shared_ptr<RevokeApplicationFromUsersRequest> request);
  RunSynchronizationJobResponse runSynchronizationJobWithOptions(shared_ptr<RunSynchronizationJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunSynchronizationJobResponse runSynchronizationJob(shared_ptr<RunSynchronizationJobRequest> request);
  SetApplicationGrantScopeResponse setApplicationGrantScopeWithOptions(shared_ptr<SetApplicationGrantScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApplicationGrantScopeResponse setApplicationGrantScope(shared_ptr<SetApplicationGrantScopeRequest> request);
  SetApplicationProvisioningConfigResponse setApplicationProvisioningConfigWithOptions(shared_ptr<SetApplicationProvisioningConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApplicationProvisioningConfigResponse setApplicationProvisioningConfig(shared_ptr<SetApplicationProvisioningConfigRequest> request);
  SetApplicationProvisioningScopeResponse setApplicationProvisioningScopeWithOptions(shared_ptr<SetApplicationProvisioningScopeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApplicationProvisioningScopeResponse setApplicationProvisioningScope(shared_ptr<SetApplicationProvisioningScopeRequest> request);
  SetApplicationSsoConfigResponse setApplicationSsoConfigWithOptions(shared_ptr<SetApplicationSsoConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApplicationSsoConfigResponse setApplicationSsoConfig(shared_ptr<SetApplicationSsoConfigRequest> request);
  SetDefaultDomainResponse setDefaultDomainWithOptions(shared_ptr<SetDefaultDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDefaultDomainResponse setDefaultDomain(shared_ptr<SetDefaultDomainRequest> request);
  SetForgetPasswordConfigurationResponse setForgetPasswordConfigurationWithOptions(shared_ptr<SetForgetPasswordConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetForgetPasswordConfigurationResponse setForgetPasswordConfiguration(shared_ptr<SetForgetPasswordConfigurationRequest> request);
  SetIdentityProviderUdPullConfigurationResponse setIdentityProviderUdPullConfigurationWithOptions(shared_ptr<SetIdentityProviderUdPullConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetIdentityProviderUdPullConfigurationResponse setIdentityProviderUdPullConfiguration(shared_ptr<SetIdentityProviderUdPullConfigurationRequest> request);
  SetPasswordComplexityConfigurationResponse setPasswordComplexityConfigurationWithOptions(shared_ptr<SetPasswordComplexityConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPasswordComplexityConfigurationResponse setPasswordComplexityConfiguration(shared_ptr<SetPasswordComplexityConfigurationRequest> request);
  SetPasswordExpirationConfigurationResponse setPasswordExpirationConfigurationWithOptions(shared_ptr<SetPasswordExpirationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPasswordExpirationConfigurationResponse setPasswordExpirationConfiguration(shared_ptr<SetPasswordExpirationConfigurationRequest> request);
  SetPasswordHistoryConfigurationResponse setPasswordHistoryConfigurationWithOptions(shared_ptr<SetPasswordHistoryConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPasswordHistoryConfigurationResponse setPasswordHistoryConfiguration(shared_ptr<SetPasswordHistoryConfigurationRequest> request);
  SetPasswordInitializationConfigurationResponse setPasswordInitializationConfigurationWithOptions(shared_ptr<SetPasswordInitializationConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetPasswordInitializationConfigurationResponse setPasswordInitializationConfiguration(shared_ptr<SetPasswordInitializationConfigurationRequest> request);
  SetUserPrimaryOrganizationalUnitResponse setUserPrimaryOrganizationalUnitWithOptions(shared_ptr<SetUserPrimaryOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetUserPrimaryOrganizationalUnitResponse setUserPrimaryOrganizationalUnit(shared_ptr<SetUserPrimaryOrganizationalUnitRequest> request);
  UnlockUserResponse unlockUserWithOptions(shared_ptr<UnlockUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockUserResponse unlockUser(shared_ptr<UnlockUserRequest> request);
  UpdateApplicationAuthorizationTypeResponse updateApplicationAuthorizationTypeWithOptions(shared_ptr<UpdateApplicationAuthorizationTypeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationAuthorizationTypeResponse updateApplicationAuthorizationType(shared_ptr<UpdateApplicationAuthorizationTypeRequest> request);
  UpdateApplicationDescriptionResponse updateApplicationDescriptionWithOptions(shared_ptr<UpdateApplicationDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationDescriptionResponse updateApplicationDescription(shared_ptr<UpdateApplicationDescriptionRequest> request);
  UpdateConditionalAccessPolicyResponse updateConditionalAccessPolicyWithOptions(shared_ptr<UpdateConditionalAccessPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConditionalAccessPolicyResponse updateConditionalAccessPolicy(shared_ptr<UpdateConditionalAccessPolicyRequest> request);
  UpdateConditionalAccessPolicyDescriptionResponse updateConditionalAccessPolicyDescriptionWithOptions(shared_ptr<UpdateConditionalAccessPolicyDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConditionalAccessPolicyDescriptionResponse updateConditionalAccessPolicyDescription(shared_ptr<UpdateConditionalAccessPolicyDescriptionRequest> request);
  UpdateGroupResponse updateGroupWithOptions(shared_ptr<UpdateGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGroupResponse updateGroup(shared_ptr<UpdateGroupRequest> request);
  UpdateGroupDescriptionResponse updateGroupDescriptionWithOptions(shared_ptr<UpdateGroupDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGroupDescriptionResponse updateGroupDescription(shared_ptr<UpdateGroupDescriptionRequest> request);
  UpdateIdentityProviderResponse updateIdentityProviderWithOptions(shared_ptr<UpdateIdentityProviderRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIdentityProviderResponse updateIdentityProvider(shared_ptr<UpdateIdentityProviderRequest> request);
  UpdateInstanceDescriptionResponse updateInstanceDescriptionWithOptions(shared_ptr<UpdateInstanceDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceDescriptionResponse updateInstanceDescription(shared_ptr<UpdateInstanceDescriptionRequest> request);
  UpdateNetworkAccessEndpointNameResponse updateNetworkAccessEndpointNameWithOptions(shared_ptr<UpdateNetworkAccessEndpointNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateNetworkAccessEndpointNameResponse updateNetworkAccessEndpointName(shared_ptr<UpdateNetworkAccessEndpointNameRequest> request);
  UpdateOrganizationalUnitResponse updateOrganizationalUnitWithOptions(shared_ptr<UpdateOrganizationalUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOrganizationalUnitResponse updateOrganizationalUnit(shared_ptr<UpdateOrganizationalUnitRequest> request);
  UpdateOrganizationalUnitDescriptionResponse updateOrganizationalUnitDescriptionWithOptions(shared_ptr<UpdateOrganizationalUnitDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOrganizationalUnitDescriptionResponse updateOrganizationalUnitDescription(shared_ptr<UpdateOrganizationalUnitDescriptionRequest> request);
  UpdateOrganizationalUnitParentIdResponse updateOrganizationalUnitParentIdWithOptions(shared_ptr<UpdateOrganizationalUnitParentIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateOrganizationalUnitParentIdResponse updateOrganizationalUnitParentId(shared_ptr<UpdateOrganizationalUnitParentIdRequest> request);
  UpdateUserResponse updateUserWithOptions(shared_ptr<UpdateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserResponse updateUser(shared_ptr<UpdateUserRequest> request);
  UpdateUserDescriptionResponse updateUserDescriptionWithOptions(shared_ptr<UpdateUserDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserDescriptionResponse updateUserDescription(shared_ptr<UpdateUserDescriptionRequest> request);
  UpdateUserPasswordResponse updateUserPasswordWithOptions(shared_ptr<UpdateUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserPasswordResponse updateUserPassword(shared_ptr<UpdateUserPasswordRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Eiam20211201

#endif
