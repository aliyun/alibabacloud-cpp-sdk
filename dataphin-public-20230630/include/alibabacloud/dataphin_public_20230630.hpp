// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_DATAPHIN-PUBLIC20230630_H_
#define ALIBABACLOUD_DATAPHIN-PUBLIC20230630_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Dataphin-public20230630 {
class AddTenantMembersRequestAddCommandUserList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<vector<string>> roleList{};

  AddTenantMembersRequestAddCommandUserList() {}

  explicit AddTenantMembersRequestAddCommandUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (roleList) {
      res["RoleList"] = boost::any(*roleList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddTenantMembersRequestAddCommandUserList() = default;
};
class AddTenantMembersRequestAddCommand : public Darabonba::Model {
public:
  shared_ptr<vector<AddTenantMembersRequestAddCommandUserList>> userList{};

  AddTenantMembersRequestAddCommand() {}

  explicit AddTenantMembersRequestAddCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<AddTenantMembersRequestAddCommandUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTenantMembersRequestAddCommandUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<AddTenantMembersRequestAddCommandUserList>>(expect1);
      }
    }
  }


  virtual ~AddTenantMembersRequestAddCommand() = default;
};
class AddTenantMembersRequest : public Darabonba::Model {
public:
  shared_ptr<AddTenantMembersRequestAddCommand> addCommand{};
  shared_ptr<long> opTenantId{};

  AddTenantMembersRequest() {}

  explicit AddTenantMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommand) {
      res["AddCommand"] = addCommand ? boost::any(addCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddCommand"].type()) {
        AddTenantMembersRequestAddCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddCommand"]));
        addCommand = make_shared<AddTenantMembersRequestAddCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddTenantMembersRequest() = default;
};
class AddTenantMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addCommandShrink{};
  shared_ptr<long> opTenantId{};

  AddTenantMembersShrinkRequest() {}

  explicit AddTenantMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommandShrink) {
      res["AddCommand"] = boost::any(*addCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      addCommandShrink = make_shared<string>(boost::any_cast<string>(m["AddCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddTenantMembersShrinkRequest() = default;
};
class AddTenantMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddTenantMembersResponseBody() {}

  explicit AddTenantMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddTenantMembersResponseBody() = default;
};
class AddTenantMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTenantMembersResponseBody> body{};

  AddTenantMembersResponse() {}

  explicit AddTenantMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTenantMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTenantMembersResponseBody>(model1);
      }
    }
  }


  virtual ~AddTenantMembersResponse() = default;
};
class AddTenantMembersBySourceUserRequestAddCommandSourceUserList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> dingNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> mail{};
  shared_ptr<string> mobilePhone{};
  shared_ptr<string> sourceId{};

  AddTenantMembersBySourceUserRequestAddCommandSourceUserList() {}

  explicit AddTenantMembersBySourceUserRequestAddCommandSourceUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (dingNumber) {
      res["DingNumber"] = boost::any(*dingNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (mobilePhone) {
      res["MobilePhone"] = boost::any(*mobilePhone);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DingNumber") != m.end() && !m["DingNumber"].empty()) {
      dingNumber = make_shared<string>(boost::any_cast<string>(m["DingNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("MobilePhone") != m.end() && !m["MobilePhone"].empty()) {
      mobilePhone = make_shared<string>(boost::any_cast<string>(m["MobilePhone"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
  }


  virtual ~AddTenantMembersBySourceUserRequestAddCommandSourceUserList() = default;
};
class AddTenantMembersBySourceUserRequestAddCommand : public Darabonba::Model {
public:
  shared_ptr<vector<AddTenantMembersBySourceUserRequestAddCommandSourceUserList>> sourceUserList{};

  AddTenantMembersBySourceUserRequestAddCommand() {}

  explicit AddTenantMembersBySourceUserRequestAddCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceUserList) {
      vector<boost::any> temp1;
      for(auto item1:*sourceUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceUserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceUserList") != m.end() && !m["SourceUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceUserList"].type()) {
        vector<AddTenantMembersBySourceUserRequestAddCommandSourceUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddTenantMembersBySourceUserRequestAddCommandSourceUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceUserList = make_shared<vector<AddTenantMembersBySourceUserRequestAddCommandSourceUserList>>(expect1);
      }
    }
  }


  virtual ~AddTenantMembersBySourceUserRequestAddCommand() = default;
};
class AddTenantMembersBySourceUserRequest : public Darabonba::Model {
public:
  shared_ptr<AddTenantMembersBySourceUserRequestAddCommand> addCommand{};
  shared_ptr<long> opTenantId{};

  AddTenantMembersBySourceUserRequest() {}

  explicit AddTenantMembersBySourceUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommand) {
      res["AddCommand"] = addCommand ? boost::any(addCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddCommand"].type()) {
        AddTenantMembersBySourceUserRequestAddCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddCommand"]));
        addCommand = make_shared<AddTenantMembersBySourceUserRequestAddCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddTenantMembersBySourceUserRequest() = default;
};
class AddTenantMembersBySourceUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addCommandShrink{};
  shared_ptr<long> opTenantId{};

  AddTenantMembersBySourceUserShrinkRequest() {}

  explicit AddTenantMembersBySourceUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommandShrink) {
      res["AddCommand"] = boost::any(*addCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      addCommandShrink = make_shared<string>(boost::any_cast<string>(m["AddCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddTenantMembersBySourceUserShrinkRequest() = default;
};
class AddTenantMembersBySourceUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddTenantMembersBySourceUserResponseBody() {}

  explicit AddTenantMembersBySourceUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddTenantMembersBySourceUserResponseBody() = default;
};
class AddTenantMembersBySourceUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTenantMembersBySourceUserResponseBody> body{};

  AddTenantMembersBySourceUserResponse() {}

  explicit AddTenantMembersBySourceUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTenantMembersBySourceUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTenantMembersBySourceUserResponseBody>(model1);
      }
    }
  }


  virtual ~AddTenantMembersBySourceUserResponse() = default;
};
class AddUserGroupMemberRequestAddCommand : public Darabonba::Model {
public:
  shared_ptr<string> userGroupId{};
  shared_ptr<vector<string>> userIdList{};

  AddUserGroupMemberRequestAddCommand() {}

  explicit AddUserGroupMemberRequestAddCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddUserGroupMemberRequestAddCommand() = default;
};
class AddUserGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<AddUserGroupMemberRequestAddCommand> addCommand{};
  shared_ptr<long> opTenantId{};

  AddUserGroupMemberRequest() {}

  explicit AddUserGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommand) {
      res["AddCommand"] = addCommand ? boost::any(addCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["AddCommand"].type()) {
        AddUserGroupMemberRequestAddCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AddCommand"]));
        addCommand = make_shared<AddUserGroupMemberRequestAddCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddUserGroupMemberRequest() = default;
};
class AddUserGroupMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addCommandShrink{};
  shared_ptr<long> opTenantId{};

  AddUserGroupMemberShrinkRequest() {}

  explicit AddUserGroupMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addCommandShrink) {
      res["AddCommand"] = boost::any(*addCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddCommand") != m.end() && !m["AddCommand"].empty()) {
      addCommandShrink = make_shared<string>(boost::any_cast<string>(m["AddCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~AddUserGroupMemberShrinkRequest() = default;
};
class AddUserGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AddUserGroupMemberResponseBody() {}

  explicit AddUserGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddUserGroupMemberResponseBody() = default;
};
class AddUserGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUserGroupMemberResponseBody> body{};

  AddUserGroupMemberResponse() {}

  explicit AddUserGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUserGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUserGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~AddUserGroupMemberResponse() = default;
};
class CheckDataSourceConnectivityRequestCheckCommandConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CheckDataSourceConnectivityRequestCheckCommandConfigItemList() {}

  explicit CheckDataSourceConnectivityRequestCheckCommandConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CheckDataSourceConnectivityRequestCheckCommandConfigItemList() = default;
};
class CheckDataSourceConnectivityRequestCheckCommand : public Darabonba::Model {
public:
  shared_ptr<vector<CheckDataSourceConnectivityRequestCheckCommandConfigItemList>> configItemList{};
  shared_ptr<string> type{};

  CheckDataSourceConnectivityRequestCheckCommand() {}

  explicit CheckDataSourceConnectivityRequestCheckCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<CheckDataSourceConnectivityRequestCheckCommandConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckDataSourceConnectivityRequestCheckCommandConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<CheckDataSourceConnectivityRequestCheckCommandConfigItemList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CheckDataSourceConnectivityRequestCheckCommand() = default;
};
class CheckDataSourceConnectivityRequest : public Darabonba::Model {
public:
  shared_ptr<CheckDataSourceConnectivityRequestCheckCommand> checkCommand{};
  shared_ptr<long> opTenantId{};

  CheckDataSourceConnectivityRequest() {}

  explicit CheckDataSourceConnectivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCommand) {
      res["CheckCommand"] = checkCommand ? boost::any(checkCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCommand") != m.end() && !m["CheckCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckCommand"].type()) {
        CheckDataSourceConnectivityRequestCheckCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckCommand"]));
        checkCommand = make_shared<CheckDataSourceConnectivityRequestCheckCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CheckDataSourceConnectivityRequest() = default;
};
class CheckDataSourceConnectivityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkCommandShrink{};
  shared_ptr<long> opTenantId{};

  CheckDataSourceConnectivityShrinkRequest() {}

  explicit CheckDataSourceConnectivityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCommandShrink) {
      res["CheckCommand"] = boost::any(*checkCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCommand") != m.end() && !m["CheckCommand"].empty()) {
      checkCommandShrink = make_shared<string>(boost::any_cast<string>(m["CheckCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CheckDataSourceConnectivityShrinkRequest() = default;
};
class CheckDataSourceConnectivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CheckDataSourceConnectivityResponseBody() {}

  explicit CheckDataSourceConnectivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckDataSourceConnectivityResponseBody() = default;
};
class CheckDataSourceConnectivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckDataSourceConnectivityResponseBody> body{};

  CheckDataSourceConnectivityResponse() {}

  explicit CheckDataSourceConnectivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckDataSourceConnectivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckDataSourceConnectivityResponseBody>(model1);
      }
    }
  }


  virtual ~CheckDataSourceConnectivityResponse() = default;
};
class CheckDataSourceConnectivityByIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  CheckDataSourceConnectivityByIdRequest() {}

  explicit CheckDataSourceConnectivityByIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CheckDataSourceConnectivityByIdRequest() = default;
};
class CheckDataSourceConnectivityByIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CheckDataSourceConnectivityByIdResponseBody() {}

  explicit CheckDataSourceConnectivityByIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckDataSourceConnectivityByIdResponseBody() = default;
};
class CheckDataSourceConnectivityByIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckDataSourceConnectivityByIdResponseBody> body{};

  CheckDataSourceConnectivityByIdResponse() {}

  explicit CheckDataSourceConnectivityByIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckDataSourceConnectivityByIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckDataSourceConnectivityByIdResponseBody>(model1);
      }
    }
  }


  virtual ~CheckDataSourceConnectivityByIdResponse() = default;
};
class CheckResourcePermissionRequestCheckCommandResourceList : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};

  CheckResourcePermissionRequestCheckCommandResourceList() {}

  explicit CheckResourcePermissionRequestCheckCommandResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~CheckResourcePermissionRequestCheckCommandResourceList() = default;
};
class CheckResourcePermissionRequestCheckCommand : public Darabonba::Model {
public:
  shared_ptr<string> operate{};
  shared_ptr<vector<CheckResourcePermissionRequestCheckCommandResourceList>> resourceList{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> userId{};

  CheckResourcePermissionRequestCheckCommand() {}

  explicit CheckResourcePermissionRequestCheckCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operate) {
      res["Operate"] = boost::any(*operate);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operate") != m.end() && !m["Operate"].empty()) {
      operate = make_shared<string>(boost::any_cast<string>(m["Operate"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<CheckResourcePermissionRequestCheckCommandResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckResourcePermissionRequestCheckCommandResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<CheckResourcePermissionRequestCheckCommandResourceList>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CheckResourcePermissionRequestCheckCommand() = default;
};
class CheckResourcePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<CheckResourcePermissionRequestCheckCommand> checkCommand{};
  shared_ptr<long> opTenantId{};

  CheckResourcePermissionRequest() {}

  explicit CheckResourcePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCommand) {
      res["CheckCommand"] = checkCommand ? boost::any(checkCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCommand") != m.end() && !m["CheckCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CheckCommand"].type()) {
        CheckResourcePermissionRequestCheckCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CheckCommand"]));
        checkCommand = make_shared<CheckResourcePermissionRequestCheckCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CheckResourcePermissionRequest() = default;
};
class CheckResourcePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkCommandShrink{};
  shared_ptr<long> opTenantId{};

  CheckResourcePermissionShrinkRequest() {}

  explicit CheckResourcePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkCommandShrink) {
      res["CheckCommand"] = boost::any(*checkCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckCommand") != m.end() && !m["CheckCommand"].empty()) {
      checkCommandShrink = make_shared<string>(boost::any_cast<string>(m["CheckCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CheckResourcePermissionShrinkRequest() = default;
};
class CheckResourcePermissionResponseBodyResourcePermissionList : public Darabonba::Model {
public:
  shared_ptr<bool> hasPermission{};
  shared_ptr<string> resourceId{};

  CheckResourcePermissionResponseBodyResourcePermissionList() {}

  explicit CheckResourcePermissionResponseBodyResourcePermissionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hasPermission) {
      res["HasPermission"] = boost::any(*hasPermission);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HasPermission") != m.end() && !m["HasPermission"].empty()) {
      hasPermission = make_shared<bool>(boost::any_cast<bool>(m["HasPermission"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~CheckResourcePermissionResponseBodyResourcePermissionList() = default;
};
class CheckResourcePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<CheckResourcePermissionResponseBodyResourcePermissionList>> resourcePermissionList{};
  shared_ptr<bool> success{};

  CheckResourcePermissionResponseBody() {}

  explicit CheckResourcePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourcePermissionList) {
      vector<boost::any> temp1;
      for(auto item1:*resourcePermissionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourcePermissionList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourcePermissionList") != m.end() && !m["ResourcePermissionList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourcePermissionList"].type()) {
        vector<CheckResourcePermissionResponseBodyResourcePermissionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourcePermissionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CheckResourcePermissionResponseBodyResourcePermissionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourcePermissionList = make_shared<vector<CheckResourcePermissionResponseBodyResourcePermissionList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckResourcePermissionResponseBody() = default;
};
class CheckResourcePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckResourcePermissionResponseBody> body{};

  CheckResourcePermissionResponse() {}

  explicit CheckResourcePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckResourcePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckResourcePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~CheckResourcePermissionResponse() = default;
};
class CreateAdHocFileRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> directory{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  CreateAdHocFileRequestCreateCommand() {}

  explicit CreateAdHocFileRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~CreateAdHocFileRequestCreateCommand() = default;
};
class CreateAdHocFileRequest : public Darabonba::Model {
public:
  shared_ptr<CreateAdHocFileRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateAdHocFileRequest() {}

  explicit CreateAdHocFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateAdHocFileRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateAdHocFileRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateAdHocFileRequest() = default;
};
class CreateAdHocFileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateAdHocFileShrinkRequest() {}

  explicit CreateAdHocFileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateAdHocFileShrinkRequest() = default;
};
class CreateAdHocFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> fileId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateAdHocFileResponseBody() {}

  explicit CreateAdHocFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAdHocFileResponseBody() = default;
};
class CreateAdHocFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAdHocFileResponseBody> body{};

  CreateAdHocFileResponse() {}

  explicit CreateAdHocFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAdHocFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAdHocFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAdHocFileResponse() = default;
};
class CreateBatchTaskRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<string> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<string> description{};
  shared_ptr<string> directory{};
  shared_ptr<string> engine{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> pythonModuleList{};
  shared_ptr<long> scheduleType{};
  shared_ptr<long> taskType{};

  CreateBatchTaskRequestCreateCommand() {}

  explicit CreateBatchTaskRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pythonModuleList) {
      res["PythonModuleList"] = boost::any(*pythonModuleList);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<string>(boost::any_cast<string>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PythonModuleList") != m.end() && !m["PythonModuleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PythonModuleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PythonModuleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pythonModuleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<long>(boost::any_cast<long>(m["ScheduleType"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
  }


  virtual ~CreateBatchTaskRequestCreateCommand() = default;
};
class CreateBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CreateBatchTaskRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateBatchTaskRequest() {}

  explicit CreateBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateBatchTaskRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateBatchTaskRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBatchTaskRequest() = default;
};
class CreateBatchTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateBatchTaskShrinkRequest() {}

  explicit CreateBatchTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBatchTaskShrinkRequest() = default;
};
class CreateBatchTaskResponseBodyCreateResult : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};

  CreateBatchTaskResponseBodyCreateResult() {}

  explicit CreateBatchTaskResponseBodyCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~CreateBatchTaskResponseBodyCreateResult() = default;
};
class CreateBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateBatchTaskResponseBodyCreateResult> createResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBatchTaskResponseBody() {}

  explicit CreateBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResult) {
      res["CreateResult"] = createResult ? boost::any(createResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResult") != m.end() && !m["CreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResult"].type()) {
        CreateBatchTaskResponseBodyCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResult"]));
        createResult = make_shared<CreateBatchTaskResponseBodyCreateResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBatchTaskResponseBody() = default;
};
class CreateBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBatchTaskResponseBody> body{};

  CreateBatchTaskResponse() {}

  explicit CreateBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBatchTaskResponse() = default;
};
class CreateBizEntityRequestCreateCommandBizObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<string> type{};

  CreateBizEntityRequestCreateCommandBizObject() {}

  explicit CreateBizEntityRequestCreateCommandBizObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateBizEntityRequestCreateCommandBizObject() = default;
};
class CreateBizEntityRequestCreateCommandBizProcess : public Darabonba::Model {
public:
  shared_ptr<vector<long>> bizEventEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<long>> preBizProcessIdList{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<string> type{};

  CreateBizEntityRequestCreateCommandBizProcess() {}

  explicit CreateBizEntityRequestCreateCommandBizProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEventEntityIdList) {
      res["BizEventEntityIdList"] = boost::any(*bizEventEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (preBizProcessIdList) {
      res["PreBizProcessIdList"] = boost::any(*preBizProcessIdList);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEventEntityIdList") != m.end() && !m["BizEventEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizEventEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizEventEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizEventEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PreBizProcessIdList") != m.end() && !m["PreBizProcessIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PreBizProcessIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreBizProcessIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      preBizProcessIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateBizEntityRequestCreateCommandBizProcess() = default;
};
class CreateBizEntityRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<CreateBizEntityRequestCreateCommandBizObject> bizObject{};
  shared_ptr<CreateBizEntityRequestCreateCommandBizProcess> bizProcess{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<string> type{};

  CreateBizEntityRequestCreateCommand() {}

  explicit CreateBizEntityRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizObject) {
      res["BizObject"] = bizObject ? boost::any(bizObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizProcess) {
      res["BizProcess"] = bizProcess ? boost::any(bizProcess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizObject") != m.end() && !m["BizObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizObject"].type()) {
        CreateBizEntityRequestCreateCommandBizObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizObject"]));
        bizObject = make_shared<CreateBizEntityRequestCreateCommandBizObject>(model1);
      }
    }
    if (m.find("BizProcess") != m.end() && !m["BizProcess"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizProcess"].type()) {
        CreateBizEntityRequestCreateCommandBizProcess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizProcess"]));
        bizProcess = make_shared<CreateBizEntityRequestCreateCommandBizProcess>(model1);
      }
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateBizEntityRequestCreateCommand() = default;
};
class CreateBizEntityRequest : public Darabonba::Model {
public:
  shared_ptr<CreateBizEntityRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateBizEntityRequest() {}

  explicit CreateBizEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateBizEntityRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateBizEntityRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBizEntityRequest() = default;
};
class CreateBizEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateBizEntityShrinkRequest() {}

  explicit CreateBizEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBizEntityShrinkRequest() = default;
};
class CreateBizEntityResponseBodyCreateResult : public Darabonba::Model {
public:
  shared_ptr<long> bizEntityId{};

  CreateBizEntityResponseBodyCreateResult() {}

  explicit CreateBizEntityResponseBodyCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEntityId) {
      res["BizEntityId"] = boost::any(*bizEntityId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEntityId") != m.end() && !m["BizEntityId"].empty()) {
      bizEntityId = make_shared<long>(boost::any_cast<long>(m["BizEntityId"]));
    }
  }


  virtual ~CreateBizEntityResponseBodyCreateResult() = default;
};
class CreateBizEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateBizEntityResponseBodyCreateResult> createResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBizEntityResponseBody() {}

  explicit CreateBizEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResult) {
      res["CreateResult"] = createResult ? boost::any(createResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResult") != m.end() && !m["CreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResult"].type()) {
        CreateBizEntityResponseBodyCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResult"]));
        createResult = make_shared<CreateBizEntityResponseBodyCreateResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBizEntityResponseBody() = default;
};
class CreateBizEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBizEntityResponseBody> body{};

  CreateBizEntityResponse() {}

  explicit CreateBizEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBizEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBizEntityResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBizEntityResponse() = default;
};
class CreateBizUnitRequestCreateCommandBizUnitAccountList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  CreateBizUnitRequestCreateCommandBizUnitAccountList() {}

  explicit CreateBizUnitRequestCreateCommandBizUnitAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CreateBizUnitRequestCreateCommandBizUnitAccountList() = default;
};
class CreateBizUnitRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<CreateBizUnitRequestCreateCommandBizUnitAccountList>> bizUnitAccountList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> icon{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};

  CreateBizUnitRequestCreateCommand() {}

  explicit CreateBizUnitRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitAccountList) {
      vector<boost::any> temp1;
      for(auto item1:*bizUnitAccountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizUnitAccountList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitAccountList") != m.end() && !m["BizUnitAccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["BizUnitAccountList"].type()) {
        vector<CreateBizUnitRequestCreateCommandBizUnitAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizUnitAccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBizUnitRequestCreateCommandBizUnitAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizUnitAccountList = make_shared<vector<CreateBizUnitRequestCreateCommandBizUnitAccountList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateBizUnitRequestCreateCommand() = default;
};
class CreateBizUnitRequest : public Darabonba::Model {
public:
  shared_ptr<CreateBizUnitRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateBizUnitRequest() {}

  explicit CreateBizUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateBizUnitRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateBizUnitRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBizUnitRequest() = default;
};
class CreateBizUnitShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateBizUnitShrinkRequest() {}

  explicit CreateBizUnitShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateBizUnitShrinkRequest() = default;
};
class CreateBizUnitResponseBodyCreateResult : public Darabonba::Model {
public:
  shared_ptr<long> bizUnitId{};

  CreateBizUnitResponseBodyCreateResult() {}

  explicit CreateBizUnitResponseBodyCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
  }


  virtual ~CreateBizUnitResponseBodyCreateResult() = default;
};
class CreateBizUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateBizUnitResponseBodyCreateResult> createResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateBizUnitResponseBody() {}

  explicit CreateBizUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResult) {
      res["CreateResult"] = createResult ? boost::any(createResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResult") != m.end() && !m["CreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResult"].type()) {
        CreateBizUnitResponseBodyCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResult"]));
        createResult = make_shared<CreateBizUnitResponseBodyCreateResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateBizUnitResponseBody() = default;
};
class CreateBizUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBizUnitResponseBody> body{};

  CreateBizUnitResponse() {}

  explicit CreateBizUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBizUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBizUnitResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBizUnitResponse() = default;
};
class CreateDataDomainRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<string> abbreviation{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};

  CreateDataDomainRequestCreateCommand() {}

  explicit CreateDataDomainRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbreviation) {
      res["Abbreviation"] = boost::any(*abbreviation);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbreviation") != m.end() && !m["Abbreviation"].empty()) {
      abbreviation = make_shared<string>(boost::any_cast<string>(m["Abbreviation"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~CreateDataDomainRequestCreateCommand() = default;
};
class CreateDataDomainRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataDomainRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateDataDomainRequest() {}

  explicit CreateDataDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateDataDomainRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateDataDomainRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataDomainRequest() = default;
};
class CreateDataDomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateDataDomainShrinkRequest() {}

  explicit CreateDataDomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataDomainShrinkRequest() = default;
};
class CreateDataDomainResponseBodyCreateResult : public Darabonba::Model {
public:
  shared_ptr<long> dataDomainId{};

  CreateDataDomainResponseBodyCreateResult() {}

  explicit CreateDataDomainResponseBodyCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
  }


  virtual ~CreateDataDomainResponseBodyCreateResult() = default;
};
class CreateDataDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDataDomainResponseBodyCreateResult> createResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataDomainResponseBody() {}

  explicit CreateDataDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResult) {
      res["CreateResult"] = createResult ? boost::any(createResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResult") != m.end() && !m["CreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResult"].type()) {
        CreateDataDomainResponseBodyCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResult"]));
        createResult = make_shared<CreateDataDomainResponseBodyCreateResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataDomainResponseBody() = default;
};
class CreateDataDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataDomainResponseBody> body{};

  CreateDataDomainResponse() {}

  explicit CreateDataDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataDomainResponse() = default;
};
class CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<bool> isRequiredParameter{};
  shared_ptr<string> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> parameterValueType{};

  CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters() {}

  explicit CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isRequiredParameter) {
      res["IsRequiredParameter"] = boost::any(*isRequiredParameter);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (parameterValueType) {
      res["ParameterValueType"] = boost::any(*parameterValueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsRequiredParameter") != m.end() && !m["IsRequiredParameter"].empty()) {
      isRequiredParameter = make_shared<bool>(boost::any_cast<bool>(m["IsRequiredParameter"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<string>(boost::any_cast<string>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ParameterValueType") != m.end() && !m["ParameterValueType"].empty()) {
      parameterValueType = make_shared<string>(boost::any_cast<string>(m["ParameterValueType"]));
    }
  }


  virtual ~CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters() = default;
};
class CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<string> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters() {}

  explicit CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<string>(boost::any_cast<string>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters() = default;
};
class CreateDataServiceApiRequestCreateCommandScriptDetails : public Darabonba::Model {
public:
  shared_ptr<long> datasourceID{};
  shared_ptr<long> datasourceType{};
  shared_ptr<bool> isPaginated{};
  shared_ptr<string> script{};
  shared_ptr<vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters>> scriptRequestParameters{};
  shared_ptr<vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters>> scriptResponseParameters{};
  shared_ptr<long> sortPriority{};
  shared_ptr<long> sqlMode{};

  CreateDataServiceApiRequestCreateCommandScriptDetails() {}

  explicit CreateDataServiceApiRequestCreateCommandScriptDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceID) {
      res["DatasourceID"] = boost::any(*datasourceID);
    }
    if (datasourceType) {
      res["DatasourceType"] = boost::any(*datasourceType);
    }
    if (isPaginated) {
      res["IsPaginated"] = boost::any(*isPaginated);
    }
    if (script) {
      res["Script"] = boost::any(*script);
    }
    if (scriptRequestParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptRequestParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptRequestParameters"] = boost::any(temp1);
    }
    if (scriptResponseParameters) {
      vector<boost::any> temp1;
      for(auto item1:*scriptResponseParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScriptResponseParameters"] = boost::any(temp1);
    }
    if (sortPriority) {
      res["SortPriority"] = boost::any(*sortPriority);
    }
    if (sqlMode) {
      res["SqlMode"] = boost::any(*sqlMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasourceID") != m.end() && !m["DatasourceID"].empty()) {
      datasourceID = make_shared<long>(boost::any_cast<long>(m["DatasourceID"]));
    }
    if (m.find("DatasourceType") != m.end() && !m["DatasourceType"].empty()) {
      datasourceType = make_shared<long>(boost::any_cast<long>(m["DatasourceType"]));
    }
    if (m.find("IsPaginated") != m.end() && !m["IsPaginated"].empty()) {
      isPaginated = make_shared<bool>(boost::any_cast<bool>(m["IsPaginated"]));
    }
    if (m.find("Script") != m.end() && !m["Script"].empty()) {
      script = make_shared<string>(boost::any_cast<string>(m["Script"]));
    }
    if (m.find("ScriptRequestParameters") != m.end() && !m["ScriptRequestParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptRequestParameters"].type()) {
        vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptRequestParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptRequestParameters = make_shared<vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptRequestParameters>>(expect1);
      }
    }
    if (m.find("ScriptResponseParameters") != m.end() && !m["ScriptResponseParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["ScriptResponseParameters"].type()) {
        vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScriptResponseParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scriptResponseParameters = make_shared<vector<CreateDataServiceApiRequestCreateCommandScriptDetailsScriptResponseParameters>>(expect1);
      }
    }
    if (m.find("SortPriority") != m.end() && !m["SortPriority"].empty()) {
      sortPriority = make_shared<long>(boost::any_cast<long>(m["SortPriority"]));
    }
    if (m.find("SqlMode") != m.end() && !m["SqlMode"].empty()) {
      sqlMode = make_shared<long>(boost::any_cast<long>(m["SqlMode"]));
    }
  }


  virtual ~CreateDataServiceApiRequestCreateCommandScriptDetails() = default;
};
class CreateDataServiceApiRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<long> apiGroupId{};
  shared_ptr<string> apiGroupName{};
  shared_ptr<string> apiName{};
  shared_ptr<long> apiType{};
  shared_ptr<vector<long>> bizProtocol{};
  shared_ptr<long> cacheTimeout{};
  shared_ptr<long> callMode{};
  shared_ptr<string> customUpdateRate{};
  shared_ptr<string> description{};
  shared_ptr<long> executionTimeout{};
  shared_ptr<long> mode{};
  shared_ptr<long> projectId{};
  shared_ptr<long> requestType{};
  shared_ptr<CreateDataServiceApiRequestCreateCommandScriptDetails> scriptDetails{};
  shared_ptr<long> timeout{};
  shared_ptr<long> updateRate{};
  shared_ptr<string> version{};

  CreateDataServiceApiRequestCreateCommand() {}

  explicit CreateDataServiceApiRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupId) {
      res["ApiGroupId"] = boost::any(*apiGroupId);
    }
    if (apiGroupName) {
      res["ApiGroupName"] = boost::any(*apiGroupName);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiType) {
      res["ApiType"] = boost::any(*apiType);
    }
    if (bizProtocol) {
      res["BizProtocol"] = boost::any(*bizProtocol);
    }
    if (cacheTimeout) {
      res["CacheTimeout"] = boost::any(*cacheTimeout);
    }
    if (callMode) {
      res["CallMode"] = boost::any(*callMode);
    }
    if (customUpdateRate) {
      res["CustomUpdateRate"] = boost::any(*customUpdateRate);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (executionTimeout) {
      res["ExecutionTimeout"] = boost::any(*executionTimeout);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (requestType) {
      res["RequestType"] = boost::any(*requestType);
    }
    if (scriptDetails) {
      res["ScriptDetails"] = scriptDetails ? boost::any(scriptDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateRate) {
      res["UpdateRate"] = boost::any(*updateRate);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupId") != m.end() && !m["ApiGroupId"].empty()) {
      apiGroupId = make_shared<long>(boost::any_cast<long>(m["ApiGroupId"]));
    }
    if (m.find("ApiGroupName") != m.end() && !m["ApiGroupName"].empty()) {
      apiGroupName = make_shared<string>(boost::any_cast<string>(m["ApiGroupName"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiType") != m.end() && !m["ApiType"].empty()) {
      apiType = make_shared<long>(boost::any_cast<long>(m["ApiType"]));
    }
    if (m.find("BizProtocol") != m.end() && !m["BizProtocol"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizProtocol"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizProtocol"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizProtocol = make_shared<vector<long>>(toVec1);
    }
    if (m.find("CacheTimeout") != m.end() && !m["CacheTimeout"].empty()) {
      cacheTimeout = make_shared<long>(boost::any_cast<long>(m["CacheTimeout"]));
    }
    if (m.find("CallMode") != m.end() && !m["CallMode"].empty()) {
      callMode = make_shared<long>(boost::any_cast<long>(m["CallMode"]));
    }
    if (m.find("CustomUpdateRate") != m.end() && !m["CustomUpdateRate"].empty()) {
      customUpdateRate = make_shared<string>(boost::any_cast<string>(m["CustomUpdateRate"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExecutionTimeout") != m.end() && !m["ExecutionTimeout"].empty()) {
      executionTimeout = make_shared<long>(boost::any_cast<long>(m["ExecutionTimeout"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<long>(boost::any_cast<long>(m["Mode"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RequestType") != m.end() && !m["RequestType"].empty()) {
      requestType = make_shared<long>(boost::any_cast<long>(m["RequestType"]));
    }
    if (m.find("ScriptDetails") != m.end() && !m["ScriptDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ScriptDetails"].type()) {
        CreateDataServiceApiRequestCreateCommandScriptDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ScriptDetails"]));
        scriptDetails = make_shared<CreateDataServiceApiRequestCreateCommandScriptDetails>(model1);
      }
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("UpdateRate") != m.end() && !m["UpdateRate"].empty()) {
      updateRate = make_shared<long>(boost::any_cast<long>(m["UpdateRate"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateDataServiceApiRequestCreateCommand() = default;
};
class CreateDataServiceApiRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataServiceApiRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateDataServiceApiRequest() {}

  explicit CreateDataServiceApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateDataServiceApiRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateDataServiceApiRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataServiceApiRequest() = default;
};
class CreateDataServiceApiShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateDataServiceApiShrinkRequest() {}

  explicit CreateDataServiceApiShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataServiceApiShrinkRequest() = default;
};
class CreateDataServiceApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataServiceApiResponseBody() {}

  explicit CreateDataServiceApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataServiceApiResponseBody() = default;
};
class CreateDataServiceApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataServiceApiResponseBody> body{};

  CreateDataServiceApiResponse() {}

  explicit CreateDataServiceApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataServiceApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataServiceApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataServiceApiResponse() = default;
};
class CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList() {}

  explicit CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList() = default;
};
class CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate : public Darabonba::Model {
public:
  shared_ptr<bool> checkActivity{};
  shared_ptr<vector<CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList>> configItemList{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate() {}

  explicit CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkActivity) {
      res["CheckActivity"] = boost::any(*checkActivity);
    }
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckActivity") != m.end() && !m["CheckActivity"].empty()) {
      checkActivity = make_shared<bool>(boost::any_cast<bool>(m["CheckActivity"]));
    }
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreateConfigItemList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate() = default;
};
class CreateDataSourceRequestCreateCommandDevDataSourceCreate : public Darabonba::Model {
public:
  shared_ptr<CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate> dataSourceCreate{};
  shared_ptr<long> prodDataSourceId{};

  CreateDataSourceRequestCreateCommandDevDataSourceCreate() {}

  explicit CreateDataSourceRequestCreateCommandDevDataSourceCreate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceCreate) {
      res["DataSourceCreate"] = dataSourceCreate ? boost::any(dataSourceCreate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (prodDataSourceId) {
      res["ProdDataSourceId"] = boost::any(*prodDataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceCreate") != m.end() && !m["DataSourceCreate"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataSourceCreate"].type()) {
        CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataSourceCreate"]));
        dataSourceCreate = make_shared<CreateDataSourceRequestCreateCommandDevDataSourceCreateDataSourceCreate>(model1);
      }
    }
    if (m.find("ProdDataSourceId") != m.end() && !m["ProdDataSourceId"].empty()) {
      prodDataSourceId = make_shared<long>(boost::any_cast<long>(m["ProdDataSourceId"]));
    }
  }


  virtual ~CreateDataSourceRequestCreateCommandDevDataSourceCreate() = default;
};
class CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList() {}

  explicit CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList() = default;
};
class CreateDataSourceRequestCreateCommandProdDataSourceCreate : public Darabonba::Model {
public:
  shared_ptr<bool> checkActivity{};
  shared_ptr<vector<CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList>> configItemList{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  CreateDataSourceRequestCreateCommandProdDataSourceCreate() {}

  explicit CreateDataSourceRequestCreateCommandProdDataSourceCreate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkActivity) {
      res["CheckActivity"] = boost::any(*checkActivity);
    }
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckActivity") != m.end() && !m["CheckActivity"].empty()) {
      checkActivity = make_shared<bool>(boost::any_cast<bool>(m["CheckActivity"]));
    }
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<CreateDataSourceRequestCreateCommandProdDataSourceCreateConfigItemList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateDataSourceRequestCreateCommandProdDataSourceCreate() = default;
};
class CreateDataSourceRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<CreateDataSourceRequestCreateCommandDevDataSourceCreate> devDataSourceCreate{};
  shared_ptr<CreateDataSourceRequestCreateCommandProdDataSourceCreate> prodDataSourceCreate{};

  CreateDataSourceRequestCreateCommand() {}

  explicit CreateDataSourceRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devDataSourceCreate) {
      res["DevDataSourceCreate"] = devDataSourceCreate ? boost::any(devDataSourceCreate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (prodDataSourceCreate) {
      res["ProdDataSourceCreate"] = prodDataSourceCreate ? boost::any(prodDataSourceCreate->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevDataSourceCreate") != m.end() && !m["DevDataSourceCreate"].empty()) {
      if (typeid(map<string, boost::any>) == m["DevDataSourceCreate"].type()) {
        CreateDataSourceRequestCreateCommandDevDataSourceCreate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DevDataSourceCreate"]));
        devDataSourceCreate = make_shared<CreateDataSourceRequestCreateCommandDevDataSourceCreate>(model1);
      }
    }
    if (m.find("ProdDataSourceCreate") != m.end() && !m["ProdDataSourceCreate"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProdDataSourceCreate"].type()) {
        CreateDataSourceRequestCreateCommandProdDataSourceCreate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProdDataSourceCreate"]));
        prodDataSourceCreate = make_shared<CreateDataSourceRequestCreateCommandProdDataSourceCreate>(model1);
      }
    }
  }


  virtual ~CreateDataSourceRequestCreateCommand() = default;
};
class CreateDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDataSourceRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateDataSourceRequest() {}

  explicit CreateDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateDataSourceRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateDataSourceRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataSourceRequest() = default;
};
class CreateDataSourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateDataSourceShrinkRequest() {}

  explicit CreateDataSourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDataSourceShrinkRequest() = default;
};
class CreateDataSourceResponseBodyCreateResult : public Darabonba::Model {
public:
  shared_ptr<long> devDataSourceId{};
  shared_ptr<long> prodDataSourceId{};

  CreateDataSourceResponseBodyCreateResult() {}

  explicit CreateDataSourceResponseBodyCreateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devDataSourceId) {
      res["DevDataSourceId"] = boost::any(*devDataSourceId);
    }
    if (prodDataSourceId) {
      res["ProdDataSourceId"] = boost::any(*prodDataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevDataSourceId") != m.end() && !m["DevDataSourceId"].empty()) {
      devDataSourceId = make_shared<long>(boost::any_cast<long>(m["DevDataSourceId"]));
    }
    if (m.find("ProdDataSourceId") != m.end() && !m["ProdDataSourceId"].empty()) {
      prodDataSourceId = make_shared<long>(boost::any_cast<long>(m["ProdDataSourceId"]));
    }
  }


  virtual ~CreateDataSourceResponseBodyCreateResult() = default;
};
class CreateDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateDataSourceResponseBodyCreateResult> createResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDataSourceResponseBody() {}

  explicit CreateDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createResult) {
      res["CreateResult"] = createResult ? boost::any(createResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateResult") != m.end() && !m["CreateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateResult"].type()) {
        CreateDataSourceResponseBodyCreateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateResult"]));
        createResult = make_shared<CreateDataSourceResponseBodyCreateResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDataSourceResponseBody() = default;
};
class CreateDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataSourceResponseBody> body{};

  CreateDataSourceResponse() {}

  explicit CreateDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataSourceResponse() = default;
};
class CreateDirectoryRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> directory{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  CreateDirectoryRequestCreateCommand() {}

  explicit CreateDirectoryRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~CreateDirectoryRequestCreateCommand() = default;
};
class CreateDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<CreateDirectoryRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateDirectoryRequest() {}

  explicit CreateDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateDirectoryRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateDirectoryRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDirectoryRequest() = default;
};
class CreateDirectoryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateDirectoryShrinkRequest() {}

  explicit CreateDirectoryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateDirectoryShrinkRequest() = default;
};
class CreateDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> fileId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateDirectoryResponseBody() {}

  explicit CreateDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateDirectoryResponseBody() = default;
};
class CreateDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDirectoryResponseBody> body{};

  CreateDirectoryResponse() {}

  explicit CreateDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDirectoryResponse() = default;
};
class CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};

  CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList() {}

  explicit CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList() = default;
};
class CreateNodeSupplementRequestCreateCommandFilterList : public Darabonba::Model {
public:
  shared_ptr<bool> exclude{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> valueList{};

  CreateNodeSupplementRequestCreateCommandFilterList() {}

  explicit CreateNodeSupplementRequestCreateCommandFilterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exclude) {
      res["Exclude"] = boost::any(*exclude);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valueList) {
      res["ValueList"] = boost::any(*valueList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exclude") != m.end() && !m["Exclude"].empty()) {
      exclude = make_shared<bool>(boost::any_cast<bool>(m["Exclude"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ValueList") != m.end() && !m["ValueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandFilterList() = default;
};
class CreateNodeSupplementRequestCreateCommandGlobalParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNodeSupplementRequestCreateCommandGlobalParamList() {}

  explicit CreateNodeSupplementRequestCreateCommandGlobalParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandGlobalParamList() = default;
};
class CreateNodeSupplementRequestCreateCommandNodeIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};

  CreateNodeSupplementRequestCreateCommandNodeIdList() {}

  explicit CreateNodeSupplementRequestCreateCommandNodeIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandNodeIdList() = default;
};
class CreateNodeSupplementRequestCreateCommandNodeParamsListParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateNodeSupplementRequestCreateCommandNodeParamsListParamList() {}

  explicit CreateNodeSupplementRequestCreateCommandNodeParamsListParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandNodeParamsListParamList() = default;
};
class CreateNodeSupplementRequestCreateCommandNodeParamsList : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandNodeParamsListParamList>> paramList{};

  CreateNodeSupplementRequestCreateCommandNodeParamsList() {}

  explicit CreateNodeSupplementRequestCreateCommandNodeParamsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandNodeParamsListParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandNodeParamsListParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<CreateNodeSupplementRequestCreateCommandNodeParamsListParamList>>(expect1);
      }
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommandNodeParamsList() = default;
};
class CreateNodeSupplementRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<bool> containAllDownStream{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList>> downStreamNodeIdList{};
  shared_ptr<string> endBizDate{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandFilterList>> filterList{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandGlobalParamList>> globalParamList{};
  shared_ptr<string> maxDueTime{};
  shared_ptr<string> minDueTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandNodeIdList>> nodeIdList{};
  shared_ptr<vector<CreateNodeSupplementRequestCreateCommandNodeParamsList>> nodeParamsList{};
  shared_ptr<long> parallelism{};
  shared_ptr<long> projectId{};
  shared_ptr<string> startBizDate{};

  CreateNodeSupplementRequestCreateCommand() {}

  explicit CreateNodeSupplementRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containAllDownStream) {
      res["ContainAllDownStream"] = boost::any(*containAllDownStream);
    }
    if (downStreamNodeIdList) {
      vector<boost::any> temp1;
      for(auto item1:*downStreamNodeIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownStreamNodeIdList"] = boost::any(temp1);
    }
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (filterList) {
      vector<boost::any> temp1;
      for(auto item1:*filterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilterList"] = boost::any(temp1);
    }
    if (globalParamList) {
      vector<boost::any> temp1;
      for(auto item1:*globalParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GlobalParamList"] = boost::any(temp1);
    }
    if (maxDueTime) {
      res["MaxDueTime"] = boost::any(*maxDueTime);
    }
    if (minDueTime) {
      res["MinDueTime"] = boost::any(*minDueTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeIdList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeIdList"] = boost::any(temp1);
    }
    if (nodeParamsList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeParamsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeParamsList"] = boost::any(temp1);
    }
    if (parallelism) {
      res["Parallelism"] = boost::any(*parallelism);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainAllDownStream") != m.end() && !m["ContainAllDownStream"].empty()) {
      containAllDownStream = make_shared<bool>(boost::any_cast<bool>(m["ContainAllDownStream"]));
    }
    if (m.find("DownStreamNodeIdList") != m.end() && !m["DownStreamNodeIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["DownStreamNodeIdList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownStreamNodeIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downStreamNodeIdList = make_shared<vector<CreateNodeSupplementRequestCreateCommandDownStreamNodeIdList>>(expect1);
      }
    }
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("FilterList") != m.end() && !m["FilterList"].empty()) {
      if (typeid(vector<boost::any>) == m["FilterList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandFilterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandFilterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filterList = make_shared<vector<CreateNodeSupplementRequestCreateCommandFilterList>>(expect1);
      }
    }
    if (m.find("GlobalParamList") != m.end() && !m["GlobalParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["GlobalParamList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandGlobalParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GlobalParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandGlobalParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        globalParamList = make_shared<vector<CreateNodeSupplementRequestCreateCommandGlobalParamList>>(expect1);
      }
    }
    if (m.find("MaxDueTime") != m.end() && !m["MaxDueTime"].empty()) {
      maxDueTime = make_shared<string>(boost::any_cast<string>(m["MaxDueTime"]));
    }
    if (m.find("MinDueTime") != m.end() && !m["MinDueTime"].empty()) {
      minDueTime = make_shared<string>(boost::any_cast<string>(m["MinDueTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeIdList") != m.end() && !m["NodeIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeIdList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandNodeIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandNodeIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeIdList = make_shared<vector<CreateNodeSupplementRequestCreateCommandNodeIdList>>(expect1);
      }
    }
    if (m.find("NodeParamsList") != m.end() && !m["NodeParamsList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeParamsList"].type()) {
        vector<CreateNodeSupplementRequestCreateCommandNodeParamsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeParamsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateNodeSupplementRequestCreateCommandNodeParamsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeParamsList = make_shared<vector<CreateNodeSupplementRequestCreateCommandNodeParamsList>>(expect1);
      }
    }
    if (m.find("Parallelism") != m.end() && !m["Parallelism"].empty()) {
      parallelism = make_shared<long>(boost::any_cast<long>(m["Parallelism"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
  }


  virtual ~CreateNodeSupplementRequestCreateCommand() = default;
};
class CreateNodeSupplementRequest : public Darabonba::Model {
public:
  shared_ptr<CreateNodeSupplementRequestCreateCommand> createCommand{};
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};

  CreateNodeSupplementRequest() {}

  explicit CreateNodeSupplementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateNodeSupplementRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateNodeSupplementRequestCreateCommand>(model1);
      }
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateNodeSupplementRequest() = default;
};
class CreateNodeSupplementShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};

  CreateNodeSupplementShrinkRequest() {}

  explicit CreateNodeSupplementShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateNodeSupplementShrinkRequest() = default;
};
class CreateNodeSupplementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> submitId{};
  shared_ptr<bool> success{};

  CreateNodeSupplementResponseBody() {}

  explicit CreateNodeSupplementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (submitId) {
      res["SubmitId"] = boost::any(*submitId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubmitId") != m.end() && !m["SubmitId"].empty()) {
      submitId = make_shared<string>(boost::any_cast<string>(m["SubmitId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateNodeSupplementResponseBody() = default;
};
class CreateNodeSupplementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateNodeSupplementResponseBody> body{};

  CreateNodeSupplementResponse() {}

  explicit CreateNodeSupplementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateNodeSupplementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateNodeSupplementResponseBody>(model1);
      }
    }
  }


  virtual ~CreateNodeSupplementResponse() = default;
};
class CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> directory{};
  shared_ptr<string> fileName{};

  CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo() {}

  explicit CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
  }


  virtual ~CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo() = default;
};
class CreatePipelineNodeRequestCreatePipelineNodeCommand : public Darabonba::Model {
public:
  shared_ptr<CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo> fileInfo{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> pipelineName{};
  shared_ptr<string> pipelineType{};
  shared_ptr<long> projectId{};

  CreatePipelineNodeRequestCreatePipelineNodeCommand() {}

  explicit CreatePipelineNodeRequestCreatePipelineNodeCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileInfo) {
      res["FileInfo"] = fileInfo ? boost::any(fileInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (pipelineName) {
      res["PipelineName"] = boost::any(*pipelineName);
    }
    if (pipelineType) {
      res["PipelineType"] = boost::any(*pipelineType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileInfo") != m.end() && !m["FileInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileInfo"].type()) {
        CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileInfo"]));
        fileInfo = make_shared<CreatePipelineNodeRequestCreatePipelineNodeCommandFileInfo>(model1);
      }
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PipelineName") != m.end() && !m["PipelineName"].empty()) {
      pipelineName = make_shared<string>(boost::any_cast<string>(m["PipelineName"]));
    }
    if (m.find("PipelineType") != m.end() && !m["PipelineType"].empty()) {
      pipelineType = make_shared<string>(boost::any_cast<string>(m["PipelineType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~CreatePipelineNodeRequestCreatePipelineNodeCommand() = default;
};
class CreatePipelineNodeRequest : public Darabonba::Model {
public:
  shared_ptr<CreatePipelineNodeRequestCreatePipelineNodeCommand> createPipelineNodeCommand{};
  shared_ptr<long> opTenantId{};

  CreatePipelineNodeRequest() {}

  explicit CreatePipelineNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createPipelineNodeCommand) {
      res["CreatePipelineNodeCommand"] = createPipelineNodeCommand ? boost::any(createPipelineNodeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatePipelineNodeCommand") != m.end() && !m["CreatePipelineNodeCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreatePipelineNodeCommand"].type()) {
        CreatePipelineNodeRequestCreatePipelineNodeCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreatePipelineNodeCommand"]));
        createPipelineNodeCommand = make_shared<CreatePipelineNodeRequestCreatePipelineNodeCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreatePipelineNodeRequest() = default;
};
class CreatePipelineNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createPipelineNodeCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreatePipelineNodeShrinkRequest() {}

  explicit CreatePipelineNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createPipelineNodeCommandShrink) {
      res["CreatePipelineNodeCommand"] = boost::any(*createPipelineNodeCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatePipelineNodeCommand") != m.end() && !m["CreatePipelineNodeCommand"].empty()) {
      createPipelineNodeCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreatePipelineNodeCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreatePipelineNodeShrinkRequest() = default;
};
class CreatePipelineNodeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> errorCodeList{};
  shared_ptr<vector<string>> errorMessageList{};
  shared_ptr<long> pipelineId{};

  CreatePipelineNodeResponseBodyData() {}

  explicit CreatePipelineNodeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeList) {
      res["ErrorCodeList"] = boost::any(*errorCodeList);
    }
    if (errorMessageList) {
      res["ErrorMessageList"] = boost::any(*errorMessageList);
    }
    if (pipelineId) {
      res["PipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeList") != m.end() && !m["ErrorCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ErrorCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ErrorCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      errorCodeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ErrorMessageList") != m.end() && !m["ErrorMessageList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ErrorMessageList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ErrorMessageList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      errorMessageList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PipelineId") != m.end() && !m["PipelineId"].empty()) {
      pipelineId = make_shared<long>(boost::any_cast<long>(m["PipelineId"]));
    }
  }


  virtual ~CreatePipelineNodeResponseBodyData() = default;
};
class CreatePipelineNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreatePipelineNodeResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreatePipelineNodeResponseBody() {}

  explicit CreatePipelineNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreatePipelineNodeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreatePipelineNodeResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreatePipelineNodeResponseBody() = default;
};
class CreatePipelineNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelineNodeResponseBody> body{};

  CreatePipelineNodeResponse() {}

  explicit CreatePipelineNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelineNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelineNodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelineNodeResponse() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnDesc{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};

  CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnDesc) {
      res["ColumnDesc"] = boost::any(*columnDesc);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnDesc") != m.end() && !m["ColumnDesc"].empty()) {
      columnDesc = make_shared<string>(boost::any_cast<string>(m["ColumnDesc"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions : public Darabonba::Model {
public:
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<boost::any>> subConditions{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (subConditions) {
      res["SubConditions"] = boost::any(*subConditions);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SubConditions") != m.end() && !m["SubConditions"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubConditions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubConditions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subConditions = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts>> accounts{};

  CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingListAccounts>>(expect1);
      }
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions>> expressions{};
  shared_ptr<bool> isDelete{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> scopeType{};
  shared_ptr<long> status{};
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList>> userMappingList{};

  CreateRowPermissionRequestCreateRowPermissionCommandRules() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userMappingList) {
      vector<boost::any> temp1;
      for(auto item1:*userMappingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserMappingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesExpressions>>(expect1);
      }
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<bool>(boost::any_cast<bool>(m["IsDelete"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserMappingList") != m.end() && !m["UserMappingList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserMappingList"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserMappingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userMappingList = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandRulesUserMappingList>>(expect1);
      }
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandRules() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommandTables : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> resourceId{};

  CreateRowPermissionRequestCreateRowPermissionCommandTables() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommandTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommandTables() = default;
};
class CreateRowPermissionRequestCreateRowPermissionCommand : public Darabonba::Model {
public:
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns>> mappingColumns{};
  shared_ptr<string> rowPermissionDesc{};
  shared_ptr<string> rowPermissionName{};
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandRules>> rules{};
  shared_ptr<vector<CreateRowPermissionRequestCreateRowPermissionCommandTables>> tables{};

  CreateRowPermissionRequestCreateRowPermissionCommand() {}

  explicit CreateRowPermissionRequestCreateRowPermissionCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumns) {
      vector<boost::any> temp1;
      for(auto item1:*mappingColumns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MappingColumns"] = boost::any(temp1);
    }
    if (rowPermissionDesc) {
      res["RowPermissionDesc"] = boost::any(*rowPermissionDesc);
    }
    if (rowPermissionName) {
      res["RowPermissionName"] = boost::any(*rowPermissionName);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumns") != m.end() && !m["MappingColumns"].empty()) {
      if (typeid(vector<boost::any>) == m["MappingColumns"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MappingColumns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mappingColumns = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandMappingColumns>>(expect1);
      }
    }
    if (m.find("RowPermissionDesc") != m.end() && !m["RowPermissionDesc"].empty()) {
      rowPermissionDesc = make_shared<string>(boost::any_cast<string>(m["RowPermissionDesc"]));
    }
    if (m.find("RowPermissionName") != m.end() && !m["RowPermissionName"].empty()) {
      rowPermissionName = make_shared<string>(boost::any_cast<string>(m["RowPermissionName"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandRules>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<CreateRowPermissionRequestCreateRowPermissionCommandTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRowPermissionRequestCreateRowPermissionCommandTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<CreateRowPermissionRequestCreateRowPermissionCommandTables>>(expect1);
      }
    }
  }


  virtual ~CreateRowPermissionRequestCreateRowPermissionCommand() = default;
};
class CreateRowPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<CreateRowPermissionRequestCreateRowPermissionCommand> createRowPermissionCommand{};
  shared_ptr<long> opTenantId{};

  CreateRowPermissionRequest() {}

  explicit CreateRowPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createRowPermissionCommand) {
      res["CreateRowPermissionCommand"] = createRowPermissionCommand ? boost::any(createRowPermissionCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateRowPermissionCommand") != m.end() && !m["CreateRowPermissionCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateRowPermissionCommand"].type()) {
        CreateRowPermissionRequestCreateRowPermissionCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateRowPermissionCommand"]));
        createRowPermissionCommand = make_shared<CreateRowPermissionRequestCreateRowPermissionCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateRowPermissionRequest() = default;
};
class CreateRowPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createRowPermissionCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateRowPermissionShrinkRequest() {}

  explicit CreateRowPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createRowPermissionCommandShrink) {
      res["CreateRowPermissionCommand"] = boost::any(*createRowPermissionCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateRowPermissionCommand") != m.end() && !m["CreateRowPermissionCommand"].empty()) {
      createRowPermissionCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateRowPermissionCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateRowPermissionShrinkRequest() = default;
};
class CreateRowPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateRowPermissionResponseBody() {}

  explicit CreateRowPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateRowPermissionResponseBody() = default;
};
class CreateRowPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRowPermissionResponseBody> body{};

  CreateRowPermissionResponse() {}

  explicit CreateRowPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRowPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRowPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRowPermissionResponse() = default;
};
class CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> description{};
  shared_ptr<string> directory{};
  shared_ptr<string> engineVersion{};
  shared_ptr<string> env{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileType{};
  shared_ptr<long> projectId{};
  shared_ptr<string> queueName{};
  shared_ptr<string> vvpClusterType{};

  CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand() {}

  explicit CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (engineVersion) {
      res["EngineVersion"] = boost::any(*engineVersion);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (vvpClusterType) {
      res["VvpClusterType"] = boost::any(*vvpClusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("EngineVersion") != m.end() && !m["EngineVersion"].empty()) {
      engineVersion = make_shared<string>(boost::any_cast<string>(m["EngineVersion"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("VvpClusterType") != m.end() && !m["VvpClusterType"].empty()) {
      vvpClusterType = make_shared<string>(boost::any_cast<string>(m["VvpClusterType"]));
    }
  }


  virtual ~CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand() = default;
};
class CreateStreamBatchJobMappingRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand> streamBatchJobMappingCreateCommand{};

  CreateStreamBatchJobMappingRequest() {}

  explicit CreateStreamBatchJobMappingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (streamBatchJobMappingCreateCommand) {
      res["StreamBatchJobMappingCreateCommand"] = streamBatchJobMappingCreateCommand ? boost::any(streamBatchJobMappingCreateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("StreamBatchJobMappingCreateCommand") != m.end() && !m["StreamBatchJobMappingCreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["StreamBatchJobMappingCreateCommand"].type()) {
        CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StreamBatchJobMappingCreateCommand"]));
        streamBatchJobMappingCreateCommand = make_shared<CreateStreamBatchJobMappingRequestStreamBatchJobMappingCreateCommand>(model1);
      }
    }
  }


  virtual ~CreateStreamBatchJobMappingRequest() = default;
};
class CreateStreamBatchJobMappingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> streamBatchJobMappingCreateCommandShrink{};

  CreateStreamBatchJobMappingShrinkRequest() {}

  explicit CreateStreamBatchJobMappingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (streamBatchJobMappingCreateCommandShrink) {
      res["StreamBatchJobMappingCreateCommand"] = boost::any(*streamBatchJobMappingCreateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("StreamBatchJobMappingCreateCommand") != m.end() && !m["StreamBatchJobMappingCreateCommand"].empty()) {
      streamBatchJobMappingCreateCommandShrink = make_shared<string>(boost::any_cast<string>(m["StreamBatchJobMappingCreateCommand"]));
    }
  }


  virtual ~CreateStreamBatchJobMappingShrinkRequest() = default;
};
class CreateStreamBatchJobMappingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileId{};
  shared_ptr<string> url{};

  CreateStreamBatchJobMappingResponseBodyData() {}

  explicit CreateStreamBatchJobMappingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<string>(boost::any_cast<string>(m["FileId"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~CreateStreamBatchJobMappingResponseBodyData() = default;
};
class CreateStreamBatchJobMappingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateStreamBatchJobMappingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  CreateStreamBatchJobMappingResponseBody() {}

  explicit CreateStreamBatchJobMappingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateStreamBatchJobMappingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateStreamBatchJobMappingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateStreamBatchJobMappingResponseBody() = default;
};
class CreateStreamBatchJobMappingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStreamBatchJobMappingResponseBody> body{};

  CreateStreamBatchJobMappingResponse() {}

  explicit CreateStreamBatchJobMappingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStreamBatchJobMappingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStreamBatchJobMappingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStreamBatchJobMappingResponse() = default;
};
class CreateUserGroupRequestCreateCommand : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<vector<string>> adminUserIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};

  CreateUserGroupRequestCreateCommand() {}

  explicit CreateUserGroupRequestCreateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (adminUserIdList) {
      res["AdminUserIdList"] = boost::any(*adminUserIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("AdminUserIdList") != m.end() && !m["AdminUserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminUserIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateUserGroupRequestCreateCommand() = default;
};
class CreateUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<CreateUserGroupRequestCreateCommand> createCommand{};
  shared_ptr<long> opTenantId{};

  CreateUserGroupRequest() {}

  explicit CreateUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommand) {
      res["CreateCommand"] = createCommand ? boost::any(createCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateCommand"].type()) {
        CreateUserGroupRequestCreateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateCommand"]));
        createCommand = make_shared<CreateUserGroupRequestCreateCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateUserGroupRequest() = default;
};
class CreateUserGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createCommandShrink{};
  shared_ptr<long> opTenantId{};

  CreateUserGroupShrinkRequest() {}

  explicit CreateUserGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createCommandShrink) {
      res["CreateCommand"] = boost::any(*createCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateCommand") != m.end() && !m["CreateCommand"].empty()) {
      createCommandShrink = make_shared<string>(boost::any_cast<string>(m["CreateCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~CreateUserGroupShrinkRequest() = default;
};
class CreateUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<string> userGroupId{};

  CreateUserGroupResponseBody() {}

  explicit CreateUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~CreateUserGroupResponseBody() = default;
};
class CreateUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserGroupResponseBody> body{};

  CreateUserGroupResponse() {}

  explicit CreateUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserGroupResponse() = default;
};
class DeleteAdHocFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  DeleteAdHocFileRequest() {}

  explicit DeleteAdHocFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteAdHocFileRequest() = default;
};
class DeleteAdHocFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteAdHocFileResponseBody() {}

  explicit DeleteAdHocFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteAdHocFileResponseBody() = default;
};
class DeleteAdHocFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAdHocFileResponseBody> body{};

  DeleteAdHocFileResponse() {}

  explicit DeleteAdHocFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAdHocFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAdHocFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAdHocFileResponse() = default;
};
class DeleteBatchTaskRequestDeleteCommand : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};

  DeleteBatchTaskRequestDeleteCommand() {}

  explicit DeleteBatchTaskRequestDeleteCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteBatchTaskRequestDeleteCommand() = default;
};
class DeleteBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<DeleteBatchTaskRequestDeleteCommand> deleteCommand{};
  shared_ptr<long> opTenantId{};

  DeleteBatchTaskRequest() {}

  explicit DeleteBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteCommand) {
      res["DeleteCommand"] = deleteCommand ? boost::any(deleteCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteCommand") != m.end() && !m["DeleteCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteCommand"].type()) {
        DeleteBatchTaskRequestDeleteCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteCommand"]));
        deleteCommand = make_shared<DeleteBatchTaskRequestDeleteCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteBatchTaskRequest() = default;
};
class DeleteBatchTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteCommandShrink{};
  shared_ptr<long> opTenantId{};

  DeleteBatchTaskShrinkRequest() {}

  explicit DeleteBatchTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteCommandShrink) {
      res["DeleteCommand"] = boost::any(*deleteCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteCommand") != m.end() && !m["DeleteCommand"].empty()) {
      deleteCommandShrink = make_shared<string>(boost::any_cast<string>(m["DeleteCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteBatchTaskShrinkRequest() = default;
};
class DeleteBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBatchTaskResponseBody() {}

  explicit DeleteBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBatchTaskResponseBody() = default;
};
class DeleteBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBatchTaskResponseBody> body{};

  DeleteBatchTaskResponse() {}

  explicit DeleteBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBatchTaskResponse() = default;
};
class DeleteBizEntityRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> type{};

  DeleteBizEntityRequest() {}

  explicit DeleteBizEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteBizEntityRequest() = default;
};
class DeleteBizEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBizEntityResponseBody() {}

  explicit DeleteBizEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBizEntityResponseBody() = default;
};
class DeleteBizEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBizEntityResponseBody> body{};

  DeleteBizEntityResponse() {}

  explicit DeleteBizEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBizEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBizEntityResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBizEntityResponse() = default;
};
class DeleteBizUnitRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  DeleteBizUnitRequest() {}

  explicit DeleteBizUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteBizUnitRequest() = default;
};
class DeleteBizUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteBizUnitResponseBody() {}

  explicit DeleteBizUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteBizUnitResponseBody() = default;
};
class DeleteBizUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBizUnitResponseBody> body{};

  DeleteBizUnitResponse() {}

  explicit DeleteBizUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBizUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBizUnitResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBizUnitResponse() = default;
};
class DeleteDataDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  DeleteDataDomainRequest() {}

  explicit DeleteDataDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteDataDomainRequest() = default;
};
class DeleteDataDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataDomainResponseBody() {}

  explicit DeleteDataDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataDomainResponseBody() = default;
};
class DeleteDataDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataDomainResponseBody> body{};

  DeleteDataDomainResponse() {}

  explicit DeleteDataDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataDomainResponse() = default;
};
class DeleteDataSourceRequestDeleteCommand : public Darabonba::Model {
public:
  shared_ptr<string> mode{};
  shared_ptr<long> prodDataSourceId{};

  DeleteDataSourceRequestDeleteCommand() {}

  explicit DeleteDataSourceRequestDeleteCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (prodDataSourceId) {
      res["ProdDataSourceId"] = boost::any(*prodDataSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("ProdDataSourceId") != m.end() && !m["ProdDataSourceId"].empty()) {
      prodDataSourceId = make_shared<long>(boost::any_cast<long>(m["ProdDataSourceId"]));
    }
  }


  virtual ~DeleteDataSourceRequestDeleteCommand() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<DeleteDataSourceRequestDeleteCommand> deleteCommand{};
  shared_ptr<long> opTenantId{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteCommand) {
      res["DeleteCommand"] = deleteCommand ? boost::any(deleteCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteCommand") != m.end() && !m["DeleteCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteCommand"].type()) {
        DeleteDataSourceRequestDeleteCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteCommand"]));
        deleteCommand = make_shared<DeleteDataSourceRequestDeleteCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteCommandShrink{};
  shared_ptr<long> opTenantId{};

  DeleteDataSourceShrinkRequest() {}

  explicit DeleteDataSourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteCommandShrink) {
      res["DeleteCommand"] = boost::any(*deleteCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteCommand") != m.end() && !m["DeleteCommand"].empty()) {
      deleteCommandShrink = make_shared<string>(boost::any_cast<string>(m["DeleteCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteDataSourceShrinkRequest() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  DeleteDirectoryRequest() {}

  explicit DeleteDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~DeleteDirectoryRequest() = default;
};
class DeleteDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteDirectoryResponseBody() {}

  explicit DeleteDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteDirectoryResponseBody() = default;
};
class DeleteDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDirectoryResponseBody> body{};

  DeleteDirectoryResponse() {}

  explicit DeleteDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDirectoryResponse() = default;
};
class DeleteRowPermissionRequestDeleteRowPermissionCommand : public Darabonba::Model {
public:
  shared_ptr<long> rowPermissionId{};

  DeleteRowPermissionRequestDeleteRowPermissionCommand() {}

  explicit DeleteRowPermissionRequestDeleteRowPermissionCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowPermissionId) {
      res["RowPermissionId"] = boost::any(*rowPermissionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowPermissionId") != m.end() && !m["RowPermissionId"].empty()) {
      rowPermissionId = make_shared<long>(boost::any_cast<long>(m["RowPermissionId"]));
    }
  }


  virtual ~DeleteRowPermissionRequestDeleteRowPermissionCommand() = default;
};
class DeleteRowPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<DeleteRowPermissionRequestDeleteRowPermissionCommand> deleteRowPermissionCommand{};
  shared_ptr<long> opTenantId{};

  DeleteRowPermissionRequest() {}

  explicit DeleteRowPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteRowPermissionCommand) {
      res["DeleteRowPermissionCommand"] = deleteRowPermissionCommand ? boost::any(deleteRowPermissionCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteRowPermissionCommand") != m.end() && !m["DeleteRowPermissionCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeleteRowPermissionCommand"].type()) {
        DeleteRowPermissionRequestDeleteRowPermissionCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeleteRowPermissionCommand"]));
        deleteRowPermissionCommand = make_shared<DeleteRowPermissionRequestDeleteRowPermissionCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteRowPermissionRequest() = default;
};
class DeleteRowPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteRowPermissionCommandShrink{};
  shared_ptr<long> opTenantId{};

  DeleteRowPermissionShrinkRequest() {}

  explicit DeleteRowPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteRowPermissionCommandShrink) {
      res["DeleteRowPermissionCommand"] = boost::any(*deleteRowPermissionCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteRowPermissionCommand") != m.end() && !m["DeleteRowPermissionCommand"].empty()) {
      deleteRowPermissionCommandShrink = make_shared<string>(boost::any_cast<string>(m["DeleteRowPermissionCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~DeleteRowPermissionShrinkRequest() = default;
};
class DeleteRowPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteRowPermissionResponseBody() {}

  explicit DeleteRowPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteRowPermissionResponseBody() = default;
};
class DeleteRowPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRowPermissionResponseBody> body{};

  DeleteRowPermissionResponse() {}

  explicit DeleteRowPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRowPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRowPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRowPermissionResponse() = default;
};
class DeleteUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> userGroupId{};

  DeleteUserGroupRequest() {}

  explicit DeleteUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~DeleteUserGroupRequest() = default;
};
class DeleteUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteUserGroupResponseBody() {}

  explicit DeleteUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteUserGroupResponseBody() = default;
};
class DeleteUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserGroupResponseBody> body{};

  DeleteUserGroupResponse() {}

  explicit DeleteUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserGroupResponse() = default;
};
class ExecuteAdHocTaskRequestExecuteCommandParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ExecuteAdHocTaskRequestExecuteCommandParamList() {}

  explicit ExecuteAdHocTaskRequestExecuteCommandParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteAdHocTaskRequestExecuteCommandParamList() = default;
};
class ExecuteAdHocTaskRequestExecuteCommand : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<string> operatorType{};
  shared_ptr<vector<ExecuteAdHocTaskRequestExecuteCommandParamList>> paramList{};
  shared_ptr<long> projectId{};

  ExecuteAdHocTaskRequestExecuteCommand() {}

  explicit ExecuteAdHocTaskRequestExecuteCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (operatorType) {
      res["OperatorType"] = boost::any(*operatorType);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("OperatorType") != m.end() && !m["OperatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["OperatorType"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<ExecuteAdHocTaskRequestExecuteCommandParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteAdHocTaskRequestExecuteCommandParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<ExecuteAdHocTaskRequestExecuteCommandParamList>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ExecuteAdHocTaskRequestExecuteCommand() = default;
};
class ExecuteAdHocTaskRequest : public Darabonba::Model {
public:
  shared_ptr<ExecuteAdHocTaskRequestExecuteCommand> executeCommand{};
  shared_ptr<long> opTenantId{};

  ExecuteAdHocTaskRequest() {}

  explicit ExecuteAdHocTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executeCommand) {
      res["ExecuteCommand"] = executeCommand ? boost::any(executeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecuteCommand") != m.end() && !m["ExecuteCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecuteCommand"].type()) {
        ExecuteAdHocTaskRequestExecuteCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecuteCommand"]));
        executeCommand = make_shared<ExecuteAdHocTaskRequestExecuteCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ExecuteAdHocTaskRequest() = default;
};
class ExecuteAdHocTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> executeCommandShrink{};
  shared_ptr<long> opTenantId{};

  ExecuteAdHocTaskShrinkRequest() {}

  explicit ExecuteAdHocTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (executeCommandShrink) {
      res["ExecuteCommand"] = boost::any(*executeCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExecuteCommand") != m.end() && !m["ExecuteCommand"].empty()) {
      executeCommandShrink = make_shared<string>(boost::any_cast<string>(m["ExecuteCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ExecuteAdHocTaskShrinkRequest() = default;
};
class ExecuteAdHocTaskResponseBodyExecuteResult : public Darabonba::Model {
public:
  shared_ptr<long> subTaskCount{};
  shared_ptr<string> taskId{};

  ExecuteAdHocTaskResponseBodyExecuteResult() {}

  explicit ExecuteAdHocTaskResponseBodyExecuteResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subTaskCount) {
      res["SubTaskCount"] = boost::any(*subTaskCount);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubTaskCount") != m.end() && !m["SubTaskCount"].empty()) {
      subTaskCount = make_shared<long>(boost::any_cast<long>(m["SubTaskCount"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ExecuteAdHocTaskResponseBodyExecuteResult() = default;
};
class ExecuteAdHocTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ExecuteAdHocTaskResponseBodyExecuteResult> executeResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecuteAdHocTaskResponseBody() {}

  explicit ExecuteAdHocTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (executeResult) {
      res["ExecuteResult"] = executeResult ? boost::any(executeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExecuteResult") != m.end() && !m["ExecuteResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecuteResult"].type()) {
        ExecuteAdHocTaskResponseBodyExecuteResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecuteResult"]));
        executeResult = make_shared<ExecuteAdHocTaskResponseBodyExecuteResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteAdHocTaskResponseBody() = default;
};
class ExecuteAdHocTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteAdHocTaskResponseBody> body{};

  ExecuteAdHocTaskResponse() {}

  explicit ExecuteAdHocTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteAdHocTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteAdHocTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteAdHocTaskResponse() = default;
};
class ExecuteManualNodeRequestExecuteCommandParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ExecuteManualNodeRequestExecuteCommandParamList() {}

  explicit ExecuteManualNodeRequestExecuteCommandParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ExecuteManualNodeRequestExecuteCommandParamList() = default;
};
class ExecuteManualNodeRequestExecuteCommand : public Darabonba::Model {
public:
  shared_ptr<string> endBizDate{};
  shared_ptr<string> flowName{};
  shared_ptr<string> nodeId{};
  shared_ptr<vector<ExecuteManualNodeRequestExecuteCommandParamList>> paramList{};
  shared_ptr<long> projectId{};
  shared_ptr<string> startBizDate{};

  ExecuteManualNodeRequestExecuteCommand() {}

  explicit ExecuteManualNodeRequestExecuteCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endBizDate) {
      res["EndBizDate"] = boost::any(*endBizDate);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (startBizDate) {
      res["StartBizDate"] = boost::any(*startBizDate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndBizDate") != m.end() && !m["EndBizDate"].empty()) {
      endBizDate = make_shared<string>(boost::any_cast<string>(m["EndBizDate"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<ExecuteManualNodeRequestExecuteCommandParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ExecuteManualNodeRequestExecuteCommandParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<ExecuteManualNodeRequestExecuteCommandParamList>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StartBizDate") != m.end() && !m["StartBizDate"].empty()) {
      startBizDate = make_shared<string>(boost::any_cast<string>(m["StartBizDate"]));
    }
  }


  virtual ~ExecuteManualNodeRequestExecuteCommand() = default;
};
class ExecuteManualNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<ExecuteManualNodeRequestExecuteCommand> executeCommand{};
  shared_ptr<long> opTenantId{};

  ExecuteManualNodeRequest() {}

  explicit ExecuteManualNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (executeCommand) {
      res["ExecuteCommand"] = executeCommand ? boost::any(executeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ExecuteCommand") != m.end() && !m["ExecuteCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecuteCommand"].type()) {
        ExecuteManualNodeRequestExecuteCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecuteCommand"]));
        executeCommand = make_shared<ExecuteManualNodeRequestExecuteCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ExecuteManualNodeRequest() = default;
};
class ExecuteManualNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> executeCommandShrink{};
  shared_ptr<long> opTenantId{};

  ExecuteManualNodeShrinkRequest() {}

  explicit ExecuteManualNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (executeCommandShrink) {
      res["ExecuteCommand"] = boost::any(*executeCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ExecuteCommand") != m.end() && !m["ExecuteCommand"].empty()) {
      executeCommandShrink = make_shared<string>(boost::any_cast<string>(m["ExecuteCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ExecuteManualNodeShrinkRequest() = default;
};
class ExecuteManualNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> flowId{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ExecuteManualNodeResponseBody() {}

  explicit ExecuteManualNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ExecuteManualNodeResponseBody() = default;
};
class ExecuteManualNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExecuteManualNodeResponseBody> body{};

  ExecuteManualNodeResponse() {}

  explicit ExecuteManualNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExecuteManualNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExecuteManualNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ExecuteManualNodeResponse() = default;
};
class FixDataRequestFixDataCommandDownStreamInstanceIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};

  FixDataRequestFixDataCommandDownStreamInstanceIdList() {}

  explicit FixDataRequestFixDataCommandDownStreamInstanceIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~FixDataRequestFixDataCommandDownStreamInstanceIdList() = default;
};
class FixDataRequestFixDataCommandRootInstanceId : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};

  FixDataRequestFixDataCommandRootInstanceId() {}

  explicit FixDataRequestFixDataCommandRootInstanceId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~FixDataRequestFixDataCommandRootInstanceId() = default;
};
class FixDataRequestFixDataCommand : public Darabonba::Model {
public:
  shared_ptr<bool> containRootInstance{};
  shared_ptr<vector<FixDataRequestFixDataCommandDownStreamInstanceIdList>> downStreamInstanceIdList{};
  shared_ptr<string> downstreamRange{};
  shared_ptr<bool> forceRerun{};
  shared_ptr<long> projectId{};
  shared_ptr<FixDataRequestFixDataCommandRootInstanceId> rootInstanceId{};

  FixDataRequestFixDataCommand() {}

  explicit FixDataRequestFixDataCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (containRootInstance) {
      res["ContainRootInstance"] = boost::any(*containRootInstance);
    }
    if (downStreamInstanceIdList) {
      vector<boost::any> temp1;
      for(auto item1:*downStreamInstanceIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownStreamInstanceIdList"] = boost::any(temp1);
    }
    if (downstreamRange) {
      res["DownstreamRange"] = boost::any(*downstreamRange);
    }
    if (forceRerun) {
      res["ForceRerun"] = boost::any(*forceRerun);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (rootInstanceId) {
      res["RootInstanceId"] = rootInstanceId ? boost::any(rootInstanceId->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContainRootInstance") != m.end() && !m["ContainRootInstance"].empty()) {
      containRootInstance = make_shared<bool>(boost::any_cast<bool>(m["ContainRootInstance"]));
    }
    if (m.find("DownStreamInstanceIdList") != m.end() && !m["DownStreamInstanceIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["DownStreamInstanceIdList"].type()) {
        vector<FixDataRequestFixDataCommandDownStreamInstanceIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownStreamInstanceIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FixDataRequestFixDataCommandDownStreamInstanceIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downStreamInstanceIdList = make_shared<vector<FixDataRequestFixDataCommandDownStreamInstanceIdList>>(expect1);
      }
    }
    if (m.find("DownstreamRange") != m.end() && !m["DownstreamRange"].empty()) {
      downstreamRange = make_shared<string>(boost::any_cast<string>(m["DownstreamRange"]));
    }
    if (m.find("ForceRerun") != m.end() && !m["ForceRerun"].empty()) {
      forceRerun = make_shared<bool>(boost::any_cast<bool>(m["ForceRerun"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RootInstanceId") != m.end() && !m["RootInstanceId"].empty()) {
      if (typeid(map<string, boost::any>) == m["RootInstanceId"].type()) {
        FixDataRequestFixDataCommandRootInstanceId model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RootInstanceId"]));
        rootInstanceId = make_shared<FixDataRequestFixDataCommandRootInstanceId>(model1);
      }
    }
  }


  virtual ~FixDataRequestFixDataCommand() = default;
};
class FixDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<FixDataRequestFixDataCommand> fixDataCommand{};
  shared_ptr<long> opTenantId{};

  FixDataRequest() {}

  explicit FixDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fixDataCommand) {
      res["FixDataCommand"] = fixDataCommand ? boost::any(fixDataCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FixDataCommand") != m.end() && !m["FixDataCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["FixDataCommand"].type()) {
        FixDataRequestFixDataCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FixDataCommand"]));
        fixDataCommand = make_shared<FixDataRequestFixDataCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~FixDataRequest() = default;
};
class FixDataShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> fixDataCommandShrink{};
  shared_ptr<long> opTenantId{};

  FixDataShrinkRequest() {}

  explicit FixDataShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fixDataCommandShrink) {
      res["FixDataCommand"] = boost::any(*fixDataCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FixDataCommand") != m.end() && !m["FixDataCommand"].empty()) {
      fixDataCommandShrink = make_shared<string>(boost::any_cast<string>(m["FixDataCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~FixDataShrinkRequest() = default;
};
class FixDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> submitId{};
  shared_ptr<bool> success{};

  FixDataResponseBody() {}

  explicit FixDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (submitId) {
      res["SubmitId"] = boost::any(*submitId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubmitId") != m.end() && !m["SubmitId"].empty()) {
      submitId = make_shared<string>(boost::any_cast<string>(m["SubmitId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~FixDataResponseBody() = default;
};
class FixDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FixDataResponseBody> body{};

  FixDataResponse() {}

  explicit FixDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FixDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FixDataResponseBody>(model1);
      }
    }
  }


  virtual ~FixDataResponse() = default;
};
class GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery : public Darabonba::Model {
public:
  shared_ptr<long> rowPermissionId{};
  shared_ptr<vector<long>> ruleIds{};

  GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery() {}

  explicit GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rowPermissionId) {
      res["RowPermissionId"] = boost::any(*rowPermissionId);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RowPermissionId") != m.end() && !m["RowPermissionId"].empty()) {
      rowPermissionId = make_shared<long>(boost::any_cast<long>(m["RowPermissionId"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ruleIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery() = default;
};
class GetAccountByRowPermissionIdRequest : public Darabonba::Model {
public:
  shared_ptr<GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery> getAccountByRowPermissionIdQuery{};
  shared_ptr<long> opTenantId{};

  GetAccountByRowPermissionIdRequest() {}

  explicit GetAccountByRowPermissionIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getAccountByRowPermissionIdQuery) {
      res["GetAccountByRowPermissionIdQuery"] = getAccountByRowPermissionIdQuery ? boost::any(getAccountByRowPermissionIdQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetAccountByRowPermissionIdQuery") != m.end() && !m["GetAccountByRowPermissionIdQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["GetAccountByRowPermissionIdQuery"].type()) {
        GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GetAccountByRowPermissionIdQuery"]));
        getAccountByRowPermissionIdQuery = make_shared<GetAccountByRowPermissionIdRequestGetAccountByRowPermissionIdQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetAccountByRowPermissionIdRequest() = default;
};
class GetAccountByRowPermissionIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> getAccountByRowPermissionIdQueryShrink{};
  shared_ptr<long> opTenantId{};

  GetAccountByRowPermissionIdShrinkRequest() {}

  explicit GetAccountByRowPermissionIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (getAccountByRowPermissionIdQueryShrink) {
      res["GetAccountByRowPermissionIdQuery"] = boost::any(*getAccountByRowPermissionIdQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GetAccountByRowPermissionIdQuery") != m.end() && !m["GetAccountByRowPermissionIdQuery"].empty()) {
      getAccountByRowPermissionIdQueryShrink = make_shared<string>(boost::any_cast<string>(m["GetAccountByRowPermissionIdQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetAccountByRowPermissionIdShrinkRequest() = default;
};
class GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};
  shared_ptr<string> accountName{};

  GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts() {}

  explicit GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
  }


  virtual ~GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts() = default;
};
class GetAccountByRowPermissionIdResponseBodyDataUserMappingList : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts>> accounts{};

  GetAccountByRowPermissionIdResponseBodyDataUserMappingList() {}

  explicit GetAccountByRowPermissionIdResponseBodyDataUserMappingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingListAccounts>>(expect1);
      }
    }
  }


  virtual ~GetAccountByRowPermissionIdResponseBodyDataUserMappingList() = default;
};
class GetAccountByRowPermissionIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingList>> userMappingList{};

  GetAccountByRowPermissionIdResponseBodyData() {}

  explicit GetAccountByRowPermissionIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (userMappingList) {
      vector<boost::any> temp1;
      for(auto item1:*userMappingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserMappingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("UserMappingList") != m.end() && !m["UserMappingList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserMappingList"].type()) {
        vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserMappingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountByRowPermissionIdResponseBodyDataUserMappingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userMappingList = make_shared<vector<GetAccountByRowPermissionIdResponseBodyDataUserMappingList>>(expect1);
      }
    }
  }


  virtual ~GetAccountByRowPermissionIdResponseBodyData() = default;
};
class GetAccountByRowPermissionIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetAccountByRowPermissionIdResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAccountByRowPermissionIdResponseBody() {}

  explicit GetAccountByRowPermissionIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetAccountByRowPermissionIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAccountByRowPermissionIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetAccountByRowPermissionIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAccountByRowPermissionIdResponseBody() = default;
};
class GetAccountByRowPermissionIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAccountByRowPermissionIdResponseBody> body{};

  GetAccountByRowPermissionIdResponse() {}

  explicit GetAccountByRowPermissionIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAccountByRowPermissionIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAccountByRowPermissionIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetAccountByRowPermissionIdResponse() = default;
};
class GetAdHocFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetAdHocFileRequest() {}

  explicit GetAdHocFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetAdHocFileRequest() = default;
};
class GetAdHocFileResponseBodyFileInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> creator{};
  shared_ptr<string> directory{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  GetAdHocFileResponseBodyFileInfo() {}

  explicit GetAdHocFileResponseBodyFileInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetAdHocFileResponseBodyFileInfo() = default;
};
class GetAdHocFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAdHocFileResponseBodyFileInfo> fileInfo{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAdHocFileResponseBody() {}

  explicit GetAdHocFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileInfo) {
      res["FileInfo"] = fileInfo ? boost::any(fileInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileInfo") != m.end() && !m["FileInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FileInfo"].type()) {
        GetAdHocFileResponseBodyFileInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FileInfo"]));
        fileInfo = make_shared<GetAdHocFileResponseBodyFileInfo>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAdHocFileResponseBody() = default;
};
class GetAdHocFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAdHocFileResponseBody> body{};

  GetAdHocFileResponse() {}

  explicit GetAdHocFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAdHocFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAdHocFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAdHocFileResponse() = default;
};
class GetAdHocTaskLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> offset{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> subTaskId{};
  shared_ptr<string> taskId{};

  GetAdHocTaskLogRequest() {}

  explicit GetAdHocTaskLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (subTaskId) {
      res["SubTaskId"] = boost::any(*subTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubTaskId") != m.end() && !m["SubTaskId"].empty()) {
      subTaskId = make_shared<long>(boost::any_cast<long>(m["SubTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetAdHocTaskLogRequest() = default;
};
class GetAdHocTaskLogResponseBodyLogInfo : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<bool> hasNext{};
  shared_ptr<bool> hasResult{};
  shared_ptr<long> nextOffset{};
  shared_ptr<long> subTaskId{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskStatus{};

  GetAdHocTaskLogResponseBodyLogInfo() {}

  explicit GetAdHocTaskLogResponseBodyLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (hasNext) {
      res["HasNext"] = boost::any(*hasNext);
    }
    if (hasResult) {
      res["HasResult"] = boost::any(*hasResult);
    }
    if (nextOffset) {
      res["NextOffset"] = boost::any(*nextOffset);
    }
    if (subTaskId) {
      res["SubTaskId"] = boost::any(*subTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("HasNext") != m.end() && !m["HasNext"].empty()) {
      hasNext = make_shared<bool>(boost::any_cast<bool>(m["HasNext"]));
    }
    if (m.find("HasResult") != m.end() && !m["HasResult"].empty()) {
      hasResult = make_shared<bool>(boost::any_cast<bool>(m["HasResult"]));
    }
    if (m.find("NextOffset") != m.end() && !m["NextOffset"].empty()) {
      nextOffset = make_shared<long>(boost::any_cast<long>(m["NextOffset"]));
    }
    if (m.find("SubTaskId") != m.end() && !m["SubTaskId"].empty()) {
      subTaskId = make_shared<long>(boost::any_cast<long>(m["SubTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~GetAdHocTaskLogResponseBodyLogInfo() = default;
};
class GetAdHocTaskLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetAdHocTaskLogResponseBodyLogInfo> logInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAdHocTaskLogResponseBody() {}

  explicit GetAdHocTaskLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (logInfo) {
      res["LogInfo"] = logInfo ? boost::any(logInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfo"].type()) {
        GetAdHocTaskLogResponseBodyLogInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfo"]));
        logInfo = make_shared<GetAdHocTaskLogResponseBodyLogInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAdHocTaskLogResponseBody() = default;
};
class GetAdHocTaskLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAdHocTaskLogResponseBody> body{};

  GetAdHocTaskLogResponse() {}

  explicit GetAdHocTaskLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAdHocTaskLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAdHocTaskLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetAdHocTaskLogResponse() = default;
};
class GetAdHocTaskResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> subTaskId{};
  shared_ptr<string> taskId{};

  GetAdHocTaskResultRequest() {}

  explicit GetAdHocTaskResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (subTaskId) {
      res["SubTaskId"] = boost::any(*subTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubTaskId") != m.end() && !m["SubTaskId"].empty()) {
      subTaskId = make_shared<long>(boost::any_cast<long>(m["SubTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetAdHocTaskResultRequest() = default;
};
class GetAdHocTaskResultResponseBodyExecuteResult : public Darabonba::Model {
public:
  shared_ptr<string> result{};
  shared_ptr<string> scheduleTaskId{};
  shared_ptr<string> taskId{};

  GetAdHocTaskResultResponseBodyExecuteResult() {}

  explicit GetAdHocTaskResultResponseBodyExecuteResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (scheduleTaskId) {
      res["ScheduleTaskId"] = boost::any(*scheduleTaskId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ScheduleTaskId") != m.end() && !m["ScheduleTaskId"].empty()) {
      scheduleTaskId = make_shared<string>(boost::any_cast<string>(m["ScheduleTaskId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetAdHocTaskResultResponseBodyExecuteResult() = default;
};
class GetAdHocTaskResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAdHocTaskResultResponseBodyExecuteResult> executeResult{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAdHocTaskResultResponseBody() {}

  explicit GetAdHocTaskResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (executeResult) {
      res["ExecuteResult"] = executeResult ? boost::any(executeResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExecuteResult") != m.end() && !m["ExecuteResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExecuteResult"].type()) {
        GetAdHocTaskResultResponseBodyExecuteResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExecuteResult"]));
        executeResult = make_shared<GetAdHocTaskResultResponseBodyExecuteResult>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAdHocTaskResultResponseBody() = default;
};
class GetAdHocTaskResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAdHocTaskResultResponseBody> body{};

  GetAdHocTaskResultResponse() {}

  explicit GetAdHocTaskResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAdHocTaskResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAdHocTaskResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetAdHocTaskResultResponse() = default;
};
class GetAlertEventRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  GetAlertEventRequest() {}

  explicit GetAlertEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetAlertEventRequest() = default;
};
class GetAlertEventResponseBodyAlertEventInfoAlertObject : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> sourceSystemType{};
  shared_ptr<string> type{};

  GetAlertEventResponseBodyAlertEventInfoAlertObject() {}

  explicit GetAlertEventResponseBodyAlertEventInfoAlertObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceSystemType) {
      res["SourceSystemType"] = boost::any(*sourceSystemType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceSystemType") != m.end() && !m["SourceSystemType"].empty()) {
      sourceSystemType = make_shared<string>(boost::any_cast<string>(m["SourceSystemType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoAlertObject() = default;
};
class GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList() {}

  explicit GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList() = default;
};
class GetAlertEventResponseBodyAlertEventInfoAlertReason : public Darabonba::Model {
public:
  shared_ptr<vector<GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList>> alertReasonParamList{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> type{};
  shared_ptr<string> uniqueKey{};

  GetAlertEventResponseBodyAlertEventInfoAlertReason() {}

  explicit GetAlertEventResponseBodyAlertEventInfoAlertReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertReasonParamList) {
      vector<boost::any> temp1;
      for(auto item1:*alertReasonParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertReasonParamList"] = boost::any(temp1);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertReasonParamList") != m.end() && !m["AlertReasonParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertReasonParamList"].type()) {
        vector<GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertReasonParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertReasonParamList = make_shared<vector<GetAlertEventResponseBodyAlertEventInfoAlertReasonAlertReasonParamList>>(expect1);
      }
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoAlertReason() = default;
};
class GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList() {}

  explicit GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList() = default;
};
class GetAlertEventResponseBodyAlertEventInfoAlertReceiverList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alertChannelTypeList{};
  shared_ptr<vector<string>> customAlertChannelIdList{};
  shared_ptr<string> onCallTableName{};
  shared_ptr<string> type{};
  shared_ptr<vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList>> userList{};

  GetAlertEventResponseBodyAlertEventInfoAlertReceiverList() {}

  explicit GetAlertEventResponseBodyAlertEventInfoAlertReceiverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertChannelTypeList) {
      res["AlertChannelTypeList"] = boost::any(*alertChannelTypeList);
    }
    if (customAlertChannelIdList) {
      res["CustomAlertChannelIdList"] = boost::any(*customAlertChannelIdList);
    }
    if (onCallTableName) {
      res["OnCallTableName"] = boost::any(*onCallTableName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertChannelTypeList") != m.end() && !m["AlertChannelTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertChannelTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertChannelTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertChannelTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomAlertChannelIdList") != m.end() && !m["CustomAlertChannelIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomAlertChannelIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomAlertChannelIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customAlertChannelIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OnCallTableName") != m.end() && !m["OnCallTableName"].empty()) {
      onCallTableName = make_shared<string>(boost::any_cast<string>(m["OnCallTableName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverListUserList>>(expect1);
      }
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoAlertReceiverList() = default;
};
class GetAlertEventResponseBodyAlertEventInfoBelongProject : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<string> projectName{};

  GetAlertEventResponseBodyAlertEventInfoBelongProject() {}

  explicit GetAlertEventResponseBodyAlertEventInfoBelongProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoBelongProject() = default;
};
class GetAlertEventResponseBodyAlertEventInfoUrlConfig : public Darabonba::Model {
public:
  shared_ptr<string> alertConfigUrl{};
  shared_ptr<string> logUrl{};
  shared_ptr<string> objectUrl{};

  GetAlertEventResponseBodyAlertEventInfoUrlConfig() {}

  explicit GetAlertEventResponseBodyAlertEventInfoUrlConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfigUrl) {
      res["AlertConfigUrl"] = boost::any(*alertConfigUrl);
    }
    if (logUrl) {
      res["LogUrl"] = boost::any(*logUrl);
    }
    if (objectUrl) {
      res["ObjectUrl"] = boost::any(*objectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfigUrl") != m.end() && !m["AlertConfigUrl"].empty()) {
      alertConfigUrl = make_shared<string>(boost::any_cast<string>(m["AlertConfigUrl"]));
    }
    if (m.find("LogUrl") != m.end() && !m["LogUrl"].empty()) {
      logUrl = make_shared<string>(boost::any_cast<string>(m["LogUrl"]));
    }
    if (m.find("ObjectUrl") != m.end() && !m["ObjectUrl"].empty()) {
      objectUrl = make_shared<string>(boost::any_cast<string>(m["ObjectUrl"]));
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfoUrlConfig() = default;
};
class GetAlertEventResponseBodyAlertEventInfo : public Darabonba::Model {
public:
  shared_ptr<string> alertFrequency{};
  shared_ptr<GetAlertEventResponseBodyAlertEventInfoAlertObject> alertObject{};
  shared_ptr<GetAlertEventResponseBodyAlertEventInfoAlertReason> alertReason{};
  shared_ptr<vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverList>> alertReceiverList{};
  shared_ptr<GetAlertEventResponseBodyAlertEventInfoBelongProject> belongProject{};
  shared_ptr<string> doNotDisturbEndTime{};
  shared_ptr<string> firstAlertTime{};
  shared_ptr<long> id{};
  shared_ptr<string> latestAlertTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalAlertTimes{};
  shared_ptr<GetAlertEventResponseBodyAlertEventInfoUrlConfig> urlConfig{};

  GetAlertEventResponseBodyAlertEventInfo() {}

  explicit GetAlertEventResponseBodyAlertEventInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertFrequency) {
      res["AlertFrequency"] = boost::any(*alertFrequency);
    }
    if (alertObject) {
      res["AlertObject"] = alertObject ? boost::any(alertObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReason) {
      res["AlertReason"] = alertReason ? boost::any(alertReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReceiverList) {
      vector<boost::any> temp1;
      for(auto item1:*alertReceiverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertReceiverList"] = boost::any(temp1);
    }
    if (belongProject) {
      res["BelongProject"] = belongProject ? boost::any(belongProject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (doNotDisturbEndTime) {
      res["DoNotDisturbEndTime"] = boost::any(*doNotDisturbEndTime);
    }
    if (firstAlertTime) {
      res["FirstAlertTime"] = boost::any(*firstAlertTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (latestAlertTime) {
      res["LatestAlertTime"] = boost::any(*latestAlertTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalAlertTimes) {
      res["TotalAlertTimes"] = boost::any(*totalAlertTimes);
    }
    if (urlConfig) {
      res["UrlConfig"] = urlConfig ? boost::any(urlConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertFrequency") != m.end() && !m["AlertFrequency"].empty()) {
      alertFrequency = make_shared<string>(boost::any_cast<string>(m["AlertFrequency"]));
    }
    if (m.find("AlertObject") != m.end() && !m["AlertObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertObject"].type()) {
        GetAlertEventResponseBodyAlertEventInfoAlertObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertObject"]));
        alertObject = make_shared<GetAlertEventResponseBodyAlertEventInfoAlertObject>(model1);
      }
    }
    if (m.find("AlertReason") != m.end() && !m["AlertReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertReason"].type()) {
        GetAlertEventResponseBodyAlertEventInfoAlertReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertReason"]));
        alertReason = make_shared<GetAlertEventResponseBodyAlertEventInfoAlertReason>(model1);
      }
    }
    if (m.find("AlertReceiverList") != m.end() && !m["AlertReceiverList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertReceiverList"].type()) {
        vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertReceiverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAlertEventResponseBodyAlertEventInfoAlertReceiverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertReceiverList = make_shared<vector<GetAlertEventResponseBodyAlertEventInfoAlertReceiverList>>(expect1);
      }
    }
    if (m.find("BelongProject") != m.end() && !m["BelongProject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BelongProject"].type()) {
        GetAlertEventResponseBodyAlertEventInfoBelongProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BelongProject"]));
        belongProject = make_shared<GetAlertEventResponseBodyAlertEventInfoBelongProject>(model1);
      }
    }
    if (m.find("DoNotDisturbEndTime") != m.end() && !m["DoNotDisturbEndTime"].empty()) {
      doNotDisturbEndTime = make_shared<string>(boost::any_cast<string>(m["DoNotDisturbEndTime"]));
    }
    if (m.find("FirstAlertTime") != m.end() && !m["FirstAlertTime"].empty()) {
      firstAlertTime = make_shared<string>(boost::any_cast<string>(m["FirstAlertTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LatestAlertTime") != m.end() && !m["LatestAlertTime"].empty()) {
      latestAlertTime = make_shared<string>(boost::any_cast<string>(m["LatestAlertTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalAlertTimes") != m.end() && !m["TotalAlertTimes"].empty()) {
      totalAlertTimes = make_shared<long>(boost::any_cast<long>(m["TotalAlertTimes"]));
    }
    if (m.find("UrlConfig") != m.end() && !m["UrlConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UrlConfig"].type()) {
        GetAlertEventResponseBodyAlertEventInfoUrlConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UrlConfig"]));
        urlConfig = make_shared<GetAlertEventResponseBodyAlertEventInfoUrlConfig>(model1);
      }
    }
  }


  virtual ~GetAlertEventResponseBodyAlertEventInfo() = default;
};
class GetAlertEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetAlertEventResponseBodyAlertEventInfo> alertEventInfo{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetAlertEventResponseBody() {}

  explicit GetAlertEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertEventInfo) {
      res["AlertEventInfo"] = alertEventInfo ? boost::any(alertEventInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertEventInfo") != m.end() && !m["AlertEventInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertEventInfo"].type()) {
        GetAlertEventResponseBodyAlertEventInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertEventInfo"]));
        alertEventInfo = make_shared<GetAlertEventResponseBodyAlertEventInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetAlertEventResponseBody() = default;
};
class GetAlertEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAlertEventResponseBody> body{};

  GetAlertEventResponse() {}

  explicit GetAlertEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAlertEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAlertEventResponseBody>(model1);
      }
    }
  }


  virtual ~GetAlertEventResponse() = default;
};
class GetBatchTaskInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> fileId{};
  shared_ptr<bool> includeAllUpStreams{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetBatchTaskInfoRequest() {}

  explicit GetBatchTaskInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (includeAllUpStreams) {
      res["IncludeAllUpStreams"] = boost::any(*includeAllUpStreams);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("IncludeAllUpStreams") != m.end() && !m["IncludeAllUpStreams"].empty()) {
      includeAllUpStreams = make_shared<bool>(boost::any_cast<bool>(m["IncludeAllUpStreams"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetBatchTaskInfoRequest() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> intervalUnit{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<string> startTime{};

  GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (intervalUnit) {
      res["IntervalUnit"] = boost::any(*intervalUnit);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IntervalUnit") != m.end() && !m["IntervalUnit"].empty()) {
      intervalUnit = make_shared<string>(boost::any_cast<string>(m["IntervalUnit"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfoParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetBatchTaskInfoResponseBodyTaskInfoParamList() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfoParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfoParamList() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> sparkClientVersion{};

  GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sparkClientVersion) {
      res["SparkClientVersion"] = boost::any(*sparkClientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SparkClientVersion") != m.end() && !m["SparkClientVersion"].empty()) {
      sparkClientVersion = make_shared<string>(boost::any_cast<string>(m["SparkClientVersion"]));
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod : public Darabonba::Model {
public:
  shared_ptr<long> periodOffset{};
  shared_ptr<string> periodType{};

  GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodOffset) {
      res["PeriodOffset"] = boost::any(*periodOffset);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodOffset") != m.end() && !m["PeriodOffset"].empty()) {
      periodOffset = make_shared<long>(boost::any_cast<long>(m["PeriodOffset"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfoUpStreamList : public Darabonba::Model {
public:
  shared_ptr<GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod> dependPeriod{};
  shared_ptr<string> dependStrategy{};
  shared_ptr<vector<string>> fieldList{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> periodDiff{};
  shared_ptr<bool> sourceNodeEnabled{};
  shared_ptr<string> sourceNodeId{};
  shared_ptr<string> sourceNodeName{};
  shared_ptr<string> sourceNodeOutputName{};
  shared_ptr<string> sourceNodeUserName{};
  shared_ptr<string> sourceTableName{};

  GetBatchTaskInfoResponseBodyTaskInfoUpStreamList() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfoUpStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependPeriod) {
      res["DependPeriod"] = dependPeriod ? boost::any(dependPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependStrategy) {
      res["DependStrategy"] = boost::any(*dependStrategy);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (periodDiff) {
      res["PeriodDiff"] = boost::any(*periodDiff);
    }
    if (sourceNodeEnabled) {
      res["SourceNodeEnabled"] = boost::any(*sourceNodeEnabled);
    }
    if (sourceNodeId) {
      res["SourceNodeId"] = boost::any(*sourceNodeId);
    }
    if (sourceNodeName) {
      res["SourceNodeName"] = boost::any(*sourceNodeName);
    }
    if (sourceNodeOutputName) {
      res["SourceNodeOutputName"] = boost::any(*sourceNodeOutputName);
    }
    if (sourceNodeUserName) {
      res["SourceNodeUserName"] = boost::any(*sourceNodeUserName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependPeriod") != m.end() && !m["DependPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependPeriod"].type()) {
        GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependPeriod"]));
        dependPeriod = make_shared<GetBatchTaskInfoResponseBodyTaskInfoUpStreamListDependPeriod>(model1);
      }
    }
    if (m.find("DependStrategy") != m.end() && !m["DependStrategy"].empty()) {
      dependStrategy = make_shared<string>(boost::any_cast<string>(m["DependStrategy"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PeriodDiff") != m.end() && !m["PeriodDiff"].empty()) {
      periodDiff = make_shared<long>(boost::any_cast<long>(m["PeriodDiff"]));
    }
    if (m.find("SourceNodeEnabled") != m.end() && !m["SourceNodeEnabled"].empty()) {
      sourceNodeEnabled = make_shared<bool>(boost::any_cast<bool>(m["SourceNodeEnabled"]));
    }
    if (m.find("SourceNodeId") != m.end() && !m["SourceNodeId"].empty()) {
      sourceNodeId = make_shared<string>(boost::any_cast<string>(m["SourceNodeId"]));
    }
    if (m.find("SourceNodeName") != m.end() && !m["SourceNodeName"].empty()) {
      sourceNodeName = make_shared<string>(boost::any_cast<string>(m["SourceNodeName"]));
    }
    if (m.find("SourceNodeOutputName") != m.end() && !m["SourceNodeOutputName"].empty()) {
      sourceNodeOutputName = make_shared<string>(boost::any_cast<string>(m["SourceNodeOutputName"]));
    }
    if (m.find("SourceNodeUserName") != m.end() && !m["SourceNodeUserName"].empty()) {
      sourceNodeUserName = make_shared<string>(boost::any_cast<string>(m["SourceNodeUserName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfoUpStreamList() = default;
};
class GetBatchTaskInfoResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> cronExpression{};
  shared_ptr<GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig> customScheduleConfig{};
  shared_ptr<string> dagId{};
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<string> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<long> fileId{};
  shared_ptr<bool> hasDevNode{};
  shared_ptr<string> name{};
  shared_ptr<bool> needPublish{};
  shared_ptr<string> nodeDescription{};
  shared_ptr<string> nodeFrom{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<vector<string>> nodeOutputNameList{};
  shared_ptr<long> nodeStatus{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<GetBatchTaskInfoResponseBodyTaskInfoParamList>> paramList{};
  shared_ptr<bool> paused{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> published{};
  shared_ptr<string> remark{};
  shared_ptr<bool> rerunable{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<long> scheduleType{};
  shared_ptr<GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo> sparkClientInfo{};
  shared_ptr<string> status{};
  shared_ptr<long> taskType{};
  shared_ptr<vector<GetBatchTaskInfoResponseBodyTaskInfoUpStreamList>> upStreamList{};

  GetBatchTaskInfoResponseBodyTaskInfo() {}

  explicit GetBatchTaskInfoResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (customScheduleConfig) {
      res["CustomScheduleConfig"] = customScheduleConfig ? boost::any(customScheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (hasDevNode) {
      res["HasDevNode"] = boost::any(*hasDevNode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needPublish) {
      res["NeedPublish"] = boost::any(*needPublish);
    }
    if (nodeDescription) {
      res["NodeDescription"] = boost::any(*nodeDescription);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutputNameList) {
      res["NodeOutputNameList"] = boost::any(*nodeOutputNameList);
    }
    if (nodeStatus) {
      res["NodeStatus"] = boost::any(*nodeStatus);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (rerunable) {
      res["Rerunable"] = boost::any(*rerunable);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (sparkClientInfo) {
      res["SparkClientInfo"] = sparkClientInfo ? boost::any(sparkClientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (upStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*upStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpStreamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CustomScheduleConfig") != m.end() && !m["CustomScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomScheduleConfig"].type()) {
        GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomScheduleConfig"]));
        customScheduleConfig = make_shared<GetBatchTaskInfoResponseBodyTaskInfoCustomScheduleConfig>(model1);
      }
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<string>(boost::any_cast<string>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("HasDevNode") != m.end() && !m["HasDevNode"].empty()) {
      hasDevNode = make_shared<bool>(boost::any_cast<bool>(m["HasDevNode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedPublish") != m.end() && !m["NeedPublish"].empty()) {
      needPublish = make_shared<bool>(boost::any_cast<bool>(m["NeedPublish"]));
    }
    if (m.find("NodeDescription") != m.end() && !m["NodeDescription"].empty()) {
      nodeDescription = make_shared<string>(boost::any_cast<string>(m["NodeDescription"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<string>(boost::any_cast<string>(m["NodeFrom"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutputNameList") != m.end() && !m["NodeOutputNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeOutputNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeOutputNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeOutputNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      nodeStatus = make_shared<long>(boost::any_cast<long>(m["NodeStatus"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<GetBatchTaskInfoResponseBodyTaskInfoParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskInfoResponseBodyTaskInfoParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<GetBatchTaskInfoResponseBodyTaskInfoParamList>>(expect1);
      }
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<bool>(boost::any_cast<bool>(m["Paused"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Rerunable") != m.end() && !m["Rerunable"].empty()) {
      rerunable = make_shared<bool>(boost::any_cast<bool>(m["Rerunable"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<long>(boost::any_cast<long>(m["ScheduleType"]));
    }
    if (m.find("SparkClientInfo") != m.end() && !m["SparkClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SparkClientInfo"].type()) {
        GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SparkClientInfo"]));
        sparkClientInfo = make_shared<GetBatchTaskInfoResponseBodyTaskInfoSparkClientInfo>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpStreamList") != m.end() && !m["UpStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpStreamList"].type()) {
        vector<GetBatchTaskInfoResponseBodyTaskInfoUpStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskInfoResponseBodyTaskInfoUpStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upStreamList = make_shared<vector<GetBatchTaskInfoResponseBodyTaskInfoUpStreamList>>(expect1);
      }
    }
  }


  virtual ~GetBatchTaskInfoResponseBodyTaskInfo() = default;
};
class GetBatchTaskInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetBatchTaskInfoResponseBodyTaskInfo> taskInfo{};

  GetBatchTaskInfoResponseBody() {}

  explicit GetBatchTaskInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        GetBatchTaskInfoResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<GetBatchTaskInfoResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~GetBatchTaskInfoResponseBody() = default;
};
class GetBatchTaskInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchTaskInfoResponseBody> body{};

  GetBatchTaskInfoResponse() {}

  explicit GetBatchTaskInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchTaskInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchTaskInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchTaskInfoResponse() = default;
};
class GetBatchTaskInfoByVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> versionId{};

  GetBatchTaskInfoByVersionRequest() {}

  explicit GetBatchTaskInfoByVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionRequest() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> intervalUnit{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<string> startTime{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (intervalUnit) {
      res["IntervalUnit"] = boost::any(*intervalUnit);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IntervalUnit") != m.end() && !m["IntervalUnit"].empty()) {
      intervalUnit = make_shared<string>(boost::any_cast<string>(m["IntervalUnit"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> sparkClientVersion{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sparkClientVersion) {
      res["SparkClientVersion"] = boost::any(*sparkClientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SparkClientVersion") != m.end() && !m["SparkClientVersion"].empty()) {
      sparkClientVersion = make_shared<string>(boost::any_cast<string>(m["SparkClientVersion"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod : public Darabonba::Model {
public:
  shared_ptr<long> periodOffset{};
  shared_ptr<string> periodType{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodOffset) {
      res["PeriodOffset"] = boost::any(*periodOffset);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodOffset") != m.end() && !m["PeriodOffset"].empty()) {
      periodOffset = make_shared<long>(boost::any_cast<long>(m["PeriodOffset"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList : public Darabonba::Model {
public:
  shared_ptr<GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod> dependPeriod{};
  shared_ptr<string> dependStrategy{};
  shared_ptr<vector<string>> fieldList{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> periodDiff{};
  shared_ptr<bool> sourceNodeEnabled{};
  shared_ptr<string> sourceNodeId{};
  shared_ptr<string> sourceNodeName{};
  shared_ptr<string> sourceNodeOutputName{};
  shared_ptr<string> sourceNodeUserName{};
  shared_ptr<string> sourceTableName{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependPeriod) {
      res["DependPeriod"] = dependPeriod ? boost::any(dependPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependStrategy) {
      res["DependStrategy"] = boost::any(*dependStrategy);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (periodDiff) {
      res["PeriodDiff"] = boost::any(*periodDiff);
    }
    if (sourceNodeEnabled) {
      res["SourceNodeEnabled"] = boost::any(*sourceNodeEnabled);
    }
    if (sourceNodeId) {
      res["SourceNodeId"] = boost::any(*sourceNodeId);
    }
    if (sourceNodeName) {
      res["SourceNodeName"] = boost::any(*sourceNodeName);
    }
    if (sourceNodeOutputName) {
      res["SourceNodeOutputName"] = boost::any(*sourceNodeOutputName);
    }
    if (sourceNodeUserName) {
      res["SourceNodeUserName"] = boost::any(*sourceNodeUserName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependPeriod") != m.end() && !m["DependPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependPeriod"].type()) {
        GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependPeriod"]));
        dependPeriod = make_shared<GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamListDependPeriod>(model1);
      }
    }
    if (m.find("DependStrategy") != m.end() && !m["DependStrategy"].empty()) {
      dependStrategy = make_shared<string>(boost::any_cast<string>(m["DependStrategy"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PeriodDiff") != m.end() && !m["PeriodDiff"].empty()) {
      periodDiff = make_shared<long>(boost::any_cast<long>(m["PeriodDiff"]));
    }
    if (m.find("SourceNodeEnabled") != m.end() && !m["SourceNodeEnabled"].empty()) {
      sourceNodeEnabled = make_shared<bool>(boost::any_cast<bool>(m["SourceNodeEnabled"]));
    }
    if (m.find("SourceNodeId") != m.end() && !m["SourceNodeId"].empty()) {
      sourceNodeId = make_shared<string>(boost::any_cast<string>(m["SourceNodeId"]));
    }
    if (m.find("SourceNodeName") != m.end() && !m["SourceNodeName"].empty()) {
      sourceNodeName = make_shared<string>(boost::any_cast<string>(m["SourceNodeName"]));
    }
    if (m.find("SourceNodeOutputName") != m.end() && !m["SourceNodeOutputName"].empty()) {
      sourceNodeOutputName = make_shared<string>(boost::any_cast<string>(m["SourceNodeOutputName"]));
    }
    if (m.find("SourceNodeUserName") != m.end() && !m["SourceNodeUserName"].empty()) {
      sourceNodeUserName = make_shared<string>(boost::any_cast<string>(m["SourceNodeUserName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList() = default;
};
class GetBatchTaskInfoByVersionResponseBodyTaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> cronExpression{};
  shared_ptr<GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig> customScheduleConfig{};
  shared_ptr<string> dagId{};
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<string> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<long> fileId{};
  shared_ptr<bool> hasDevNode{};
  shared_ptr<string> name{};
  shared_ptr<bool> needPublish{};
  shared_ptr<string> nodeDescription{};
  shared_ptr<string> nodeFrom{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<vector<string>> nodeOutputNameList{};
  shared_ptr<long> nodeStatus{};
  shared_ptr<string> operatorUserId{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList>> paramList{};
  shared_ptr<bool> paused{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> published{};
  shared_ptr<string> remark{};
  shared_ptr<bool> rerunable{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<long> scheduleType{};
  shared_ptr<GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo> sparkClientInfo{};
  shared_ptr<string> status{};
  shared_ptr<long> taskType{};
  shared_ptr<vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList>> upStreamList{};

  GetBatchTaskInfoByVersionResponseBodyTaskInfo() {}

  explicit GetBatchTaskInfoByVersionResponseBodyTaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (customScheduleConfig) {
      res["CustomScheduleConfig"] = customScheduleConfig ? boost::any(customScheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dagId) {
      res["DagId"] = boost::any(*dagId);
    }
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (hasDevNode) {
      res["HasDevNode"] = boost::any(*hasDevNode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needPublish) {
      res["NeedPublish"] = boost::any(*needPublish);
    }
    if (nodeDescription) {
      res["NodeDescription"] = boost::any(*nodeDescription);
    }
    if (nodeFrom) {
      res["NodeFrom"] = boost::any(*nodeFrom);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutputNameList) {
      res["NodeOutputNameList"] = boost::any(*nodeOutputNameList);
    }
    if (nodeStatus) {
      res["NodeStatus"] = boost::any(*nodeStatus);
    }
    if (operatorUserId) {
      res["OperatorUserId"] = boost::any(*operatorUserId);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (paused) {
      res["Paused"] = boost::any(*paused);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (rerunable) {
      res["Rerunable"] = boost::any(*rerunable);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (sparkClientInfo) {
      res["SparkClientInfo"] = sparkClientInfo ? boost::any(sparkClientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (upStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*upStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpStreamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CustomScheduleConfig") != m.end() && !m["CustomScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomScheduleConfig"].type()) {
        GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomScheduleConfig"]));
        customScheduleConfig = make_shared<GetBatchTaskInfoByVersionResponseBodyTaskInfoCustomScheduleConfig>(model1);
      }
    }
    if (m.find("DagId") != m.end() && !m["DagId"].empty()) {
      dagId = make_shared<string>(boost::any_cast<string>(m["DagId"]));
    }
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<string>(boost::any_cast<string>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("HasDevNode") != m.end() && !m["HasDevNode"].empty()) {
      hasDevNode = make_shared<bool>(boost::any_cast<bool>(m["HasDevNode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedPublish") != m.end() && !m["NeedPublish"].empty()) {
      needPublish = make_shared<bool>(boost::any_cast<bool>(m["NeedPublish"]));
    }
    if (m.find("NodeDescription") != m.end() && !m["NodeDescription"].empty()) {
      nodeDescription = make_shared<string>(boost::any_cast<string>(m["NodeDescription"]));
    }
    if (m.find("NodeFrom") != m.end() && !m["NodeFrom"].empty()) {
      nodeFrom = make_shared<string>(boost::any_cast<string>(m["NodeFrom"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutputNameList") != m.end() && !m["NodeOutputNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeOutputNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeOutputNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeOutputNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      nodeStatus = make_shared<long>(boost::any_cast<long>(m["NodeStatus"]));
    }
    if (m.find("OperatorUserId") != m.end() && !m["OperatorUserId"].empty()) {
      operatorUserId = make_shared<string>(boost::any_cast<string>(m["OperatorUserId"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoParamList>>(expect1);
      }
    }
    if (m.find("Paused") != m.end() && !m["Paused"].empty()) {
      paused = make_shared<bool>(boost::any_cast<bool>(m["Paused"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Rerunable") != m.end() && !m["Rerunable"].empty()) {
      rerunable = make_shared<bool>(boost::any_cast<bool>(m["Rerunable"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<long>(boost::any_cast<long>(m["ScheduleType"]));
    }
    if (m.find("SparkClientInfo") != m.end() && !m["SparkClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SparkClientInfo"].type()) {
        GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SparkClientInfo"]));
        sparkClientInfo = make_shared<GetBatchTaskInfoByVersionResponseBodyTaskInfoSparkClientInfo>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpStreamList") != m.end() && !m["UpStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpStreamList"].type()) {
        vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upStreamList = make_shared<vector<GetBatchTaskInfoByVersionResponseBodyTaskInfoUpStreamList>>(expect1);
      }
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBodyTaskInfo() = default;
};
class GetBatchTaskInfoByVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetBatchTaskInfoByVersionResponseBodyTaskInfo> taskInfo{};

  GetBatchTaskInfoByVersionResponseBody() {}

  explicit GetBatchTaskInfoByVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskInfo) {
      res["TaskInfo"] = taskInfo ? boost::any(taskInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskInfo") != m.end() && !m["TaskInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TaskInfo"].type()) {
        GetBatchTaskInfoByVersionResponseBodyTaskInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TaskInfo"]));
        taskInfo = make_shared<GetBatchTaskInfoByVersionResponseBodyTaskInfo>(model1);
      }
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponseBody() = default;
};
class GetBatchTaskInfoByVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchTaskInfoByVersionResponseBody> body{};

  GetBatchTaskInfoByVersionResponse() {}

  explicit GetBatchTaskInfoByVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchTaskInfoByVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchTaskInfoByVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchTaskInfoByVersionResponse() = default;
};
class GetBatchTaskUdfLineagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetBatchTaskUdfLineagesRequest() {}

  explicit GetBatchTaskUdfLineagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesRequest() = default;
};
class GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<bool> partitionKey{};
  shared_ptr<bool> primaryKey{};

  GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList() {}

  explicit GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (partitionKey) {
      res["PartitionKey"] = boost::any(*partitionKey);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PartitionKey") != m.end() && !m["PartitionKey"].empty()) {
      partitionKey = make_shared<bool>(boost::any_cast<bool>(m["PartitionKey"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<bool>(boost::any_cast<bool>(m["PrimaryKey"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList() = default;
};
class GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitId{};
  shared_ptr<string> bizUnitName{};
  shared_ptr<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList>> columnList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<bool> fullTable{};
  shared_ptr<string> guid{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> subType{};

  GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList() {}

  explicit GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fullTable) {
      res["FullTable"] = boost::any(*fullTable);
    }
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<string>(boost::any_cast<string>(m["BizUnitId"]));
    }
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageListColumnList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FullTable") != m.end() && !m["FullTable"].empty()) {
      fullTable = make_shared<bool>(boost::any_cast<bool>(m["FullTable"]));
    }
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList() = default;
};
class GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList : public Darabonba::Model {
public:
  shared_ptr<string> dataType{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<bool> partitionKey{};
  shared_ptr<bool> primaryKey{};

  GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList() {}

  explicit GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (partitionKey) {
      res["PartitionKey"] = boost::any(*partitionKey);
    }
    if (primaryKey) {
      res["PrimaryKey"] = boost::any(*primaryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<string>(boost::any_cast<string>(m["DataType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PartitionKey") != m.end() && !m["PartitionKey"].empty()) {
      partitionKey = make_shared<bool>(boost::any_cast<bool>(m["PartitionKey"]));
    }
    if (m.find("PrimaryKey") != m.end() && !m["PrimaryKey"].empty()) {
      primaryKey = make_shared<bool>(boost::any_cast<bool>(m["PrimaryKey"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList() = default;
};
class GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitId{};
  shared_ptr<string> bizUnitName{};
  shared_ptr<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList>> columnList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<bool> fullTable{};
  shared_ptr<string> guid{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> subType{};

  GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList() {}

  explicit GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (columnList) {
      vector<boost::any> temp1;
      for(auto item1:*columnList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fullTable) {
      res["FullTable"] = boost::any(*fullTable);
    }
    if (guid) {
      res["Guid"] = boost::any(*guid);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<string>(boost::any_cast<string>(m["BizUnitId"]));
    }
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnList = make_shared<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageListColumnList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FullTable") != m.end() && !m["FullTable"].empty()) {
      fullTable = make_shared<bool>(boost::any_cast<bool>(m["FullTable"]));
    }
    if (m.find("Guid") != m.end() && !m["Guid"].empty()) {
      guid = make_shared<string>(boost::any_cast<string>(m["Guid"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList() = default;
};
class GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList>> inputLineageList{};
  shared_ptr<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList>> outputLineageList{};

  GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList() {}

  explicit GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputLineageList) {
      vector<boost::any> temp1;
      for(auto item1:*inputLineageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputLineageList"] = boost::any(temp1);
    }
    if (outputLineageList) {
      vector<boost::any> temp1;
      for(auto item1:*outputLineageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputLineageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputLineageList") != m.end() && !m["InputLineageList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputLineageList"].type()) {
        vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputLineageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputLineageList = make_shared<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListInputLineageList>>(expect1);
      }
    }
    if (m.find("OutputLineageList") != m.end() && !m["OutputLineageList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputLineageList"].type()) {
        vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputLineageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputLineageList = make_shared<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupListOutputLineageList>>(expect1);
      }
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList() = default;
};
class GetBatchTaskUdfLineagesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList>> lineageGroupList{};

  GetBatchTaskUdfLineagesResponseBodyData() {}

  explicit GetBatchTaskUdfLineagesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lineageGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*lineageGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LineageGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LineageGroupList") != m.end() && !m["LineageGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["LineageGroupList"].type()) {
        vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LineageGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineageGroupList = make_shared<vector<GetBatchTaskUdfLineagesResponseBodyDataLineageGroupList>>(expect1);
      }
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBodyData() = default;
};
class GetBatchTaskUdfLineagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetBatchTaskUdfLineagesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBatchTaskUdfLineagesResponseBody() {}

  explicit GetBatchTaskUdfLineagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBatchTaskUdfLineagesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBatchTaskUdfLineagesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponseBody() = default;
};
class GetBatchTaskUdfLineagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchTaskUdfLineagesResponseBody> body{};

  GetBatchTaskUdfLineagesResponse() {}

  explicit GetBatchTaskUdfLineagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchTaskUdfLineagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchTaskUdfLineagesResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchTaskUdfLineagesResponse() = default;
};
class GetBatchTaskVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetBatchTaskVersionsRequest() {}

  explicit GetBatchTaskVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetBatchTaskVersionsRequest() = default;
};
class GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> published{};
  shared_ptr<string> userId{};
  shared_ptr<string> userName{};
  shared_ptr<string> version{};

  GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList() {}

  explicit GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList() = default;
};
class GetBatchTaskVersionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList>> batchTaskVersionList{};

  GetBatchTaskVersionsResponseBodyData() {}

  explicit GetBatchTaskVersionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTaskVersionList) {
      vector<boost::any> temp1;
      for(auto item1:*batchTaskVersionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BatchTaskVersionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTaskVersionList") != m.end() && !m["BatchTaskVersionList"].empty()) {
      if (typeid(vector<boost::any>) == m["BatchTaskVersionList"].type()) {
        vector<GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BatchTaskVersionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        batchTaskVersionList = make_shared<vector<GetBatchTaskVersionsResponseBodyDataBatchTaskVersionList>>(expect1);
      }
    }
  }


  virtual ~GetBatchTaskVersionsResponseBodyData() = default;
};
class GetBatchTaskVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetBatchTaskVersionsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBatchTaskVersionsResponseBody() {}

  explicit GetBatchTaskVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetBatchTaskVersionsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetBatchTaskVersionsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBatchTaskVersionsResponseBody() = default;
};
class GetBatchTaskVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchTaskVersionsResponseBody> body{};

  GetBatchTaskVersionsResponse() {}

  explicit GetBatchTaskVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchTaskVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchTaskVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchTaskVersionsResponse() = default;
};
class GetBizEntityInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> type{};

  GetBizEntityInfoRequest() {}

  explicit GetBizEntityInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoRequest() = default;
};
class GetBizEntityInfoResponseBodyBizEntityInfoBizObject : public Darabonba::Model {
public:
  shared_ptr<string> approvalId{};
  shared_ptr<string> approvalStatus{};
  shared_ptr<vector<long>> childBizEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineStatus{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<long> refDimTableCount{};
  shared_ptr<long> refSummaryTableCount{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetBizEntityInfoResponseBodyBizEntityInfoBizObject() {}

  explicit GetBizEntityInfoResponseBodyBizEntityInfoBizObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalId) {
      res["ApprovalId"] = boost::any(*approvalId);
    }
    if (approvalStatus) {
      res["ApprovalStatus"] = boost::any(*approvalStatus);
    }
    if (childBizEntityIdList) {
      res["ChildBizEntityIdList"] = boost::any(*childBizEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (refDimTableCount) {
      res["RefDimTableCount"] = boost::any(*refDimTableCount);
    }
    if (refSummaryTableCount) {
      res["RefSummaryTableCount"] = boost::any(*refSummaryTableCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalId") != m.end() && !m["ApprovalId"].empty()) {
      approvalId = make_shared<string>(boost::any_cast<string>(m["ApprovalId"]));
    }
    if (m.find("ApprovalStatus") != m.end() && !m["ApprovalStatus"].empty()) {
      approvalStatus = make_shared<string>(boost::any_cast<string>(m["ApprovalStatus"]));
    }
    if (m.find("ChildBizEntityIdList") != m.end() && !m["ChildBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ChildBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChildBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      childBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<string>(boost::any_cast<string>(m["OnlineStatus"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefDimTableCount") != m.end() && !m["RefDimTableCount"].empty()) {
      refDimTableCount = make_shared<long>(boost::any_cast<long>(m["RefDimTableCount"]));
    }
    if (m.find("RefSummaryTableCount") != m.end() && !m["RefSummaryTableCount"].empty()) {
      refSummaryTableCount = make_shared<long>(boost::any_cast<long>(m["RefSummaryTableCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoResponseBodyBizEntityInfoBizObject() = default;
};
class GetBizEntityInfoResponseBodyBizEntityInfoBizProcess : public Darabonba::Model {
public:
  shared_ptr<string> approvalId{};
  shared_ptr<string> approvalStatus{};
  shared_ptr<vector<long>> bizEventEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> hasDependent{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineStatus{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<long>> preBizProcessIdList{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<long> refFactTableCount{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetBizEntityInfoResponseBodyBizEntityInfoBizProcess() {}

  explicit GetBizEntityInfoResponseBodyBizEntityInfoBizProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalId) {
      res["ApprovalId"] = boost::any(*approvalId);
    }
    if (approvalStatus) {
      res["ApprovalStatus"] = boost::any(*approvalStatus);
    }
    if (bizEventEntityIdList) {
      res["BizEventEntityIdList"] = boost::any(*bizEventEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hasDependent) {
      res["HasDependent"] = boost::any(*hasDependent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (preBizProcessIdList) {
      res["PreBizProcessIdList"] = boost::any(*preBizProcessIdList);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (refFactTableCount) {
      res["RefFactTableCount"] = boost::any(*refFactTableCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalId") != m.end() && !m["ApprovalId"].empty()) {
      approvalId = make_shared<string>(boost::any_cast<string>(m["ApprovalId"]));
    }
    if (m.find("ApprovalStatus") != m.end() && !m["ApprovalStatus"].empty()) {
      approvalStatus = make_shared<string>(boost::any_cast<string>(m["ApprovalStatus"]));
    }
    if (m.find("BizEventEntityIdList") != m.end() && !m["BizEventEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizEventEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizEventEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizEventEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HasDependent") != m.end() && !m["HasDependent"].empty()) {
      hasDependent = make_shared<bool>(boost::any_cast<bool>(m["HasDependent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<string>(boost::any_cast<string>(m["OnlineStatus"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PreBizProcessIdList") != m.end() && !m["PreBizProcessIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PreBizProcessIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreBizProcessIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      preBizProcessIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefFactTableCount") != m.end() && !m["RefFactTableCount"].empty()) {
      refFactTableCount = make_shared<long>(boost::any_cast<long>(m["RefFactTableCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoResponseBodyBizEntityInfoBizProcess() = default;
};
class GetBizEntityInfoResponseBodyBizEntityInfo : public Darabonba::Model {
public:
  shared_ptr<GetBizEntityInfoResponseBodyBizEntityInfoBizObject> bizObject{};
  shared_ptr<GetBizEntityInfoResponseBodyBizEntityInfoBizProcess> bizProcess{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<string> type{};

  GetBizEntityInfoResponseBodyBizEntityInfo() {}

  explicit GetBizEntityInfoResponseBodyBizEntityInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizObject) {
      res["BizObject"] = bizObject ? boost::any(bizObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizProcess) {
      res["BizProcess"] = bizProcess ? boost::any(bizProcess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizObject") != m.end() && !m["BizObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizObject"].type()) {
        GetBizEntityInfoResponseBodyBizEntityInfoBizObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizObject"]));
        bizObject = make_shared<GetBizEntityInfoResponseBodyBizEntityInfoBizObject>(model1);
      }
    }
    if (m.find("BizProcess") != m.end() && !m["BizProcess"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizProcess"].type()) {
        GetBizEntityInfoResponseBodyBizEntityInfoBizProcess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizProcess"]));
        bizProcess = make_shared<GetBizEntityInfoResponseBodyBizEntityInfoBizProcess>(model1);
      }
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoResponseBodyBizEntityInfo() = default;
};
class GetBizEntityInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBizEntityInfoResponseBodyBizEntityInfo> bizEntityInfo{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBizEntityInfoResponseBody() {}

  explicit GetBizEntityInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEntityInfo) {
      res["BizEntityInfo"] = bizEntityInfo ? boost::any(bizEntityInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEntityInfo") != m.end() && !m["BizEntityInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizEntityInfo"].type()) {
        GetBizEntityInfoResponseBodyBizEntityInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizEntityInfo"]));
        bizEntityInfo = make_shared<GetBizEntityInfoResponseBodyBizEntityInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBizEntityInfoResponseBody() = default;
};
class GetBizEntityInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBizEntityInfoResponseBody> body{};

  GetBizEntityInfoResponse() {}

  explicit GetBizEntityInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBizEntityInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBizEntityInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBizEntityInfoResponse() = default;
};
class GetBizEntityInfoByVersionRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> type{};
  shared_ptr<long> versionId{};

  GetBizEntityInfoByVersionRequest() {}

  explicit GetBizEntityInfoByVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (versionId) {
      res["VersionId"] = boost::any(*versionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VersionId") != m.end() && !m["VersionId"].empty()) {
      versionId = make_shared<long>(boost::any_cast<long>(m["VersionId"]));
    }
  }


  virtual ~GetBizEntityInfoByVersionRequest() = default;
};
class GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject : public Darabonba::Model {
public:
  shared_ptr<string> approvalId{};
  shared_ptr<string> approvalStatus{};
  shared_ptr<vector<long>> childBizEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineStatus{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<long> refDimTableCount{};
  shared_ptr<long> refSummaryTableCount{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject() {}

  explicit GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalId) {
      res["ApprovalId"] = boost::any(*approvalId);
    }
    if (approvalStatus) {
      res["ApprovalStatus"] = boost::any(*approvalStatus);
    }
    if (childBizEntityIdList) {
      res["ChildBizEntityIdList"] = boost::any(*childBizEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (refDimTableCount) {
      res["RefDimTableCount"] = boost::any(*refDimTableCount);
    }
    if (refSummaryTableCount) {
      res["RefSummaryTableCount"] = boost::any(*refSummaryTableCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalId") != m.end() && !m["ApprovalId"].empty()) {
      approvalId = make_shared<string>(boost::any_cast<string>(m["ApprovalId"]));
    }
    if (m.find("ApprovalStatus") != m.end() && !m["ApprovalStatus"].empty()) {
      approvalStatus = make_shared<string>(boost::any_cast<string>(m["ApprovalStatus"]));
    }
    if (m.find("ChildBizEntityIdList") != m.end() && !m["ChildBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ChildBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChildBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      childBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<string>(boost::any_cast<string>(m["OnlineStatus"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefDimTableCount") != m.end() && !m["RefDimTableCount"].empty()) {
      refDimTableCount = make_shared<long>(boost::any_cast<long>(m["RefDimTableCount"]));
    }
    if (m.find("RefSummaryTableCount") != m.end() && !m["RefSummaryTableCount"].empty()) {
      refSummaryTableCount = make_shared<long>(boost::any_cast<long>(m["RefSummaryTableCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject() = default;
};
class GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess : public Darabonba::Model {
public:
  shared_ptr<string> approvalId{};
  shared_ptr<string> approvalStatus{};
  shared_ptr<vector<long>> bizEventEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> hasDependent{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineStatus{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<long>> preBizProcessIdList{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<long> refFactTableCount{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess() {}

  explicit GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvalId) {
      res["ApprovalId"] = boost::any(*approvalId);
    }
    if (approvalStatus) {
      res["ApprovalStatus"] = boost::any(*approvalStatus);
    }
    if (bizEventEntityIdList) {
      res["BizEventEntityIdList"] = boost::any(*bizEventEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hasDependent) {
      res["HasDependent"] = boost::any(*hasDependent);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (preBizProcessIdList) {
      res["PreBizProcessIdList"] = boost::any(*preBizProcessIdList);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (refFactTableCount) {
      res["RefFactTableCount"] = boost::any(*refFactTableCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApprovalId") != m.end() && !m["ApprovalId"].empty()) {
      approvalId = make_shared<string>(boost::any_cast<string>(m["ApprovalId"]));
    }
    if (m.find("ApprovalStatus") != m.end() && !m["ApprovalStatus"].empty()) {
      approvalStatus = make_shared<string>(boost::any_cast<string>(m["ApprovalStatus"]));
    }
    if (m.find("BizEventEntityIdList") != m.end() && !m["BizEventEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizEventEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizEventEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizEventEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HasDependent") != m.end() && !m["HasDependent"].empty()) {
      hasDependent = make_shared<bool>(boost::any_cast<bool>(m["HasDependent"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<string>(boost::any_cast<string>(m["OnlineStatus"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PreBizProcessIdList") != m.end() && !m["PreBizProcessIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PreBizProcessIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreBizProcessIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      preBizProcessIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefFactTableCount") != m.end() && !m["RefFactTableCount"].empty()) {
      refFactTableCount = make_shared<long>(boost::any_cast<long>(m["RefFactTableCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess() = default;
};
class GetBizEntityInfoByVersionResponseBodyBizEntityInfo : public Darabonba::Model {
public:
  shared_ptr<GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject> bizObject{};
  shared_ptr<GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess> bizProcess{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<string> type{};

  GetBizEntityInfoByVersionResponseBodyBizEntityInfo() {}

  explicit GetBizEntityInfoByVersionResponseBodyBizEntityInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizObject) {
      res["BizObject"] = bizObject ? boost::any(bizObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizProcess) {
      res["BizProcess"] = bizProcess ? boost::any(bizProcess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizObject") != m.end() && !m["BizObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizObject"].type()) {
        GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizObject"]));
        bizObject = make_shared<GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizObject>(model1);
      }
    }
    if (m.find("BizProcess") != m.end() && !m["BizProcess"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizProcess"].type()) {
        GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizProcess"]));
        bizProcess = make_shared<GetBizEntityInfoByVersionResponseBodyBizEntityInfoBizProcess>(model1);
      }
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBizEntityInfoByVersionResponseBodyBizEntityInfo() = default;
};
class GetBizEntityInfoByVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBizEntityInfoByVersionResponseBodyBizEntityInfo> bizEntityInfo{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBizEntityInfoByVersionResponseBody() {}

  explicit GetBizEntityInfoByVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEntityInfo) {
      res["BizEntityInfo"] = bizEntityInfo ? boost::any(bizEntityInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEntityInfo") != m.end() && !m["BizEntityInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizEntityInfo"].type()) {
        GetBizEntityInfoByVersionResponseBodyBizEntityInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizEntityInfo"]));
        bizEntityInfo = make_shared<GetBizEntityInfoByVersionResponseBodyBizEntityInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBizEntityInfoByVersionResponseBody() = default;
};
class GetBizEntityInfoByVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBizEntityInfoByVersionResponseBody> body{};

  GetBizEntityInfoByVersionResponse() {}

  explicit GetBizEntityInfoByVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBizEntityInfoByVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBizEntityInfoByVersionResponseBody>(model1);
      }
    }
  }


  virtual ~GetBizEntityInfoByVersionResponse() = default;
};
class GetBizUnitInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  GetBizUnitInfoRequest() {}

  explicit GetBizUnitInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetBizUnitInfoRequest() = default;
};
class GetBizUnitInfoResponseBodyBizUnitInfoAccountList : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetBizUnitInfoResponseBodyBizUnitInfoAccountList() {}

  explicit GetBizUnitInfoResponseBodyBizUnitInfoAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBodyBizUnitInfoAccountList() = default;
};
class GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList() {}

  explicit GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList() = default;
};
class GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList() {}

  explicit GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList() = default;
};
class GetBizUnitInfoResponseBodyBizUnitInfoEnvList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> envName{};
  shared_ptr<string> name{};

  GetBizUnitInfoResponseBodyBizUnitInfoEnvList() {}

  explicit GetBizUnitInfoResponseBodyBizUnitInfoEnvList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (envName) {
      res["EnvName"] = boost::any(*envName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EnvName") != m.end() && !m["EnvName"].empty()) {
      envName = make_shared<string>(boost::any_cast<string>(m["EnvName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBodyBizUnitInfoEnvList() = default;
};
class GetBizUnitInfoResponseBodyBizUnitInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetBizUnitInfoResponseBodyBizUnitInfoAccountList>> accountList{};
  shared_ptr<long> bizObjectCount{};
  shared_ptr<long> bizProcessCount{};
  shared_ptr<vector<GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList>> businessLeaderList{};
  shared_ptr<long> dataDomainCount{};
  shared_ptr<vector<GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList>> dataLeaderList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<vector<GetBizUnitInfoResponseBodyBizUnitInfoEnvList>> envList{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};

  GetBizUnitInfoResponseBodyBizUnitInfo() {}

  explicit GetBizUnitInfoResponseBodyBizUnitInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountList) {
      vector<boost::any> temp1;
      for(auto item1:*accountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountList"] = boost::any(temp1);
    }
    if (bizObjectCount) {
      res["BizObjectCount"] = boost::any(*bizObjectCount);
    }
    if (bizProcessCount) {
      res["BizProcessCount"] = boost::any(*bizProcessCount);
    }
    if (businessLeaderList) {
      vector<boost::any> temp1;
      for(auto item1:*businessLeaderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BusinessLeaderList"] = boost::any(temp1);
    }
    if (dataDomainCount) {
      res["DataDomainCount"] = boost::any(*dataDomainCount);
    }
    if (dataLeaderList) {
      vector<boost::any> temp1;
      for(auto item1:*dataLeaderList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataLeaderList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (envList) {
      vector<boost::any> temp1;
      for(auto item1:*envList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnvList"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountList") != m.end() && !m["AccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountList"].type()) {
        vector<GetBizUnitInfoResponseBodyBizUnitInfoAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBizUnitInfoResponseBodyBizUnitInfoAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountList = make_shared<vector<GetBizUnitInfoResponseBodyBizUnitInfoAccountList>>(expect1);
      }
    }
    if (m.find("BizObjectCount") != m.end() && !m["BizObjectCount"].empty()) {
      bizObjectCount = make_shared<long>(boost::any_cast<long>(m["BizObjectCount"]));
    }
    if (m.find("BizProcessCount") != m.end() && !m["BizProcessCount"].empty()) {
      bizProcessCount = make_shared<long>(boost::any_cast<long>(m["BizProcessCount"]));
    }
    if (m.find("BusinessLeaderList") != m.end() && !m["BusinessLeaderList"].empty()) {
      if (typeid(vector<boost::any>) == m["BusinessLeaderList"].type()) {
        vector<GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BusinessLeaderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        businessLeaderList = make_shared<vector<GetBizUnitInfoResponseBodyBizUnitInfoBusinessLeaderList>>(expect1);
      }
    }
    if (m.find("DataDomainCount") != m.end() && !m["DataDomainCount"].empty()) {
      dataDomainCount = make_shared<long>(boost::any_cast<long>(m["DataDomainCount"]));
    }
    if (m.find("DataLeaderList") != m.end() && !m["DataLeaderList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataLeaderList"].type()) {
        vector<GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataLeaderList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataLeaderList = make_shared<vector<GetBizUnitInfoResponseBodyBizUnitInfoDataLeaderList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("EnvList") != m.end() && !m["EnvList"].empty()) {
      if (typeid(vector<boost::any>) == m["EnvList"].type()) {
        vector<GetBizUnitInfoResponseBodyBizUnitInfoEnvList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnvList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBizUnitInfoResponseBodyBizUnitInfoEnvList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        envList = make_shared<vector<GetBizUnitInfoResponseBodyBizUnitInfoEnvList>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBodyBizUnitInfo() = default;
};
class GetBizUnitInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetBizUnitInfoResponseBodyBizUnitInfo> bizUnitInfo{};
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetBizUnitInfoResponseBody() {}

  explicit GetBizUnitInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitInfo) {
      res["BizUnitInfo"] = bizUnitInfo ? boost::any(bizUnitInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitInfo") != m.end() && !m["BizUnitInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizUnitInfo"].type()) {
        GetBizUnitInfoResponseBodyBizUnitInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizUnitInfo"]));
        bizUnitInfo = make_shared<GetBizUnitInfoResponseBodyBizUnitInfo>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetBizUnitInfoResponseBody() = default;
};
class GetBizUnitInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBizUnitInfoResponseBody> body{};

  GetBizUnitInfoResponse() {}

  explicit GetBizUnitInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBizUnitInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBizUnitInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBizUnitInfoResponse() = default;
};
class GetClusterQueueInfoByEnvRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> streamBatchMode{};

  GetClusterQueueInfoByEnvRequest() {}

  explicit GetClusterQueueInfoByEnvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (streamBatchMode) {
      res["StreamBatchMode"] = boost::any(*streamBatchMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StreamBatchMode") != m.end() && !m["StreamBatchMode"].empty()) {
      streamBatchMode = make_shared<string>(boost::any_cast<string>(m["StreamBatchMode"]));
    }
  }


  virtual ~GetClusterQueueInfoByEnvRequest() = default;
};
class GetClusterQueueInfoByEnvResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> annotations{};
  shared_ptr<string> clusterId{};
  shared_ptr<string> createAt{};
  shared_ptr<string> flinkImageRegistry{};
  shared_ptr<string> flinkImageRepository{};
  shared_ptr<string> flinkImageTag{};
  shared_ptr<string> flinkVersion{};
  shared_ptr<string> labels{};
  shared_ptr<string> maxVcore{};
  shared_ptr<string> modifiedAt{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> queueName{};
  shared_ptr<string> resourceVersion{};
  shared_ptr<string> spec{};
  shared_ptr<string> vvpClusterType{};

  GetClusterQueueInfoByEnvResponseBodyData() {}

  explicit GetClusterQueueInfoByEnvResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (annotations) {
      res["Annotations"] = boost::any(*annotations);
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (createAt) {
      res["CreateAt"] = boost::any(*createAt);
    }
    if (flinkImageRegistry) {
      res["FlinkImageRegistry"] = boost::any(*flinkImageRegistry);
    }
    if (flinkImageRepository) {
      res["FlinkImageRepository"] = boost::any(*flinkImageRepository);
    }
    if (flinkImageTag) {
      res["FlinkImageTag"] = boost::any(*flinkImageTag);
    }
    if (flinkVersion) {
      res["FlinkVersion"] = boost::any(*flinkVersion);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (maxVcore) {
      res["MaxVcore"] = boost::any(*maxVcore);
    }
    if (modifiedAt) {
      res["ModifiedAt"] = boost::any(*modifiedAt);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (resourceVersion) {
      res["ResourceVersion"] = boost::any(*resourceVersion);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (vvpClusterType) {
      res["VvpClusterType"] = boost::any(*vvpClusterType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Annotations") != m.end() && !m["Annotations"].empty()) {
      annotations = make_shared<string>(boost::any_cast<string>(m["Annotations"]));
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("CreateAt") != m.end() && !m["CreateAt"].empty()) {
      createAt = make_shared<string>(boost::any_cast<string>(m["CreateAt"]));
    }
    if (m.find("FlinkImageRegistry") != m.end() && !m["FlinkImageRegistry"].empty()) {
      flinkImageRegistry = make_shared<string>(boost::any_cast<string>(m["FlinkImageRegistry"]));
    }
    if (m.find("FlinkImageRepository") != m.end() && !m["FlinkImageRepository"].empty()) {
      flinkImageRepository = make_shared<string>(boost::any_cast<string>(m["FlinkImageRepository"]));
    }
    if (m.find("FlinkImageTag") != m.end() && !m["FlinkImageTag"].empty()) {
      flinkImageTag = make_shared<string>(boost::any_cast<string>(m["FlinkImageTag"]));
    }
    if (m.find("FlinkVersion") != m.end() && !m["FlinkVersion"].empty()) {
      flinkVersion = make_shared<string>(boost::any_cast<string>(m["FlinkVersion"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("MaxVcore") != m.end() && !m["MaxVcore"].empty()) {
      maxVcore = make_shared<string>(boost::any_cast<string>(m["MaxVcore"]));
    }
    if (m.find("ModifiedAt") != m.end() && !m["ModifiedAt"].empty()) {
      modifiedAt = make_shared<string>(boost::any_cast<string>(m["ModifiedAt"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("ResourceVersion") != m.end() && !m["ResourceVersion"].empty()) {
      resourceVersion = make_shared<string>(boost::any_cast<string>(m["ResourceVersion"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("VvpClusterType") != m.end() && !m["VvpClusterType"].empty()) {
      vvpClusterType = make_shared<string>(boost::any_cast<string>(m["VvpClusterType"]));
    }
  }


  virtual ~GetClusterQueueInfoByEnvResponseBodyData() = default;
};
class GetClusterQueueInfoByEnvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetClusterQueueInfoByEnvResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetClusterQueueInfoByEnvResponseBody() {}

  explicit GetClusterQueueInfoByEnvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetClusterQueueInfoByEnvResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetClusterQueueInfoByEnvResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetClusterQueueInfoByEnvResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetClusterQueueInfoByEnvResponseBody() = default;
};
class GetClusterQueueInfoByEnvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterQueueInfoByEnvResponseBody> body{};

  GetClusterQueueInfoByEnvResponse() {}

  explicit GetClusterQueueInfoByEnvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterQueueInfoByEnvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterQueueInfoByEnvResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterQueueInfoByEnvResponse() = default;
};
class GetDataDomainInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> opTenantId{};

  GetDataDomainInfoRequest() {}

  explicit GetDataDomainInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetDataDomainInfoRequest() = default;
};
class GetDataDomainInfoResponseBodyDataDomainInfo : public Darabonba::Model {
public:
  shared_ptr<string> abbreviation{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};

  GetDataDomainInfoResponseBodyDataDomainInfo() {}

  explicit GetDataDomainInfoResponseBodyDataDomainInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbreviation) {
      res["Abbreviation"] = boost::any(*abbreviation);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbreviation") != m.end() && !m["Abbreviation"].empty()) {
      abbreviation = make_shared<string>(boost::any_cast<string>(m["Abbreviation"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~GetDataDomainInfoResponseBodyDataDomainInfo() = default;
};
class GetDataDomainInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDataDomainInfoResponseBodyDataDomainInfo> dataDomainInfo{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDataDomainInfoResponseBody() {}

  explicit GetDataDomainInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataDomainInfo) {
      res["DataDomainInfo"] = dataDomainInfo ? boost::any(dataDomainInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataDomainInfo") != m.end() && !m["DataDomainInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDomainInfo"].type()) {
        GetDataDomainInfoResponseBodyDataDomainInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDomainInfo"]));
        dataDomainInfo = make_shared<GetDataDomainInfoResponseBodyDataDomainInfo>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDataDomainInfoResponseBody() = default;
};
class GetDataDomainInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDataDomainInfoResponseBody> body{};

  GetDataDomainInfoResponse() {}

  explicit GetDataDomainInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDataDomainInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDataDomainInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetDataDomainInfoResponse() = default;
};
class GetDevObjectDependencyRequest : public Darabonba::Model {
public:
  shared_ptr<string> objectFrom{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetDevObjectDependencyRequest() {}

  explicit GetDevObjectDependencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectFrom) {
      res["ObjectFrom"] = boost::any(*objectFrom);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectFrom") != m.end() && !m["ObjectFrom"].empty()) {
      objectFrom = make_shared<string>(boost::any_cast<string>(m["ObjectFrom"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetDevObjectDependencyRequest() = default;
};
class GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod : public Darabonba::Model {
public:
  shared_ptr<long> periodOffset{};
  shared_ptr<string> periodType{};

  GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod() {}

  explicit GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodOffset) {
      res["PeriodOffset"] = boost::any(*periodOffset);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodOffset") != m.end() && !m["PeriodOffset"].empty()) {
      periodOffset = make_shared<long>(boost::any_cast<long>(m["PeriodOffset"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod() = default;
};
class GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList : public Darabonba::Model {
public:
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> key{};

  GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList() {}

  explicit GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
  }


  virtual ~GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList() = default;
};
class GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList() {}

  explicit GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList() = default;
};
class GetDevObjectDependencyResponseBodyDevObjectDependencyList : public Darabonba::Model {
public:
  shared_ptr<bool> autoParse{};
  shared_ptr<string> bizType{};
  shared_ptr<string> bizUnitId{};
  shared_ptr<string> bizUnitName{};
  shared_ptr<string> cronExpression{};
  shared_ptr<bool> customCronExpression{};
  shared_ptr<vector<string>> dependFieldList{};
  shared_ptr<GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod> dependencyPeriod{};
  shared_ptr<string> dependencyStrategy{};
  shared_ptr<bool> dimMidNode{};
  shared_ptr<vector<string>> effectFieldList{};
  shared_ptr<string> externalBizInfo{};
  shared_ptr<bool> manuallyAdd{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodeOutputName{};
  shared_ptr<string> nodeOutputTableName{};
  shared_ptr<string> nodeType{};
  shared_ptr<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList>> outputContextParamList{};
  shared_ptr<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList>> ownerList{};
  shared_ptr<long> periodDiff{};
  shared_ptr<long> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> scheduleType{};
  shared_ptr<bool> selfDepend{};
  shared_ptr<string> subBizType{};
  shared_ptr<bool> valid{};

  GetDevObjectDependencyResponseBodyDevObjectDependencyList() {}

  explicit GetDevObjectDependencyResponseBodyDevObjectDependencyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoParse) {
      res["AutoParse"] = boost::any(*autoParse);
    }
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (customCronExpression) {
      res["CustomCronExpression"] = boost::any(*customCronExpression);
    }
    if (dependFieldList) {
      res["DependFieldList"] = boost::any(*dependFieldList);
    }
    if (dependencyPeriod) {
      res["DependencyPeriod"] = dependencyPeriod ? boost::any(dependencyPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependencyStrategy) {
      res["DependencyStrategy"] = boost::any(*dependencyStrategy);
    }
    if (dimMidNode) {
      res["DimMidNode"] = boost::any(*dimMidNode);
    }
    if (effectFieldList) {
      res["EffectFieldList"] = boost::any(*effectFieldList);
    }
    if (externalBizInfo) {
      res["ExternalBizInfo"] = boost::any(*externalBizInfo);
    }
    if (manuallyAdd) {
      res["ManuallyAdd"] = boost::any(*manuallyAdd);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeOutputName) {
      res["NodeOutputName"] = boost::any(*nodeOutputName);
    }
    if (nodeOutputTableName) {
      res["NodeOutputTableName"] = boost::any(*nodeOutputTableName);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (outputContextParamList) {
      vector<boost::any> temp1;
      for(auto item1:*outputContextParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputContextParamList"] = boost::any(temp1);
    }
    if (ownerList) {
      vector<boost::any> temp1;
      for(auto item1:*ownerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OwnerList"] = boost::any(temp1);
    }
    if (periodDiff) {
      res["PeriodDiff"] = boost::any(*periodDiff);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (selfDepend) {
      res["SelfDepend"] = boost::any(*selfDepend);
    }
    if (subBizType) {
      res["SubBizType"] = boost::any(*subBizType);
    }
    if (valid) {
      res["Valid"] = boost::any(*valid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoParse") != m.end() && !m["AutoParse"].empty()) {
      autoParse = make_shared<bool>(boost::any_cast<bool>(m["AutoParse"]));
    }
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<string>(boost::any_cast<string>(m["BizUnitId"]));
    }
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CustomCronExpression") != m.end() && !m["CustomCronExpression"].empty()) {
      customCronExpression = make_shared<bool>(boost::any_cast<bool>(m["CustomCronExpression"]));
    }
    if (m.find("DependFieldList") != m.end() && !m["DependFieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DependFieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DependFieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dependFieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DependencyPeriod") != m.end() && !m["DependencyPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependencyPeriod"].type()) {
        GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependencyPeriod"]));
        dependencyPeriod = make_shared<GetDevObjectDependencyResponseBodyDevObjectDependencyListDependencyPeriod>(model1);
      }
    }
    if (m.find("DependencyStrategy") != m.end() && !m["DependencyStrategy"].empty()) {
      dependencyStrategy = make_shared<string>(boost::any_cast<string>(m["DependencyStrategy"]));
    }
    if (m.find("DimMidNode") != m.end() && !m["DimMidNode"].empty()) {
      dimMidNode = make_shared<bool>(boost::any_cast<bool>(m["DimMidNode"]));
    }
    if (m.find("EffectFieldList") != m.end() && !m["EffectFieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EffectFieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EffectFieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      effectFieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ExternalBizInfo") != m.end() && !m["ExternalBizInfo"].empty()) {
      externalBizInfo = make_shared<string>(boost::any_cast<string>(m["ExternalBizInfo"]));
    }
    if (m.find("ManuallyAdd") != m.end() && !m["ManuallyAdd"].empty()) {
      manuallyAdd = make_shared<bool>(boost::any_cast<bool>(m["ManuallyAdd"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeOutputName") != m.end() && !m["NodeOutputName"].empty()) {
      nodeOutputName = make_shared<string>(boost::any_cast<string>(m["NodeOutputName"]));
    }
    if (m.find("NodeOutputTableName") != m.end() && !m["NodeOutputTableName"].empty()) {
      nodeOutputTableName = make_shared<string>(boost::any_cast<string>(m["NodeOutputTableName"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("OutputContextParamList") != m.end() && !m["OutputContextParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputContextParamList"].type()) {
        vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputContextParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputContextParamList = make_shared<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOutputContextParamList>>(expect1);
      }
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OwnerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ownerList = make_shared<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyListOwnerList>>(expect1);
      }
    }
    if (m.find("PeriodDiff") != m.end() && !m["PeriodDiff"].empty()) {
      periodDiff = make_shared<long>(boost::any_cast<long>(m["PeriodDiff"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("SelfDepend") != m.end() && !m["SelfDepend"].empty()) {
      selfDepend = make_shared<bool>(boost::any_cast<bool>(m["SelfDepend"]));
    }
    if (m.find("SubBizType") != m.end() && !m["SubBizType"].empty()) {
      subBizType = make_shared<string>(boost::any_cast<string>(m["SubBizType"]));
    }
    if (m.find("Valid") != m.end() && !m["Valid"].empty()) {
      valid = make_shared<bool>(boost::any_cast<bool>(m["Valid"]));
    }
  }


  virtual ~GetDevObjectDependencyResponseBodyDevObjectDependencyList() = default;
};
class GetDevObjectDependencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyList>> devObjectDependencyList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDevObjectDependencyResponseBody() {}

  explicit GetDevObjectDependencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (devObjectDependencyList) {
      vector<boost::any> temp1;
      for(auto item1:*devObjectDependencyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DevObjectDependencyList"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DevObjectDependencyList") != m.end() && !m["DevObjectDependencyList"].empty()) {
      if (typeid(vector<boost::any>) == m["DevObjectDependencyList"].type()) {
        vector<GetDevObjectDependencyResponseBodyDevObjectDependencyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DevObjectDependencyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDevObjectDependencyResponseBodyDevObjectDependencyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        devObjectDependencyList = make_shared<vector<GetDevObjectDependencyResponseBodyDevObjectDependencyList>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDevObjectDependencyResponseBody() = default;
};
class GetDevObjectDependencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDevObjectDependencyResponseBody> body{};

  GetDevObjectDependencyResponse() {}

  explicit GetDevObjectDependencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDevObjectDependencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDevObjectDependencyResponseBody>(model1);
      }
    }
  }


  virtual ~GetDevObjectDependencyResponse() = default;
};
class GetDirectoryTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetDirectoryTreeRequest() {}

  explicit GetDirectoryTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetDirectoryTreeRequest() = default;
};
class GetDirectoryTreeResponseBodyDataChildren : public Darabonba::Model {
public:
  shared_ptr<string> categoryType{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<long> dataCellId{};
  shared_ptr<string> dirName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> stringId{};
  shared_ptr<string> type{};

  GetDirectoryTreeResponseBodyDataChildren() {}

  explicit GetDirectoryTreeResponseBodyDataChildren(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryType) {
      res["CategoryType"] = boost::any(*categoryType);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (dataCellId) {
      res["DataCellId"] = boost::any(*dataCellId);
    }
    if (dirName) {
      res["DirName"] = boost::any(*dirName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stringId) {
      res["StringId"] = boost::any(*stringId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryType") != m.end() && !m["CategoryType"].empty()) {
      categoryType = make_shared<string>(boost::any_cast<string>(m["CategoryType"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DataCellId") != m.end() && !m["DataCellId"].empty()) {
      dataCellId = make_shared<long>(boost::any_cast<long>(m["DataCellId"]));
    }
    if (m.find("DirName") != m.end() && !m["DirName"].empty()) {
      dirName = make_shared<string>(boost::any_cast<string>(m["DirName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StringId") != m.end() && !m["StringId"].empty()) {
      stringId = make_shared<string>(boost::any_cast<string>(m["StringId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDirectoryTreeResponseBodyDataChildren() = default;
};
class GetDirectoryTreeResponseBodyDataParent : public Darabonba::Model {
public:
  shared_ptr<string> categoryType{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<long> dataCellId{};
  shared_ptr<string> dirName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};
  shared_ptr<string> stringId{};
  shared_ptr<string> type{};

  GetDirectoryTreeResponseBodyDataParent() {}

  explicit GetDirectoryTreeResponseBodyDataParent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categoryType) {
      res["CategoryType"] = boost::any(*categoryType);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (dataCellId) {
      res["DataCellId"] = boost::any(*dataCellId);
    }
    if (dirName) {
      res["DirName"] = boost::any(*dirName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stringId) {
      res["StringId"] = boost::any(*stringId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CategoryType") != m.end() && !m["CategoryType"].empty()) {
      categoryType = make_shared<string>(boost::any_cast<string>(m["CategoryType"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("DataCellId") != m.end() && !m["DataCellId"].empty()) {
      dataCellId = make_shared<long>(boost::any_cast<long>(m["DataCellId"]));
    }
    if (m.find("DirName") != m.end() && !m["DirName"].empty()) {
      dirName = make_shared<string>(boost::any_cast<string>(m["DirName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("StringId") != m.end() && !m["StringId"].empty()) {
      stringId = make_shared<string>(boost::any_cast<string>(m["StringId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetDirectoryTreeResponseBodyDataParent() = default;
};
class GetDirectoryTreeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetDirectoryTreeResponseBodyDataChildren> children{};
  shared_ptr<GetDirectoryTreeResponseBodyDataParent> parent{};

  GetDirectoryTreeResponseBodyData() {}

  explicit GetDirectoryTreeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = children ? boost::any(children->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (parent) {
      res["Parent"] = parent ? boost::any(parent->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      if (typeid(map<string, boost::any>) == m["Children"].type()) {
        GetDirectoryTreeResponseBodyDataChildren model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Children"]));
        children = make_shared<GetDirectoryTreeResponseBodyDataChildren>(model1);
      }
    }
    if (m.find("Parent") != m.end() && !m["Parent"].empty()) {
      if (typeid(map<string, boost::any>) == m["Parent"].type()) {
        GetDirectoryTreeResponseBodyDataParent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Parent"]));
        parent = make_shared<GetDirectoryTreeResponseBodyDataParent>(model1);
      }
    }
  }


  virtual ~GetDirectoryTreeResponseBodyData() = default;
};
class GetDirectoryTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetDirectoryTreeResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDirectoryTreeResponseBody() {}

  explicit GetDirectoryTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetDirectoryTreeResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetDirectoryTreeResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetDirectoryTreeResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDirectoryTreeResponseBody() = default;
};
class GetDirectoryTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDirectoryTreeResponseBody> body{};

  GetDirectoryTreeResponse() {}

  explicit GetDirectoryTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDirectoryTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDirectoryTreeResponseBody>(model1);
      }
    }
  }


  virtual ~GetDirectoryTreeResponse() = default;
};
class GetInstanceDownStreamRequestInstanceGet : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeType{};

  GetInstanceDownStreamRequestInstanceGet() {}

  explicit GetInstanceDownStreamRequestInstanceGet(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~GetInstanceDownStreamRequestInstanceGet() = default;
};
class GetInstanceDownStreamRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<GetInstanceDownStreamRequestInstanceGet> instanceGet{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> runStatus{};

  GetInstanceDownStreamRequest() {}

  explicit GetInstanceDownStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceGet) {
      res["InstanceGet"] = instanceGet ? boost::any(instanceGet->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (runStatus) {
      res["RunStatus"] = boost::any(*runStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceGet") != m.end() && !m["InstanceGet"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceGet"].type()) {
        GetInstanceDownStreamRequestInstanceGet model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceGet"]));
        instanceGet = make_shared<GetInstanceDownStreamRequestInstanceGet>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RunStatus") != m.end() && !m["RunStatus"].empty()) {
      runStatus = make_shared<string>(boost::any_cast<string>(m["RunStatus"]));
    }
  }


  virtual ~GetInstanceDownStreamRequest() = default;
};
class GetInstanceDownStreamShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<string> instanceGetShrink{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> runStatus{};

  GetInstanceDownStreamShrinkRequest() {}

  explicit GetInstanceDownStreamShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceGetShrink) {
      res["InstanceGet"] = boost::any(*instanceGetShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (runStatus) {
      res["RunStatus"] = boost::any(*runStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceGet") != m.end() && !m["InstanceGet"].empty()) {
      instanceGetShrink = make_shared<string>(boost::any_cast<string>(m["InstanceGet"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RunStatus") != m.end() && !m["RunStatus"].empty()) {
      runStatus = make_shared<string>(boost::any_cast<string>(m["RunStatus"]));
    }
  }


  virtual ~GetInstanceDownStreamShrinkRequest() = default;
};
class GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList : public Darabonba::Model {
public:
  shared_ptr<string> fieldInstanceId{};
  shared_ptr<string> runStatus{};
  shared_ptr<string> selectStatus{};

  GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList() {}

  explicit GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceId) {
      res["FieldInstanceId"] = boost::any(*fieldInstanceId);
    }
    if (runStatus) {
      res["RunStatus"] = boost::any(*runStatus);
    }
    if (selectStatus) {
      res["SelectStatus"] = boost::any(*selectStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceId") != m.end() && !m["FieldInstanceId"].empty()) {
      fieldInstanceId = make_shared<string>(boost::any_cast<string>(m["FieldInstanceId"]));
    }
    if (m.find("RunStatus") != m.end() && !m["RunStatus"].empty()) {
      runStatus = make_shared<string>(boost::any_cast<string>(m["RunStatus"]));
    }
    if (m.find("SelectStatus") != m.end() && !m["SelectStatus"].empty()) {
      selectStatus = make_shared<string>(boost::any_cast<string>(m["SelectStatus"]));
    }
  }


  virtual ~GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList() = default;
};
class GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo() {}

  explicit GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo() = default;
};
class GetInstanceDownStreamResponseBodyInstanceRelationList : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> extendInfo{};
  shared_ptr<vector<GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList>> fieldInstanceList{};
  shared_ptr<GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo> instanceInfo{};
  shared_ptr<string> runStatus{};
  shared_ptr<string> selectStatus{};
  shared_ptr<string> selectStatusCause{};

  GetInstanceDownStreamResponseBodyInstanceRelationList() {}

  explicit GetInstanceDownStreamResponseBodyInstanceRelationList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (fieldInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*fieldInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FieldInstanceList"] = boost::any(temp1);
    }
    if (instanceInfo) {
      res["InstanceInfo"] = instanceInfo ? boost::any(instanceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runStatus) {
      res["RunStatus"] = boost::any(*runStatus);
    }
    if (selectStatus) {
      res["SelectStatus"] = boost::any(*selectStatus);
    }
    if (selectStatusCause) {
      res["SelectStatusCause"] = boost::any(*selectStatusCause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("FieldInstanceList") != m.end() && !m["FieldInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["FieldInstanceList"].type()) {
        vector<GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FieldInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fieldInstanceList = make_shared<vector<GetInstanceDownStreamResponseBodyInstanceRelationListFieldInstanceList>>(expect1);
      }
    }
    if (m.find("InstanceInfo") != m.end() && !m["InstanceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceInfo"].type()) {
        GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceInfo"]));
        instanceInfo = make_shared<GetInstanceDownStreamResponseBodyInstanceRelationListInstanceInfo>(model1);
      }
    }
    if (m.find("RunStatus") != m.end() && !m["RunStatus"].empty()) {
      runStatus = make_shared<string>(boost::any_cast<string>(m["RunStatus"]));
    }
    if (m.find("SelectStatus") != m.end() && !m["SelectStatus"].empty()) {
      selectStatus = make_shared<string>(boost::any_cast<string>(m["SelectStatus"]));
    }
    if (m.find("SelectStatusCause") != m.end() && !m["SelectStatusCause"].empty()) {
      selectStatusCause = make_shared<string>(boost::any_cast<string>(m["SelectStatusCause"]));
    }
  }


  virtual ~GetInstanceDownStreamResponseBodyInstanceRelationList() = default;
};
class GetInstanceDownStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<GetInstanceDownStreamResponseBodyInstanceRelationList>> instanceRelationList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInstanceDownStreamResponseBody() {}

  explicit GetInstanceDownStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceRelationList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceRelationList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceRelationList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceRelationList") != m.end() && !m["InstanceRelationList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceRelationList"].type()) {
        vector<GetInstanceDownStreamResponseBodyInstanceRelationList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceRelationList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceDownStreamResponseBodyInstanceRelationList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceRelationList = make_shared<vector<GetInstanceDownStreamResponseBodyInstanceRelationList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceDownStreamResponseBody() = default;
};
class GetInstanceDownStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceDownStreamResponseBody> body{};

  GetInstanceDownStreamResponse() {}

  explicit GetInstanceDownStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceDownStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceDownStreamResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceDownStreamResponse() = default;
};
class GetInstanceUpDownStreamRequestInstanceId : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};

  GetInstanceUpDownStreamRequestInstanceId() {}

  explicit GetInstanceUpDownStreamRequestInstanceId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetInstanceUpDownStreamRequestInstanceId() = default;
};
class GetInstanceUpDownStreamRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<GetInstanceUpDownStreamRequestInstanceId> instanceId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> upStreamDepth{};

  GetInstanceUpDownStreamRequest() {}

  explicit GetInstanceUpDownStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceId) {
      res["InstanceId"] = instanceId ? boost::any(instanceId->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (upStreamDepth) {
      res["UpStreamDepth"] = boost::any(*upStreamDepth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceId"].type()) {
        GetInstanceUpDownStreamRequestInstanceId model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceId"]));
        instanceId = make_shared<GetInstanceUpDownStreamRequestInstanceId>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UpStreamDepth") != m.end() && !m["UpStreamDepth"].empty()) {
      upStreamDepth = make_shared<long>(boost::any_cast<long>(m["UpStreamDepth"]));
    }
  }


  virtual ~GetInstanceUpDownStreamRequest() = default;
};
class GetInstanceUpDownStreamShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<string> instanceIdShrink{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> upStreamDepth{};

  GetInstanceUpDownStreamShrinkRequest() {}

  explicit GetInstanceUpDownStreamShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceIdShrink) {
      res["InstanceId"] = boost::any(*instanceIdShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (upStreamDepth) {
      res["UpStreamDepth"] = boost::any(*upStreamDepth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceIdShrink = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UpStreamDepth") != m.end() && !m["UpStreamDepth"].empty()) {
      upStreamDepth = make_shared<long>(boost::any_cast<long>(m["UpStreamDepth"]));
    }
  }


  virtual ~GetInstanceUpDownStreamShrinkRequest() = default;
};
class GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeType{};

  GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList() {}

  explicit GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList() = default;
};
class GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeType{};

  GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList() {}

  explicit GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList() = default;
};
class GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeType{};

  GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList() {}

  explicit GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList() = default;
};
class GetInstanceUpDownStreamResponseBodyInstanceDagInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList>> downInstanceList{};
  shared_ptr<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList>> startInstanceList{};
  shared_ptr<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList>> upInstanceList{};

  GetInstanceUpDownStreamResponseBodyInstanceDagInfo() {}

  explicit GetInstanceUpDownStreamResponseBodyInstanceDagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*downInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownInstanceList"] = boost::any(temp1);
    }
    if (startInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*startInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StartInstanceList"] = boost::any(temp1);
    }
    if (upInstanceList) {
      vector<boost::any> temp1;
      for(auto item1:*upInstanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpInstanceList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownInstanceList") != m.end() && !m["DownInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DownInstanceList"].type()) {
        vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downInstanceList = make_shared<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoDownInstanceList>>(expect1);
      }
    }
    if (m.find("StartInstanceList") != m.end() && !m["StartInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["StartInstanceList"].type()) {
        vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StartInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        startInstanceList = make_shared<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoStartInstanceList>>(expect1);
      }
    }
    if (m.find("UpInstanceList") != m.end() && !m["UpInstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpInstanceList"].type()) {
        vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpInstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upInstanceList = make_shared<vector<GetInstanceUpDownStreamResponseBodyInstanceDagInfoUpInstanceList>>(expect1);
      }
    }
  }


  virtual ~GetInstanceUpDownStreamResponseBodyInstanceDagInfo() = default;
};
class GetInstanceUpDownStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetInstanceUpDownStreamResponseBodyInstanceDagInfo> instanceDagInfo{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetInstanceUpDownStreamResponseBody() {}

  explicit GetInstanceUpDownStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceDagInfo) {
      res["InstanceDagInfo"] = instanceDagInfo ? boost::any(instanceDagInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceDagInfo") != m.end() && !m["InstanceDagInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceDagInfo"].type()) {
        GetInstanceUpDownStreamResponseBodyInstanceDagInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceDagInfo"]));
        instanceDagInfo = make_shared<GetInstanceUpDownStreamResponseBodyInstanceDagInfo>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetInstanceUpDownStreamResponseBody() = default;
};
class GetInstanceUpDownStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceUpDownStreamResponseBody> body{};

  GetInstanceUpDownStreamResponse() {}

  explicit GetInstanceUpDownStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceUpDownStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceUpDownStreamResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceUpDownStreamResponse() = default;
};
class GetLatestSubmitDetailRequestSubmitDetailQuery : public Darabonba::Model {
public:
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  GetLatestSubmitDetailRequestSubmitDetailQuery() {}

  explicit GetLatestSubmitDetailRequestSubmitDetailQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~GetLatestSubmitDetailRequestSubmitDetailQuery() = default;
};
class GetLatestSubmitDetailRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<GetLatestSubmitDetailRequestSubmitDetailQuery> submitDetailQuery{};

  GetLatestSubmitDetailRequest() {}

  explicit GetLatestSubmitDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (submitDetailQuery) {
      res["SubmitDetailQuery"] = submitDetailQuery ? boost::any(submitDetailQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SubmitDetailQuery") != m.end() && !m["SubmitDetailQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubmitDetailQuery"].type()) {
        GetLatestSubmitDetailRequestSubmitDetailQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubmitDetailQuery"]));
        submitDetailQuery = make_shared<GetLatestSubmitDetailRequestSubmitDetailQuery>(model1);
      }
    }
  }


  virtual ~GetLatestSubmitDetailRequest() = default;
};
class GetLatestSubmitDetailShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> submitDetailQueryShrink{};

  GetLatestSubmitDetailShrinkRequest() {}

  explicit GetLatestSubmitDetailShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (submitDetailQueryShrink) {
      res["SubmitDetailQuery"] = boost::any(*submitDetailQueryShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SubmitDetailQuery") != m.end() && !m["SubmitDetailQuery"].empty()) {
      submitDetailQueryShrink = make_shared<string>(boost::any_cast<string>(m["SubmitDetailQuery"]));
    }
  }


  virtual ~GetLatestSubmitDetailShrinkRequest() = default;
};
class GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject : public Darabonba::Model {
public:
  shared_ptr<string> objectId{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};

  GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject() {}

  explicit GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject() = default;
};
class GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject : public Darabonba::Model {
public:
  shared_ptr<string> changeType{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> objectVersion{};
  shared_ptr<long> projectId{};
  shared_ptr<string> submitComment{};
  shared_ptr<GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject> submitObject{};

  GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject() {}

  explicit GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (objectVersion) {
      res["ObjectVersion"] = boost::any(*objectVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (submitComment) {
      res["SubmitComment"] = boost::any(*submitComment);
    }
    if (submitObject) {
      res["SubmitObject"] = submitObject ? boost::any(submitObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<string>(boost::any_cast<string>(m["ChangeType"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ObjectVersion") != m.end() && !m["ObjectVersion"].empty()) {
      objectVersion = make_shared<string>(boost::any_cast<string>(m["ObjectVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubmitComment") != m.end() && !m["SubmitComment"].empty()) {
      submitComment = make_shared<string>(boost::any_cast<string>(m["SubmitComment"]));
    }
    if (m.find("SubmitObject") != m.end() && !m["SubmitObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubmitObject"].type()) {
        GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubmitObject"]));
        submitObject = make_shared<GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObjectSubmitObject>(model1);
      }
    }
  }


  virtual ~GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject() = default;
};
class GetLatestSubmitDetailResponseBodySubmitDetailResult : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> publishStatus{};
  shared_ptr<GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject> releaseObject{};
  shared_ptr<string> submitStatus{};
  shared_ptr<string> tag{};

  GetLatestSubmitDetailResponseBodySubmitDetailResult() {}

  explicit GetLatestSubmitDetailResponseBodySubmitDetailResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (publishStatus) {
      res["PublishStatus"] = boost::any(*publishStatus);
    }
    if (releaseObject) {
      res["ReleaseObject"] = releaseObject ? boost::any(releaseObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (submitStatus) {
      res["SubmitStatus"] = boost::any(*submitStatus);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("PublishStatus") != m.end() && !m["PublishStatus"].empty()) {
      publishStatus = make_shared<string>(boost::any_cast<string>(m["PublishStatus"]));
    }
    if (m.find("ReleaseObject") != m.end() && !m["ReleaseObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReleaseObject"].type()) {
        GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReleaseObject"]));
        releaseObject = make_shared<GetLatestSubmitDetailResponseBodySubmitDetailResultReleaseObject>(model1);
      }
    }
    if (m.find("SubmitStatus") != m.end() && !m["SubmitStatus"].empty()) {
      submitStatus = make_shared<string>(boost::any_cast<string>(m["SubmitStatus"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~GetLatestSubmitDetailResponseBodySubmitDetailResult() = default;
};
class GetLatestSubmitDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<GetLatestSubmitDetailResponseBodySubmitDetailResult> submitDetailResult{};
  shared_ptr<bool> success{};

  GetLatestSubmitDetailResponseBody() {}

  explicit GetLatestSubmitDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (submitDetailResult) {
      res["SubmitDetailResult"] = submitDetailResult ? boost::any(submitDetailResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubmitDetailResult") != m.end() && !m["SubmitDetailResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubmitDetailResult"].type()) {
        GetLatestSubmitDetailResponseBodySubmitDetailResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubmitDetailResult"]));
        submitDetailResult = make_shared<GetLatestSubmitDetailResponseBodySubmitDetailResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetLatestSubmitDetailResponseBody() = default;
};
class GetLatestSubmitDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLatestSubmitDetailResponseBody> body{};

  GetLatestSubmitDetailResponse() {}

  explicit GetLatestSubmitDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLatestSubmitDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLatestSubmitDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetLatestSubmitDetailResponse() = default;
};
class GetMyRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};

  GetMyRolesRequest() {}

  explicit GetMyRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetMyRolesRequest() = default;
};
class GetMyRolesResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  GetMyRolesResponseBodyRoleList() {}

  explicit GetMyRolesResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetMyRolesResponseBodyRoleList() = default;
};
class GetMyRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMyRolesResponseBodyRoleList>> roleList{};
  shared_ptr<bool> success{};

  GetMyRolesResponseBody() {}

  explicit GetMyRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleList) {
      vector<boost::any> temp1;
      for(auto item1:*roleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoleList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<GetMyRolesResponseBodyRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMyRolesResponseBodyRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleList = make_shared<vector<GetMyRolesResponseBodyRoleList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetMyRolesResponseBody() = default;
};
class GetMyRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMyRolesResponseBody> body{};

  GetMyRolesResponse() {}

  explicit GetMyRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMyRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMyRolesResponseBody>(model1);
      }
    }
  }


  virtual ~GetMyRolesResponse() = default;
};
class GetMyTenantsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> featureCodeList{};
  shared_ptr<long> opTenantId{};

  GetMyTenantsRequest() {}

  explicit GetMyTenantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (featureCodeList) {
      res["FeatureCodeList"] = boost::any(*featureCodeList);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeatureCodeList") != m.end() && !m["FeatureCodeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FeatureCodeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FeatureCodeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      featureCodeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetMyTenantsRequest() = default;
};
class GetMyTenantsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> featureCodeListShrink{};
  shared_ptr<long> opTenantId{};

  GetMyTenantsShrinkRequest() {}

  explicit GetMyTenantsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (featureCodeListShrink) {
      res["FeatureCodeList"] = boost::any(*featureCodeListShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FeatureCodeList") != m.end() && !m["FeatureCodeList"].empty()) {
      featureCodeListShrink = make_shared<string>(boost::any_cast<string>(m["FeatureCodeList"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetMyTenantsShrinkRequest() = default;
};
class GetMyTenantsResponseBodyTenantList : public Darabonba::Model {
public:
  shared_ptr<long> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<bool> opsTenant{};
  shared_ptr<string> ownerId{};
  shared_ptr<bool> resourceLimited{};
  shared_ptr<vector<string>> tenantTypeList{};
  shared_ptr<string> titleType{};
  shared_ptr<bool> visible{};

  GetMyTenantsResponseBodyTenantList() {}

  explicit GetMyTenantsResponseBodyTenantList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (opsTenant) {
      res["OpsTenant"] = boost::any(*opsTenant);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceLimited) {
      res["ResourceLimited"] = boost::any(*resourceLimited);
    }
    if (tenantTypeList) {
      res["TenantTypeList"] = boost::any(*tenantTypeList);
    }
    if (titleType) {
      res["TitleType"] = boost::any(*titleType);
    }
    if (visible) {
      res["Visible"] = boost::any(*visible);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<long>(boost::any_cast<long>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpsTenant") != m.end() && !m["OpsTenant"].empty()) {
      opsTenant = make_shared<bool>(boost::any_cast<bool>(m["OpsTenant"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ResourceLimited") != m.end() && !m["ResourceLimited"].empty()) {
      resourceLimited = make_shared<bool>(boost::any_cast<bool>(m["ResourceLimited"]));
    }
    if (m.find("TenantTypeList") != m.end() && !m["TenantTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TenantTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TenantTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tenantTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TitleType") != m.end() && !m["TitleType"].empty()) {
      titleType = make_shared<string>(boost::any_cast<string>(m["TitleType"]));
    }
    if (m.find("Visible") != m.end() && !m["Visible"].empty()) {
      visible = make_shared<bool>(boost::any_cast<bool>(m["Visible"]));
    }
  }


  virtual ~GetMyTenantsResponseBodyTenantList() = default;
};
class GetMyTenantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetMyTenantsResponseBodyTenantList>> tenantList{};

  GetMyTenantsResponseBody() {}

  explicit GetMyTenantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (tenantList) {
      vector<boost::any> temp1;
      for(auto item1:*tenantList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TenantList") != m.end() && !m["TenantList"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantList"].type()) {
        vector<GetMyTenantsResponseBodyTenantList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMyTenantsResponseBodyTenantList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantList = make_shared<vector<GetMyTenantsResponseBodyTenantList>>(expect1);
      }
    }
  }


  virtual ~GetMyTenantsResponseBody() = default;
};
class GetMyTenantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMyTenantsResponseBody> body{};

  GetMyTenantsResponse() {}

  explicit GetMyTenantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMyTenantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMyTenantsResponseBody>(model1);
      }
    }
  }


  virtual ~GetMyTenantsResponse() = default;
};
class GetNodeUpDownStreamRequestNodeId : public Darabonba::Model {
public:
  shared_ptr<string> fieldIdList{};
  shared_ptr<string> id{};

  GetNodeUpDownStreamRequestNodeId() {}

  explicit GetNodeUpDownStreamRequestNodeId(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      fieldIdList = make_shared<string>(boost::any_cast<string>(m["FieldIdList"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetNodeUpDownStreamRequestNodeId() = default;
};
class GetNodeUpDownStreamRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<GetNodeUpDownStreamRequestNodeId> nodeId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> upStreamDepth{};

  GetNodeUpDownStreamRequest() {}

  explicit GetNodeUpDownStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (nodeId) {
      res["NodeId"] = nodeId ? boost::any(nodeId->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (upStreamDepth) {
      res["UpStreamDepth"] = boost::any(*upStreamDepth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeId"].type()) {
        GetNodeUpDownStreamRequestNodeId model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeId"]));
        nodeId = make_shared<GetNodeUpDownStreamRequestNodeId>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UpStreamDepth") != m.end() && !m["UpStreamDepth"].empty()) {
      upStreamDepth = make_shared<long>(boost::any_cast<long>(m["UpStreamDepth"]));
    }
  }


  virtual ~GetNodeUpDownStreamRequest() = default;
};
class GetNodeUpDownStreamShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<string> env{};
  shared_ptr<string> nodeIdShrink{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<long> upStreamDepth{};

  GetNodeUpDownStreamShrinkRequest() {}

  explicit GetNodeUpDownStreamShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (nodeIdShrink) {
      res["NodeId"] = boost::any(*nodeIdShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (upStreamDepth) {
      res["UpStreamDepth"] = boost::any(*upStreamDepth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeIdShrink = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("UpStreamDepth") != m.end() && !m["UpStreamDepth"].empty()) {
      upStreamDepth = make_shared<long>(boost::any_cast<long>(m["UpStreamDepth"]));
    }
  }


  virtual ~GetNodeUpDownStreamShrinkRequest() = default;
};
class GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList() {}

  explicit GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList() = default;
};
class GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList() {}

  explicit GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList() = default;
};
class GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList() {}

  explicit GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList() = default;
};
class GetNodeUpDownStreamResponseBodyNodeDagInfo : public Darabonba::Model {
public:
  shared_ptr<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList>> downStreamNodeList{};
  shared_ptr<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList>> startNodeList{};
  shared_ptr<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList>> upStreamNodeList{};

  GetNodeUpDownStreamResponseBodyNodeDagInfo() {}

  explicit GetNodeUpDownStreamResponseBodyNodeDagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamNodeList) {
      vector<boost::any> temp1;
      for(auto item1:*downStreamNodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DownStreamNodeList"] = boost::any(temp1);
    }
    if (startNodeList) {
      vector<boost::any> temp1;
      for(auto item1:*startNodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StartNodeList"] = boost::any(temp1);
    }
    if (upStreamNodeList) {
      vector<boost::any> temp1;
      for(auto item1:*upStreamNodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpStreamNodeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamNodeList") != m.end() && !m["DownStreamNodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["DownStreamNodeList"].type()) {
        vector<GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DownStreamNodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        downStreamNodeList = make_shared<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoDownStreamNodeList>>(expect1);
      }
    }
    if (m.find("StartNodeList") != m.end() && !m["StartNodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["StartNodeList"].type()) {
        vector<GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StartNodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        startNodeList = make_shared<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoStartNodeList>>(expect1);
      }
    }
    if (m.find("UpStreamNodeList") != m.end() && !m["UpStreamNodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpStreamNodeList"].type()) {
        vector<GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpStreamNodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upStreamNodeList = make_shared<vector<GetNodeUpDownStreamResponseBodyNodeDagInfoUpStreamNodeList>>(expect1);
      }
    }
  }


  virtual ~GetNodeUpDownStreamResponseBodyNodeDagInfo() = default;
};
class GetNodeUpDownStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<GetNodeUpDownStreamResponseBodyNodeDagInfo> nodeDagInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetNodeUpDownStreamResponseBody() {}

  explicit GetNodeUpDownStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeDagInfo) {
      res["NodeDagInfo"] = nodeDagInfo ? boost::any(nodeDagInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeDagInfo") != m.end() && !m["NodeDagInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeDagInfo"].type()) {
        GetNodeUpDownStreamResponseBodyNodeDagInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeDagInfo"]));
        nodeDagInfo = make_shared<GetNodeUpDownStreamResponseBodyNodeDagInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetNodeUpDownStreamResponseBody() = default;
};
class GetNodeUpDownStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNodeUpDownStreamResponseBody> body{};

  GetNodeUpDownStreamResponse() {}

  explicit GetNodeUpDownStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNodeUpDownStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNodeUpDownStreamResponseBody>(model1);
      }
    }
  }


  virtual ~GetNodeUpDownStreamResponse() = default;
};
class GetOperationSubmitStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> jobId{};
  shared_ptr<long> opTenantId{};

  GetOperationSubmitStatusRequest() {}

  explicit GetOperationSubmitStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetOperationSubmitStatusRequest() = default;
};
class GetOperationSubmitStatusResponseBodyOperationSubmitJob : public Darabonba::Model {
public:
  shared_ptr<string> externalBizId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> operation{};
  shared_ptr<string> operationStatus{};
  shared_ptr<string> operator_{};
  shared_ptr<string> progress{};

  GetOperationSubmitStatusResponseBodyOperationSubmitJob() {}

  explicit GetOperationSubmitStatusResponseBodyOperationSubmitJob(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (externalBizId) {
      res["ExternalBizId"] = boost::any(*externalBizId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (operationStatus) {
      res["OperationStatus"] = boost::any(*operationStatus);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExternalBizId") != m.end() && !m["ExternalBizId"].empty()) {
      externalBizId = make_shared<string>(boost::any_cast<string>(m["ExternalBizId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("OperationStatus") != m.end() && !m["OperationStatus"].empty()) {
      operationStatus = make_shared<string>(boost::any_cast<string>(m["OperationStatus"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
  }


  virtual ~GetOperationSubmitStatusResponseBodyOperationSubmitJob() = default;
};
class GetOperationSubmitStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<GetOperationSubmitStatusResponseBodyOperationSubmitJob> operationSubmitJob{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetOperationSubmitStatusResponseBody() {}

  explicit GetOperationSubmitStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (operationSubmitJob) {
      res["OperationSubmitJob"] = operationSubmitJob ? boost::any(operationSubmitJob->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OperationSubmitJob") != m.end() && !m["OperationSubmitJob"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperationSubmitJob"].type()) {
        GetOperationSubmitStatusResponseBodyOperationSubmitJob model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperationSubmitJob"]));
        operationSubmitJob = make_shared<GetOperationSubmitStatusResponseBodyOperationSubmitJob>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetOperationSubmitStatusResponseBody() = default;
};
class GetOperationSubmitStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOperationSubmitStatusResponseBody> body{};

  GetOperationSubmitStatusResponse() {}

  explicit GetOperationSubmitStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOperationSubmitStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOperationSubmitStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetOperationSubmitStatusResponse() = default;
};
class GetPhysicalInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetPhysicalInstanceRequest() {}

  explicit GetPhysicalInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetPhysicalInstanceRequest() = default;
};
class GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator() {}

  explicit GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator() = default;
};
class GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier() {}

  explicit GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier() = default;
};
class GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList() {}

  explicit GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList() = default;
};
class GetPhysicalInstanceResponseBodyInstanceNodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitName{};
  shared_ptr<string> createTime{};
  shared_ptr<GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> from{};
  shared_ptr<bool> hasDev{};
  shared_ptr<bool> hasProd{};
  shared_ptr<string> id{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList>> ownerList{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<vector<string>> resourceGroupList{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> subDetailType{};
  shared_ptr<string> type{};

  GetPhysicalInstanceResponseBodyInstanceNodeInfo() {}

  explicit GetPhysicalInstanceResponseBodyInstanceNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (hasDev) {
      res["HasDev"] = boost::any(*hasDev);
    }
    if (hasProd) {
      res["HasProd"] = boost::any(*hasProd);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerList) {
      vector<boost::any> temp1;
      for(auto item1:*ownerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OwnerList"] = boost::any(temp1);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (resourceGroupList) {
      res["ResourceGroupList"] = boost::any(*resourceGroupList);
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (subDetailType) {
      res["SubDetailType"] = boost::any(*subDetailType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetPhysicalInstanceResponseBodyInstanceNodeInfoCreator>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("HasDev") != m.end() && !m["HasDev"].empty()) {
      hasDev = make_shared<bool>(boost::any_cast<bool>(m["HasDev"]));
    }
    if (m.find("HasProd") != m.end() && !m["HasProd"].empty()) {
      hasProd = make_shared<bool>(boost::any_cast<bool>(m["HasProd"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<GetPhysicalInstanceResponseBodyInstanceNodeInfoModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OwnerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ownerList = make_shared<vector<GetPhysicalInstanceResponseBodyInstanceNodeInfoOwnerList>>(expect1);
      }
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceGroupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDetailType") != m.end() && !m["SubDetailType"].empty()) {
      subDetailType = make_shared<string>(boost::any_cast<string>(m["SubDetailType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetPhysicalInstanceResponseBodyInstanceNodeInfo() = default;
};
class GetPhysicalInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> dueTime{};
  shared_ptr<string> duration{};
  shared_ptr<long> endExecuteTime{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> id{};
  shared_ptr<long> index{};
  shared_ptr<GetPhysicalInstanceResponseBodyInstanceNodeInfo> nodeInfo{};
  shared_ptr<long> startExecuteTime{};
  shared_ptr<vector<string>> statusList{};

  GetPhysicalInstanceResponseBodyInstance() {}

  explicit GetPhysicalInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endExecuteTime) {
      res["EndExecuteTime"] = boost::any(*endExecuteTime);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (nodeInfo) {
      res["NodeInfo"] = nodeInfo ? boost::any(nodeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startExecuteTime) {
      res["StartExecuteTime"] = boost::any(*startExecuteTime);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<string>(boost::any_cast<string>(m["DueTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndExecuteTime") != m.end() && !m["EndExecuteTime"].empty()) {
      endExecuteTime = make_shared<long>(boost::any_cast<long>(m["EndExecuteTime"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInfo"].type()) {
        GetPhysicalInstanceResponseBodyInstanceNodeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInfo"]));
        nodeInfo = make_shared<GetPhysicalInstanceResponseBodyInstanceNodeInfo>(model1);
      }
    }
    if (m.find("StartExecuteTime") != m.end() && !m["StartExecuteTime"].empty()) {
      startExecuteTime = make_shared<long>(boost::any_cast<long>(m["StartExecuteTime"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetPhysicalInstanceResponseBodyInstance() = default;
};
class GetPhysicalInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<GetPhysicalInstanceResponseBodyInstance> instance{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalInstanceResponseBody() {}

  explicit GetPhysicalInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        GetPhysicalInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<GetPhysicalInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalInstanceResponseBody() = default;
};
class GetPhysicalInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalInstanceResponseBody> body{};

  GetPhysicalInstanceResponse() {}

  explicit GetPhysicalInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalInstanceResponse() = default;
};
class GetPhysicalInstanceLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetPhysicalInstanceLogRequest() {}

  explicit GetPhysicalInstanceLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetPhysicalInstanceLogRequest() = default;
};
class GetPhysicalInstanceLogResponseBodyTaskrunLogList : public Darabonba::Model {
public:
  shared_ptr<string> duration{};
  shared_ptr<string> endTime{};
  shared_ptr<string> logContent{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskrunId{};

  GetPhysicalInstanceLogResponseBodyTaskrunLogList() {}

  explicit GetPhysicalInstanceLogResponseBodyTaskrunLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (logContent) {
      res["LogContent"] = boost::any(*logContent);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskrunId) {
      res["TaskrunId"] = boost::any(*taskrunId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("LogContent") != m.end() && !m["LogContent"].empty()) {
      logContent = make_shared<string>(boost::any_cast<string>(m["LogContent"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskrunId") != m.end() && !m["TaskrunId"].empty()) {
      taskrunId = make_shared<string>(boost::any_cast<string>(m["TaskrunId"]));
    }
  }


  virtual ~GetPhysicalInstanceLogResponseBodyTaskrunLogList() = default;
};
class GetPhysicalInstanceLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetPhysicalInstanceLogResponseBodyTaskrunLogList>> taskrunLogList{};

  GetPhysicalInstanceLogResponseBody() {}

  explicit GetPhysicalInstanceLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (taskrunLogList) {
      vector<boost::any> temp1;
      for(auto item1:*taskrunLogList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskrunLogList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TaskrunLogList") != m.end() && !m["TaskrunLogList"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskrunLogList"].type()) {
        vector<GetPhysicalInstanceLogResponseBodyTaskrunLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskrunLogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPhysicalInstanceLogResponseBodyTaskrunLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskrunLogList = make_shared<vector<GetPhysicalInstanceLogResponseBodyTaskrunLogList>>(expect1);
      }
    }
  }


  virtual ~GetPhysicalInstanceLogResponseBody() = default;
};
class GetPhysicalInstanceLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalInstanceLogResponseBody> body{};

  GetPhysicalInstanceLogResponse() {}

  explicit GetPhysicalInstanceLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalInstanceLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalInstanceLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalInstanceLogResponse() = default;
};
class GetPhysicalNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> opTenantId{};

  GetPhysicalNodeRequest() {}

  explicit GetPhysicalNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetPhysicalNodeRequest() = default;
};
class GetPhysicalNodeResponseBodyNodeInfoCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeResponseBodyNodeInfoCreator() {}

  explicit GetPhysicalNodeResponseBodyNodeInfoCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBodyNodeInfoCreator() = default;
};
class GetPhysicalNodeResponseBodyNodeInfoModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeResponseBodyNodeInfoModifier() {}

  explicit GetPhysicalNodeResponseBodyNodeInfoModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBodyNodeInfoModifier() = default;
};
class GetPhysicalNodeResponseBodyNodeInfoOwner : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeResponseBodyNodeInfoOwner() {}

  explicit GetPhysicalNodeResponseBodyNodeInfoOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBodyNodeInfoOwner() = default;
};
class GetPhysicalNodeResponseBodyNodeInfoProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeResponseBodyNodeInfoProjectInfo() {}

  explicit GetPhysicalNodeResponseBodyNodeInfoProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBodyNodeInfoProjectInfo() = default;
};
class GetPhysicalNodeResponseBodyNodeInfo : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<GetPhysicalNodeResponseBodyNodeInfoCreator> creator{};
  shared_ptr<string> cronExpression{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<string> description{};
  shared_ptr<string> from{};
  shared_ptr<string> id{};
  shared_ptr<long> lastModifiedTime{};
  shared_ptr<GetPhysicalNodeResponseBodyNodeInfoModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> operatorType{};
  shared_ptr<vector<string>> outputNameList{};
  shared_ptr<GetPhysicalNodeResponseBodyNodeInfoOwner> owner{};
  shared_ptr<string> priority{};
  shared_ptr<GetPhysicalNodeResponseBodyNodeInfoProjectInfo> projectInfo{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> status{};
  shared_ptr<string> triggerConfig{};

  GetPhysicalNodeResponseBodyNodeInfo() {}

  explicit GetPhysicalNodeResponseBodyNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operatorType) {
      res["OperatorType"] = boost::any(*operatorType);
    }
    if (outputNameList) {
      res["OutputNameList"] = boost::any(*outputNameList);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetPhysicalNodeResponseBodyNodeInfoCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetPhysicalNodeResponseBodyNodeInfoCreator>(model1);
      }
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<long>(boost::any_cast<long>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        GetPhysicalNodeResponseBodyNodeInfoModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<GetPhysicalNodeResponseBodyNodeInfoModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OperatorType") != m.end() && !m["OperatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["OperatorType"]));
    }
    if (m.find("OutputNameList") != m.end() && !m["OutputNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OutputNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OutputNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      outputNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        GetPhysicalNodeResponseBodyNodeInfoOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<GetPhysicalNodeResponseBodyNodeInfoOwner>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        GetPhysicalNodeResponseBodyNodeInfoProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<GetPhysicalNodeResponseBodyNodeInfoProjectInfo>(model1);
      }
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBodyNodeInfo() = default;
};
class GetPhysicalNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<GetPhysicalNodeResponseBodyNodeInfo> nodeInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalNodeResponseBody() {}

  explicit GetPhysicalNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeInfo) {
      res["NodeInfo"] = nodeInfo ? boost::any(nodeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInfo"].type()) {
        GetPhysicalNodeResponseBodyNodeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInfo"]));
        nodeInfo = make_shared<GetPhysicalNodeResponseBodyNodeInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalNodeResponseBody() = default;
};
class GetPhysicalNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalNodeResponseBody> body{};

  GetPhysicalNodeResponse() {}

  explicit GetPhysicalNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalNodeResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalNodeResponse() = default;
};
class GetPhysicalNodeByOutputNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> outputName{};

  GetPhysicalNodeByOutputNameRequest() {}

  explicit GetPhysicalNodeByOutputNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameRequest() = default;
};
class GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator() {}

  explicit GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator() = default;
};
class GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier() {}

  explicit GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier() = default;
};
class GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner() {}

  explicit GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner() = default;
};
class GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo() {}

  explicit GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo() = default;
};
class GetPhysicalNodeByOutputNameResponseBodyNodeInfo : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> from{};
  shared_ptr<string> id{};
  shared_ptr<long> lastModifiedTime{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<string> operatorType{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner> owner{};
  shared_ptr<string> priority{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo> projectInfo{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> status{};
  shared_ptr<string> triggerConfig{};

  GetPhysicalNodeByOutputNameResponseBodyNodeInfo() {}

  explicit GetPhysicalNodeByOutputNameResponseBodyNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operatorType) {
      res["OperatorType"] = boost::any(*operatorType);
    }
    if (owner) {
      res["Owner"] = owner ? boost::any(owner->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (triggerConfig) {
      res["TriggerConfig"] = boost::any(*triggerConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetPhysicalNodeByOutputNameResponseBodyNodeInfoCreator>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<long>(boost::any_cast<long>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<GetPhysicalNodeByOutputNameResponseBodyNodeInfoModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OperatorType") != m.end() && !m["OperatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["OperatorType"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      if (typeid(map<string, boost::any>) == m["Owner"].type()) {
        GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Owner"]));
        owner = make_shared<GetPhysicalNodeByOutputNameResponseBodyNodeInfoOwner>(model1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<string>(boost::any_cast<string>(m["Priority"]));
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<GetPhysicalNodeByOutputNameResponseBodyNodeInfoProjectInfo>(model1);
      }
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TriggerConfig") != m.end() && !m["TriggerConfig"].empty()) {
      triggerConfig = make_shared<string>(boost::any_cast<string>(m["TriggerConfig"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBodyNodeInfo() = default;
};
class GetPhysicalNodeByOutputNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBodyNodeInfo> nodeInfo{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalNodeByOutputNameResponseBody() {}

  explicit GetPhysicalNodeByOutputNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeInfo) {
      res["NodeInfo"] = nodeInfo ? boost::any(nodeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInfo"].type()) {
        GetPhysicalNodeByOutputNameResponseBodyNodeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInfo"]));
        nodeInfo = make_shared<GetPhysicalNodeByOutputNameResponseBodyNodeInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponseBody() = default;
};
class GetPhysicalNodeByOutputNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalNodeByOutputNameResponseBody> body{};

  GetPhysicalNodeByOutputNameResponse() {}

  explicit GetPhysicalNodeByOutputNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalNodeByOutputNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalNodeByOutputNameResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalNodeByOutputNameResponse() = default;
};
class GetPhysicalNodeContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> opTenantId{};

  GetPhysicalNodeContentRequest() {}

  explicit GetPhysicalNodeContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetPhysicalNodeContentRequest() = default;
};
class GetPhysicalNodeContentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> codeContent{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  GetPhysicalNodeContentResponseBodyData() {}

  explicit GetPhysicalNodeContentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeContent) {
      res["CodeContent"] = boost::any(*codeContent);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeContent") != m.end() && !m["CodeContent"].empty()) {
      codeContent = make_shared<string>(boost::any_cast<string>(m["CodeContent"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~GetPhysicalNodeContentResponseBodyData() = default;
};
class GetPhysicalNodeContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetPhysicalNodeContentResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalNodeContentResponseBody() {}

  explicit GetPhysicalNodeContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetPhysicalNodeContentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetPhysicalNodeContentResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalNodeContentResponseBody() = default;
};
class GetPhysicalNodeContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalNodeContentResponseBody> body{};

  GetPhysicalNodeContentResponse() {}

  explicit GetPhysicalNodeContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalNodeContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalNodeContentResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalNodeContentResponse() = default;
};
class GetPhysicalNodeOperationLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> nodeId{};
  shared_ptr<long> opTenantId{};

  GetPhysicalNodeOperationLogRequest() {}

  explicit GetPhysicalNodeOperationLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetPhysicalNodeOperationLogRequest() = default;
};
class GetPhysicalNodeOperationLogResponseBodyOperationLogList : public Darabonba::Model {
public:
  shared_ptr<string> context{};
  shared_ptr<string> operationTime{};
  shared_ptr<string> operationType{};
  shared_ptr<string> operator_{};
  shared_ptr<string> operatorName{};

  GetPhysicalNodeOperationLogResponseBodyOperationLogList() {}

  explicit GetPhysicalNodeOperationLogResponseBodyOperationLogList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (context) {
      res["Context"] = boost::any(*context);
    }
    if (operationTime) {
      res["OperationTime"] = boost::any(*operationTime);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (operatorName) {
      res["OperatorName"] = boost::any(*operatorName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Context") != m.end() && !m["Context"].empty()) {
      context = make_shared<string>(boost::any_cast<string>(m["Context"]));
    }
    if (m.find("OperationTime") != m.end() && !m["OperationTime"].empty()) {
      operationTime = make_shared<string>(boost::any_cast<string>(m["OperationTime"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("OperatorName") != m.end() && !m["OperatorName"].empty()) {
      operatorName = make_shared<string>(boost::any_cast<string>(m["OperatorName"]));
    }
  }


  virtual ~GetPhysicalNodeOperationLogResponseBodyOperationLogList() = default;
};
class GetPhysicalNodeOperationLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<GetPhysicalNodeOperationLogResponseBodyOperationLogList>> operationLogList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetPhysicalNodeOperationLogResponseBody() {}

  explicit GetPhysicalNodeOperationLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (operationLogList) {
      vector<boost::any> temp1;
      for(auto item1:*operationLogList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OperationLogList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OperationLogList") != m.end() && !m["OperationLogList"].empty()) {
      if (typeid(vector<boost::any>) == m["OperationLogList"].type()) {
        vector<GetPhysicalNodeOperationLogResponseBodyOperationLogList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OperationLogList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetPhysicalNodeOperationLogResponseBodyOperationLogList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        operationLogList = make_shared<vector<GetPhysicalNodeOperationLogResponseBodyOperationLogList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetPhysicalNodeOperationLogResponseBody() = default;
};
class GetPhysicalNodeOperationLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetPhysicalNodeOperationLogResponseBody> body{};

  GetPhysicalNodeOperationLogResponse() {}

  explicit GetPhysicalNodeOperationLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetPhysicalNodeOperationLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetPhysicalNodeOperationLogResponseBody>(model1);
      }
    }
  }


  virtual ~GetPhysicalNodeOperationLogResponse() = default;
};
class GetProjectProduceUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  GetProjectProduceUserRequest() {}

  explicit GetProjectProduceUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~GetProjectProduceUserRequest() = default;
};
class GetProjectProduceUserResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  GetProjectProduceUserResponseBodyUser() {}

  explicit GetProjectProduceUserResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetProjectProduceUserResponseBodyUser() = default;
};
class GetProjectProduceUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetProjectProduceUserResponseBodyUser> user{};

  GetProjectProduceUserResponseBody() {}

  explicit GetProjectProduceUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetProjectProduceUserResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetProjectProduceUserResponseBodyUser>(model1);
      }
    }
  }


  virtual ~GetProjectProduceUserResponseBody() = default;
};
class GetProjectProduceUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectProduceUserResponseBody> body{};

  GetProjectProduceUserResponse() {}

  explicit GetProjectProduceUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectProduceUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectProduceUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectProduceUserResponse() = default;
};
class GetQueueEngineVersionByEnvRequest : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> queueName{};
  shared_ptr<string> streamBatchMode{};

  GetQueueEngineVersionByEnvRequest() {}

  explicit GetQueueEngineVersionByEnvRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (streamBatchMode) {
      res["StreamBatchMode"] = boost::any(*streamBatchMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("StreamBatchMode") != m.end() && !m["StreamBatchMode"].empty()) {
      streamBatchMode = make_shared<string>(boost::any_cast<string>(m["StreamBatchMode"]));
    }
  }


  virtual ~GetQueueEngineVersionByEnvRequest() = default;
};
class GetQueueEngineVersionByEnvResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetQueueEngineVersionByEnvResponseBody() {}

  explicit GetQueueEngineVersionByEnvResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetQueueEngineVersionByEnvResponseBody() = default;
};
class GetQueueEngineVersionByEnvResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetQueueEngineVersionByEnvResponseBody> body{};

  GetQueueEngineVersionByEnvResponse() {}

  explicit GetQueueEngineVersionByEnvResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQueueEngineVersionByEnvResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQueueEngineVersionByEnvResponseBody>(model1);
      }
    }
  }


  virtual ~GetQueueEngineVersionByEnvResponse() = default;
};
class GetSparkLocalClientInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> envEnum{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> projectId{};

  GetSparkLocalClientInfoRequest() {}

  explicit GetSparkLocalClientInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (envEnum) {
      res["EnvEnum"] = boost::any(*envEnum);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnvEnum") != m.end() && !m["EnvEnum"].empty()) {
      envEnum = make_shared<string>(boost::any_cast<string>(m["EnvEnum"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~GetSparkLocalClientInfoRequest() = default;
};
class GetSparkLocalClientInfoResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clientFileResourceId{};
  shared_ptr<string> clientFileResourceName{};
  shared_ptr<string> clientName{};
  shared_ptr<bool> editable{};

  GetSparkLocalClientInfoResponseBodyData() {}

  explicit GetSparkLocalClientInfoResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientFileResourceId) {
      res["ClientFileResourceId"] = boost::any(*clientFileResourceId);
    }
    if (clientFileResourceName) {
      res["ClientFileResourceName"] = boost::any(*clientFileResourceName);
    }
    if (clientName) {
      res["ClientName"] = boost::any(*clientName);
    }
    if (editable) {
      res["Editable"] = boost::any(*editable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientFileResourceId") != m.end() && !m["ClientFileResourceId"].empty()) {
      clientFileResourceId = make_shared<string>(boost::any_cast<string>(m["ClientFileResourceId"]));
    }
    if (m.find("ClientFileResourceName") != m.end() && !m["ClientFileResourceName"].empty()) {
      clientFileResourceName = make_shared<string>(boost::any_cast<string>(m["ClientFileResourceName"]));
    }
    if (m.find("ClientName") != m.end() && !m["ClientName"].empty()) {
      clientName = make_shared<string>(boost::any_cast<string>(m["ClientName"]));
    }
    if (m.find("Editable") != m.end() && !m["Editable"].empty()) {
      editable = make_shared<bool>(boost::any_cast<bool>(m["Editable"]));
    }
  }


  virtual ~GetSparkLocalClientInfoResponseBodyData() = default;
};
class GetSparkLocalClientInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetSparkLocalClientInfoResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSparkLocalClientInfoResponseBody() {}

  explicit GetSparkLocalClientInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetSparkLocalClientInfoResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSparkLocalClientInfoResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetSparkLocalClientInfoResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSparkLocalClientInfoResponseBody() = default;
};
class GetSparkLocalClientInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSparkLocalClientInfoResponseBody> body{};

  GetSparkLocalClientInfoResponse() {}

  explicit GetSparkLocalClientInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSparkLocalClientInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSparkLocalClientInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetSparkLocalClientInfoResponse() = default;
};
class GetSupplementDagrunRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> supplementId{};

  GetSupplementDagrunRequest() {}

  explicit GetSupplementDagrunRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (supplementId) {
      res["SupplementId"] = boost::any(*supplementId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SupplementId") != m.end() && !m["SupplementId"].empty()) {
      supplementId = make_shared<string>(boost::any_cast<string>(m["SupplementId"]));
    }
  }


  virtual ~GetSupplementDagrunRequest() = default;
};
class GetSupplementDagrunResponseBodyDagrunList : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> duration{};
  shared_ptr<long> endExecuteTime{};
  shared_ptr<string> id{};
  shared_ptr<long> startExecuteTime{};
  shared_ptr<string> status{};
  shared_ptr<string> supplementId{};

  GetSupplementDagrunResponseBodyDagrunList() {}

  explicit GetSupplementDagrunResponseBodyDagrunList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endExecuteTime) {
      res["EndExecuteTime"] = boost::any(*endExecuteTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (startExecuteTime) {
      res["StartExecuteTime"] = boost::any(*startExecuteTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supplementId) {
      res["SupplementId"] = boost::any(*supplementId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndExecuteTime") != m.end() && !m["EndExecuteTime"].empty()) {
      endExecuteTime = make_shared<long>(boost::any_cast<long>(m["EndExecuteTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("StartExecuteTime") != m.end() && !m["StartExecuteTime"].empty()) {
      startExecuteTime = make_shared<long>(boost::any_cast<long>(m["StartExecuteTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupplementId") != m.end() && !m["SupplementId"].empty()) {
      supplementId = make_shared<string>(boost::any_cast<string>(m["SupplementId"]));
    }
  }


  virtual ~GetSupplementDagrunResponseBodyDagrunList() = default;
};
class GetSupplementDagrunResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetSupplementDagrunResponseBodyDagrunList>> dagrunList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSupplementDagrunResponseBody() {}

  explicit GetSupplementDagrunResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dagrunList) {
      vector<boost::any> temp1;
      for(auto item1:*dagrunList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DagrunList"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DagrunList") != m.end() && !m["DagrunList"].empty()) {
      if (typeid(vector<boost::any>) == m["DagrunList"].type()) {
        vector<GetSupplementDagrunResponseBodyDagrunList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DagrunList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSupplementDagrunResponseBodyDagrunList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dagrunList = make_shared<vector<GetSupplementDagrunResponseBodyDagrunList>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSupplementDagrunResponseBody() = default;
};
class GetSupplementDagrunResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSupplementDagrunResponseBody> body{};

  GetSupplementDagrunResponse() {}

  explicit GetSupplementDagrunResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSupplementDagrunResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSupplementDagrunResponseBody>(model1);
      }
    }
  }


  virtual ~GetSupplementDagrunResponse() = default;
};
class GetSupplementDagrunInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> dagrunId{};
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};

  GetSupplementDagrunInstanceRequest() {}

  explicit GetSupplementDagrunInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dagrunId) {
      res["DagrunId"] = boost::any(*dagrunId);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DagrunId") != m.end() && !m["DagrunId"].empty()) {
      dagrunId = make_shared<string>(boost::any_cast<string>(m["DagrunId"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceRequest() = default;
};
class GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator() {}

  explicit GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator() = default;
};
class GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier() {}

  explicit GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier() = default;
};
class GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList() {}

  explicit GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList() = default;
};
class GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitName{};
  shared_ptr<string> createTime{};
  shared_ptr<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> from{};
  shared_ptr<bool> hasDev{};
  shared_ptr<bool> hasProd{};
  shared_ptr<string> id{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList>> ownerList{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<vector<string>> resourceGroupList{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> subDetailType{};
  shared_ptr<string> type{};

  GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo() {}

  explicit GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (hasDev) {
      res["HasDev"] = boost::any(*hasDev);
    }
    if (hasProd) {
      res["HasProd"] = boost::any(*hasProd);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerList) {
      vector<boost::any> temp1;
      for(auto item1:*ownerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OwnerList"] = boost::any(temp1);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (resourceGroupList) {
      res["ResourceGroupList"] = boost::any(*resourceGroupList);
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (subDetailType) {
      res["SubDetailType"] = boost::any(*subDetailType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoCreator>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("HasDev") != m.end() && !m["HasDev"].empty()) {
      hasDev = make_shared<bool>(boost::any_cast<bool>(m["HasDev"]));
    }
    if (m.find("HasProd") != m.end() && !m["HasProd"].empty()) {
      hasProd = make_shared<bool>(boost::any_cast<bool>(m["HasProd"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OwnerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ownerList = make_shared<vector<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfoOwnerList>>(expect1);
      }
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceGroupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDetailType") != m.end() && !m["SubDetailType"].empty()) {
      subDetailType = make_shared<string>(boost::any_cast<string>(m["SubDetailType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo() = default;
};
class GetSupplementDagrunInstanceResponseBodyInstanceList : public Darabonba::Model {
public:
  shared_ptr<long> bizDate{};
  shared_ptr<long> dueTime{};
  shared_ptr<string> duration{};
  shared_ptr<long> endExecuteTime{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> id{};
  shared_ptr<long> index{};
  shared_ptr<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo> nodeInfo{};
  shared_ptr<long> startExecuteTime{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<string> type{};

  GetSupplementDagrunInstanceResponseBodyInstanceList() {}

  explicit GetSupplementDagrunInstanceResponseBodyInstanceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endExecuteTime) {
      res["EndExecuteTime"] = boost::any(*endExecuteTime);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (nodeInfo) {
      res["NodeInfo"] = nodeInfo ? boost::any(nodeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startExecuteTime) {
      res["StartExecuteTime"] = boost::any(*startExecuteTime);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<long>(boost::any_cast<long>(m["BizDate"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<long>(boost::any_cast<long>(m["DueTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndExecuteTime") != m.end() && !m["EndExecuteTime"].empty()) {
      endExecuteTime = make_shared<long>(boost::any_cast<long>(m["EndExecuteTime"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInfo"].type()) {
        GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInfo"]));
        nodeInfo = make_shared<GetSupplementDagrunInstanceResponseBodyInstanceListNodeInfo>(model1);
      }
    }
    if (m.find("StartExecuteTime") != m.end() && !m["StartExecuteTime"].empty()) {
      startExecuteTime = make_shared<long>(boost::any_cast<long>(m["StartExecuteTime"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBodyInstanceList() = default;
};
class GetSupplementDagrunInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<GetSupplementDagrunInstanceResponseBodyInstanceList>> instanceList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetSupplementDagrunInstanceResponseBody() {}

  explicit GetSupplementDagrunInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceList") != m.end() && !m["InstanceList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceList"].type()) {
        vector<GetSupplementDagrunInstanceResponseBodyInstanceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSupplementDagrunInstanceResponseBodyInstanceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceList = make_shared<vector<GetSupplementDagrunInstanceResponseBodyInstanceList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetSupplementDagrunInstanceResponseBody() = default;
};
class GetSupplementDagrunInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSupplementDagrunInstanceResponseBody> body{};

  GetSupplementDagrunInstanceResponse() {}

  explicit GetSupplementDagrunInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSupplementDagrunInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSupplementDagrunInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetSupplementDagrunInstanceResponse() = default;
};
class GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery : public Darabonba::Model {
public:
  shared_ptr<bool> needNotExistObject{};
  shared_ptr<string> taskEnv{};
  shared_ptr<string> taskId{};

  GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery() {}

  explicit GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needNotExistObject) {
      res["NeedNotExistObject"] = boost::any(*needNotExistObject);
    }
    if (taskEnv) {
      res["TaskEnv"] = boost::any(*taskEnv);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NeedNotExistObject") != m.end() && !m["NeedNotExistObject"].empty()) {
      needNotExistObject = make_shared<bool>(boost::any_cast<bool>(m["NeedNotExistObject"]));
    }
    if (m.find("TaskEnv") != m.end() && !m["TaskEnv"].empty()) {
      taskEnv = make_shared<string>(boost::any_cast<string>(m["TaskEnv"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery() = default;
};
class GetTableColumnLineageByTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery> tableColumnLineageByTaskIdQuery{};

  GetTableColumnLineageByTaskIdRequest() {}

  explicit GetTableColumnLineageByTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (tableColumnLineageByTaskIdQuery) {
      res["TableColumnLineageByTaskIdQuery"] = tableColumnLineageByTaskIdQuery ? boost::any(tableColumnLineageByTaskIdQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("TableColumnLineageByTaskIdQuery") != m.end() && !m["TableColumnLineageByTaskIdQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableColumnLineageByTaskIdQuery"].type()) {
        GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableColumnLineageByTaskIdQuery"]));
        tableColumnLineageByTaskIdQuery = make_shared<GetTableColumnLineageByTaskIdRequestTableColumnLineageByTaskIdQuery>(model1);
      }
    }
  }


  virtual ~GetTableColumnLineageByTaskIdRequest() = default;
};
class GetTableColumnLineageByTaskIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> tableColumnLineageByTaskIdQueryShrink{};

  GetTableColumnLineageByTaskIdShrinkRequest() {}

  explicit GetTableColumnLineageByTaskIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (tableColumnLineageByTaskIdQueryShrink) {
      res["TableColumnLineageByTaskIdQuery"] = boost::any(*tableColumnLineageByTaskIdQueryShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("TableColumnLineageByTaskIdQuery") != m.end() && !m["TableColumnLineageByTaskIdQuery"].empty()) {
      tableColumnLineageByTaskIdQueryShrink = make_shared<string>(boost::any_cast<string>(m["TableColumnLineageByTaskIdQuery"]));
    }
  }


  virtual ~GetTableColumnLineageByTaskIdShrinkRequest() = default;
};
class GetTableColumnLineageByTaskIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> inputBizUnitId{};
  shared_ptr<string> inputColumnId{};
  shared_ptr<string> inputColumnName{};
  shared_ptr<long> inputDataSourceId{};
  shared_ptr<string> inputDataSourceType{};
  shared_ptr<string> inputDbType{};
  shared_ptr<string> inputEnv{};
  shared_ptr<long> inputProjectId{};
  shared_ptr<bool> inputTableDeleted{};
  shared_ptr<string> inputTableId{};
  shared_ptr<string> inputTableName{};
  shared_ptr<string> inputTableType{};
  shared_ptr<long> outputBizUnitId{};
  shared_ptr<string> outputColumnId{};
  shared_ptr<string> outputColumnName{};
  shared_ptr<long> outputDataSourceId{};
  shared_ptr<string> outputDataSourceType{};
  shared_ptr<string> outputDbType{};
  shared_ptr<string> outputEnv{};
  shared_ptr<long> outputProjectId{};
  shared_ptr<bool> outputTableDeleted{};
  shared_ptr<string> outputTableId{};
  shared_ptr<string> outputTableName{};
  shared_ptr<string> outputTableType{};
  shared_ptr<string> taskEnv{};
  shared_ptr<string> taskId{};
  shared_ptr<long> tenantId{};

  GetTableColumnLineageByTaskIdResponseBodyData() {}

  explicit GetTableColumnLineageByTaskIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputBizUnitId) {
      res["InputBizUnitId"] = boost::any(*inputBizUnitId);
    }
    if (inputColumnId) {
      res["InputColumnId"] = boost::any(*inputColumnId);
    }
    if (inputColumnName) {
      res["InputColumnName"] = boost::any(*inputColumnName);
    }
    if (inputDataSourceId) {
      res["InputDataSourceId"] = boost::any(*inputDataSourceId);
    }
    if (inputDataSourceType) {
      res["InputDataSourceType"] = boost::any(*inputDataSourceType);
    }
    if (inputDbType) {
      res["InputDbType"] = boost::any(*inputDbType);
    }
    if (inputEnv) {
      res["InputEnv"] = boost::any(*inputEnv);
    }
    if (inputProjectId) {
      res["InputProjectId"] = boost::any(*inputProjectId);
    }
    if (inputTableDeleted) {
      res["InputTableDeleted"] = boost::any(*inputTableDeleted);
    }
    if (inputTableId) {
      res["InputTableId"] = boost::any(*inputTableId);
    }
    if (inputTableName) {
      res["InputTableName"] = boost::any(*inputTableName);
    }
    if (inputTableType) {
      res["InputTableType"] = boost::any(*inputTableType);
    }
    if (outputBizUnitId) {
      res["OutputBizUnitId"] = boost::any(*outputBizUnitId);
    }
    if (outputColumnId) {
      res["OutputColumnId"] = boost::any(*outputColumnId);
    }
    if (outputColumnName) {
      res["OutputColumnName"] = boost::any(*outputColumnName);
    }
    if (outputDataSourceId) {
      res["OutputDataSourceId"] = boost::any(*outputDataSourceId);
    }
    if (outputDataSourceType) {
      res["OutputDataSourceType"] = boost::any(*outputDataSourceType);
    }
    if (outputDbType) {
      res["OutputDbType"] = boost::any(*outputDbType);
    }
    if (outputEnv) {
      res["OutputEnv"] = boost::any(*outputEnv);
    }
    if (outputProjectId) {
      res["OutputProjectId"] = boost::any(*outputProjectId);
    }
    if (outputTableDeleted) {
      res["OutputTableDeleted"] = boost::any(*outputTableDeleted);
    }
    if (outputTableId) {
      res["OutputTableId"] = boost::any(*outputTableId);
    }
    if (outputTableName) {
      res["OutputTableName"] = boost::any(*outputTableName);
    }
    if (outputTableType) {
      res["OutputTableType"] = boost::any(*outputTableType);
    }
    if (taskEnv) {
      res["TaskEnv"] = boost::any(*taskEnv);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputBizUnitId") != m.end() && !m["InputBizUnitId"].empty()) {
      inputBizUnitId = make_shared<long>(boost::any_cast<long>(m["InputBizUnitId"]));
    }
    if (m.find("InputColumnId") != m.end() && !m["InputColumnId"].empty()) {
      inputColumnId = make_shared<string>(boost::any_cast<string>(m["InputColumnId"]));
    }
    if (m.find("InputColumnName") != m.end() && !m["InputColumnName"].empty()) {
      inputColumnName = make_shared<string>(boost::any_cast<string>(m["InputColumnName"]));
    }
    if (m.find("InputDataSourceId") != m.end() && !m["InputDataSourceId"].empty()) {
      inputDataSourceId = make_shared<long>(boost::any_cast<long>(m["InputDataSourceId"]));
    }
    if (m.find("InputDataSourceType") != m.end() && !m["InputDataSourceType"].empty()) {
      inputDataSourceType = make_shared<string>(boost::any_cast<string>(m["InputDataSourceType"]));
    }
    if (m.find("InputDbType") != m.end() && !m["InputDbType"].empty()) {
      inputDbType = make_shared<string>(boost::any_cast<string>(m["InputDbType"]));
    }
    if (m.find("InputEnv") != m.end() && !m["InputEnv"].empty()) {
      inputEnv = make_shared<string>(boost::any_cast<string>(m["InputEnv"]));
    }
    if (m.find("InputProjectId") != m.end() && !m["InputProjectId"].empty()) {
      inputProjectId = make_shared<long>(boost::any_cast<long>(m["InputProjectId"]));
    }
    if (m.find("InputTableDeleted") != m.end() && !m["InputTableDeleted"].empty()) {
      inputTableDeleted = make_shared<bool>(boost::any_cast<bool>(m["InputTableDeleted"]));
    }
    if (m.find("InputTableId") != m.end() && !m["InputTableId"].empty()) {
      inputTableId = make_shared<string>(boost::any_cast<string>(m["InputTableId"]));
    }
    if (m.find("InputTableName") != m.end() && !m["InputTableName"].empty()) {
      inputTableName = make_shared<string>(boost::any_cast<string>(m["InputTableName"]));
    }
    if (m.find("InputTableType") != m.end() && !m["InputTableType"].empty()) {
      inputTableType = make_shared<string>(boost::any_cast<string>(m["InputTableType"]));
    }
    if (m.find("OutputBizUnitId") != m.end() && !m["OutputBizUnitId"].empty()) {
      outputBizUnitId = make_shared<long>(boost::any_cast<long>(m["OutputBizUnitId"]));
    }
    if (m.find("OutputColumnId") != m.end() && !m["OutputColumnId"].empty()) {
      outputColumnId = make_shared<string>(boost::any_cast<string>(m["OutputColumnId"]));
    }
    if (m.find("OutputColumnName") != m.end() && !m["OutputColumnName"].empty()) {
      outputColumnName = make_shared<string>(boost::any_cast<string>(m["OutputColumnName"]));
    }
    if (m.find("OutputDataSourceId") != m.end() && !m["OutputDataSourceId"].empty()) {
      outputDataSourceId = make_shared<long>(boost::any_cast<long>(m["OutputDataSourceId"]));
    }
    if (m.find("OutputDataSourceType") != m.end() && !m["OutputDataSourceType"].empty()) {
      outputDataSourceType = make_shared<string>(boost::any_cast<string>(m["OutputDataSourceType"]));
    }
    if (m.find("OutputDbType") != m.end() && !m["OutputDbType"].empty()) {
      outputDbType = make_shared<string>(boost::any_cast<string>(m["OutputDbType"]));
    }
    if (m.find("OutputEnv") != m.end() && !m["OutputEnv"].empty()) {
      outputEnv = make_shared<string>(boost::any_cast<string>(m["OutputEnv"]));
    }
    if (m.find("OutputProjectId") != m.end() && !m["OutputProjectId"].empty()) {
      outputProjectId = make_shared<long>(boost::any_cast<long>(m["OutputProjectId"]));
    }
    if (m.find("OutputTableDeleted") != m.end() && !m["OutputTableDeleted"].empty()) {
      outputTableDeleted = make_shared<bool>(boost::any_cast<bool>(m["OutputTableDeleted"]));
    }
    if (m.find("OutputTableId") != m.end() && !m["OutputTableId"].empty()) {
      outputTableId = make_shared<string>(boost::any_cast<string>(m["OutputTableId"]));
    }
    if (m.find("OutputTableName") != m.end() && !m["OutputTableName"].empty()) {
      outputTableName = make_shared<string>(boost::any_cast<string>(m["OutputTableName"]));
    }
    if (m.find("OutputTableType") != m.end() && !m["OutputTableType"].empty()) {
      outputTableType = make_shared<string>(boost::any_cast<string>(m["OutputTableType"]));
    }
    if (m.find("TaskEnv") != m.end() && !m["TaskEnv"].empty()) {
      taskEnv = make_shared<string>(boost::any_cast<string>(m["TaskEnv"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~GetTableColumnLineageByTaskIdResponseBodyData() = default;
};
class GetTableColumnLineageByTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetTableColumnLineageByTaskIdResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTableColumnLineageByTaskIdResponseBody() {}

  explicit GetTableColumnLineageByTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetTableColumnLineageByTaskIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableColumnLineageByTaskIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetTableColumnLineageByTaskIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTableColumnLineageByTaskIdResponseBody() = default;
};
class GetTableColumnLineageByTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTableColumnLineageByTaskIdResponseBody> body{};

  GetTableColumnLineageByTaskIdResponse() {}

  explicit GetTableColumnLineageByTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTableColumnLineageByTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTableColumnLineageByTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTableColumnLineageByTaskIdResponse() = default;
};
class GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery : public Darabonba::Model {
public:
  shared_ptr<bool> needNotExistObject{};
  shared_ptr<string> taskEnv{};
  shared_ptr<string> taskId{};

  GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery() {}

  explicit GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (needNotExistObject) {
      res["NeedNotExistObject"] = boost::any(*needNotExistObject);
    }
    if (taskEnv) {
      res["TaskEnv"] = boost::any(*taskEnv);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NeedNotExistObject") != m.end() && !m["NeedNotExistObject"].empty()) {
      needNotExistObject = make_shared<bool>(boost::any_cast<bool>(m["NeedNotExistObject"]));
    }
    if (m.find("TaskEnv") != m.end() && !m["TaskEnv"].empty()) {
      taskEnv = make_shared<string>(boost::any_cast<string>(m["TaskEnv"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery() = default;
};
class GetTableLineageByTaskIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery> tableLineageByTaskIdQuery{};

  GetTableLineageByTaskIdRequest() {}

  explicit GetTableLineageByTaskIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (tableLineageByTaskIdQuery) {
      res["TableLineageByTaskIdQuery"] = tableLineageByTaskIdQuery ? boost::any(tableLineageByTaskIdQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("TableLineageByTaskIdQuery") != m.end() && !m["TableLineageByTaskIdQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["TableLineageByTaskIdQuery"].type()) {
        GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TableLineageByTaskIdQuery"]));
        tableLineageByTaskIdQuery = make_shared<GetTableLineageByTaskIdRequestTableLineageByTaskIdQuery>(model1);
      }
    }
  }


  virtual ~GetTableLineageByTaskIdRequest() = default;
};
class GetTableLineageByTaskIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> tableLineageByTaskIdQueryShrink{};

  GetTableLineageByTaskIdShrinkRequest() {}

  explicit GetTableLineageByTaskIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (tableLineageByTaskIdQueryShrink) {
      res["TableLineageByTaskIdQuery"] = boost::any(*tableLineageByTaskIdQueryShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("TableLineageByTaskIdQuery") != m.end() && !m["TableLineageByTaskIdQuery"].empty()) {
      tableLineageByTaskIdQueryShrink = make_shared<string>(boost::any_cast<string>(m["TableLineageByTaskIdQuery"]));
    }
  }


  virtual ~GetTableLineageByTaskIdShrinkRequest() = default;
};
class GetTableLineageByTaskIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> inputBizUnitId{};
  shared_ptr<long> inputDataSourceId{};
  shared_ptr<string> inputDataSourceType{};
  shared_ptr<string> inputDbType{};
  shared_ptr<string> inputEnv{};
  shared_ptr<long> inputProjectId{};
  shared_ptr<bool> inputTableDeleted{};
  shared_ptr<string> inputTableId{};
  shared_ptr<string> inputTableName{};
  shared_ptr<string> inputTableType{};
  shared_ptr<long> outputBizUnitId{};
  shared_ptr<long> outputDataSourceId{};
  shared_ptr<string> outputDataSourceType{};
  shared_ptr<string> outputDbType{};
  shared_ptr<string> outputEnv{};
  shared_ptr<long> outputProjectId{};
  shared_ptr<bool> outputTableDeleted{};
  shared_ptr<string> outputTableId{};
  shared_ptr<string> outputTableName{};
  shared_ptr<string> outputTableType{};
  shared_ptr<string> taskEnv{};
  shared_ptr<string> taskId{};
  shared_ptr<long> tenantId{};

  GetTableLineageByTaskIdResponseBodyData() {}

  explicit GetTableLineageByTaskIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputBizUnitId) {
      res["InputBizUnitId"] = boost::any(*inputBizUnitId);
    }
    if (inputDataSourceId) {
      res["InputDataSourceId"] = boost::any(*inputDataSourceId);
    }
    if (inputDataSourceType) {
      res["InputDataSourceType"] = boost::any(*inputDataSourceType);
    }
    if (inputDbType) {
      res["InputDbType"] = boost::any(*inputDbType);
    }
    if (inputEnv) {
      res["InputEnv"] = boost::any(*inputEnv);
    }
    if (inputProjectId) {
      res["InputProjectId"] = boost::any(*inputProjectId);
    }
    if (inputTableDeleted) {
      res["InputTableDeleted"] = boost::any(*inputTableDeleted);
    }
    if (inputTableId) {
      res["InputTableId"] = boost::any(*inputTableId);
    }
    if (inputTableName) {
      res["InputTableName"] = boost::any(*inputTableName);
    }
    if (inputTableType) {
      res["InputTableType"] = boost::any(*inputTableType);
    }
    if (outputBizUnitId) {
      res["OutputBizUnitId"] = boost::any(*outputBizUnitId);
    }
    if (outputDataSourceId) {
      res["OutputDataSourceId"] = boost::any(*outputDataSourceId);
    }
    if (outputDataSourceType) {
      res["OutputDataSourceType"] = boost::any(*outputDataSourceType);
    }
    if (outputDbType) {
      res["OutputDbType"] = boost::any(*outputDbType);
    }
    if (outputEnv) {
      res["OutputEnv"] = boost::any(*outputEnv);
    }
    if (outputProjectId) {
      res["OutputProjectId"] = boost::any(*outputProjectId);
    }
    if (outputTableDeleted) {
      res["OutputTableDeleted"] = boost::any(*outputTableDeleted);
    }
    if (outputTableId) {
      res["OutputTableId"] = boost::any(*outputTableId);
    }
    if (outputTableName) {
      res["OutputTableName"] = boost::any(*outputTableName);
    }
    if (outputTableType) {
      res["OutputTableType"] = boost::any(*outputTableType);
    }
    if (taskEnv) {
      res["TaskEnv"] = boost::any(*taskEnv);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputBizUnitId") != m.end() && !m["InputBizUnitId"].empty()) {
      inputBizUnitId = make_shared<long>(boost::any_cast<long>(m["InputBizUnitId"]));
    }
    if (m.find("InputDataSourceId") != m.end() && !m["InputDataSourceId"].empty()) {
      inputDataSourceId = make_shared<long>(boost::any_cast<long>(m["InputDataSourceId"]));
    }
    if (m.find("InputDataSourceType") != m.end() && !m["InputDataSourceType"].empty()) {
      inputDataSourceType = make_shared<string>(boost::any_cast<string>(m["InputDataSourceType"]));
    }
    if (m.find("InputDbType") != m.end() && !m["InputDbType"].empty()) {
      inputDbType = make_shared<string>(boost::any_cast<string>(m["InputDbType"]));
    }
    if (m.find("InputEnv") != m.end() && !m["InputEnv"].empty()) {
      inputEnv = make_shared<string>(boost::any_cast<string>(m["InputEnv"]));
    }
    if (m.find("InputProjectId") != m.end() && !m["InputProjectId"].empty()) {
      inputProjectId = make_shared<long>(boost::any_cast<long>(m["InputProjectId"]));
    }
    if (m.find("InputTableDeleted") != m.end() && !m["InputTableDeleted"].empty()) {
      inputTableDeleted = make_shared<bool>(boost::any_cast<bool>(m["InputTableDeleted"]));
    }
    if (m.find("InputTableId") != m.end() && !m["InputTableId"].empty()) {
      inputTableId = make_shared<string>(boost::any_cast<string>(m["InputTableId"]));
    }
    if (m.find("InputTableName") != m.end() && !m["InputTableName"].empty()) {
      inputTableName = make_shared<string>(boost::any_cast<string>(m["InputTableName"]));
    }
    if (m.find("InputTableType") != m.end() && !m["InputTableType"].empty()) {
      inputTableType = make_shared<string>(boost::any_cast<string>(m["InputTableType"]));
    }
    if (m.find("OutputBizUnitId") != m.end() && !m["OutputBizUnitId"].empty()) {
      outputBizUnitId = make_shared<long>(boost::any_cast<long>(m["OutputBizUnitId"]));
    }
    if (m.find("OutputDataSourceId") != m.end() && !m["OutputDataSourceId"].empty()) {
      outputDataSourceId = make_shared<long>(boost::any_cast<long>(m["OutputDataSourceId"]));
    }
    if (m.find("OutputDataSourceType") != m.end() && !m["OutputDataSourceType"].empty()) {
      outputDataSourceType = make_shared<string>(boost::any_cast<string>(m["OutputDataSourceType"]));
    }
    if (m.find("OutputDbType") != m.end() && !m["OutputDbType"].empty()) {
      outputDbType = make_shared<string>(boost::any_cast<string>(m["OutputDbType"]));
    }
    if (m.find("OutputEnv") != m.end() && !m["OutputEnv"].empty()) {
      outputEnv = make_shared<string>(boost::any_cast<string>(m["OutputEnv"]));
    }
    if (m.find("OutputProjectId") != m.end() && !m["OutputProjectId"].empty()) {
      outputProjectId = make_shared<long>(boost::any_cast<long>(m["OutputProjectId"]));
    }
    if (m.find("OutputTableDeleted") != m.end() && !m["OutputTableDeleted"].empty()) {
      outputTableDeleted = make_shared<bool>(boost::any_cast<bool>(m["OutputTableDeleted"]));
    }
    if (m.find("OutputTableId") != m.end() && !m["OutputTableId"].empty()) {
      outputTableId = make_shared<string>(boost::any_cast<string>(m["OutputTableId"]));
    }
    if (m.find("OutputTableName") != m.end() && !m["OutputTableName"].empty()) {
      outputTableName = make_shared<string>(boost::any_cast<string>(m["OutputTableName"]));
    }
    if (m.find("OutputTableType") != m.end() && !m["OutputTableType"].empty()) {
      outputTableType = make_shared<string>(boost::any_cast<string>(m["OutputTableType"]));
    }
    if (m.find("TaskEnv") != m.end() && !m["TaskEnv"].empty()) {
      taskEnv = make_shared<string>(boost::any_cast<string>(m["TaskEnv"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~GetTableLineageByTaskIdResponseBodyData() = default;
};
class GetTableLineageByTaskIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<GetTableLineageByTaskIdResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetTableLineageByTaskIdResponseBody() {}

  explicit GetTableLineageByTaskIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<GetTableLineageByTaskIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTableLineageByTaskIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetTableLineageByTaskIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetTableLineageByTaskIdResponseBody() = default;
};
class GetTableLineageByTaskIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTableLineageByTaskIdResponseBody> body{};

  GetTableLineageByTaskIdResponse() {}

  explicit GetTableLineageByTaskIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTableLineageByTaskIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTableLineageByTaskIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetTableLineageByTaskIdResponse() = default;
};
class GetUserBySourceIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> sourceId{};

  GetUserBySourceIdRequest() {}

  explicit GetUserBySourceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
  }


  virtual ~GetUserBySourceIdRequest() = default;
};
class GetUserBySourceIdResponseBodyUser : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};

  GetUserBySourceIdResponseBodyUser() {}

  explicit GetUserBySourceIdResponseBodyUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetUserBySourceIdResponseBodyUser() = default;
};
class GetUserBySourceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetUserBySourceIdResponseBodyUser> user{};

  GetUserBySourceIdResponseBody() {}

  explicit GetUserBySourceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        GetUserBySourceIdResponseBodyUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<GetUserBySourceIdResponseBodyUser>(model1);
      }
    }
  }


  virtual ~GetUserBySourceIdResponseBody() = default;
};
class GetUserBySourceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserBySourceIdResponseBody> body{};

  GetUserBySourceIdResponse() {}

  explicit GetUserBySourceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserBySourceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserBySourceIdResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserBySourceIdResponse() = default;
};
class GetUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> userGroupId{};

  GetUserGroupRequest() {}

  explicit GetUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~GetUserGroupRequest() = default;
};
class GetUserGroupResponseBodyUserGroupInfoAdminList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};

  GetUserGroupResponseBodyUserGroupInfoAdminList() {}

  explicit GetUserGroupResponseBodyUserGroupInfoAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~GetUserGroupResponseBodyUserGroupInfoAdminList() = default;
};
class GetUserGroupResponseBodyUserGroupInfo : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<vector<GetUserGroupResponseBodyUserGroupInfoAdminList>> adminList{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> myRole{};
  shared_ptr<string> name{};

  GetUserGroupResponseBodyUserGroupInfo() {}

  explicit GetUserGroupResponseBodyUserGroupInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (myRole) {
      res["MyRole"] = boost::any(*myRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<GetUserGroupResponseBodyUserGroupInfoAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserGroupResponseBodyUserGroupInfoAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<GetUserGroupResponseBodyUserGroupInfoAdminList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MyRole") != m.end() && !m["MyRole"].empty()) {
      myRole = make_shared<string>(boost::any_cast<string>(m["MyRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~GetUserGroupResponseBodyUserGroupInfo() = default;
};
class GetUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<GetUserGroupResponseBodyUserGroupInfo> userGroupInfo{};

  GetUserGroupResponseBody() {}

  explicit GetUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userGroupInfo) {
      res["UserGroupInfo"] = userGroupInfo ? boost::any(userGroupInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserGroupInfo") != m.end() && !m["UserGroupInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserGroupInfo"].type()) {
        GetUserGroupResponseBodyUserGroupInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserGroupInfo"]));
        userGroupInfo = make_shared<GetUserGroupResponseBodyUserGroupInfo>(model1);
      }
    }
  }


  virtual ~GetUserGroupResponseBody() = default;
};
class GetUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserGroupResponseBody> body{};

  GetUserGroupResponse() {}

  explicit GetUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserGroupResponse() = default;
};
class GetUsersRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<vector<string>> userIdList{};

  GetUsersRequest() {}

  explicit GetUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetUsersRequest() = default;
};
class GetUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> userIdListShrink{};

  GetUsersShrinkRequest() {}

  explicit GetUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (userIdListShrink) {
      res["UserIdList"] = boost::any(*userIdListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdListShrink = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~GetUsersShrinkRequest() = default;
};
class GetUsersResponseBodyUserList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> dingNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameWithoutStatus{};
  shared_ptr<string> enableWhiteIp{};
  shared_ptr<string> feiShuRobot{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> mail{};
  shared_ptr<string> mobilePhone{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> realName{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> weChatRobot{};
  shared_ptr<string> whiteIp{};

  GetUsersResponseBodyUserList() {}

  explicit GetUsersResponseBodyUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (dingNumber) {
      res["DingNumber"] = boost::any(*dingNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameWithoutStatus) {
      res["DisplayNameWithoutStatus"] = boost::any(*displayNameWithoutStatus);
    }
    if (enableWhiteIp) {
      res["EnableWhiteIp"] = boost::any(*enableWhiteIp);
    }
    if (feiShuRobot) {
      res["FeiShuRobot"] = boost::any(*feiShuRobot);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (mobilePhone) {
      res["MobilePhone"] = boost::any(*mobilePhone);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (realName) {
      res["RealName"] = boost::any(*realName);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (weChatRobot) {
      res["WeChatRobot"] = boost::any(*weChatRobot);
    }
    if (whiteIp) {
      res["WhiteIp"] = boost::any(*whiteIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DingNumber") != m.end() && !m["DingNumber"].empty()) {
      dingNumber = make_shared<string>(boost::any_cast<string>(m["DingNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameWithoutStatus") != m.end() && !m["DisplayNameWithoutStatus"].empty()) {
      displayNameWithoutStatus = make_shared<string>(boost::any_cast<string>(m["DisplayNameWithoutStatus"]));
    }
    if (m.find("EnableWhiteIp") != m.end() && !m["EnableWhiteIp"].empty()) {
      enableWhiteIp = make_shared<string>(boost::any_cast<string>(m["EnableWhiteIp"]));
    }
    if (m.find("FeiShuRobot") != m.end() && !m["FeiShuRobot"].empty()) {
      feiShuRobot = make_shared<string>(boost::any_cast<string>(m["FeiShuRobot"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("MobilePhone") != m.end() && !m["MobilePhone"].empty()) {
      mobilePhone = make_shared<string>(boost::any_cast<string>(m["MobilePhone"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("RealName") != m.end() && !m["RealName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["RealName"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("WeChatRobot") != m.end() && !m["WeChatRobot"].empty()) {
      weChatRobot = make_shared<string>(boost::any_cast<string>(m["WeChatRobot"]));
    }
    if (m.find("WhiteIp") != m.end() && !m["WhiteIp"].empty()) {
      whiteIp = make_shared<string>(boost::any_cast<string>(m["WhiteIp"]));
    }
  }


  virtual ~GetUsersResponseBodyUserList() = default;
};
class GetUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<vector<GetUsersResponseBodyUserList>> userList{};

  GetUsersResponseBody() {}

  explicit GetUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<GetUsersResponseBodyUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUsersResponseBodyUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<GetUsersResponseBodyUserList>>(expect1);
      }
    }
  }


  virtual ~GetUsersResponseBody() = default;
};
class GetUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUsersResponseBody> body{};

  GetUsersResponse() {}

  explicit GetUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUsersResponseBody>(model1);
      }
    }
  }


  virtual ~GetUsersResponse() = default;
};
class GrantResourcePermissionRequestGrantCommandResourceList : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};

  GrantResourcePermissionRequestGrantCommandResourceList() {}

  explicit GrantResourcePermissionRequestGrantCommandResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~GrantResourcePermissionRequestGrantCommandResourceList() = default;
};
class GrantResourcePermissionRequestGrantCommand : public Darabonba::Model {
public:
  shared_ptr<string> effectiveEnd{};
  shared_ptr<vector<string>> operateList{};
  shared_ptr<string> reason{};
  shared_ptr<vector<GrantResourcePermissionRequestGrantCommandResourceList>> resourceList{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> userIdList{};

  GrantResourcePermissionRequestGrantCommand() {}

  explicit GrantResourcePermissionRequestGrantCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveEnd) {
      res["EffectiveEnd"] = boost::any(*effectiveEnd);
    }
    if (operateList) {
      res["OperateList"] = boost::any(*operateList);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveEnd") != m.end() && !m["EffectiveEnd"].empty()) {
      effectiveEnd = make_shared<string>(boost::any_cast<string>(m["EffectiveEnd"]));
    }
    if (m.find("OperateList") != m.end() && !m["OperateList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperateList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperateList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operateList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<GrantResourcePermissionRequestGrantCommandResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GrantResourcePermissionRequestGrantCommandResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<GrantResourcePermissionRequestGrantCommandResourceList>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GrantResourcePermissionRequestGrantCommand() = default;
};
class GrantResourcePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<GrantResourcePermissionRequestGrantCommand> grantCommand{};
  shared_ptr<long> opTenantId{};

  GrantResourcePermissionRequest() {}

  explicit GrantResourcePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantCommand) {
      res["GrantCommand"] = grantCommand ? boost::any(grantCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantCommand") != m.end() && !m["GrantCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["GrantCommand"].type()) {
        GrantResourcePermissionRequestGrantCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GrantCommand"]));
        grantCommand = make_shared<GrantResourcePermissionRequestGrantCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GrantResourcePermissionRequest() = default;
};
class GrantResourcePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> grantCommandShrink{};
  shared_ptr<long> opTenantId{};

  GrantResourcePermissionShrinkRequest() {}

  explicit GrantResourcePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantCommandShrink) {
      res["GrantCommand"] = boost::any(*grantCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantCommand") != m.end() && !m["GrantCommand"].empty()) {
      grantCommandShrink = make_shared<string>(boost::any_cast<string>(m["GrantCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~GrantResourcePermissionShrinkRequest() = default;
};
class GrantResourcePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GrantResourcePermissionResponseBody() {}

  explicit GrantResourcePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GrantResourcePermissionResponseBody() = default;
};
class GrantResourcePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GrantResourcePermissionResponseBody> body{};

  GrantResourcePermissionResponse() {}

  explicit GrantResourcePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantResourcePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantResourcePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~GrantResourcePermissionResponse() = default;
};
class ListAddableRolesRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};

  ListAddableRolesRequest() {}

  explicit ListAddableRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAddableRolesRequest() = default;
};
class ListAddableRolesResponseBodyRoleList : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};

  ListAddableRolesResponseBodyRoleList() {}

  explicit ListAddableRolesResponseBodyRoleList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAddableRolesResponseBodyRoleList() = default;
};
class ListAddableRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAddableRolesResponseBodyRoleList>> roleList{};
  shared_ptr<bool> success{};

  ListAddableRolesResponseBody() {}

  explicit ListAddableRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (roleList) {
      vector<boost::any> temp1;
      for(auto item1:*roleList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RoleList"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<ListAddableRolesResponseBodyRoleList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RoleList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddableRolesResponseBodyRoleList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roleList = make_shared<vector<ListAddableRolesResponseBodyRoleList>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAddableRolesResponseBody() = default;
};
class ListAddableRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAddableRolesResponseBody> body{};

  ListAddableRolesResponse() {}

  explicit ListAddableRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAddableRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAddableRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAddableRolesResponse() = default;
};
class ListAddableUsersRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchText{};

  ListAddableUsersRequestListQuery() {}

  explicit ListAddableUsersRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListAddableUsersRequestListQuery() = default;
};
class ListAddableUsersRequest : public Darabonba::Model {
public:
  shared_ptr<ListAddableUsersRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListAddableUsersRequest() {}

  explicit ListAddableUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListAddableUsersRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListAddableUsersRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAddableUsersRequest() = default;
};
class ListAddableUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListAddableUsersShrinkRequest() {}

  explicit ListAddableUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAddableUsersShrinkRequest() = default;
};
class ListAddableUsersResponseBodyPageResultUserList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> dingNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameWithoutStatus{};
  shared_ptr<string> enableWhiteIp{};
  shared_ptr<string> feiShuRobot{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> mail{};
  shared_ptr<string> mobilePhone{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> parentId{};
  shared_ptr<string> realName{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> weChatRobot{};
  shared_ptr<string> whiteIp{};

  ListAddableUsersResponseBodyPageResultUserList() {}

  explicit ListAddableUsersResponseBodyPageResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (dingNumber) {
      res["DingNumber"] = boost::any(*dingNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameWithoutStatus) {
      res["DisplayNameWithoutStatus"] = boost::any(*displayNameWithoutStatus);
    }
    if (enableWhiteIp) {
      res["EnableWhiteIp"] = boost::any(*enableWhiteIp);
    }
    if (feiShuRobot) {
      res["FeiShuRobot"] = boost::any(*feiShuRobot);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (mobilePhone) {
      res["MobilePhone"] = boost::any(*mobilePhone);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (realName) {
      res["RealName"] = boost::any(*realName);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (weChatRobot) {
      res["WeChatRobot"] = boost::any(*weChatRobot);
    }
    if (whiteIp) {
      res["WhiteIp"] = boost::any(*whiteIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DingNumber") != m.end() && !m["DingNumber"].empty()) {
      dingNumber = make_shared<string>(boost::any_cast<string>(m["DingNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameWithoutStatus") != m.end() && !m["DisplayNameWithoutStatus"].empty()) {
      displayNameWithoutStatus = make_shared<string>(boost::any_cast<string>(m["DisplayNameWithoutStatus"]));
    }
    if (m.find("EnableWhiteIp") != m.end() && !m["EnableWhiteIp"].empty()) {
      enableWhiteIp = make_shared<string>(boost::any_cast<string>(m["EnableWhiteIp"]));
    }
    if (m.find("FeiShuRobot") != m.end() && !m["FeiShuRobot"].empty()) {
      feiShuRobot = make_shared<string>(boost::any_cast<string>(m["FeiShuRobot"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("MobilePhone") != m.end() && !m["MobilePhone"].empty()) {
      mobilePhone = make_shared<string>(boost::any_cast<string>(m["MobilePhone"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<string>(boost::any_cast<string>(m["ParentId"]));
    }
    if (m.find("RealName") != m.end() && !m["RealName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["RealName"]));
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("WeChatRobot") != m.end() && !m["WeChatRobot"].empty()) {
      weChatRobot = make_shared<string>(boost::any_cast<string>(m["WeChatRobot"]));
    }
    if (m.find("WhiteIp") != m.end() && !m["WhiteIp"].empty()) {
      whiteIp = make_shared<string>(boost::any_cast<string>(m["WhiteIp"]));
    }
  }


  virtual ~ListAddableUsersResponseBodyPageResultUserList() = default;
};
class ListAddableUsersResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListAddableUsersResponseBodyPageResultUserList>> userList{};

  ListAddableUsersResponseBodyPageResult() {}

  explicit ListAddableUsersResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListAddableUsersResponseBodyPageResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAddableUsersResponseBodyPageResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListAddableUsersResponseBodyPageResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListAddableUsersResponseBodyPageResult() = default;
};
class ListAddableUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListAddableUsersResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAddableUsersResponseBody() {}

  explicit ListAddableUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListAddableUsersResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListAddableUsersResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAddableUsersResponseBody() = default;
};
class ListAddableUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAddableUsersResponseBody> body{};

  ListAddableUsersResponse() {}

  explicit ListAddableUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAddableUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAddableUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListAddableUsersResponse() = default;
};
class ListAlertEventsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> alertEndTime{};
  shared_ptr<vector<string>> alertObjectTypeList{};
  shared_ptr<vector<string>> alertReasonList{};
  shared_ptr<string> alertStartTime{};
  shared_ptr<vector<string>> bizNameList{};
  shared_ptr<string> keyword{};
  shared_ptr<vector<string>> monitoredItemIdList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> projectNameList{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<string>> userIdList{};

  ListAlertEventsRequestListQuery() {}

  explicit ListAlertEventsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertEndTime) {
      res["AlertEndTime"] = boost::any(*alertEndTime);
    }
    if (alertObjectTypeList) {
      res["AlertObjectTypeList"] = boost::any(*alertObjectTypeList);
    }
    if (alertReasonList) {
      res["AlertReasonList"] = boost::any(*alertReasonList);
    }
    if (alertStartTime) {
      res["AlertStartTime"] = boost::any(*alertStartTime);
    }
    if (bizNameList) {
      res["BizNameList"] = boost::any(*bizNameList);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (monitoredItemIdList) {
      res["MonitoredItemIdList"] = boost::any(*monitoredItemIdList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectNameList) {
      res["ProjectNameList"] = boost::any(*projectNameList);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertEndTime") != m.end() && !m["AlertEndTime"].empty()) {
      alertEndTime = make_shared<string>(boost::any_cast<string>(m["AlertEndTime"]));
    }
    if (m.find("AlertObjectTypeList") != m.end() && !m["AlertObjectTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertObjectTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertObjectTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertObjectTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertReasonList") != m.end() && !m["AlertReasonList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertReasonList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertReasonList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertReasonList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AlertStartTime") != m.end() && !m["AlertStartTime"].empty()) {
      alertStartTime = make_shared<string>(boost::any_cast<string>(m["AlertStartTime"]));
    }
    if (m.find("BizNameList") != m.end() && !m["BizNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BizNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bizNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MonitoredItemIdList") != m.end() && !m["MonitoredItemIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MonitoredItemIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MonitoredItemIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      monitoredItemIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectNameList") != m.end() && !m["ProjectNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      projectNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAlertEventsRequestListQuery() = default;
};
class ListAlertEventsRequest : public Darabonba::Model {
public:
  shared_ptr<ListAlertEventsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListAlertEventsRequest() {}

  explicit ListAlertEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListAlertEventsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListAlertEventsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAlertEventsRequest() = default;
};
class ListAlertEventsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListAlertEventsShrinkRequest() {}

  explicit ListAlertEventsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAlertEventsShrinkRequest() = default;
};
class ListAlertEventsResponseBodyListResultDataAlertObject : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> sourceSystemType{};
  shared_ptr<string> type{};

  ListAlertEventsResponseBodyListResultDataAlertObject() {}

  explicit ListAlertEventsResponseBodyListResultDataAlertObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceSystemType) {
      res["SourceSystemType"] = boost::any(*sourceSystemType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceSystemType") != m.end() && !m["SourceSystemType"].empty()) {
      sourceSystemType = make_shared<string>(boost::any_cast<string>(m["SourceSystemType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataAlertObject() = default;
};
class ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList() {}

  explicit ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList() = default;
};
class ListAlertEventsResponseBodyListResultDataAlertReason : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList>> alertReasonParamList{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> type{};
  shared_ptr<string> uniqueKey{};

  ListAlertEventsResponseBodyListResultDataAlertReason() {}

  explicit ListAlertEventsResponseBodyListResultDataAlertReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertReasonParamList) {
      vector<boost::any> temp1;
      for(auto item1:*alertReasonParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertReasonParamList"] = boost::any(temp1);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertReasonParamList") != m.end() && !m["AlertReasonParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertReasonParamList"].type()) {
        vector<ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertReasonParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertReasonParamList = make_shared<vector<ListAlertEventsResponseBodyListResultDataAlertReasonAlertReasonParamList>>(expect1);
      }
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataAlertReason() = default;
};
class ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList() {}

  explicit ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList() = default;
};
class ListAlertEventsResponseBodyListResultDataAlertReceiverList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alertChannelTypeList{};
  shared_ptr<vector<string>> customAlertChannelIdList{};
  shared_ptr<string> onCallTableName{};
  shared_ptr<string> type{};
  shared_ptr<vector<ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList>> userList{};

  ListAlertEventsResponseBodyListResultDataAlertReceiverList() {}

  explicit ListAlertEventsResponseBodyListResultDataAlertReceiverList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertChannelTypeList) {
      res["AlertChannelTypeList"] = boost::any(*alertChannelTypeList);
    }
    if (customAlertChannelIdList) {
      res["CustomAlertChannelIdList"] = boost::any(*customAlertChannelIdList);
    }
    if (onCallTableName) {
      res["OnCallTableName"] = boost::any(*onCallTableName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertChannelTypeList") != m.end() && !m["AlertChannelTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertChannelTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertChannelTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertChannelTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomAlertChannelIdList") != m.end() && !m["CustomAlertChannelIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomAlertChannelIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomAlertChannelIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customAlertChannelIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OnCallTableName") != m.end() && !m["OnCallTableName"].empty()) {
      onCallTableName = make_shared<string>(boost::any_cast<string>(m["OnCallTableName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListAlertEventsResponseBodyListResultDataAlertReceiverListUserList>>(expect1);
      }
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataAlertReceiverList() = default;
};
class ListAlertEventsResponseBodyListResultDataBelongProject : public Darabonba::Model {
public:
  shared_ptr<string> bizName{};
  shared_ptr<string> projectName{};

  ListAlertEventsResponseBodyListResultDataBelongProject() {}

  explicit ListAlertEventsResponseBodyListResultDataBelongProject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizName) {
      res["BizName"] = boost::any(*bizName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizName") != m.end() && !m["BizName"].empty()) {
      bizName = make_shared<string>(boost::any_cast<string>(m["BizName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataBelongProject() = default;
};
class ListAlertEventsResponseBodyListResultDataUrlConfig : public Darabonba::Model {
public:
  shared_ptr<string> alertConfigUrl{};
  shared_ptr<string> logUrl{};
  shared_ptr<string> objectUrl{};

  ListAlertEventsResponseBodyListResultDataUrlConfig() {}

  explicit ListAlertEventsResponseBodyListResultDataUrlConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertConfigUrl) {
      res["AlertConfigUrl"] = boost::any(*alertConfigUrl);
    }
    if (logUrl) {
      res["LogUrl"] = boost::any(*logUrl);
    }
    if (objectUrl) {
      res["ObjectUrl"] = boost::any(*objectUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertConfigUrl") != m.end() && !m["AlertConfigUrl"].empty()) {
      alertConfigUrl = make_shared<string>(boost::any_cast<string>(m["AlertConfigUrl"]));
    }
    if (m.find("LogUrl") != m.end() && !m["LogUrl"].empty()) {
      logUrl = make_shared<string>(boost::any_cast<string>(m["LogUrl"]));
    }
    if (m.find("ObjectUrl") != m.end() && !m["ObjectUrl"].empty()) {
      objectUrl = make_shared<string>(boost::any_cast<string>(m["ObjectUrl"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultDataUrlConfig() = default;
};
class ListAlertEventsResponseBodyListResultData : public Darabonba::Model {
public:
  shared_ptr<string> alertFrequency{};
  shared_ptr<ListAlertEventsResponseBodyListResultDataAlertObject> alertObject{};
  shared_ptr<ListAlertEventsResponseBodyListResultDataAlertReason> alertReason{};
  shared_ptr<vector<ListAlertEventsResponseBodyListResultDataAlertReceiverList>> alertReceiverList{};
  shared_ptr<ListAlertEventsResponseBodyListResultDataBelongProject> belongProject{};
  shared_ptr<string> doNotDisturbEndTime{};
  shared_ptr<string> firstAlertTime{};
  shared_ptr<string> id{};
  shared_ptr<string> latestAlertTime{};
  shared_ptr<string> status{};
  shared_ptr<long> totalAlertTimes{};
  shared_ptr<ListAlertEventsResponseBodyListResultDataUrlConfig> urlConfig{};

  ListAlertEventsResponseBodyListResultData() {}

  explicit ListAlertEventsResponseBodyListResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertFrequency) {
      res["AlertFrequency"] = boost::any(*alertFrequency);
    }
    if (alertObject) {
      res["AlertObject"] = alertObject ? boost::any(alertObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReason) {
      res["AlertReason"] = alertReason ? boost::any(alertReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReceiverList) {
      vector<boost::any> temp1;
      for(auto item1:*alertReceiverList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertReceiverList"] = boost::any(temp1);
    }
    if (belongProject) {
      res["BelongProject"] = belongProject ? boost::any(belongProject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (doNotDisturbEndTime) {
      res["DoNotDisturbEndTime"] = boost::any(*doNotDisturbEndTime);
    }
    if (firstAlertTime) {
      res["FirstAlertTime"] = boost::any(*firstAlertTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (latestAlertTime) {
      res["LatestAlertTime"] = boost::any(*latestAlertTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalAlertTimes) {
      res["TotalAlertTimes"] = boost::any(*totalAlertTimes);
    }
    if (urlConfig) {
      res["UrlConfig"] = urlConfig ? boost::any(urlConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertFrequency") != m.end() && !m["AlertFrequency"].empty()) {
      alertFrequency = make_shared<string>(boost::any_cast<string>(m["AlertFrequency"]));
    }
    if (m.find("AlertObject") != m.end() && !m["AlertObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertObject"].type()) {
        ListAlertEventsResponseBodyListResultDataAlertObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertObject"]));
        alertObject = make_shared<ListAlertEventsResponseBodyListResultDataAlertObject>(model1);
      }
    }
    if (m.find("AlertReason") != m.end() && !m["AlertReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertReason"].type()) {
        ListAlertEventsResponseBodyListResultDataAlertReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertReason"]));
        alertReason = make_shared<ListAlertEventsResponseBodyListResultDataAlertReason>(model1);
      }
    }
    if (m.find("AlertReceiverList") != m.end() && !m["AlertReceiverList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertReceiverList"].type()) {
        vector<ListAlertEventsResponseBodyListResultDataAlertReceiverList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertReceiverList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyListResultDataAlertReceiverList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertReceiverList = make_shared<vector<ListAlertEventsResponseBodyListResultDataAlertReceiverList>>(expect1);
      }
    }
    if (m.find("BelongProject") != m.end() && !m["BelongProject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BelongProject"].type()) {
        ListAlertEventsResponseBodyListResultDataBelongProject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BelongProject"]));
        belongProject = make_shared<ListAlertEventsResponseBodyListResultDataBelongProject>(model1);
      }
    }
    if (m.find("DoNotDisturbEndTime") != m.end() && !m["DoNotDisturbEndTime"].empty()) {
      doNotDisturbEndTime = make_shared<string>(boost::any_cast<string>(m["DoNotDisturbEndTime"]));
    }
    if (m.find("FirstAlertTime") != m.end() && !m["FirstAlertTime"].empty()) {
      firstAlertTime = make_shared<string>(boost::any_cast<string>(m["FirstAlertTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LatestAlertTime") != m.end() && !m["LatestAlertTime"].empty()) {
      latestAlertTime = make_shared<string>(boost::any_cast<string>(m["LatestAlertTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalAlertTimes") != m.end() && !m["TotalAlertTimes"].empty()) {
      totalAlertTimes = make_shared<long>(boost::any_cast<long>(m["TotalAlertTimes"]));
    }
    if (m.find("UrlConfig") != m.end() && !m["UrlConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["UrlConfig"].type()) {
        ListAlertEventsResponseBodyListResultDataUrlConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UrlConfig"]));
        urlConfig = make_shared<ListAlertEventsResponseBodyListResultDataUrlConfig>(model1);
      }
    }
  }


  virtual ~ListAlertEventsResponseBodyListResultData() = default;
};
class ListAlertEventsResponseBodyListResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertEventsResponseBodyListResultData>> data{};
  shared_ptr<long> totalCount{};

  ListAlertEventsResponseBodyListResult() {}

  explicit ListAlertEventsResponseBodyListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAlertEventsResponseBodyListResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertEventsResponseBodyListResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAlertEventsResponseBodyListResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlertEventsResponseBodyListResult() = default;
};
class ListAlertEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListAlertEventsResponseBodyListResult> listResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAlertEventsResponseBody() {}

  explicit ListAlertEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (listResult) {
      res["ListResult"] = listResult ? boost::any(listResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ListResult") != m.end() && !m["ListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListResult"].type()) {
        ListAlertEventsResponseBodyListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListResult"]));
        listResult = make_shared<ListAlertEventsResponseBodyListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAlertEventsResponseBody() = default;
};
class ListAlertEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertEventsResponseBody> body{};

  ListAlertEventsResponse() {}

  explicit ListAlertEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertEventsResponse() = default;
};
class ListAlertNotificationsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<vector<string>> alertReasonList{};
  shared_ptr<vector<string>> channelTypeList{};
  shared_ptr<vector<string>> customChannelIdList{};
  shared_ptr<string> keyword{};
  shared_ptr<vector<string>> monitoredItemIdList{};
  shared_ptr<string> notifyEndTime{};
  shared_ptr<string> notifyStartTime{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceSystem{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<string>> userIdList{};

  ListAlertNotificationsRequestListQuery() {}

  explicit ListAlertNotificationsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertReasonList) {
      res["AlertReasonList"] = boost::any(*alertReasonList);
    }
    if (channelTypeList) {
      res["ChannelTypeList"] = boost::any(*channelTypeList);
    }
    if (customChannelIdList) {
      res["CustomChannelIdList"] = boost::any(*customChannelIdList);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (monitoredItemIdList) {
      res["MonitoredItemIdList"] = boost::any(*monitoredItemIdList);
    }
    if (notifyEndTime) {
      res["NotifyEndTime"] = boost::any(*notifyEndTime);
    }
    if (notifyStartTime) {
      res["NotifyStartTime"] = boost::any(*notifyStartTime);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceSystem) {
      res["SourceSystem"] = boost::any(*sourceSystem);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertReasonList") != m.end() && !m["AlertReasonList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AlertReasonList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AlertReasonList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      alertReasonList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ChannelTypeList") != m.end() && !m["ChannelTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CustomChannelIdList") != m.end() && !m["CustomChannelIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["CustomChannelIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomChannelIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      customChannelIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("MonitoredItemIdList") != m.end() && !m["MonitoredItemIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MonitoredItemIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MonitoredItemIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      monitoredItemIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NotifyEndTime") != m.end() && !m["NotifyEndTime"].empty()) {
      notifyEndTime = make_shared<string>(boost::any_cast<string>(m["NotifyEndTime"]));
    }
    if (m.find("NotifyStartTime") != m.end() && !m["NotifyStartTime"].empty()) {
      notifyStartTime = make_shared<string>(boost::any_cast<string>(m["NotifyStartTime"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceSystem") != m.end() && !m["SourceSystem"].empty()) {
      sourceSystem = make_shared<string>(boost::any_cast<string>(m["SourceSystem"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListAlertNotificationsRequestListQuery() = default;
};
class ListAlertNotificationsRequest : public Darabonba::Model {
public:
  shared_ptr<ListAlertNotificationsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListAlertNotificationsRequest() {}

  explicit ListAlertNotificationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListAlertNotificationsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListAlertNotificationsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAlertNotificationsRequest() = default;
};
class ListAlertNotificationsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListAlertNotificationsShrinkRequest() {}

  explicit ListAlertNotificationsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAlertNotificationsShrinkRequest() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertObject : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> sourceSystemType{};
  shared_ptr<string> type{};

  ListAlertNotificationsResponseBodyListResultDataAlertObject() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceSystemType) {
      res["SourceSystemType"] = boost::any(*sourceSystemType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceSystemType") != m.end() && !m["SourceSystemType"].empty()) {
      sourceSystemType = make_shared<string>(boost::any_cast<string>(m["SourceSystemType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertObject() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertReason : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList>> alertReasonParamList{};
  shared_ptr<string> bizDate{};
  shared_ptr<string> type{};
  shared_ptr<string> uniqueKey{};

  ListAlertNotificationsResponseBodyListResultDataAlertReason() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertReason(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertReasonParamList) {
      vector<boost::any> temp1;
      for(auto item1:*alertReasonParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AlertReasonParamList"] = boost::any(temp1);
    }
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (uniqueKey) {
      res["UniqueKey"] = boost::any(*uniqueKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertReasonParamList") != m.end() && !m["AlertReasonParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["AlertReasonParamList"].type()) {
        vector<ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AlertReasonParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        alertReasonParamList = make_shared<vector<ListAlertNotificationsResponseBodyListResultDataAlertReasonAlertReasonParamList>>(expect1);
      }
    }
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UniqueKey") != m.end() && !m["UniqueKey"].empty()) {
      uniqueKey = make_shared<string>(boost::any_cast<string>(m["UniqueKey"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertReason() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertReceiver : public Darabonba::Model {
public:
  shared_ptr<string> alertChannelType{};
  shared_ptr<string> customAlertChannelId{};
  shared_ptr<string> onCallTableId{};
  shared_ptr<string> onCallTableName{};
  shared_ptr<string> type{};
  shared_ptr<ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser> user{};

  ListAlertNotificationsResponseBodyListResultDataAlertReceiver() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertReceiver(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertChannelType) {
      res["AlertChannelType"] = boost::any(*alertChannelType);
    }
    if (customAlertChannelId) {
      res["CustomAlertChannelId"] = boost::any(*customAlertChannelId);
    }
    if (onCallTableId) {
      res["OnCallTableId"] = boost::any(*onCallTableId);
    }
    if (onCallTableName) {
      res["OnCallTableName"] = boost::any(*onCallTableName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertChannelType") != m.end() && !m["AlertChannelType"].empty()) {
      alertChannelType = make_shared<string>(boost::any_cast<string>(m["AlertChannelType"]));
    }
    if (m.find("CustomAlertChannelId") != m.end() && !m["CustomAlertChannelId"].empty()) {
      customAlertChannelId = make_shared<string>(boost::any_cast<string>(m["CustomAlertChannelId"]));
    }
    if (m.find("OnCallTableId") != m.end() && !m["OnCallTableId"].empty()) {
      onCallTableId = make_shared<string>(boost::any_cast<string>(m["OnCallTableId"]));
    }
    if (m.find("OnCallTableName") != m.end() && !m["OnCallTableName"].empty()) {
      onCallTableName = make_shared<string>(boost::any_cast<string>(m["OnCallTableName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<ListAlertNotificationsResponseBodyListResultDataAlertReceiverUser>(model1);
      }
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertReceiver() = default;
};
class ListAlertNotificationsResponseBodyListResultDataAlertSend : public Darabonba::Model {
public:
  shared_ptr<string> failReason{};
  shared_ptr<string> sendContent{};
  shared_ptr<string> sendTime{};
  shared_ptr<string> status{};

  ListAlertNotificationsResponseBodyListResultDataAlertSend() {}

  explicit ListAlertNotificationsResponseBodyListResultDataAlertSend(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failReason) {
      res["FailReason"] = boost::any(*failReason);
    }
    if (sendContent) {
      res["SendContent"] = boost::any(*sendContent);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailReason") != m.end() && !m["FailReason"].empty()) {
      failReason = make_shared<string>(boost::any_cast<string>(m["FailReason"]));
    }
    if (m.find("SendContent") != m.end() && !m["SendContent"].empty()) {
      sendContent = make_shared<string>(boost::any_cast<string>(m["SendContent"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<string>(boost::any_cast<string>(m["SendTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultDataAlertSend() = default;
};
class ListAlertNotificationsResponseBodyListResultData : public Darabonba::Model {
public:
  shared_ptr<string> alertEventId{};
  shared_ptr<ListAlertNotificationsResponseBodyListResultDataAlertObject> alertObject{};
  shared_ptr<ListAlertNotificationsResponseBodyListResultDataAlertReason> alertReason{};
  shared_ptr<ListAlertNotificationsResponseBodyListResultDataAlertReceiver> alertReceiver{};
  shared_ptr<ListAlertNotificationsResponseBodyListResultDataAlertSend> alertSend{};

  ListAlertNotificationsResponseBodyListResultData() {}

  explicit ListAlertNotificationsResponseBodyListResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertEventId) {
      res["AlertEventId"] = boost::any(*alertEventId);
    }
    if (alertObject) {
      res["AlertObject"] = alertObject ? boost::any(alertObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReason) {
      res["AlertReason"] = alertReason ? boost::any(alertReason->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertReceiver) {
      res["AlertReceiver"] = alertReceiver ? boost::any(alertReceiver->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (alertSend) {
      res["AlertSend"] = alertSend ? boost::any(alertSend->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlertEventId") != m.end() && !m["AlertEventId"].empty()) {
      alertEventId = make_shared<string>(boost::any_cast<string>(m["AlertEventId"]));
    }
    if (m.find("AlertObject") != m.end() && !m["AlertObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertObject"].type()) {
        ListAlertNotificationsResponseBodyListResultDataAlertObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertObject"]));
        alertObject = make_shared<ListAlertNotificationsResponseBodyListResultDataAlertObject>(model1);
      }
    }
    if (m.find("AlertReason") != m.end() && !m["AlertReason"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertReason"].type()) {
        ListAlertNotificationsResponseBodyListResultDataAlertReason model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertReason"]));
        alertReason = make_shared<ListAlertNotificationsResponseBodyListResultDataAlertReason>(model1);
      }
    }
    if (m.find("AlertReceiver") != m.end() && !m["AlertReceiver"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertReceiver"].type()) {
        ListAlertNotificationsResponseBodyListResultDataAlertReceiver model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertReceiver"]));
        alertReceiver = make_shared<ListAlertNotificationsResponseBodyListResultDataAlertReceiver>(model1);
      }
    }
    if (m.find("AlertSend") != m.end() && !m["AlertSend"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlertSend"].type()) {
        ListAlertNotificationsResponseBodyListResultDataAlertSend model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlertSend"]));
        alertSend = make_shared<ListAlertNotificationsResponseBodyListResultDataAlertSend>(model1);
      }
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResultData() = default;
};
class ListAlertNotificationsResponseBodyListResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertNotificationsResponseBodyListResultData>> data{};
  shared_ptr<long> totalCount{};

  ListAlertNotificationsResponseBodyListResult() {}

  explicit ListAlertNotificationsResponseBodyListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAlertNotificationsResponseBodyListResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertNotificationsResponseBodyListResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAlertNotificationsResponseBodyListResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBodyListResult() = default;
};
class ListAlertNotificationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListAlertNotificationsResponseBodyListResult> listResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAlertNotificationsResponseBody() {}

  explicit ListAlertNotificationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (listResult) {
      res["ListResult"] = listResult ? boost::any(listResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ListResult") != m.end() && !m["ListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListResult"].type()) {
        ListAlertNotificationsResponseBodyListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListResult"]));
        listResult = make_shared<ListAlertNotificationsResponseBodyListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAlertNotificationsResponseBody() = default;
};
class ListAlertNotificationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertNotificationsResponseBody> body{};

  ListAlertNotificationsResponse() {}

  explicit ListAlertNotificationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertNotificationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertNotificationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertNotificationsResponse() = default;
};
class ListApiByAppRequestPageQuery : public Darabonba::Model {
public:
  shared_ptr<long> appKey{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListApiByAppRequestPageQuery() {}

  explicit ListApiByAppRequestPageQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<long>(boost::any_cast<long>(m["AppKey"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListApiByAppRequestPageQuery() = default;
};
class ListApiByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<ListApiByAppRequestPageQuery> pageQuery{};

  ListApiByAppRequest() {}

  explicit ListApiByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pageQuery) {
      res["PageQuery"] = pageQuery ? boost::any(pageQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PageQuery") != m.end() && !m["PageQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageQuery"].type()) {
        ListApiByAppRequestPageQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageQuery"]));
        pageQuery = make_shared<ListApiByAppRequestPageQuery>(model1);
      }
    }
  }


  virtual ~ListApiByAppRequest() = default;
};
class ListApiByAppShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> pageQueryShrink{};

  ListApiByAppShrinkRequest() {}

  explicit ListApiByAppShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pageQueryShrink) {
      res["PageQuery"] = boost::any(*pageQueryShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PageQuery") != m.end() && !m["PageQuery"].empty()) {
      pageQueryShrink = make_shared<string>(boost::any_cast<string>(m["PageQuery"]));
    }
  }


  virtual ~ListApiByAppShrinkRequest() = default;
};
class ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList : public Darabonba::Model {
public:
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<long> datasourceType{};
  shared_ptr<string> datasourceUrl{};
  shared_ptr<string> tableName{};

  ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList() {}

  explicit ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceId) {
      res["DatasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (datasourceType) {
      res["DatasourceType"] = boost::any(*datasourceType);
    }
    if (datasourceUrl) {
      res["DatasourceUrl"] = boost::any(*datasourceUrl);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasourceId") != m.end() && !m["DatasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["DatasourceId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("DatasourceType") != m.end() && !m["DatasourceType"].empty()) {
      datasourceType = make_shared<long>(boost::any_cast<long>(m["DatasourceType"]));
    }
    if (m.find("DatasourceUrl") != m.end() && !m["DatasourceUrl"].empty()) {
      datasourceUrl = make_shared<string>(boost::any_cast<string>(m["DatasourceUrl"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList() = default;
};
class ListApiByAppResponseBodyListResultDataPublicParamList : public Darabonba::Model {
public:
  shared_ptr<string> dateFormat{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> descriptionCode{};
  shared_ptr<long> id{};
  shared_ptr<string> initialValue{};
  shared_ptr<string> mappingColumn{};
  shared_ptr<long> must{};
  shared_ptr<string> operator_{};
  shared_ptr<long> optional{};
  shared_ptr<string> originalColumn{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};
  shared_ptr<string> parameterLocation{};
  shared_ptr<string> sample{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList>> tableAndDsList{};

  ListApiByAppResponseBodyListResultDataPublicParamList() {}

  explicit ListApiByAppResponseBodyListResultDataPublicParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (descriptionCode) {
      res["DescriptionCode"] = boost::any(*descriptionCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initialValue) {
      res["InitialValue"] = boost::any(*initialValue);
    }
    if (mappingColumn) {
      res["MappingColumn"] = boost::any(*mappingColumn);
    }
    if (must) {
      res["Must"] = boost::any(*must);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (originalColumn) {
      res["OriginalColumn"] = boost::any(*originalColumn);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (parameterLocation) {
      res["ParameterLocation"] = boost::any(*parameterLocation);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (tableAndDsList) {
      vector<boost::any> temp1;
      for(auto item1:*tableAndDsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableAndDsList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DescriptionCode") != m.end() && !m["DescriptionCode"].empty()) {
      descriptionCode = make_shared<string>(boost::any_cast<string>(m["DescriptionCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InitialValue") != m.end() && !m["InitialValue"].empty()) {
      initialValue = make_shared<string>(boost::any_cast<string>(m["InitialValue"]));
    }
    if (m.find("MappingColumn") != m.end() && !m["MappingColumn"].empty()) {
      mappingColumn = make_shared<string>(boost::any_cast<string>(m["MappingColumn"]));
    }
    if (m.find("Must") != m.end() && !m["Must"].empty()) {
      must = make_shared<long>(boost::any_cast<long>(m["Must"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("OriginalColumn") != m.end() && !m["OriginalColumn"].empty()) {
      originalColumn = make_shared<string>(boost::any_cast<string>(m["OriginalColumn"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ParameterLocation") != m.end() && !m["ParameterLocation"].empty()) {
      parameterLocation = make_shared<string>(boost::any_cast<string>(m["ParameterLocation"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("TableAndDsList") != m.end() && !m["TableAndDsList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableAndDsList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableAndDsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableAndDsList = make_shared<vector<ListApiByAppResponseBodyListResultDataPublicParamListTableAndDsList>>(expect1);
      }
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataPublicParamList() = default;
};
class ListApiByAppResponseBodyListResultDataRegisterApi : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<string> authenticationMode{};
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<string> failExample{};
  shared_ptr<long> httpMethod{};
  shared_ptr<long> modelType{};
  shared_ptr<string> path{};
  shared_ptr<string> protocol{};
  shared_ptr<string> successExample{};
  shared_ptr<long> timeout{};
  shared_ptr<string> url{};

  ListApiByAppResponseBodyListResultDataRegisterApi() {}

  explicit ListApiByAppResponseBodyListResultDataRegisterApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (authenticationMode) {
      res["AuthenticationMode"] = boost::any(*authenticationMode);
    }
    if (datasourceId) {
      res["DatasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (failExample) {
      res["FailExample"] = boost::any(*failExample);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (successExample) {
      res["SuccessExample"] = boost::any(*successExample);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("AuthenticationMode") != m.end() && !m["AuthenticationMode"].empty()) {
      authenticationMode = make_shared<string>(boost::any_cast<string>(m["AuthenticationMode"]));
    }
    if (m.find("DatasourceId") != m.end() && !m["DatasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["DatasourceId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("FailExample") != m.end() && !m["FailExample"].empty()) {
      failExample = make_shared<string>(boost::any_cast<string>(m["FailExample"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<long>(boost::any_cast<long>(m["HttpMethod"]));
    }
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<long>(boost::any_cast<long>(m["ModelType"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("SuccessExample") != m.end() && !m["SuccessExample"].empty()) {
      successExample = make_shared<string>(boost::any_cast<string>(m["SuccessExample"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<long>(boost::any_cast<long>(m["Timeout"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataRegisterApi() = default;
};
class ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList : public Darabonba::Model {
public:
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<long> datasourceType{};
  shared_ptr<string> datasourceUrl{};
  shared_ptr<string> tableName{};

  ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList() {}

  explicit ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceId) {
      res["DatasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (datasourceType) {
      res["DatasourceType"] = boost::any(*datasourceType);
    }
    if (datasourceUrl) {
      res["DatasourceUrl"] = boost::any(*datasourceUrl);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasourceId") != m.end() && !m["DatasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["DatasourceId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("DatasourceType") != m.end() && !m["DatasourceType"].empty()) {
      datasourceType = make_shared<long>(boost::any_cast<long>(m["DatasourceType"]));
    }
    if (m.find("DatasourceUrl") != m.end() && !m["DatasourceUrl"].empty()) {
      datasourceUrl = make_shared<string>(boost::any_cast<string>(m["DatasourceUrl"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList() = default;
};
class ListApiByAppResponseBodyListResultDataRequestParamList : public Darabonba::Model {
public:
  shared_ptr<string> dateFormat{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> descriptionCode{};
  shared_ptr<long> id{};
  shared_ptr<string> initialValue{};
  shared_ptr<string> mappingColumn{};
  shared_ptr<long> must{};
  shared_ptr<string> operator_{};
  shared_ptr<long> optional{};
  shared_ptr<string> originalColumn{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};
  shared_ptr<string> parameterLocation{};
  shared_ptr<string> sample{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList>> tableAndDsList{};

  ListApiByAppResponseBodyListResultDataRequestParamList() {}

  explicit ListApiByAppResponseBodyListResultDataRequestParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (descriptionCode) {
      res["DescriptionCode"] = boost::any(*descriptionCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initialValue) {
      res["InitialValue"] = boost::any(*initialValue);
    }
    if (mappingColumn) {
      res["MappingColumn"] = boost::any(*mappingColumn);
    }
    if (must) {
      res["Must"] = boost::any(*must);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (originalColumn) {
      res["OriginalColumn"] = boost::any(*originalColumn);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (parameterLocation) {
      res["ParameterLocation"] = boost::any(*parameterLocation);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (tableAndDsList) {
      vector<boost::any> temp1;
      for(auto item1:*tableAndDsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableAndDsList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DescriptionCode") != m.end() && !m["DescriptionCode"].empty()) {
      descriptionCode = make_shared<string>(boost::any_cast<string>(m["DescriptionCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InitialValue") != m.end() && !m["InitialValue"].empty()) {
      initialValue = make_shared<string>(boost::any_cast<string>(m["InitialValue"]));
    }
    if (m.find("MappingColumn") != m.end() && !m["MappingColumn"].empty()) {
      mappingColumn = make_shared<string>(boost::any_cast<string>(m["MappingColumn"]));
    }
    if (m.find("Must") != m.end() && !m["Must"].empty()) {
      must = make_shared<long>(boost::any_cast<long>(m["Must"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("OriginalColumn") != m.end() && !m["OriginalColumn"].empty()) {
      originalColumn = make_shared<string>(boost::any_cast<string>(m["OriginalColumn"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ParameterLocation") != m.end() && !m["ParameterLocation"].empty()) {
      parameterLocation = make_shared<string>(boost::any_cast<string>(m["ParameterLocation"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("TableAndDsList") != m.end() && !m["TableAndDsList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableAndDsList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableAndDsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableAndDsList = make_shared<vector<ListApiByAppResponseBodyListResultDataRequestParamListTableAndDsList>>(expect1);
      }
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataRequestParamList() = default;
};
class ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList : public Darabonba::Model {
public:
  shared_ptr<string> datasourceId{};
  shared_ptr<string> datasourceName{};
  shared_ptr<long> datasourceType{};
  shared_ptr<string> datasourceUrl{};
  shared_ptr<string> tableName{};

  ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList() {}

  explicit ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasourceId) {
      res["DatasourceId"] = boost::any(*datasourceId);
    }
    if (datasourceName) {
      res["DatasourceName"] = boost::any(*datasourceName);
    }
    if (datasourceType) {
      res["DatasourceType"] = boost::any(*datasourceType);
    }
    if (datasourceUrl) {
      res["DatasourceUrl"] = boost::any(*datasourceUrl);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasourceId") != m.end() && !m["DatasourceId"].empty()) {
      datasourceId = make_shared<string>(boost::any_cast<string>(m["DatasourceId"]));
    }
    if (m.find("DatasourceName") != m.end() && !m["DatasourceName"].empty()) {
      datasourceName = make_shared<string>(boost::any_cast<string>(m["DatasourceName"]));
    }
    if (m.find("DatasourceType") != m.end() && !m["DatasourceType"].empty()) {
      datasourceType = make_shared<long>(boost::any_cast<long>(m["DatasourceType"]));
    }
    if (m.find("DatasourceUrl") != m.end() && !m["DatasourceUrl"].empty()) {
      datasourceUrl = make_shared<string>(boost::any_cast<string>(m["DatasourceUrl"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList() = default;
};
class ListApiByAppResponseBodyListResultDataResponseParamList : public Darabonba::Model {
public:
  shared_ptr<string> dateFormat{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> descriptionCode{};
  shared_ptr<long> id{};
  shared_ptr<string> initialValue{};
  shared_ptr<string> mappingColumn{};
  shared_ptr<long> must{};
  shared_ptr<string> operator_{};
  shared_ptr<long> optional{};
  shared_ptr<string> originalColumn{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};
  shared_ptr<string> parameterLocation{};
  shared_ptr<string> sample{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList>> tableAndDsList{};

  ListApiByAppResponseBodyListResultDataResponseParamList() {}

  explicit ListApiByAppResponseBodyListResultDataResponseParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dateFormat) {
      res["DateFormat"] = boost::any(*dateFormat);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (descriptionCode) {
      res["DescriptionCode"] = boost::any(*descriptionCode);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (initialValue) {
      res["InitialValue"] = boost::any(*initialValue);
    }
    if (mappingColumn) {
      res["MappingColumn"] = boost::any(*mappingColumn);
    }
    if (must) {
      res["Must"] = boost::any(*must);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (optional) {
      res["Optional"] = boost::any(*optional);
    }
    if (originalColumn) {
      res["OriginalColumn"] = boost::any(*originalColumn);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    if (parameterLocation) {
      res["ParameterLocation"] = boost::any(*parameterLocation);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (tableAndDsList) {
      vector<boost::any> temp1;
      for(auto item1:*tableAndDsList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableAndDsList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DateFormat") != m.end() && !m["DateFormat"].empty()) {
      dateFormat = make_shared<string>(boost::any_cast<string>(m["DateFormat"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DescriptionCode") != m.end() && !m["DescriptionCode"].empty()) {
      descriptionCode = make_shared<string>(boost::any_cast<string>(m["DescriptionCode"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InitialValue") != m.end() && !m["InitialValue"].empty()) {
      initialValue = make_shared<string>(boost::any_cast<string>(m["InitialValue"]));
    }
    if (m.find("MappingColumn") != m.end() && !m["MappingColumn"].empty()) {
      mappingColumn = make_shared<string>(boost::any_cast<string>(m["MappingColumn"]));
    }
    if (m.find("Must") != m.end() && !m["Must"].empty()) {
      must = make_shared<long>(boost::any_cast<long>(m["Must"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Optional") != m.end() && !m["Optional"].empty()) {
      optional = make_shared<long>(boost::any_cast<long>(m["Optional"]));
    }
    if (m.find("OriginalColumn") != m.end() && !m["OriginalColumn"].empty()) {
      originalColumn = make_shared<string>(boost::any_cast<string>(m["OriginalColumn"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
    if (m.find("ParameterLocation") != m.end() && !m["ParameterLocation"].empty()) {
      parameterLocation = make_shared<string>(boost::any_cast<string>(m["ParameterLocation"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("TableAndDsList") != m.end() && !m["TableAndDsList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableAndDsList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableAndDsList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableAndDsList = make_shared<vector<ListApiByAppResponseBodyListResultDataResponseParamListTableAndDsList>>(expect1);
      }
    }
  }


  virtual ~ListApiByAppResponseBodyListResultDataResponseParamList() = default;
};
class ListApiByAppResponseBodyListResultData : public Darabonba::Model {
public:
  shared_ptr<long> apiNo{};
  shared_ptr<long> apiTimeout{};
  shared_ptr<string> appName{};
  shared_ptr<string> bizModuleEnName{};
  shared_ptr<string> cacheSwitch{};
  shared_ptr<string> cacheTime{};
  shared_ptr<long> createType{};
  shared_ptr<long> dbEnv{};
  shared_ptr<string> description{};
  shared_ptr<long> directDatasourceId{};
  shared_ptr<string> directDatasourceName{};
  shared_ptr<long> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> id{};
  shared_ptr<bool> isLogicalTable{};
  shared_ptr<long> isPagedQuery{};
  shared_ptr<long> maxReturnNum{};
  shared_ptr<long> modelType{};
  shared_ptr<string> name{};
  shared_ptr<long> projId{};
  shared_ptr<string> projName{};
  shared_ptr<long> protocol{};
  shared_ptr<string> protocolName{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataPublicParamList>> publicParamList{};
  shared_ptr<ListApiByAppResponseBodyListResultDataRegisterApi> registerApi{};
  shared_ptr<long> requestMethod{};
  shared_ptr<string> requestMethodName{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataRequestParamList>> requestParamList{};
  shared_ptr<string> resourceGroupName{};
  shared_ptr<vector<ListApiByAppResponseBodyListResultDataResponseParamList>> responseParamList{};
  shared_ptr<string> resultSample{};
  shared_ptr<long> returnType{};
  shared_ptr<string> returnTypeName{};
  shared_ptr<string> rsGrpId{};
  shared_ptr<string> scriptType{};
  shared_ptr<long> specialSql{};
  shared_ptr<string> sqlStatement{};
  shared_ptr<string> tableName{};
  shared_ptr<string> timeout{};
  shared_ptr<long> updateRate{};
  shared_ptr<string> updateRateName{};
  shared_ptr<string> version{};

  ListApiByAppResponseBodyListResultData() {}

  explicit ListApiByAppResponseBodyListResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiNo) {
      res["ApiNo"] = boost::any(*apiNo);
    }
    if (apiTimeout) {
      res["ApiTimeout"] = boost::any(*apiTimeout);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (bizModuleEnName) {
      res["BizModuleEnName"] = boost::any(*bizModuleEnName);
    }
    if (cacheSwitch) {
      res["CacheSwitch"] = boost::any(*cacheSwitch);
    }
    if (cacheTime) {
      res["CacheTime"] = boost::any(*cacheTime);
    }
    if (createType) {
      res["CreateType"] = boost::any(*createType);
    }
    if (dbEnv) {
      res["DbEnv"] = boost::any(*dbEnv);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (directDatasourceId) {
      res["DirectDatasourceId"] = boost::any(*directDatasourceId);
    }
    if (directDatasourceName) {
      res["DirectDatasourceName"] = boost::any(*directDatasourceName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isLogicalTable) {
      res["IsLogicalTable"] = boost::any(*isLogicalTable);
    }
    if (isPagedQuery) {
      res["IsPagedQuery"] = boost::any(*isPagedQuery);
    }
    if (maxReturnNum) {
      res["MaxReturnNum"] = boost::any(*maxReturnNum);
    }
    if (modelType) {
      res["ModelType"] = boost::any(*modelType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projId) {
      res["ProjId"] = boost::any(*projId);
    }
    if (projName) {
      res["ProjName"] = boost::any(*projName);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (protocolName) {
      res["ProtocolName"] = boost::any(*protocolName);
    }
    if (publicParamList) {
      vector<boost::any> temp1;
      for(auto item1:*publicParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PublicParamList"] = boost::any(temp1);
    }
    if (registerApi) {
      res["RegisterApi"] = registerApi ? boost::any(registerApi->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestMethod) {
      res["RequestMethod"] = boost::any(*requestMethod);
    }
    if (requestMethodName) {
      res["RequestMethodName"] = boost::any(*requestMethodName);
    }
    if (requestParamList) {
      vector<boost::any> temp1;
      for(auto item1:*requestParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParamList"] = boost::any(temp1);
    }
    if (resourceGroupName) {
      res["ResourceGroupName"] = boost::any(*resourceGroupName);
    }
    if (responseParamList) {
      vector<boost::any> temp1;
      for(auto item1:*responseParamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResponseParamList"] = boost::any(temp1);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (returnType) {
      res["ReturnType"] = boost::any(*returnType);
    }
    if (returnTypeName) {
      res["ReturnTypeName"] = boost::any(*returnTypeName);
    }
    if (rsGrpId) {
      res["RsGrpId"] = boost::any(*rsGrpId);
    }
    if (scriptType) {
      res["ScriptType"] = boost::any(*scriptType);
    }
    if (specialSql) {
      res["SpecialSql"] = boost::any(*specialSql);
    }
    if (sqlStatement) {
      res["SqlStatement"] = boost::any(*sqlStatement);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (timeout) {
      res["Timeout"] = boost::any(*timeout);
    }
    if (updateRate) {
      res["UpdateRate"] = boost::any(*updateRate);
    }
    if (updateRateName) {
      res["UpdateRateName"] = boost::any(*updateRateName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiNo") != m.end() && !m["ApiNo"].empty()) {
      apiNo = make_shared<long>(boost::any_cast<long>(m["ApiNo"]));
    }
    if (m.find("ApiTimeout") != m.end() && !m["ApiTimeout"].empty()) {
      apiTimeout = make_shared<long>(boost::any_cast<long>(m["ApiTimeout"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BizModuleEnName") != m.end() && !m["BizModuleEnName"].empty()) {
      bizModuleEnName = make_shared<string>(boost::any_cast<string>(m["BizModuleEnName"]));
    }
    if (m.find("CacheSwitch") != m.end() && !m["CacheSwitch"].empty()) {
      cacheSwitch = make_shared<string>(boost::any_cast<string>(m["CacheSwitch"]));
    }
    if (m.find("CacheTime") != m.end() && !m["CacheTime"].empty()) {
      cacheTime = make_shared<string>(boost::any_cast<string>(m["CacheTime"]));
    }
    if (m.find("CreateType") != m.end() && !m["CreateType"].empty()) {
      createType = make_shared<long>(boost::any_cast<long>(m["CreateType"]));
    }
    if (m.find("DbEnv") != m.end() && !m["DbEnv"].empty()) {
      dbEnv = make_shared<long>(boost::any_cast<long>(m["DbEnv"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DirectDatasourceId") != m.end() && !m["DirectDatasourceId"].empty()) {
      directDatasourceId = make_shared<long>(boost::any_cast<long>(m["DirectDatasourceId"]));
    }
    if (m.find("DirectDatasourceName") != m.end() && !m["DirectDatasourceName"].empty()) {
      directDatasourceName = make_shared<string>(boost::any_cast<string>(m["DirectDatasourceName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<long>(boost::any_cast<long>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsLogicalTable") != m.end() && !m["IsLogicalTable"].empty()) {
      isLogicalTable = make_shared<bool>(boost::any_cast<bool>(m["IsLogicalTable"]));
    }
    if (m.find("IsPagedQuery") != m.end() && !m["IsPagedQuery"].empty()) {
      isPagedQuery = make_shared<long>(boost::any_cast<long>(m["IsPagedQuery"]));
    }
    if (m.find("MaxReturnNum") != m.end() && !m["MaxReturnNum"].empty()) {
      maxReturnNum = make_shared<long>(boost::any_cast<long>(m["MaxReturnNum"]));
    }
    if (m.find("ModelType") != m.end() && !m["ModelType"].empty()) {
      modelType = make_shared<long>(boost::any_cast<long>(m["ModelType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjId") != m.end() && !m["ProjId"].empty()) {
      projId = make_shared<long>(boost::any_cast<long>(m["ProjId"]));
    }
    if (m.find("ProjName") != m.end() && !m["ProjName"].empty()) {
      projName = make_shared<string>(boost::any_cast<string>(m["ProjName"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<long>(boost::any_cast<long>(m["Protocol"]));
    }
    if (m.find("ProtocolName") != m.end() && !m["ProtocolName"].empty()) {
      protocolName = make_shared<string>(boost::any_cast<string>(m["ProtocolName"]));
    }
    if (m.find("PublicParamList") != m.end() && !m["PublicParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["PublicParamList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataPublicParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PublicParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataPublicParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        publicParamList = make_shared<vector<ListApiByAppResponseBodyListResultDataPublicParamList>>(expect1);
      }
    }
    if (m.find("RegisterApi") != m.end() && !m["RegisterApi"].empty()) {
      if (typeid(map<string, boost::any>) == m["RegisterApi"].type()) {
        ListApiByAppResponseBodyListResultDataRegisterApi model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RegisterApi"]));
        registerApi = make_shared<ListApiByAppResponseBodyListResultDataRegisterApi>(model1);
      }
    }
    if (m.find("RequestMethod") != m.end() && !m["RequestMethod"].empty()) {
      requestMethod = make_shared<long>(boost::any_cast<long>(m["RequestMethod"]));
    }
    if (m.find("RequestMethodName") != m.end() && !m["RequestMethodName"].empty()) {
      requestMethodName = make_shared<string>(boost::any_cast<string>(m["RequestMethodName"]));
    }
    if (m.find("RequestParamList") != m.end() && !m["RequestParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParamList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataRequestParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataRequestParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParamList = make_shared<vector<ListApiByAppResponseBodyListResultDataRequestParamList>>(expect1);
      }
    }
    if (m.find("ResourceGroupName") != m.end() && !m["ResourceGroupName"].empty()) {
      resourceGroupName = make_shared<string>(boost::any_cast<string>(m["ResourceGroupName"]));
    }
    if (m.find("ResponseParamList") != m.end() && !m["ResponseParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResponseParamList"].type()) {
        vector<ListApiByAppResponseBodyListResultDataResponseParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResponseParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultDataResponseParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responseParamList = make_shared<vector<ListApiByAppResponseBodyListResultDataResponseParamList>>(expect1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ReturnType") != m.end() && !m["ReturnType"].empty()) {
      returnType = make_shared<long>(boost::any_cast<long>(m["ReturnType"]));
    }
    if (m.find("ReturnTypeName") != m.end() && !m["ReturnTypeName"].empty()) {
      returnTypeName = make_shared<string>(boost::any_cast<string>(m["ReturnTypeName"]));
    }
    if (m.find("RsGrpId") != m.end() && !m["RsGrpId"].empty()) {
      rsGrpId = make_shared<string>(boost::any_cast<string>(m["RsGrpId"]));
    }
    if (m.find("ScriptType") != m.end() && !m["ScriptType"].empty()) {
      scriptType = make_shared<string>(boost::any_cast<string>(m["ScriptType"]));
    }
    if (m.find("SpecialSql") != m.end() && !m["SpecialSql"].empty()) {
      specialSql = make_shared<long>(boost::any_cast<long>(m["SpecialSql"]));
    }
    if (m.find("SqlStatement") != m.end() && !m["SqlStatement"].empty()) {
      sqlStatement = make_shared<string>(boost::any_cast<string>(m["SqlStatement"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("Timeout") != m.end() && !m["Timeout"].empty()) {
      timeout = make_shared<string>(boost::any_cast<string>(m["Timeout"]));
    }
    if (m.find("UpdateRate") != m.end() && !m["UpdateRate"].empty()) {
      updateRate = make_shared<long>(boost::any_cast<long>(m["UpdateRate"]));
    }
    if (m.find("UpdateRateName") != m.end() && !m["UpdateRateName"].empty()) {
      updateRateName = make_shared<string>(boost::any_cast<string>(m["UpdateRateName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResultData() = default;
};
class ListApiByAppResponseBodyListResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListApiByAppResponseBodyListResultData>> data{};
  shared_ptr<long> totalCount{};

  ListApiByAppResponseBodyListResult() {}

  explicit ListApiByAppResponseBodyListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListApiByAppResponseBodyListResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApiByAppResponseBodyListResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListApiByAppResponseBodyListResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApiByAppResponseBodyListResult() = default;
};
class ListApiByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListApiByAppResponseBodyListResult> listResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListApiByAppResponseBody() {}

  explicit ListApiByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (listResult) {
      res["ListResult"] = listResult ? boost::any(listResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ListResult") != m.end() && !m["ListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListResult"].type()) {
        ListApiByAppResponseBodyListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListResult"]));
        listResult = make_shared<ListApiByAppResponseBodyListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListApiByAppResponseBody() = default;
};
class ListApiByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApiByAppResponseBody> body{};

  ListApiByAppResponse() {}

  explicit ListApiByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApiByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApiByAppResponseBody>(model1);
      }
    }
  }


  virtual ~ListApiByAppResponse() = default;
};
class ListAuthorizedDataServiceApiDetailsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> appKey{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};

  ListAuthorizedDataServiceApiDetailsRequestListQuery() {}

  explicit ListAuthorizedDataServiceApiDetailsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<long>(boost::any_cast<long>(m["AppKey"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsRequestListQuery() = default;
};
class ListAuthorizedDataServiceApiDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<ListAuthorizedDataServiceApiDetailsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListAuthorizedDataServiceApiDetailsRequest() {}

  explicit ListAuthorizedDataServiceApiDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListAuthorizedDataServiceApiDetailsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListAuthorizedDataServiceApiDetailsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsRequest() = default;
};
class ListAuthorizedDataServiceApiDetailsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListAuthorizedDataServiceApiDetailsShrinkRequest() {}

  explicit ListAuthorizedDataServiceApiDetailsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsShrinkRequest() = default;
};
class ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<long> isAuthorized{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters() {}

  explicit ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<long>(boost::any_cast<long>(m["IsAuthorized"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters() = default;
};
class ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters : public Darabonba::Model {
public:
  shared_ptr<string> exampleValue{};
  shared_ptr<long> isAuthorized{};
  shared_ptr<long> parameterDataType{};
  shared_ptr<string> parameterDescription{};
  shared_ptr<string> parameterName{};

  ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters() {}

  explicit ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exampleValue) {
      res["ExampleValue"] = boost::any(*exampleValue);
    }
    if (isAuthorized) {
      res["IsAuthorized"] = boost::any(*isAuthorized);
    }
    if (parameterDataType) {
      res["ParameterDataType"] = boost::any(*parameterDataType);
    }
    if (parameterDescription) {
      res["ParameterDescription"] = boost::any(*parameterDescription);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExampleValue") != m.end() && !m["ExampleValue"].empty()) {
      exampleValue = make_shared<string>(boost::any_cast<string>(m["ExampleValue"]));
    }
    if (m.find("IsAuthorized") != m.end() && !m["IsAuthorized"].empty()) {
      isAuthorized = make_shared<long>(boost::any_cast<long>(m["IsAuthorized"]));
    }
    if (m.find("ParameterDataType") != m.end() && !m["ParameterDataType"].empty()) {
      parameterDataType = make_shared<long>(boost::any_cast<long>(m["ParameterDataType"]));
    }
    if (m.find("ParameterDescription") != m.end() && !m["ParameterDescription"].empty()) {
      parameterDescription = make_shared<string>(boost::any_cast<string>(m["ParameterDescription"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters() = default;
};
class ListAuthorizedDataServiceApiDetailsResponseBodyResultData : public Darabonba::Model {
public:
  shared_ptr<long> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<long> appId{};
  shared_ptr<string> authType{};
  shared_ptr<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters>> authorizedDevReturnParameters{};
  shared_ptr<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters>> authorizedProdReturnParameters{};
  shared_ptr<string> description{};
  shared_ptr<string> devAuthPeriod{};
  shared_ptr<string> prodAuthPeriod{};
  shared_ptr<long> projectId{};

  ListAuthorizedDataServiceApiDetailsResponseBodyResultData() {}

  explicit ListAuthorizedDataServiceApiDetailsResponseBodyResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (authorizedDevReturnParameters) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedDevReturnParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedDevReturnParameters"] = boost::any(temp1);
    }
    if (authorizedProdReturnParameters) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedProdReturnParameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedProdReturnParameters"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (devAuthPeriod) {
      res["DevAuthPeriod"] = boost::any(*devAuthPeriod);
    }
    if (prodAuthPeriod) {
      res["ProdAuthPeriod"] = boost::any(*prodAuthPeriod);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<long>(boost::any_cast<long>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("AuthorizedDevReturnParameters") != m.end() && !m["AuthorizedDevReturnParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedDevReturnParameters"].type()) {
        vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedDevReturnParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedDevReturnParameters = make_shared<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedDevReturnParameters>>(expect1);
      }
    }
    if (m.find("AuthorizedProdReturnParameters") != m.end() && !m["AuthorizedProdReturnParameters"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedProdReturnParameters"].type()) {
        vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedProdReturnParameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedProdReturnParameters = make_shared<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultDataAuthorizedProdReturnParameters>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DevAuthPeriod") != m.end() && !m["DevAuthPeriod"].empty()) {
      devAuthPeriod = make_shared<string>(boost::any_cast<string>(m["DevAuthPeriod"]));
    }
    if (m.find("ProdAuthPeriod") != m.end() && !m["ProdAuthPeriod"].empty()) {
      prodAuthPeriod = make_shared<string>(boost::any_cast<string>(m["ProdAuthPeriod"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponseBodyResultData() = default;
};
class ListAuthorizedDataServiceApiDetailsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultData>> data{};
  shared_ptr<long> totalCount{};

  ListAuthorizedDataServiceApiDetailsResponseBodyResult() {}

  explicit ListAuthorizedDataServiceApiDetailsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAuthorizedDataServiceApiDetailsResponseBodyResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAuthorizedDataServiceApiDetailsResponseBodyResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponseBodyResult() = default;
};
class ListAuthorizedDataServiceApiDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ListAuthorizedDataServiceApiDetailsResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ListAuthorizedDataServiceApiDetailsResponseBody() {}

  explicit ListAuthorizedDataServiceApiDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListAuthorizedDataServiceApiDetailsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListAuthorizedDataServiceApiDetailsResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponseBody() = default;
};
class ListAuthorizedDataServiceApiDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAuthorizedDataServiceApiDetailsResponseBody> body{};

  ListAuthorizedDataServiceApiDetailsResponse() {}

  explicit ListAuthorizedDataServiceApiDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAuthorizedDataServiceApiDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAuthorizedDataServiceApiDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAuthorizedDataServiceApiDetailsResponse() = default;
};
class ListBizEntitiesRequestListQueryFilterCriteria : public Darabonba::Model {
public:
  shared_ptr<vector<long>> bizUnitIdList{};
  shared_ptr<vector<string>> bizUnitNameList{};
  shared_ptr<vector<long>> dataDomainIdList{};
  shared_ptr<vector<string>> dataDomainNameList{};
  shared_ptr<bool> hasTableRef{};
  shared_ptr<vector<string>> ownerUserIdList{};
  shared_ptr<vector<string>> statusList{};
  shared_ptr<vector<string>> subTypeList{};

  ListBizEntitiesRequestListQueryFilterCriteria() {}

  explicit ListBizEntitiesRequestListQueryFilterCriteria(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitIdList) {
      res["BizUnitIdList"] = boost::any(*bizUnitIdList);
    }
    if (bizUnitNameList) {
      res["BizUnitNameList"] = boost::any(*bizUnitNameList);
    }
    if (dataDomainIdList) {
      res["DataDomainIdList"] = boost::any(*dataDomainIdList);
    }
    if (dataDomainNameList) {
      res["DataDomainNameList"] = boost::any(*dataDomainNameList);
    }
    if (hasTableRef) {
      res["HasTableRef"] = boost::any(*hasTableRef);
    }
    if (ownerUserIdList) {
      res["OwnerUserIdList"] = boost::any(*ownerUserIdList);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    if (subTypeList) {
      res["SubTypeList"] = boost::any(*subTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitIdList") != m.end() && !m["BizUnitIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizUnitIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizUnitIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizUnitIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BizUnitNameList") != m.end() && !m["BizUnitNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["BizUnitNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizUnitNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      bizUnitNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DataDomainIdList") != m.end() && !m["DataDomainIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["DataDomainIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDomainIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      dataDomainIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DataDomainNameList") != m.end() && !m["DataDomainNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DataDomainNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DataDomainNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dataDomainNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HasTableRef") != m.end() && !m["HasTableRef"].empty()) {
      hasTableRef = make_shared<bool>(boost::any_cast<bool>(m["HasTableRef"]));
    }
    if (m.find("OwnerUserIdList") != m.end() && !m["OwnerUserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerUserIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubTypeList") != m.end() && !m["SubTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListBizEntitiesRequestListQueryFilterCriteria() = default;
};
class ListBizEntitiesRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<ListBizEntitiesRequestListQueryFilterCriteria> filterCriteria{};
  shared_ptr<string> keyword{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};

  ListBizEntitiesRequestListQuery() {}

  explicit ListBizEntitiesRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filterCriteria) {
      res["FilterCriteria"] = filterCriteria ? boost::any(filterCriteria->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilterCriteria") != m.end() && !m["FilterCriteria"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterCriteria"].type()) {
        ListBizEntitiesRequestListQueryFilterCriteria model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterCriteria"]));
        filterCriteria = make_shared<ListBizEntitiesRequestListQueryFilterCriteria>(model1);
      }
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListBizEntitiesRequestListQuery() = default;
};
class ListBizEntitiesRequest : public Darabonba::Model {
public:
  shared_ptr<ListBizEntitiesRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListBizEntitiesRequest() {}

  explicit ListBizEntitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListBizEntitiesRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListBizEntitiesRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListBizEntitiesRequest() = default;
};
class ListBizEntitiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListBizEntitiesShrinkRequest() {}

  explicit ListBizEntitiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListBizEntitiesShrinkRequest() = default;
};
class ListBizEntitiesResponseBodyPageResultBizEntityList : public Darabonba::Model {
public:
  shared_ptr<vector<long>> belongToBizEntityIdList{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<vector<long>> childBizEntityIdList{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<bool> hasChildBizEntity{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<bool> levelSubBizObject{};
  shared_ptr<string> name{};
  shared_ptr<string> onlineStatus{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<long>> refBizEntityIdList{};
  shared_ptr<long> refTableCount{};
  shared_ptr<string> status{};
  shared_ptr<string> subType{};
  shared_ptr<vector<long>> suffixBizEntityIdList{};
  shared_ptr<string> type{};

  ListBizEntitiesResponseBodyPageResultBizEntityList() {}

  explicit ListBizEntitiesResponseBodyPageResultBizEntityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (belongToBizEntityIdList) {
      res["BelongToBizEntityIdList"] = boost::any(*belongToBizEntityIdList);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (childBizEntityIdList) {
      res["ChildBizEntityIdList"] = boost::any(*childBizEntityIdList);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (hasChildBizEntity) {
      res["HasChildBizEntity"] = boost::any(*hasChildBizEntity);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (levelSubBizObject) {
      res["LevelSubBizObject"] = boost::any(*levelSubBizObject);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (onlineStatus) {
      res["OnlineStatus"] = boost::any(*onlineStatus);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    if (refTableCount) {
      res["RefTableCount"] = boost::any(*refTableCount);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subType) {
      res["SubType"] = boost::any(*subType);
    }
    if (suffixBizEntityIdList) {
      res["SuffixBizEntityIdList"] = boost::any(*suffixBizEntityIdList);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BelongToBizEntityIdList") != m.end() && !m["BelongToBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BelongToBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BelongToBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      belongToBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("ChildBizEntityIdList") != m.end() && !m["ChildBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ChildBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChildBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      childBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("HasChildBizEntity") != m.end() && !m["HasChildBizEntity"].empty()) {
      hasChildBizEntity = make_shared<bool>(boost::any_cast<bool>(m["HasChildBizEntity"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("LevelSubBizObject") != m.end() && !m["LevelSubBizObject"].empty()) {
      levelSubBizObject = make_shared<bool>(boost::any_cast<bool>(m["LevelSubBizObject"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OnlineStatus") != m.end() && !m["OnlineStatus"].empty()) {
      onlineStatus = make_shared<string>(boost::any_cast<string>(m["OnlineStatus"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefTableCount") != m.end() && !m["RefTableCount"].empty()) {
      refTableCount = make_shared<long>(boost::any_cast<long>(m["RefTableCount"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubType") != m.end() && !m["SubType"].empty()) {
      subType = make_shared<string>(boost::any_cast<string>(m["SubType"]));
    }
    if (m.find("SuffixBizEntityIdList") != m.end() && !m["SuffixBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SuffixBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SuffixBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      suffixBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListBizEntitiesResponseBodyPageResultBizEntityList() = default;
};
class ListBizEntitiesResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListBizEntitiesResponseBodyPageResultBizEntityList>> bizEntityList{};
  shared_ptr<long> totalCount{};

  ListBizEntitiesResponseBodyPageResult() {}

  explicit ListBizEntitiesResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEntityList) {
      vector<boost::any> temp1;
      for(auto item1:*bizEntityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizEntityList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEntityList") != m.end() && !m["BizEntityList"].empty()) {
      if (typeid(vector<boost::any>) == m["BizEntityList"].type()) {
        vector<ListBizEntitiesResponseBodyPageResultBizEntityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizEntityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBizEntitiesResponseBodyPageResultBizEntityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizEntityList = make_shared<vector<ListBizEntitiesResponseBodyPageResultBizEntityList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBizEntitiesResponseBodyPageResult() = default;
};
class ListBizEntitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListBizEntitiesResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListBizEntitiesResponseBody() {}

  explicit ListBizEntitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListBizEntitiesResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListBizEntitiesResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListBizEntitiesResponseBody() = default;
};
class ListBizEntitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBizEntitiesResponseBody> body{};

  ListBizEntitiesResponse() {}

  explicit ListBizEntitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBizEntitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBizEntitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListBizEntitiesResponse() = default;
};
class ListBizUnitsRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};

  ListBizUnitsRequest() {}

  explicit ListBizUnitsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListBizUnitsRequest() = default;
};
class ListBizUnitsResponseBodyDataBizUnitListAccountList : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ListBizUnitsResponseBodyDataBizUnitListAccountList() {}

  explicit ListBizUnitsResponseBodyDataBizUnitListAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListBizUnitsResponseBodyDataBizUnitListAccountList() = default;
};
class ListBizUnitsResponseBodyDataBizUnitList : public Darabonba::Model {
public:
  shared_ptr<vector<ListBizUnitsResponseBodyDataBizUnitListAccountList>> accountList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> icon{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> mode{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};

  ListBizUnitsResponseBodyDataBizUnitList() {}

  explicit ListBizUnitsResponseBodyDataBizUnitList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountList) {
      vector<boost::any> temp1;
      for(auto item1:*accountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccountList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountList") != m.end() && !m["AccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["AccountList"].type()) {
        vector<ListBizUnitsResponseBodyDataBizUnitListAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBizUnitsResponseBodyDataBizUnitListAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accountList = make_shared<vector<ListBizUnitsResponseBodyDataBizUnitListAccountList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
  }


  virtual ~ListBizUnitsResponseBodyDataBizUnitList() = default;
};
class ListBizUnitsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListBizUnitsResponseBodyDataBizUnitList>> bizUnitList{};

  ListBizUnitsResponseBodyData() {}

  explicit ListBizUnitsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitList) {
      vector<boost::any> temp1;
      for(auto item1:*bizUnitList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizUnitList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitList") != m.end() && !m["BizUnitList"].empty()) {
      if (typeid(vector<boost::any>) == m["BizUnitList"].type()) {
        vector<ListBizUnitsResponseBodyDataBizUnitList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizUnitList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBizUnitsResponseBodyDataBizUnitList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizUnitList = make_shared<vector<ListBizUnitsResponseBodyDataBizUnitList>>(expect1);
      }
    }
  }


  virtual ~ListBizUnitsResponseBodyData() = default;
};
class ListBizUnitsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListBizUnitsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListBizUnitsResponseBody() {}

  explicit ListBizUnitsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBizUnitsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBizUnitsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListBizUnitsResponseBody() = default;
};
class ListBizUnitsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBizUnitsResponseBody> body{};

  ListBizUnitsResponse() {}

  explicit ListBizUnitsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBizUnitsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBizUnitsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBizUnitsResponse() = default;
};
class ListDataDomainsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<vector<long>> bizUnitIdList{};
  shared_ptr<string> keyword{};
  shared_ptr<vector<long>> parentIdList{};

  ListDataDomainsRequestListQuery() {}

  explicit ListDataDomainsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitIdList) {
      res["BizUnitIdList"] = boost::any(*bizUnitIdList);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (parentIdList) {
      res["ParentIdList"] = boost::any(*parentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitIdList") != m.end() && !m["BizUnitIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizUnitIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizUnitIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizUnitIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("ParentIdList") != m.end() && !m["ParentIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ParentIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ParentIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      parentIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListDataDomainsRequestListQuery() = default;
};
class ListDataDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<ListDataDomainsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListDataDomainsRequest() {}

  explicit ListDataDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListDataDomainsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListDataDomainsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListDataDomainsRequest() = default;
};
class ListDataDomainsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListDataDomainsShrinkRequest() {}

  explicit ListDataDomainsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListDataDomainsShrinkRequest() = default;
};
class ListDataDomainsResponseBodyDataDataDomainList : public Darabonba::Model {
public:
  shared_ptr<string> abbreviation{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> lastModifierName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};

  ListDataDomainsResponseBodyDataDataDomainList() {}

  explicit ListDataDomainsResponseBodyDataDataDomainList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbreviation) {
      res["Abbreviation"] = boost::any(*abbreviation);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (lastModifierName) {
      res["LastModifierName"] = boost::any(*lastModifierName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbreviation") != m.end() && !m["Abbreviation"].empty()) {
      abbreviation = make_shared<string>(boost::any_cast<string>(m["Abbreviation"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("LastModifierName") != m.end() && !m["LastModifierName"].empty()) {
      lastModifierName = make_shared<string>(boost::any_cast<string>(m["LastModifierName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~ListDataDomainsResponseBodyDataDataDomainList() = default;
};
class ListDataDomainsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataDomainsResponseBodyDataDataDomainList>> dataDomainList{};

  ListDataDomainsResponseBodyData() {}

  explicit ListDataDomainsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataDomainList) {
      vector<boost::any> temp1;
      for(auto item1:*dataDomainList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataDomainList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataDomainList") != m.end() && !m["DataDomainList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataDomainList"].type()) {
        vector<ListDataDomainsResponseBodyDataDataDomainList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataDomainList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataDomainsResponseBodyDataDataDomainList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDomainList = make_shared<vector<ListDataDomainsResponseBodyDataDataDomainList>>(expect1);
      }
    }
  }


  virtual ~ListDataDomainsResponseBodyData() = default;
};
class ListDataDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDataDomainsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDataDomainsResponseBody() {}

  explicit ListDataDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDataDomainsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDataDomainsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDataDomainsResponseBody() = default;
};
class ListDataDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataDomainsResponseBody> body{};

  ListDataDomainsResponse() {}

  explicit ListDataDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataDomainsResponse() = default;
};
class ListDataSourceWithConfigRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<string>> ownerList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> scopeList{};
  shared_ptr<string> tag{};
  shared_ptr<vector<string>> typeList{};

  ListDataSourceWithConfigRequestListQuery() {}

  explicit ListDataSourceWithConfigRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerList) {
      res["OwnerList"] = boost::any(*ownerList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scopeList) {
      res["ScopeList"] = boost::any(*scopeList);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ScopeList") != m.end() && !m["ScopeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ScopeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ScopeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scopeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      typeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataSourceWithConfigRequestListQuery() = default;
};
class ListDataSourceWithConfigRequest : public Darabonba::Model {
public:
  shared_ptr<ListDataSourceWithConfigRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListDataSourceWithConfigRequest() {}

  explicit ListDataSourceWithConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListDataSourceWithConfigRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListDataSourceWithConfigRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListDataSourceWithConfigRequest() = default;
};
class ListDataSourceWithConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListDataSourceWithConfigShrinkRequest() {}

  explicit ListDataSourceWithConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListDataSourceWithConfigShrinkRequest() = default;
};
class ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList() {}

  explicit ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList() = default;
};
class ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList>> configItemList{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> description{};
  shared_ptr<string> env{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};

  ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo() {}

  explicit ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfoConfigItemList>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo() = default;
};
class ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList() {}

  explicit ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList() = default;
};
class ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList>> configItemList{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> creatorName{};
  shared_ptr<string> description{};
  shared_ptr<string> env{};
  shared_ptr<long> id{};
  shared_ptr<long> modifyTime{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> scope{};
  shared_ptr<string> type{};

  ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo() {}

  explicit ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (creatorName) {
      res["CreatorName"] = boost::any(*creatorName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfoConfigItemList>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("CreatorName") != m.end() && !m["CreatorName"].empty()) {
      creatorName = make_shared<string>(boost::any_cast<string>(m["CreatorName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<long>(boost::any_cast<long>(m["ModifyTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo() = default;
};
class ListDataSourceWithConfigResponseBodyPageResultDataSourceList : public Darabonba::Model {
public:
  shared_ptr<ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo> devDataSourceInfo{};
  shared_ptr<ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo> prodDataSourceInfo{};

  ListDataSourceWithConfigResponseBodyPageResultDataSourceList() {}

  explicit ListDataSourceWithConfigResponseBodyPageResultDataSourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (devDataSourceInfo) {
      res["DevDataSourceInfo"] = devDataSourceInfo ? boost::any(devDataSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (prodDataSourceInfo) {
      res["ProdDataSourceInfo"] = prodDataSourceInfo ? boost::any(prodDataSourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DevDataSourceInfo") != m.end() && !m["DevDataSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DevDataSourceInfo"].type()) {
        ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DevDataSourceInfo"]));
        devDataSourceInfo = make_shared<ListDataSourceWithConfigResponseBodyPageResultDataSourceListDevDataSourceInfo>(model1);
      }
    }
    if (m.find("ProdDataSourceInfo") != m.end() && !m["ProdDataSourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProdDataSourceInfo"].type()) {
        ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProdDataSourceInfo"]));
        prodDataSourceInfo = make_shared<ListDataSourceWithConfigResponseBodyPageResultDataSourceListProdDataSourceInfo>(model1);
      }
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResultDataSourceList() = default;
};
class ListDataSourceWithConfigResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceList>> dataSourceList{};
  shared_ptr<long> totalCount{};

  ListDataSourceWithConfigResponseBodyPageResult() {}

  explicit ListDataSourceWithConfigResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceList) {
      vector<boost::any> temp1;
      for(auto item1:*dataSourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSourceList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataSourceList") != m.end() && !m["DataSourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSourceList"].type()) {
        vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceWithConfigResponseBodyPageResultDataSourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSourceList = make_shared<vector<ListDataSourceWithConfigResponseBodyPageResultDataSourceList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBodyPageResult() = default;
};
class ListDataSourceWithConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListDataSourceWithConfigResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListDataSourceWithConfigResponseBody() {}

  explicit ListDataSourceWithConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListDataSourceWithConfigResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListDataSourceWithConfigResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListDataSourceWithConfigResponseBody() = default;
};
class ListDataSourceWithConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourceWithConfigResponseBody> body{};

  ListDataSourceWithConfigResponse() {}

  explicit ListDataSourceWithConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourceWithConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourceWithConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourceWithConfigResponse() = default;
};
class ListFilesRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> directory{};
  shared_ptr<string> env{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> recursive{};

  ListFilesRequestListQuery() {}

  explicit ListFilesRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (recursive) {
      res["Recursive"] = boost::any(*recursive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("Recursive") != m.end() && !m["Recursive"].empty()) {
      recursive = make_shared<bool>(boost::any_cast<bool>(m["Recursive"]));
    }
  }


  virtual ~ListFilesRequestListQuery() = default;
};
class ListFilesRequest : public Darabonba::Model {
public:
  shared_ptr<ListFilesRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListFilesRequest() {}

  explicit ListFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListFilesRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListFilesRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListFilesRequest() = default;
};
class ListFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListFilesShrinkRequest() {}

  explicit ListFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListFilesShrinkRequest() = default;
};
class ListFilesResponseBodyFileList : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> content{};
  shared_ptr<string> creator{};
  shared_ptr<string> directory{};
  shared_ptr<string> fileType{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<string> lastModifier{};
  shared_ptr<string> name{};
  shared_ptr<long> projectId{};

  ListFilesResponseBodyFileList() {}

  explicit ListFilesResponseBodyFileList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (fileType) {
      res["FileType"] = boost::any(*fileType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifier) {
      res["LastModifier"] = boost::any(*lastModifier);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("FileType") != m.end() && !m["FileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["FileType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("LastModifier") != m.end() && !m["LastModifier"].empty()) {
      lastModifier = make_shared<string>(boost::any_cast<string>(m["LastModifier"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListFilesResponseBodyFileList() = default;
};
class ListFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListFilesResponseBodyFileList>> fileList{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListFilesResponseBody() {}

  explicit ListFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (fileList) {
      vector<boost::any> temp1;
      for(auto item1:*fileList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FileList"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("FileList") != m.end() && !m["FileList"].empty()) {
      if (typeid(vector<boost::any>) == m["FileList"].type()) {
        vector<ListFilesResponseBodyFileList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FileList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListFilesResponseBodyFileList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fileList = make_shared<vector<ListFilesResponseBodyFileList>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListFilesResponseBody() = default;
};
class ListFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListFilesResponseBody> body{};

  ListFilesResponse() {}

  explicit ListFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListFilesResponse() = default;
};
class ListInstancesRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> bizType{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> maxBizDate{};
  shared_ptr<string> maxRunDate{};
  shared_ptr<string> minBizDate{};
  shared_ptr<string> minRunDate{};
  shared_ptr<string> nodeId{};
  shared_ptr<vector<string>> ownerList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> runStatusList{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> searchText{};
  shared_ptr<vector<string>> subBizTypeList{};

  ListInstancesRequestListQuery() {}

  explicit ListInstancesRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizType) {
      res["BizType"] = boost::any(*bizType);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (maxBizDate) {
      res["MaxBizDate"] = boost::any(*maxBizDate);
    }
    if (maxRunDate) {
      res["MaxRunDate"] = boost::any(*maxRunDate);
    }
    if (minBizDate) {
      res["MinBizDate"] = boost::any(*minBizDate);
    }
    if (minRunDate) {
      res["MinRunDate"] = boost::any(*minRunDate);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (ownerList) {
      res["OwnerList"] = boost::any(*ownerList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (runStatusList) {
      res["RunStatusList"] = boost::any(*runStatusList);
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (subBizTypeList) {
      res["SubBizTypeList"] = boost::any(*subBizTypeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizType") != m.end() && !m["BizType"].empty()) {
      bizType = make_shared<string>(boost::any_cast<string>(m["BizType"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("MaxBizDate") != m.end() && !m["MaxBizDate"].empty()) {
      maxBizDate = make_shared<string>(boost::any_cast<string>(m["MaxBizDate"]));
    }
    if (m.find("MaxRunDate") != m.end() && !m["MaxRunDate"].empty()) {
      maxRunDate = make_shared<string>(boost::any_cast<string>(m["MaxRunDate"]));
    }
    if (m.find("MinBizDate") != m.end() && !m["MinBizDate"].empty()) {
      minBizDate = make_shared<string>(boost::any_cast<string>(m["MinBizDate"]));
    }
    if (m.find("MinRunDate") != m.end() && !m["MinRunDate"].empty()) {
      minRunDate = make_shared<string>(boost::any_cast<string>(m["MinRunDate"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("RunStatusList") != m.end() && !m["RunStatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RunStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RunStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      runStatusList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("SubBizTypeList") != m.end() && !m["SubBizTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubBizTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubBizTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subBizTypeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListInstancesRequestListQuery() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<ListInstancesRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListInstancesRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListInstancesRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListInstancesShrinkRequest() {}

  explicit ListInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListInstancesShrinkRequest() = default;
};
class ListInstancesResponseBodyPageResultDataNodeInfoCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListInstancesResponseBodyPageResultDataNodeInfoCreator() {}

  explicit ListInstancesResponseBodyPageResultDataNodeInfoCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstancesResponseBodyPageResultDataNodeInfoCreator() = default;
};
class ListInstancesResponseBodyPageResultDataNodeInfoModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListInstancesResponseBodyPageResultDataNodeInfoModifier() {}

  explicit ListInstancesResponseBodyPageResultDataNodeInfoModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstancesResponseBodyPageResultDataNodeInfoModifier() = default;
};
class ListInstancesResponseBodyPageResultDataNodeInfoOwnerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListInstancesResponseBodyPageResultDataNodeInfoOwnerList() {}

  explicit ListInstancesResponseBodyPageResultDataNodeInfoOwnerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListInstancesResponseBodyPageResultDataNodeInfoOwnerList() = default;
};
class ListInstancesResponseBodyPageResultDataNodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitName{};
  shared_ptr<string> createTime{};
  shared_ptr<ListInstancesResponseBodyPageResultDataNodeInfoCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> from{};
  shared_ptr<bool> hasDev{};
  shared_ptr<bool> hasProd{};
  shared_ptr<string> id{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<ListInstancesResponseBodyPageResultDataNodeInfoModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListInstancesResponseBodyPageResultDataNodeInfoOwnerList>> ownerList{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<vector<string>> resourceGroupList{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> subDetailType{};
  shared_ptr<string> type{};

  ListInstancesResponseBodyPageResultDataNodeInfo() {}

  explicit ListInstancesResponseBodyPageResultDataNodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (hasDev) {
      res["HasDev"] = boost::any(*hasDev);
    }
    if (hasProd) {
      res["HasProd"] = boost::any(*hasProd);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerList) {
      vector<boost::any> temp1;
      for(auto item1:*ownerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OwnerList"] = boost::any(temp1);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (resourceGroupList) {
      res["ResourceGroupList"] = boost::any(*resourceGroupList);
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (subDetailType) {
      res["SubDetailType"] = boost::any(*subDetailType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        ListInstancesResponseBodyPageResultDataNodeInfoCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<ListInstancesResponseBodyPageResultDataNodeInfoCreator>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("HasDev") != m.end() && !m["HasDev"].empty()) {
      hasDev = make_shared<bool>(boost::any_cast<bool>(m["HasDev"]));
    }
    if (m.find("HasProd") != m.end() && !m["HasProd"].empty()) {
      hasProd = make_shared<bool>(boost::any_cast<bool>(m["HasProd"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        ListInstancesResponseBodyPageResultDataNodeInfoModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<ListInstancesResponseBodyPageResultDataNodeInfoModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<ListInstancesResponseBodyPageResultDataNodeInfoOwnerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OwnerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyPageResultDataNodeInfoOwnerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ownerList = make_shared<vector<ListInstancesResponseBodyPageResultDataNodeInfoOwnerList>>(expect1);
      }
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceGroupList") != m.end() && !m["ResourceGroupList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceGroupList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceGroupList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceGroupList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDetailType") != m.end() && !m["SubDetailType"].empty()) {
      subDetailType = make_shared<string>(boost::any_cast<string>(m["SubDetailType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListInstancesResponseBodyPageResultDataNodeInfo() = default;
};
class ListInstancesResponseBodyPageResultData : public Darabonba::Model {
public:
  shared_ptr<string> bizDate{};
  shared_ptr<string> dueTime{};
  shared_ptr<string> duration{};
  shared_ptr<long> endExecuteTime{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> id{};
  shared_ptr<long> index{};
  shared_ptr<ListInstancesResponseBodyPageResultDataNodeInfo> nodeInfo{};
  shared_ptr<long> startExecuteTime{};
  shared_ptr<vector<string>> statusList{};

  ListInstancesResponseBodyPageResultData() {}

  explicit ListInstancesResponseBodyPageResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizDate) {
      res["BizDate"] = boost::any(*bizDate);
    }
    if (dueTime) {
      res["DueTime"] = boost::any(*dueTime);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (endExecuteTime) {
      res["EndExecuteTime"] = boost::any(*endExecuteTime);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (nodeInfo) {
      res["NodeInfo"] = nodeInfo ? boost::any(nodeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (startExecuteTime) {
      res["StartExecuteTime"] = boost::any(*startExecuteTime);
    }
    if (statusList) {
      res["StatusList"] = boost::any(*statusList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizDate") != m.end() && !m["BizDate"].empty()) {
      bizDate = make_shared<string>(boost::any_cast<string>(m["BizDate"]));
    }
    if (m.find("DueTime") != m.end() && !m["DueTime"].empty()) {
      dueTime = make_shared<string>(boost::any_cast<string>(m["DueTime"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("EndExecuteTime") != m.end() && !m["EndExecuteTime"].empty()) {
      endExecuteTime = make_shared<long>(boost::any_cast<long>(m["EndExecuteTime"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("NodeInfo") != m.end() && !m["NodeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["NodeInfo"].type()) {
        ListInstancesResponseBodyPageResultDataNodeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NodeInfo"]));
        nodeInfo = make_shared<ListInstancesResponseBodyPageResultDataNodeInfo>(model1);
      }
    }
    if (m.find("StartExecuteTime") != m.end() && !m["StartExecuteTime"].empty()) {
      startExecuteTime = make_shared<long>(boost::any_cast<long>(m["StartExecuteTime"]));
    }
    if (m.find("StatusList") != m.end() && !m["StatusList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["StatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["StatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      statusList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListInstancesResponseBodyPageResultData() = default;
};
class ListInstancesResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyPageResultData>> data{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBodyPageResult() {}

  explicit ListInstancesResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListInstancesResponseBodyPageResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyPageResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListInstancesResponseBodyPageResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBodyPageResult() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListInstancesResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListInstancesResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListInstancesResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListNodeDownStreamRequestListQueryFilterList : public Darabonba::Model {
public:
  shared_ptr<bool> exclude{};
  shared_ptr<string> key{};
  shared_ptr<vector<string>> valueList{};

  ListNodeDownStreamRequestListQueryFilterList() {}

  explicit ListNodeDownStreamRequestListQueryFilterList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exclude) {
      res["Exclude"] = boost::any(*exclude);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (valueList) {
      res["ValueList"] = boost::any(*valueList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Exclude") != m.end() && !m["Exclude"].empty()) {
      exclude = make_shared<bool>(boost::any_cast<bool>(m["Exclude"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("ValueList") != m.end() && !m["ValueList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ValueList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ValueList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListNodeDownStreamRequestListQueryFilterList() = default;
};
class ListNodeDownStreamRequestListQueryNodeIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};

  ListNodeDownStreamRequestListQueryNodeIdList() {}

  explicit ListNodeDownStreamRequestListQueryNodeIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListNodeDownStreamRequestListQueryNodeIdList() = default;
};
class ListNodeDownStreamRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> downStreamDepth{};
  shared_ptr<vector<ListNodeDownStreamRequestListQueryFilterList>> filterList{};
  shared_ptr<vector<ListNodeDownStreamRequestListQueryNodeIdList>> nodeIdList{};
  shared_ptr<long> projectId{};

  ListNodeDownStreamRequestListQuery() {}

  explicit ListNodeDownStreamRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downStreamDepth) {
      res["DownStreamDepth"] = boost::any(*downStreamDepth);
    }
    if (filterList) {
      vector<boost::any> temp1;
      for(auto item1:*filterList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FilterList"] = boost::any(temp1);
    }
    if (nodeIdList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeIdList"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownStreamDepth") != m.end() && !m["DownStreamDepth"].empty()) {
      downStreamDepth = make_shared<long>(boost::any_cast<long>(m["DownStreamDepth"]));
    }
    if (m.find("FilterList") != m.end() && !m["FilterList"].empty()) {
      if (typeid(vector<boost::any>) == m["FilterList"].type()) {
        vector<ListNodeDownStreamRequestListQueryFilterList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FilterList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDownStreamRequestListQueryFilterList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        filterList = make_shared<vector<ListNodeDownStreamRequestListQueryFilterList>>(expect1);
      }
    }
    if (m.find("NodeIdList") != m.end() && !m["NodeIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeIdList"].type()) {
        vector<ListNodeDownStreamRequestListQueryNodeIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDownStreamRequestListQueryNodeIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeIdList = make_shared<vector<ListNodeDownStreamRequestListQueryNodeIdList>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ListNodeDownStreamRequestListQuery() = default;
};
class ListNodeDownStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<ListNodeDownStreamRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListNodeDownStreamRequest() {}

  explicit ListNodeDownStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListNodeDownStreamRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListNodeDownStreamRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListNodeDownStreamRequest() = default;
};
class ListNodeDownStreamShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListNodeDownStreamShrinkRequest() {}

  explicit ListNodeDownStreamShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListNodeDownStreamShrinkRequest() = default;
};
class ListNodeDownStreamResponseBodyNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> depth{};
  shared_ptr<vector<string>> fieldIdList{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListNodeDownStreamResponseBodyNodeInfoList() {}

  explicit ListNodeDownStreamResponseBodyNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (depth) {
      res["Depth"] = boost::any(*depth);
    }
    if (fieldIdList) {
      res["FieldIdList"] = boost::any(*fieldIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Depth") != m.end() && !m["Depth"].empty()) {
      depth = make_shared<long>(boost::any_cast<long>(m["Depth"]));
    }
    if (m.find("FieldIdList") != m.end() && !m["FieldIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodeDownStreamResponseBodyNodeInfoList() = default;
};
class ListNodeDownStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<ListNodeDownStreamResponseBodyNodeInfoList>> nodeInfoList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListNodeDownStreamResponseBody() {}

  explicit ListNodeDownStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<ListNodeDownStreamResponseBodyNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodeDownStreamResponseBodyNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<ListNodeDownStreamResponseBodyNodeInfoList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListNodeDownStreamResponseBody() = default;
};
class ListNodeDownStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodeDownStreamResponseBody> body{};

  ListNodeDownStreamResponse() {}

  explicit ListNodeDownStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodeDownStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodeDownStreamResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodeDownStreamResponse() = default;
};
class ListNodesRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> nodeBizType{};
  shared_ptr<vector<string>> nodeSubBizTypeList{};
  shared_ptr<vector<string>> ownerList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<long> projectId{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> scheduleType{};
  shared_ptr<string> searchText{};

  ListNodesRequestListQuery() {}

  explicit ListNodesRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (nodeBizType) {
      res["NodeBizType"] = boost::any(*nodeBizType);
    }
    if (nodeSubBizTypeList) {
      res["NodeSubBizTypeList"] = boost::any(*nodeSubBizTypeList);
    }
    if (ownerList) {
      res["OwnerList"] = boost::any(*ownerList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (scheduleType) {
      res["ScheduleType"] = boost::any(*scheduleType);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("NodeBizType") != m.end() && !m["NodeBizType"].empty()) {
      nodeBizType = make_shared<string>(boost::any_cast<string>(m["NodeBizType"]));
    }
    if (m.find("NodeSubBizTypeList") != m.end() && !m["NodeSubBizTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeSubBizTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeSubBizTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeSubBizTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OwnerList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ownerList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ScheduleType") != m.end() && !m["ScheduleType"].empty()) {
      scheduleType = make_shared<string>(boost::any_cast<string>(m["ScheduleType"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
  }


  virtual ~ListNodesRequestListQuery() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<ListNodesRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListNodesRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListNodesRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListNodesShrinkRequest() {}

  explicit ListNodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListNodesShrinkRequest() = default;
};
class ListNodesResponseBodyPageResultNodeListCreator : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListNodesResponseBodyPageResultNodeListCreator() {}

  explicit ListNodesResponseBodyPageResultNodeListCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResultNodeListCreator() = default;
};
class ListNodesResponseBodyPageResultNodeListModifier : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListNodesResponseBodyPageResultNodeListModifier() {}

  explicit ListNodesResponseBodyPageResultNodeListModifier(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResultNodeListModifier() = default;
};
class ListNodesResponseBodyPageResultNodeListOwnerList : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListNodesResponseBodyPageResultNodeListOwnerList() {}

  explicit ListNodesResponseBodyPageResultNodeListOwnerList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResultNodeListOwnerList() = default;
};
class ListNodesResponseBodyPageResultNodeListProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListNodesResponseBodyPageResultNodeListProjectInfo() {}

  explicit ListNodesResponseBodyPageResultNodeListProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResultNodeListProjectInfo() = default;
};
class ListNodesResponseBodyPageResultNodeList : public Darabonba::Model {
public:
  shared_ptr<string> bizUnitName{};
  shared_ptr<string> createTime{};
  shared_ptr<ListNodesResponseBodyPageResultNodeListCreator> creator{};
  shared_ptr<string> description{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> extendInfo{};
  shared_ptr<string> from{};
  shared_ptr<bool> hasDev{};
  shared_ptr<bool> hasProd{};
  shared_ptr<string> id{};
  shared_ptr<string> lastModifiedTime{};
  shared_ptr<ListNodesResponseBodyPageResultNodeListModifier> modifier{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListNodesResponseBodyPageResultNodeListOwnerList>> ownerList{};
  shared_ptr<vector<string>> priorityList{};
  shared_ptr<ListNodesResponseBodyPageResultNodeListProjectInfo> projectInfo{};
  shared_ptr<bool> schedulePaused{};
  shared_ptr<vector<string>> schedulePeriodList{};
  shared_ptr<string> subDetailType{};
  shared_ptr<string> type{};

  ListNodesResponseBodyPageResultNodeList() {}

  explicit ListNodesResponseBodyPageResultNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitName) {
      res["BizUnitName"] = boost::any(*bizUnitName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (extendInfo) {
      res["ExtendInfo"] = boost::any(*extendInfo);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (hasDev) {
      res["HasDev"] = boost::any(*hasDev);
    }
    if (hasProd) {
      res["HasProd"] = boost::any(*hasProd);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (lastModifiedTime) {
      res["LastModifiedTime"] = boost::any(*lastModifiedTime);
    }
    if (modifier) {
      res["Modifier"] = modifier ? boost::any(modifier->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerList) {
      vector<boost::any> temp1;
      for(auto item1:*ownerList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OwnerList"] = boost::any(temp1);
    }
    if (priorityList) {
      res["PriorityList"] = boost::any(*priorityList);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulePaused) {
      res["SchedulePaused"] = boost::any(*schedulePaused);
    }
    if (schedulePeriodList) {
      res["SchedulePeriodList"] = boost::any(*schedulePeriodList);
    }
    if (subDetailType) {
      res["SubDetailType"] = boost::any(*subDetailType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitName") != m.end() && !m["BizUnitName"].empty()) {
      bizUnitName = make_shared<string>(boost::any_cast<string>(m["BizUnitName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        ListNodesResponseBodyPageResultNodeListCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<ListNodesResponseBodyPageResultNodeListCreator>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ExtendInfo") != m.end() && !m["ExtendInfo"].empty()) {
      extendInfo = make_shared<string>(boost::any_cast<string>(m["ExtendInfo"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("HasDev") != m.end() && !m["HasDev"].empty()) {
      hasDev = make_shared<bool>(boost::any_cast<bool>(m["HasDev"]));
    }
    if (m.find("HasProd") != m.end() && !m["HasProd"].empty()) {
      hasProd = make_shared<bool>(boost::any_cast<bool>(m["HasProd"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("LastModifiedTime") != m.end() && !m["LastModifiedTime"].empty()) {
      lastModifiedTime = make_shared<string>(boost::any_cast<string>(m["LastModifiedTime"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      if (typeid(map<string, boost::any>) == m["Modifier"].type()) {
        ListNodesResponseBodyPageResultNodeListModifier model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Modifier"]));
        modifier = make_shared<ListNodesResponseBodyPageResultNodeListModifier>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerList") != m.end() && !m["OwnerList"].empty()) {
      if (typeid(vector<boost::any>) == m["OwnerList"].type()) {
        vector<ListNodesResponseBodyPageResultNodeListOwnerList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OwnerList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPageResultNodeListOwnerList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ownerList = make_shared<vector<ListNodesResponseBodyPageResultNodeListOwnerList>>(expect1);
      }
    }
    if (m.find("PriorityList") != m.end() && !m["PriorityList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PriorityList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PriorityList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      priorityList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        ListNodesResponseBodyPageResultNodeListProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<ListNodesResponseBodyPageResultNodeListProjectInfo>(model1);
      }
    }
    if (m.find("SchedulePaused") != m.end() && !m["SchedulePaused"].empty()) {
      schedulePaused = make_shared<bool>(boost::any_cast<bool>(m["SchedulePaused"]));
    }
    if (m.find("SchedulePeriodList") != m.end() && !m["SchedulePeriodList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SchedulePeriodList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SchedulePeriodList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      schedulePeriodList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SubDetailType") != m.end() && !m["SubDetailType"].empty()) {
      subDetailType = make_shared<string>(boost::any_cast<string>(m["SubDetailType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResultNodeList() = default;
};
class ListNodesResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListNodesResponseBodyPageResultNodeList>> nodeList{};
  shared_ptr<long> totalCount{};

  ListNodesResponseBodyPageResult() {}

  explicit ListNodesResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeList") != m.end() && !m["NodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeList"].type()) {
        vector<ListNodesResponseBodyPageResultNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyPageResultNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeList = make_shared<vector<ListNodesResponseBodyPageResultNodeList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListNodesResponseBodyPageResult() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListNodesResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListNodesResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListNodesResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListPublishRecordsRequestListQuerySearchFilter : public Darabonba::Model {
public:
  shared_ptr<vector<long>> changeTypeList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<long>> projectIdList{};
  shared_ptr<string> publishEndTime{};
  shared_ptr<string> publishStartTime{};
  shared_ptr<vector<long>> publishStatusList{};
  shared_ptr<vector<string>> submitterList{};

  ListPublishRecordsRequestListQuerySearchFilter() {}

  explicit ListPublishRecordsRequestListQuerySearchFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTypeList) {
      res["ChangeTypeList"] = boost::any(*changeTypeList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectIdList) {
      res["ProjectIdList"] = boost::any(*projectIdList);
    }
    if (publishEndTime) {
      res["PublishEndTime"] = boost::any(*publishEndTime);
    }
    if (publishStartTime) {
      res["PublishStartTime"] = boost::any(*publishStartTime);
    }
    if (publishStatusList) {
      res["PublishStatusList"] = boost::any(*publishStatusList);
    }
    if (submitterList) {
      res["SubmitterList"] = boost::any(*submitterList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeTypeList") != m.end() && !m["ChangeTypeList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ChangeTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChangeTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      changeTypeList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectIdList") != m.end() && !m["ProjectIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("PublishEndTime") != m.end() && !m["PublishEndTime"].empty()) {
      publishEndTime = make_shared<string>(boost::any_cast<string>(m["PublishEndTime"]));
    }
    if (m.find("PublishStartTime") != m.end() && !m["PublishStartTime"].empty()) {
      publishStartTime = make_shared<string>(boost::any_cast<string>(m["PublishStartTime"]));
    }
    if (m.find("PublishStatusList") != m.end() && !m["PublishStatusList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PublishStatusList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PublishStatusList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      publishStatusList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SubmitterList") != m.end() && !m["SubmitterList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubmitterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubmitterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      submitterList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListPublishRecordsRequestListQuerySearchFilter() = default;
};
class ListPublishRecordsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<ListPublishRecordsRequestListQuerySearchFilter> searchFilter{};

  ListPublishRecordsRequestListQuery() {}

  explicit ListPublishRecordsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (searchFilter) {
      res["SearchFilter"] = searchFilter ? boost::any(searchFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("SearchFilter") != m.end() && !m["SearchFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchFilter"].type()) {
        ListPublishRecordsRequestListQuerySearchFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchFilter"]));
        searchFilter = make_shared<ListPublishRecordsRequestListQuerySearchFilter>(model1);
      }
    }
  }


  virtual ~ListPublishRecordsRequestListQuery() = default;
};
class ListPublishRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<ListPublishRecordsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListPublishRecordsRequest() {}

  explicit ListPublishRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListPublishRecordsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListPublishRecordsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListPublishRecordsRequest() = default;
};
class ListPublishRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListPublishRecordsShrinkRequest() {}

  explicit ListPublishRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListPublishRecordsShrinkRequest() = default;
};
class ListPublishRecordsResponseBodyListResultData : public Darabonba::Model {
public:
  shared_ptr<long> changeType{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<long> id{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> objectVersion{};
  shared_ptr<string> projectId{};
  shared_ptr<string> publishName{};
  shared_ptr<long> publishStatus{};
  shared_ptr<string> publisher{};
  shared_ptr<string> publisherName{};

  ListPublishRecordsResponseBodyListResultData() {}

  explicit ListPublishRecordsResponseBodyListResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (objectVersion) {
      res["ObjectVersion"] = boost::any(*objectVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (publishName) {
      res["PublishName"] = boost::any(*publishName);
    }
    if (publishStatus) {
      res["PublishStatus"] = boost::any(*publishStatus);
    }
    if (publisher) {
      res["Publisher"] = boost::any(*publisher);
    }
    if (publisherName) {
      res["PublisherName"] = boost::any(*publisherName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["ChangeType"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ObjectVersion") != m.end() && !m["ObjectVersion"].empty()) {
      objectVersion = make_shared<string>(boost::any_cast<string>(m["ObjectVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("PublishName") != m.end() && !m["PublishName"].empty()) {
      publishName = make_shared<string>(boost::any_cast<string>(m["PublishName"]));
    }
    if (m.find("PublishStatus") != m.end() && !m["PublishStatus"].empty()) {
      publishStatus = make_shared<long>(boost::any_cast<long>(m["PublishStatus"]));
    }
    if (m.find("Publisher") != m.end() && !m["Publisher"].empty()) {
      publisher = make_shared<string>(boost::any_cast<string>(m["Publisher"]));
    }
    if (m.find("PublisherName") != m.end() && !m["PublisherName"].empty()) {
      publisherName = make_shared<string>(boost::any_cast<string>(m["PublisherName"]));
    }
  }


  virtual ~ListPublishRecordsResponseBodyListResultData() = default;
};
class ListPublishRecordsResponseBodyListResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListPublishRecordsResponseBodyListResultData>> data{};
  shared_ptr<long> totalCount{};

  ListPublishRecordsResponseBodyListResult() {}

  explicit ListPublishRecordsResponseBodyListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPublishRecordsResponseBodyListResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPublishRecordsResponseBodyListResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPublishRecordsResponseBodyListResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPublishRecordsResponseBodyListResult() = default;
};
class ListPublishRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListPublishRecordsResponseBodyListResult> listResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListPublishRecordsResponseBody() {}

  explicit ListPublishRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (listResult) {
      res["ListResult"] = listResult ? boost::any(listResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ListResult") != m.end() && !m["ListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListResult"].type()) {
        ListPublishRecordsResponseBodyListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListResult"]));
        listResult = make_shared<ListPublishRecordsResponseBodyListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListPublishRecordsResponseBody() = default;
};
class ListPublishRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPublishRecordsResponseBody> body{};

  ListPublishRecordsResponse() {}

  explicit ListPublishRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPublishRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPublishRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPublishRecordsResponse() = default;
};
class ListResourcePermissionOperationLogRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchText{};
  shared_ptr<string> tabType{};

  ListResourcePermissionOperationLogRequestListQuery() {}

  explicit ListResourcePermissionOperationLogRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (tabType) {
      res["TabType"] = boost::any(*tabType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("TabType") != m.end() && !m["TabType"].empty()) {
      tabType = make_shared<string>(boost::any_cast<string>(m["TabType"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogRequestListQuery() = default;
};
class ListResourcePermissionOperationLogRequest : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionOperationLogRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListResourcePermissionOperationLogRequest() {}

  explicit ListResourcePermissionOperationLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListResourcePermissionOperationLogRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListResourcePermissionOperationLogRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogRequest() = default;
};
class ListResourcePermissionOperationLogShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListResourcePermissionOperationLogShrinkRequest() {}

  explicit ListResourcePermissionOperationLogShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogShrinkRequest() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataAccount : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataAccount() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataAccount() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> type{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo> bizUnitInfo{};
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo> projectInfo{};
  shared_ptr<string> type{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitInfo) {
      res["BizUnitInfo"] = bizUnitInfo ? boost::any(bizUnitInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitInfo") != m.end() && !m["BizUnitInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizUnitInfo"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizUnitInfo"]));
        bizUnitInfo = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoBizUnitInfo>(model1);
      }
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfoProjectInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResultData : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataAccount> account{};
  shared_ptr<string> authScope{};
  shared_ptr<long> operateId{};
  shared_ptr<long> operateTime{};
  shared_ptr<string> operateType{};
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod> period{};
  shared_ptr<string> reason{};
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo> resourceInfo{};
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount> targetAccount{};

  ListResourcePermissionOperationLogResponseBodyPageResultData() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = account ? boost::any(account->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (authScope) {
      res["AuthScope"] = boost::any(*authScope);
    }
    if (operateId) {
      res["OperateId"] = boost::any(*operateId);
    }
    if (operateTime) {
      res["OperateTime"] = boost::any(*operateTime);
    }
    if (operateType) {
      res["OperateType"] = boost::any(*operateType);
    }
    if (period) {
      res["Period"] = period ? boost::any(period->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = resourceInfo ? boost::any(resourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetAccount) {
      res["TargetAccount"] = targetAccount ? boost::any(targetAccount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      if (typeid(map<string, boost::any>) == m["Account"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Account"]));
        account = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataAccount>(model1);
      }
    }
    if (m.find("AuthScope") != m.end() && !m["AuthScope"].empty()) {
      authScope = make_shared<string>(boost::any_cast<string>(m["AuthScope"]));
    }
    if (m.find("OperateId") != m.end() && !m["OperateId"].empty()) {
      operateId = make_shared<long>(boost::any_cast<long>(m["OperateId"]));
    }
    if (m.find("OperateTime") != m.end() && !m["OperateTime"].empty()) {
      operateTime = make_shared<long>(boost::any_cast<long>(m["OperateTime"]));
    }
    if (m.find("OperateType") != m.end() && !m["OperateType"].empty()) {
      operateType = make_shared<string>(boost::any_cast<string>(m["OperateType"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      if (typeid(map<string, boost::any>) == m["Period"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Period"]));
        period = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataPeriod>(model1);
      }
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInfo"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInfo"]));
        resourceInfo = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataResourceInfo>(model1);
      }
    }
    if (m.find("TargetAccount") != m.end() && !m["TargetAccount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetAccount"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetAccount"]));
        targetAccount = make_shared<ListResourcePermissionOperationLogResponseBodyPageResultDataTargetAccount>(model1);
      }
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResultData() = default;
};
class ListResourcePermissionOperationLogResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePermissionOperationLogResponseBodyPageResultData>> data{};
  shared_ptr<long> totalCount{};

  ListResourcePermissionOperationLogResponseBodyPageResult() {}

  explicit ListResourcePermissionOperationLogResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListResourcePermissionOperationLogResponseBodyPageResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePermissionOperationLogResponseBodyPageResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListResourcePermissionOperationLogResponseBodyPageResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBodyPageResult() = default;
};
class ListResourcePermissionOperationLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListResourcePermissionOperationLogResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListResourcePermissionOperationLogResponseBody() {}

  explicit ListResourcePermissionOperationLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListResourcePermissionOperationLogResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListResourcePermissionOperationLogResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListResourcePermissionOperationLogResponseBody() = default;
};
class ListResourcePermissionOperationLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcePermissionOperationLogResponseBody> body{};

  ListResourcePermissionOperationLogResponse() {}

  explicit ListResourcePermissionOperationLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcePermissionOperationLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcePermissionOperationLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcePermissionOperationLogResponse() = default;
};
class ListResourcePermissionsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchText{};
  shared_ptr<string> tabType{};

  ListResourcePermissionsRequestListQuery() {}

  explicit ListResourcePermissionsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (tabType) {
      res["TabType"] = boost::any(*tabType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("TabType") != m.end() && !m["TabType"].empty()) {
      tabType = make_shared<string>(boost::any_cast<string>(m["TabType"]));
    }
  }


  virtual ~ListResourcePermissionsRequestListQuery() = default;
};
class ListResourcePermissionsRequest : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListResourcePermissionsRequest() {}

  explicit ListResourcePermissionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListResourcePermissionsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListResourcePermissionsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListResourcePermissionsRequest() = default;
};
class ListResourcePermissionsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListResourcePermissionsShrinkRequest() {}

  explicit ListResourcePermissionsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListResourcePermissionsShrinkRequest() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataPeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> type{};

  ListResourcePermissionsResponseBodyPageResultDataPeriod() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataPeriod() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> type{};

  ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod> period{};
  shared_ptr<string> permissionType{};

  ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (period) {
      res["Period"] = period ? boost::any(period->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (permissionType) {
      res["PermissionType"] = boost::any(*permissionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      if (typeid(map<string, boost::any>) == m["Period"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Period"]));
        period = make_shared<ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodListPeriod>(model1);
      }
    }
    if (m.find("PermissionType") != m.end() && !m["PermissionType"].empty()) {
      permissionType = make_shared<string>(boost::any_cast<string>(m["PermissionType"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataResourceInfo : public Darabonba::Model {
public:
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo> bizUnitInfo{};
  shared_ptr<string> displayName{};
  shared_ptr<string> env{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo> projectInfo{};
  shared_ptr<string> type{};

  ListResourcePermissionsResponseBodyPageResultDataResourceInfo() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataResourceInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitInfo) {
      res["BizUnitInfo"] = bizUnitInfo ? boost::any(bizUnitInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectInfo) {
      res["ProjectInfo"] = projectInfo ? boost::any(projectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitInfo") != m.end() && !m["BizUnitInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizUnitInfo"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizUnitInfo"]));
        bizUnitInfo = make_shared<ListResourcePermissionsResponseBodyPageResultDataResourceInfoBizUnitInfo>(model1);
      }
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectInfo") != m.end() && !m["ProjectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ProjectInfo"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ProjectInfo"]));
        projectInfo = make_shared<ListResourcePermissionsResponseBodyPageResultDataResourceInfoProjectInfo>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataResourceInfo() = default;
};
class ListResourcePermissionsResponseBodyPageResultDataTargetAccount : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};

  ListResourcePermissionsResponseBodyPageResultDataTargetAccount() {}

  explicit ListResourcePermissionsResponseBodyPageResultDataTargetAccount(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultDataTargetAccount() = default;
};
class ListResourcePermissionsResponseBodyPageResultData : public Darabonba::Model {
public:
  shared_ptr<string> authScope{};
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataPeriod> period{};
  shared_ptr<vector<ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList>> permissionPeriodList{};
  shared_ptr<string> recordId{};
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataResourceInfo> resourceInfo{};
  shared_ptr<ListResourcePermissionsResponseBodyPageResultDataTargetAccount> targetAccount{};

  ListResourcePermissionsResponseBodyPageResultData() {}

  explicit ListResourcePermissionsResponseBodyPageResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authScope) {
      res["AuthScope"] = boost::any(*authScope);
    }
    if (period) {
      res["Period"] = period ? boost::any(period->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (permissionPeriodList) {
      vector<boost::any> temp1;
      for(auto item1:*permissionPeriodList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PermissionPeriodList"] = boost::any(temp1);
    }
    if (recordId) {
      res["RecordId"] = boost::any(*recordId);
    }
    if (resourceInfo) {
      res["ResourceInfo"] = resourceInfo ? boost::any(resourceInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (targetAccount) {
      res["TargetAccount"] = targetAccount ? boost::any(targetAccount->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthScope") != m.end() && !m["AuthScope"].empty()) {
      authScope = make_shared<string>(boost::any_cast<string>(m["AuthScope"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      if (typeid(map<string, boost::any>) == m["Period"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Period"]));
        period = make_shared<ListResourcePermissionsResponseBodyPageResultDataPeriod>(model1);
      }
    }
    if (m.find("PermissionPeriodList") != m.end() && !m["PermissionPeriodList"].empty()) {
      if (typeid(vector<boost::any>) == m["PermissionPeriodList"].type()) {
        vector<ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PermissionPeriodList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        permissionPeriodList = make_shared<vector<ListResourcePermissionsResponseBodyPageResultDataPermissionPeriodList>>(expect1);
      }
    }
    if (m.find("RecordId") != m.end() && !m["RecordId"].empty()) {
      recordId = make_shared<string>(boost::any_cast<string>(m["RecordId"]));
    }
    if (m.find("ResourceInfo") != m.end() && !m["ResourceInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResourceInfo"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataResourceInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResourceInfo"]));
        resourceInfo = make_shared<ListResourcePermissionsResponseBodyPageResultDataResourceInfo>(model1);
      }
    }
    if (m.find("TargetAccount") != m.end() && !m["TargetAccount"].empty()) {
      if (typeid(map<string, boost::any>) == m["TargetAccount"].type()) {
        ListResourcePermissionsResponseBodyPageResultDataTargetAccount model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TargetAccount"]));
        targetAccount = make_shared<ListResourcePermissionsResponseBodyPageResultDataTargetAccount>(model1);
      }
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResultData() = default;
};
class ListResourcePermissionsResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListResourcePermissionsResponseBodyPageResultData>> data{};
  shared_ptr<long> totalCount{};

  ListResourcePermissionsResponseBodyPageResult() {}

  explicit ListResourcePermissionsResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListResourcePermissionsResponseBodyPageResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListResourcePermissionsResponseBodyPageResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListResourcePermissionsResponseBodyPageResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBodyPageResult() = default;
};
class ListResourcePermissionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListResourcePermissionsResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListResourcePermissionsResponseBody() {}

  explicit ListResourcePermissionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListResourcePermissionsResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListResourcePermissionsResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListResourcePermissionsResponseBody() = default;
};
class ListResourcePermissionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListResourcePermissionsResponseBody> body{};

  ListResourcePermissionsResponse() {}

  explicit ListResourcePermissionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListResourcePermissionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListResourcePermissionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListResourcePermissionsResponse() = default;
};
class ListRowPermissionRequestPageRowPermissionQuery : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListRowPermissionRequestPageRowPermissionQuery() {}

  explicit ListRowPermissionRequestPageRowPermissionQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRowPermissionRequestPageRowPermissionQuery() = default;
};
class ListRowPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<ListRowPermissionRequestPageRowPermissionQuery> pageRowPermissionQuery{};

  ListRowPermissionRequest() {}

  explicit ListRowPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pageRowPermissionQuery) {
      res["PageRowPermissionQuery"] = pageRowPermissionQuery ? boost::any(pageRowPermissionQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PageRowPermissionQuery") != m.end() && !m["PageRowPermissionQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageRowPermissionQuery"].type()) {
        ListRowPermissionRequestPageRowPermissionQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageRowPermissionQuery"]));
        pageRowPermissionQuery = make_shared<ListRowPermissionRequestPageRowPermissionQuery>(model1);
      }
    }
  }


  virtual ~ListRowPermissionRequest() = default;
};
class ListRowPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> pageRowPermissionQueryShrink{};

  ListRowPermissionShrinkRequest() {}

  explicit ListRowPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pageRowPermissionQueryShrink) {
      res["PageRowPermissionQuery"] = boost::any(*pageRowPermissionQueryShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PageRowPermissionQuery") != m.end() && !m["PageRowPermissionQuery"].empty()) {
      pageRowPermissionQueryShrink = make_shared<string>(boost::any_cast<string>(m["PageRowPermissionQuery"]));
    }
  }


  virtual ~ListRowPermissionShrinkRequest() = default;
};
class ListRowPermissionResponseBodyPageResultDataMappingColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnDesc{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};

  ListRowPermissionResponseBodyPageResultDataMappingColumns() {}

  explicit ListRowPermissionResponseBodyPageResultDataMappingColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnDesc) {
      res["ColumnDesc"] = boost::any(*columnDesc);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnDesc") != m.end() && !m["ColumnDesc"].empty()) {
      columnDesc = make_shared<string>(boost::any_cast<string>(m["ColumnDesc"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataMappingColumns() = default;
};
class ListRowPermissionResponseBodyPageResultDataRulesExpressions : public Darabonba::Model {
public:
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<boost::any>> subConditions{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  ListRowPermissionResponseBodyPageResultDataRulesExpressions() {}

  explicit ListRowPermissionResponseBodyPageResultDataRulesExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (subConditions) {
      res["SubConditions"] = boost::any(*subConditions);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SubConditions") != m.end() && !m["SubConditions"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubConditions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubConditions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subConditions = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataRulesExpressions() = default;
};
class ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts() {}

  explicit ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts() = default;
};
class ListRowPermissionResponseBodyPageResultDataRulesUserMappingList : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts>> accounts{};

  ListRowPermissionResponseBodyPageResultDataRulesUserMappingList() {}

  explicit ListRowPermissionResponseBodyPageResultDataRulesUserMappingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingListAccounts>>(expect1);
      }
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataRulesUserMappingList() = default;
};
class ListRowPermissionResponseBodyPageResultDataRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataRulesExpressions>> expressions{};
  shared_ptr<bool> isDelete{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> scopeType{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingList>> userMappingList{};

  ListRowPermissionResponseBodyPageResultDataRules() {}

  explicit ListRowPermissionResponseBodyPageResultDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userMappingList) {
      vector<boost::any> temp1;
      for(auto item1:*userMappingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserMappingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataRulesExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataRulesExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<ListRowPermissionResponseBodyPageResultDataRulesExpressions>>(expect1);
      }
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<bool>(boost::any_cast<bool>(m["IsDelete"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserMappingList") != m.end() && !m["UserMappingList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserMappingList"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserMappingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataRulesUserMappingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userMappingList = make_shared<vector<ListRowPermissionResponseBodyPageResultDataRulesUserMappingList>>(expect1);
      }
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataRules() = default;
};
class ListRowPermissionResponseBodyPageResultDataTables : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> resourceId{};

  ListRowPermissionResponseBodyPageResultDataTables() {}

  explicit ListRowPermissionResponseBodyPageResultDataTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultDataTables() = default;
};
class ListRowPermissionResponseBodyPageResultData : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataMappingColumns>> mappingColumns{};
  shared_ptr<string> modifier{};
  shared_ptr<string> rowPermissionDesc{};
  shared_ptr<long> rowPermissionId{};
  shared_ptr<string> rowPermissionName{};
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataRules>> rules{};
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultDataTables>> tables{};
  shared_ptr<long> tenantId{};

  ListRowPermissionResponseBodyPageResultData() {}

  explicit ListRowPermissionResponseBodyPageResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (mappingColumns) {
      vector<boost::any> temp1;
      for(auto item1:*mappingColumns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MappingColumns"] = boost::any(temp1);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (rowPermissionDesc) {
      res["RowPermissionDesc"] = boost::any(*rowPermissionDesc);
    }
    if (rowPermissionId) {
      res["RowPermissionId"] = boost::any(*rowPermissionId);
    }
    if (rowPermissionName) {
      res["RowPermissionName"] = boost::any(*rowPermissionName);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("MappingColumns") != m.end() && !m["MappingColumns"].empty()) {
      if (typeid(vector<boost::any>) == m["MappingColumns"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataMappingColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MappingColumns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataMappingColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mappingColumns = make_shared<vector<ListRowPermissionResponseBodyPageResultDataMappingColumns>>(expect1);
      }
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("RowPermissionDesc") != m.end() && !m["RowPermissionDesc"].empty()) {
      rowPermissionDesc = make_shared<string>(boost::any_cast<string>(m["RowPermissionDesc"]));
    }
    if (m.find("RowPermissionId") != m.end() && !m["RowPermissionId"].empty()) {
      rowPermissionId = make_shared<long>(boost::any_cast<long>(m["RowPermissionId"]));
    }
    if (m.find("RowPermissionName") != m.end() && !m["RowPermissionName"].empty()) {
      rowPermissionName = make_shared<string>(boost::any_cast<string>(m["RowPermissionName"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListRowPermissionResponseBodyPageResultDataRules>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListRowPermissionResponseBodyPageResultDataTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultDataTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListRowPermissionResponseBodyPageResultDataTables>>(expect1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResultData() = default;
};
class ListRowPermissionResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListRowPermissionResponseBodyPageResultData>> data{};
  shared_ptr<long> totalCount{};

  ListRowPermissionResponseBodyPageResult() {}

  explicit ListRowPermissionResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListRowPermissionResponseBodyPageResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionResponseBodyPageResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRowPermissionResponseBodyPageResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRowPermissionResponseBodyPageResult() = default;
};
class ListRowPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListRowPermissionResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListRowPermissionResponseBody() {}

  explicit ListRowPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListRowPermissionResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListRowPermissionResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRowPermissionResponseBody() = default;
};
class ListRowPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRowPermissionResponseBody> body{};

  ListRowPermissionResponse() {}

  explicit ListRowPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRowPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRowPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ListRowPermissionResponse() = default;
};
class ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery : public Darabonba::Model {
public:
  shared_ptr<string> operator_{};
  shared_ptr<long> pageNum{};
  shared_ptr<long> pageSize{};

  ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery() {}

  explicit ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (pageNum) {
      res["PageNum"] = boost::any(*pageNum);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("PageNum") != m.end() && !m["PageNum"].empty()) {
      pageNum = make_shared<long>(boost::any_cast<long>(m["PageNum"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery() = default;
};
class ListRowPermissionByUserIdRequest : public Darabonba::Model {
public:
  shared_ptr<ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery> listRowPermissionByUserIdQuery{};
  shared_ptr<long> opTenantId{};

  ListRowPermissionByUserIdRequest() {}

  explicit ListRowPermissionByUserIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listRowPermissionByUserIdQuery) {
      res["ListRowPermissionByUserIdQuery"] = listRowPermissionByUserIdQuery ? boost::any(listRowPermissionByUserIdQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListRowPermissionByUserIdQuery") != m.end() && !m["ListRowPermissionByUserIdQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListRowPermissionByUserIdQuery"].type()) {
        ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListRowPermissionByUserIdQuery"]));
        listRowPermissionByUserIdQuery = make_shared<ListRowPermissionByUserIdRequestListRowPermissionByUserIdQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListRowPermissionByUserIdRequest() = default;
};
class ListRowPermissionByUserIdShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listRowPermissionByUserIdQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListRowPermissionByUserIdShrinkRequest() {}

  explicit ListRowPermissionByUserIdShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listRowPermissionByUserIdQueryShrink) {
      res["ListRowPermissionByUserIdQuery"] = boost::any(*listRowPermissionByUserIdQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListRowPermissionByUserIdQuery") != m.end() && !m["ListRowPermissionByUserIdQuery"].empty()) {
      listRowPermissionByUserIdQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListRowPermissionByUserIdQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListRowPermissionByUserIdShrinkRequest() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions : public Darabonba::Model {
public:
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<boost::any>> subConditions{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (subConditions) {
      res["SubConditions"] = boost::any(*subConditions);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SubConditions") != m.end() && !m["SubConditions"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubConditions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubConditions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subConditions = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts>> accounts{};

  ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingListAccounts>>(expect1);
      }
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultDataRules : public Darabonba::Model {
public:
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions>> expressions{};
  shared_ptr<bool> isDelete{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> scopeType{};
  shared_ptr<long> status{};
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList>> userMappingList{};

  ListRowPermissionByUserIdResponseBodyPageResultDataRules() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultDataRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userMappingList) {
      vector<boost::any> temp1;
      for(auto item1:*userMappingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserMappingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesExpressions>>(expect1);
      }
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<bool>(boost::any_cast<bool>(m["IsDelete"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserMappingList") != m.end() && !m["UserMappingList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserMappingList"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserMappingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userMappingList = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRulesUserMappingList>>(expect1);
      }
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultDataRules() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultDataTables : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> resourceId{};

  ListRowPermissionByUserIdResponseBodyPageResultDataTables() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultDataTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultDataTables() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResultData : public Darabonba::Model {
public:
  shared_ptr<string> creator{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> modifier{};
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRules>> rules{};
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultDataTables>> tables{};
  shared_ptr<long> tenantId{};

  ListRowPermissionByUserIdResponseBodyPageResultData() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (modifier) {
      res["Modifier"] = boost::any(*modifier);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Modifier") != m.end() && !m["Modifier"].empty()) {
      modifier = make_shared<string>(boost::any_cast<string>(m["Modifier"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultDataRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultDataRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultDataRules>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultDataTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultDataTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultDataTables>>(expect1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<long>(boost::any_cast<long>(m["TenantId"]));
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResultData() = default;
};
class ListRowPermissionByUserIdResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListRowPermissionByUserIdResponseBodyPageResultData>> data{};
  shared_ptr<long> totalCount{};

  ListRowPermissionByUserIdResponseBodyPageResult() {}

  explicit ListRowPermissionByUserIdResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListRowPermissionByUserIdResponseBodyPageResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRowPermissionByUserIdResponseBodyPageResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRowPermissionByUserIdResponseBodyPageResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBodyPageResult() = default;
};
class ListRowPermissionByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListRowPermissionByUserIdResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListRowPermissionByUserIdResponseBody() {}

  explicit ListRowPermissionByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListRowPermissionByUserIdResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListRowPermissionByUserIdResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListRowPermissionByUserIdResponseBody() = default;
};
class ListRowPermissionByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRowPermissionByUserIdResponseBody> body{};

  ListRowPermissionByUserIdResponse() {}

  explicit ListRowPermissionByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRowPermissionByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRowPermissionByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListRowPermissionByUserIdResponse() = default;
};
class ListSubmitRecordsRequestListQuerySearchFilter : public Darabonba::Model {
public:
  shared_ptr<vector<long>> changeTypeList{};
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<long>> projectIdList{};
  shared_ptr<string> submitEndTime{};
  shared_ptr<string> submitStartTime{};
  shared_ptr<vector<string>> submitterList{};

  ListSubmitRecordsRequestListQuerySearchFilter() {}

  explicit ListSubmitRecordsRequestListQuerySearchFilter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeTypeList) {
      res["ChangeTypeList"] = boost::any(*changeTypeList);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectIdList) {
      res["ProjectIdList"] = boost::any(*projectIdList);
    }
    if (submitEndTime) {
      res["SubmitEndTime"] = boost::any(*submitEndTime);
    }
    if (submitStartTime) {
      res["SubmitStartTime"] = boost::any(*submitStartTime);
    }
    if (submitterList) {
      res["SubmitterList"] = boost::any(*submitterList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeTypeList") != m.end() && !m["ChangeTypeList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ChangeTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChangeTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      changeTypeList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectIdList") != m.end() && !m["ProjectIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["ProjectIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ProjectIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      projectIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("SubmitEndTime") != m.end() && !m["SubmitEndTime"].empty()) {
      submitEndTime = make_shared<string>(boost::any_cast<string>(m["SubmitEndTime"]));
    }
    if (m.find("SubmitStartTime") != m.end() && !m["SubmitStartTime"].empty()) {
      submitStartTime = make_shared<string>(boost::any_cast<string>(m["SubmitStartTime"]));
    }
    if (m.find("SubmitterList") != m.end() && !m["SubmitterList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SubmitterList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubmitterList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      submitterList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListSubmitRecordsRequestListQuerySearchFilter() = default;
};
class ListSubmitRecordsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<ListSubmitRecordsRequestListQuerySearchFilter> searchFilter{};

  ListSubmitRecordsRequestListQuery() {}

  explicit ListSubmitRecordsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (searchFilter) {
      res["SearchFilter"] = searchFilter ? boost::any(searchFilter->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("SearchFilter") != m.end() && !m["SearchFilter"].empty()) {
      if (typeid(map<string, boost::any>) == m["SearchFilter"].type()) {
        ListSubmitRecordsRequestListQuerySearchFilter model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SearchFilter"]));
        searchFilter = make_shared<ListSubmitRecordsRequestListQuerySearchFilter>(model1);
      }
    }
  }


  virtual ~ListSubmitRecordsRequestListQuery() = default;
};
class ListSubmitRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<ListSubmitRecordsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListSubmitRecordsRequest() {}

  explicit ListSubmitRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListSubmitRecordsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListSubmitRecordsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListSubmitRecordsRequest() = default;
};
class ListSubmitRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListSubmitRecordsShrinkRequest() {}

  explicit ListSubmitRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListSubmitRecordsShrinkRequest() = default;
};
class ListSubmitRecordsResponseBodyListResultData : public Darabonba::Model {
public:
  shared_ptr<long> changeType{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<long> id{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectName{};
  shared_ptr<string> objectType{};
  shared_ptr<string> objectVersion{};
  shared_ptr<string> projectId{};
  shared_ptr<string> submitComment{};
  shared_ptr<string> submitter{};
  shared_ptr<string> submitterName{};

  ListSubmitRecordsResponseBodyListResultData() {}

  explicit ListSubmitRecordsResponseBodyListResultData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (changeType) {
      res["ChangeType"] = boost::any(*changeType);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectName) {
      res["ObjectName"] = boost::any(*objectName);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (objectVersion) {
      res["ObjectVersion"] = boost::any(*objectVersion);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (submitComment) {
      res["SubmitComment"] = boost::any(*submitComment);
    }
    if (submitter) {
      res["Submitter"] = boost::any(*submitter);
    }
    if (submitterName) {
      res["SubmitterName"] = boost::any(*submitterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChangeType") != m.end() && !m["ChangeType"].empty()) {
      changeType = make_shared<long>(boost::any_cast<long>(m["ChangeType"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectName") != m.end() && !m["ObjectName"].empty()) {
      objectName = make_shared<string>(boost::any_cast<string>(m["ObjectName"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("ObjectVersion") != m.end() && !m["ObjectVersion"].empty()) {
      objectVersion = make_shared<string>(boost::any_cast<string>(m["ObjectVersion"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SubmitComment") != m.end() && !m["SubmitComment"].empty()) {
      submitComment = make_shared<string>(boost::any_cast<string>(m["SubmitComment"]));
    }
    if (m.find("Submitter") != m.end() && !m["Submitter"].empty()) {
      submitter = make_shared<string>(boost::any_cast<string>(m["Submitter"]));
    }
    if (m.find("SubmitterName") != m.end() && !m["SubmitterName"].empty()) {
      submitterName = make_shared<string>(boost::any_cast<string>(m["SubmitterName"]));
    }
  }


  virtual ~ListSubmitRecordsResponseBodyListResultData() = default;
};
class ListSubmitRecordsResponseBodyListResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListSubmitRecordsResponseBodyListResultData>> data{};
  shared_ptr<long> totalCount{};

  ListSubmitRecordsResponseBodyListResult() {}

  explicit ListSubmitRecordsResponseBodyListResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListSubmitRecordsResponseBodyListResultData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubmitRecordsResponseBodyListResultData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSubmitRecordsResponseBodyListResultData>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSubmitRecordsResponseBodyListResult() = default;
};
class ListSubmitRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<ListSubmitRecordsResponseBodyListResult> listResult{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSubmitRecordsResponseBody() {}

  explicit ListSubmitRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (listResult) {
      res["ListResult"] = listResult ? boost::any(listResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("ListResult") != m.end() && !m["ListResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListResult"].type()) {
        ListSubmitRecordsResponseBodyListResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListResult"]));
        listResult = make_shared<ListSubmitRecordsResponseBodyListResult>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSubmitRecordsResponseBody() = default;
};
class ListSubmitRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSubmitRecordsResponseBody> body{};

  ListSubmitRecordsResponse() {}

  explicit ListSubmitRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSubmitRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSubmitRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSubmitRecordsResponse() = default;
};
class ListTenantMembersRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<string>> roleList{};
  shared_ptr<string> searchText{};
  shared_ptr<vector<string>> userGroupIdList{};

  ListTenantMembersRequestListQuery() {}

  explicit ListTenantMembersRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (roleList) {
      res["RoleList"] = boost::any(*roleList);
    }
    if (searchText) {
      res["SearchText"] = boost::any(*searchText);
    }
    if (userGroupIdList) {
      res["UserGroupIdList"] = boost::any(*userGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SearchText") != m.end() && !m["SearchText"].empty()) {
      searchText = make_shared<string>(boost::any_cast<string>(m["SearchText"]));
    }
    if (m.find("UserGroupIdList") != m.end() && !m["UserGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userGroupIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTenantMembersRequestListQuery() = default;
};
class ListTenantMembersRequest : public Darabonba::Model {
public:
  shared_ptr<ListTenantMembersRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListTenantMembersRequest() {}

  explicit ListTenantMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListTenantMembersRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListTenantMembersRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListTenantMembersRequest() = default;
};
class ListTenantMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListTenantMembersShrinkRequest() {}

  explicit ListTenantMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListTenantMembersShrinkRequest() = default;
};
class ListTenantMembersResponseBodyPageResultUserListUserGroupList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListTenantMembersResponseBodyPageResultUserListUserGroupList() {}

  explicit ListTenantMembersResponseBodyPageResultUserListUserGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListTenantMembersResponseBodyPageResultUserListUserGroupList() = default;
};
class ListTenantMembersResponseBodyPageResultUserList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> dingNumber{};
  shared_ptr<string> displayName{};
  shared_ptr<string> displayNameWithoutStatus{};
  shared_ptr<string> enableWhiteIp{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> mail{};
  shared_ptr<string> mobilePhone{};
  shared_ptr<string> name{};
  shared_ptr<string> nickName{};
  shared_ptr<string> realName{};
  shared_ptr<vector<string>> roleList{};
  shared_ptr<string> sourceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<ListTenantMembersResponseBodyPageResultUserListUserGroupList>> userGroupList{};
  shared_ptr<string> whiteIp{};

  ListTenantMembersResponseBodyPageResultUserList() {}

  explicit ListTenantMembersResponseBodyPageResultUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (dingNumber) {
      res["DingNumber"] = boost::any(*dingNumber);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (displayNameWithoutStatus) {
      res["DisplayNameWithoutStatus"] = boost::any(*displayNameWithoutStatus);
    }
    if (enableWhiteIp) {
      res["EnableWhiteIp"] = boost::any(*enableWhiteIp);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (mobilePhone) {
      res["MobilePhone"] = boost::any(*mobilePhone);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nickName) {
      res["NickName"] = boost::any(*nickName);
    }
    if (realName) {
      res["RealName"] = boost::any(*realName);
    }
    if (roleList) {
      res["RoleList"] = boost::any(*roleList);
    }
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (userGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*userGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserGroupList"] = boost::any(temp1);
    }
    if (whiteIp) {
      res["WhiteIp"] = boost::any(*whiteIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DingNumber") != m.end() && !m["DingNumber"].empty()) {
      dingNumber = make_shared<string>(boost::any_cast<string>(m["DingNumber"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("DisplayNameWithoutStatus") != m.end() && !m["DisplayNameWithoutStatus"].empty()) {
      displayNameWithoutStatus = make_shared<string>(boost::any_cast<string>(m["DisplayNameWithoutStatus"]));
    }
    if (m.find("EnableWhiteIp") != m.end() && !m["EnableWhiteIp"].empty()) {
      enableWhiteIp = make_shared<string>(boost::any_cast<string>(m["EnableWhiteIp"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("MobilePhone") != m.end() && !m["MobilePhone"].empty()) {
      mobilePhone = make_shared<string>(boost::any_cast<string>(m["MobilePhone"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NickName") != m.end() && !m["NickName"].empty()) {
      nickName = make_shared<string>(boost::any_cast<string>(m["NickName"]));
    }
    if (m.find("RealName") != m.end() && !m["RealName"].empty()) {
      realName = make_shared<string>(boost::any_cast<string>(m["RealName"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("UserGroupList") != m.end() && !m["UserGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserGroupList"].type()) {
        vector<ListTenantMembersResponseBodyPageResultUserListUserGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTenantMembersResponseBodyPageResultUserListUserGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userGroupList = make_shared<vector<ListTenantMembersResponseBodyPageResultUserListUserGroupList>>(expect1);
      }
    }
    if (m.find("WhiteIp") != m.end() && !m["WhiteIp"].empty()) {
      whiteIp = make_shared<string>(boost::any_cast<string>(m["WhiteIp"]));
    }
  }


  virtual ~ListTenantMembersResponseBodyPageResultUserList() = default;
};
class ListTenantMembersResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListTenantMembersResponseBodyPageResultUserList>> userList{};

  ListTenantMembersResponseBodyPageResult() {}

  explicit ListTenantMembersResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userList) {
      vector<boost::any> temp1;
      for(auto item1:*userList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserList") != m.end() && !m["UserList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserList"].type()) {
        vector<ListTenantMembersResponseBodyPageResultUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTenantMembersResponseBodyPageResultUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userList = make_shared<vector<ListTenantMembersResponseBodyPageResultUserList>>(expect1);
      }
    }
  }


  virtual ~ListTenantMembersResponseBodyPageResult() = default;
};
class ListTenantMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListTenantMembersResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListTenantMembersResponseBody() {}

  explicit ListTenantMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListTenantMembersResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListTenantMembersResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListTenantMembersResponseBody() = default;
};
class ListTenantMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTenantMembersResponseBody> body{};

  ListTenantMembersResponse() {}

  explicit ListTenantMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTenantMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTenantMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListTenantMembersResponse() = default;
};
class ListUserGroupMembersRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userGroupId{};
  shared_ptr<vector<string>> userIdList{};

  ListUserGroupMembersRequestListQuery() {}

  explicit ListUserGroupMembersRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListUserGroupMembersRequestListQuery() = default;
};
class ListUserGroupMembersRequest : public Darabonba::Model {
public:
  shared_ptr<ListUserGroupMembersRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListUserGroupMembersRequest() {}

  explicit ListUserGroupMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListUserGroupMembersRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListUserGroupMembersRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListUserGroupMembersRequest() = default;
};
class ListUserGroupMembersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListUserGroupMembersShrinkRequest() {}

  explicit ListUserGroupMembersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListUserGroupMembersShrinkRequest() = default;
};
class ListUserGroupMembersResponseBodyPageResultMemberListCreator : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};

  ListUserGroupMembersResponseBodyPageResultMemberListCreator() {}

  explicit ListUserGroupMembersResponseBodyPageResultMemberListCreator(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListUserGroupMembersResponseBodyPageResultMemberListCreator() = default;
};
class ListUserGroupMembersResponseBodyPageResultMemberListUserInfo : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};

  ListUserGroupMembersResponseBodyPageResultMemberListUserInfo() {}

  explicit ListUserGroupMembersResponseBodyPageResultMemberListUserInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListUserGroupMembersResponseBodyPageResultMemberListUserInfo() = default;
};
class ListUserGroupMembersResponseBodyPageResultMemberList : public Darabonba::Model {
public:
  shared_ptr<ListUserGroupMembersResponseBodyPageResultMemberListCreator> creator{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> id{};
  shared_ptr<string> userGroupId{};
  shared_ptr<ListUserGroupMembersResponseBodyPageResultMemberListUserInfo> userInfo{};
  shared_ptr<string> userRole{};

  ListUserGroupMembersResponseBodyPageResultMemberList() {}

  explicit ListUserGroupMembersResponseBodyPageResultMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (creator) {
      res["Creator"] = creator ? boost::any(creator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userInfo) {
      res["UserInfo"] = userInfo ? boost::any(userInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userRole) {
      res["UserRole"] = boost::any(*userRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Creator"].type()) {
        ListUserGroupMembersResponseBodyPageResultMemberListCreator model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Creator"]));
        creator = make_shared<ListUserGroupMembersResponseBodyPageResultMemberListCreator>(model1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserInfo"].type()) {
        ListUserGroupMembersResponseBodyPageResultMemberListUserInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserInfo"]));
        userInfo = make_shared<ListUserGroupMembersResponseBodyPageResultMemberListUserInfo>(model1);
      }
    }
    if (m.find("UserRole") != m.end() && !m["UserRole"].empty()) {
      userRole = make_shared<string>(boost::any_cast<string>(m["UserRole"]));
    }
  }


  virtual ~ListUserGroupMembersResponseBodyPageResultMemberList() = default;
};
class ListUserGroupMembersResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserGroupMembersResponseBodyPageResultMemberList>> memberList{};
  shared_ptr<long> totalCount{};

  ListUserGroupMembersResponseBodyPageResult() {}

  explicit ListUserGroupMembersResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberList) {
      vector<boost::any> temp1;
      for(auto item1:*memberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MemberList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["MemberList"].type()) {
        vector<ListUserGroupMembersResponseBodyPageResultMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserGroupMembersResponseBodyPageResultMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberList = make_shared<vector<ListUserGroupMembersResponseBodyPageResultMemberList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserGroupMembersResponseBodyPageResult() = default;
};
class ListUserGroupMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListUserGroupMembersResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListUserGroupMembersResponseBody() {}

  explicit ListUserGroupMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListUserGroupMembersResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListUserGroupMembersResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListUserGroupMembersResponseBody() = default;
};
class ListUserGroupMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserGroupMembersResponseBody> body{};

  ListUserGroupMembersResponse() {}

  explicit ListUserGroupMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserGroupMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserGroupMembersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserGroupMembersResponse() = default;
};
class ListUserGroupsRequestListQuery : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<vector<string>> adminIdList{};
  shared_ptr<bool> filterMine{};
  shared_ptr<string> keyword{};
  shared_ptr<long> pageNo{};
  shared_ptr<long> pageSize{};

  ListUserGroupsRequestListQuery() {}

  explicit ListUserGroupsRequestListQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (adminIdList) {
      res["AdminIdList"] = boost::any(*adminIdList);
    }
    if (filterMine) {
      res["FilterMine"] = boost::any(*filterMine);
    }
    if (keyword) {
      res["Keyword"] = boost::any(*keyword);
    }
    if (pageNo) {
      res["PageNo"] = boost::any(*pageNo);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("AdminIdList") != m.end() && !m["AdminIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("FilterMine") != m.end() && !m["FilterMine"].empty()) {
      filterMine = make_shared<bool>(boost::any_cast<bool>(m["FilterMine"]));
    }
    if (m.find("Keyword") != m.end() && !m["Keyword"].empty()) {
      keyword = make_shared<string>(boost::any_cast<string>(m["Keyword"]));
    }
    if (m.find("PageNo") != m.end() && !m["PageNo"].empty()) {
      pageNo = make_shared<long>(boost::any_cast<long>(m["PageNo"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListUserGroupsRequestListQuery() = default;
};
class ListUserGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<ListUserGroupsRequestListQuery> listQuery{};
  shared_ptr<long> opTenantId{};

  ListUserGroupsRequest() {}

  explicit ListUserGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQuery) {
      res["ListQuery"] = listQuery ? boost::any(listQuery->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      if (typeid(map<string, boost::any>) == m["ListQuery"].type()) {
        ListUserGroupsRequestListQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ListQuery"]));
        listQuery = make_shared<ListUserGroupsRequestListQuery>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListUserGroupsRequest() = default;
};
class ListUserGroupsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> listQueryShrink{};
  shared_ptr<long> opTenantId{};

  ListUserGroupsShrinkRequest() {}

  explicit ListUserGroupsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listQueryShrink) {
      res["ListQuery"] = boost::any(*listQueryShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListQuery") != m.end() && !m["ListQuery"].empty()) {
      listQueryShrink = make_shared<string>(boost::any_cast<string>(m["ListQuery"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~ListUserGroupsShrinkRequest() = default;
};
class ListUserGroupsResponseBodyPageResultUserGroupListAdminList : public Darabonba::Model {
public:
  shared_ptr<string> accountName{};
  shared_ptr<string> displayName{};
  shared_ptr<string> id{};

  ListUserGroupsResponseBodyPageResultUserGroupListAdminList() {}

  explicit ListUserGroupsResponseBodyPageResultUserGroupListAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountName) {
      res["AccountName"] = boost::any(*accountName);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountName") != m.end() && !m["AccountName"].empty()) {
      accountName = make_shared<string>(boost::any_cast<string>(m["AccountName"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListUserGroupsResponseBodyPageResultUserGroupListAdminList() = default;
};
class ListUserGroupsResponseBodyPageResultUserGroupList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<vector<ListUserGroupsResponseBodyPageResultUserGroupListAdminList>> adminList{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> myRole{};
  shared_ptr<string> name{};

  ListUserGroupsResponseBodyPageResultUserGroupList() {}

  explicit ListUserGroupsResponseBodyPageResultUserGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (myRole) {
      res["MyRole"] = boost::any(*myRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<ListUserGroupsResponseBodyPageResultUserGroupListAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserGroupsResponseBodyPageResultUserGroupListAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<ListUserGroupsResponseBodyPageResultUserGroupListAdminList>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MyRole") != m.end() && !m["MyRole"].empty()) {
      myRole = make_shared<string>(boost::any_cast<string>(m["MyRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListUserGroupsResponseBodyPageResultUserGroupList() = default;
};
class ListUserGroupsResponseBodyPageResult : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<vector<ListUserGroupsResponseBodyPageResultUserGroupList>> userGroupList{};

  ListUserGroupsResponseBodyPageResult() {}

  explicit ListUserGroupsResponseBodyPageResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (userGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*userGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("UserGroupList") != m.end() && !m["UserGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserGroupList"].type()) {
        vector<ListUserGroupsResponseBodyPageResultUserGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserGroupsResponseBodyPageResultUserGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userGroupList = make_shared<vector<ListUserGroupsResponseBodyPageResultUserGroupList>>(expect1);
      }
    }
  }


  virtual ~ListUserGroupsResponseBodyPageResult() = default;
};
class ListUserGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListUserGroupsResponseBodyPageResult> pageResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListUserGroupsResponseBody() {}

  explicit ListUserGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageResult) {
      res["PageResult"] = pageResult ? boost::any(pageResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageResult") != m.end() && !m["PageResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PageResult"].type()) {
        ListUserGroupsResponseBodyPageResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PageResult"]));
        pageResult = make_shared<ListUserGroupsResponseBodyPageResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListUserGroupsResponseBody() = default;
};
class ListUserGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserGroupsResponseBody> body{};

  ListUserGroupsResponse() {}

  explicit ListUserGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserGroupsResponse() = default;
};
class OfflineBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  OfflineBatchTaskRequest() {}

  explicit OfflineBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~OfflineBatchTaskRequest() = default;
};
class OfflineBatchTaskResponseBodyOfflineResult : public Darabonba::Model {
public:
  shared_ptr<long> publishObjectId{};

  OfflineBatchTaskResponseBodyOfflineResult() {}

  explicit OfflineBatchTaskResponseBodyOfflineResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publishObjectId) {
      res["PublishObjectId"] = boost::any(*publishObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PublishObjectId") != m.end() && !m["PublishObjectId"].empty()) {
      publishObjectId = make_shared<long>(boost::any_cast<long>(m["PublishObjectId"]));
    }
  }


  virtual ~OfflineBatchTaskResponseBodyOfflineResult() = default;
};
class OfflineBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<OfflineBatchTaskResponseBodyOfflineResult> offlineResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OfflineBatchTaskResponseBody() {}

  explicit OfflineBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (offlineResult) {
      res["OfflineResult"] = offlineResult ? boost::any(offlineResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OfflineResult") != m.end() && !m["OfflineResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineResult"].type()) {
        OfflineBatchTaskResponseBodyOfflineResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineResult"]));
        offlineResult = make_shared<OfflineBatchTaskResponseBodyOfflineResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OfflineBatchTaskResponseBody() = default;
};
class OfflineBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OfflineBatchTaskResponseBody> body{};

  OfflineBatchTaskResponse() {}

  explicit OfflineBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OfflineBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OfflineBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~OfflineBatchTaskResponse() = default;
};
class OfflineBizEntityRequestOfflineCommand : public Darabonba::Model {
public:
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<string> type{};

  OfflineBizEntityRequestOfflineCommand() {}

  explicit OfflineBizEntityRequestOfflineCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OfflineBizEntityRequestOfflineCommand() = default;
};
class OfflineBizEntityRequest : public Darabonba::Model {
public:
  shared_ptr<OfflineBizEntityRequestOfflineCommand> offlineCommand{};
  shared_ptr<long> opTenantId{};

  OfflineBizEntityRequest() {}

  explicit OfflineBizEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineCommand) {
      res["OfflineCommand"] = offlineCommand ? boost::any(offlineCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineCommand") != m.end() && !m["OfflineCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["OfflineCommand"].type()) {
        OfflineBizEntityRequestOfflineCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OfflineCommand"]));
        offlineCommand = make_shared<OfflineBizEntityRequestOfflineCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~OfflineBizEntityRequest() = default;
};
class OfflineBizEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> offlineCommandShrink{};
  shared_ptr<long> opTenantId{};

  OfflineBizEntityShrinkRequest() {}

  explicit OfflineBizEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (offlineCommandShrink) {
      res["OfflineCommand"] = boost::any(*offlineCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OfflineCommand") != m.end() && !m["OfflineCommand"].empty()) {
      offlineCommandShrink = make_shared<string>(boost::any_cast<string>(m["OfflineCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~OfflineBizEntityShrinkRequest() = default;
};
class OfflineBizEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OfflineBizEntityResponseBody() {}

  explicit OfflineBizEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OfflineBizEntityResponseBody() = default;
};
class OfflineBizEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OfflineBizEntityResponseBody> body{};

  OfflineBizEntityResponse() {}

  explicit OfflineBizEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OfflineBizEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OfflineBizEntityResponseBody>(model1);
      }
    }
  }


  virtual ~OfflineBizEntityResponse() = default;
};
class OnlineBizEntityRequestOnlineCommand : public Darabonba::Model {
public:
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> comment{};
  shared_ptr<long> id{};
  shared_ptr<string> type{};

  OnlineBizEntityRequestOnlineCommand() {}

  explicit OnlineBizEntityRequestOnlineCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~OnlineBizEntityRequestOnlineCommand() = default;
};
class OnlineBizEntityRequest : public Darabonba::Model {
public:
  shared_ptr<OnlineBizEntityRequestOnlineCommand> onlineCommand{};
  shared_ptr<long> opTenantId{};

  OnlineBizEntityRequest() {}

  explicit OnlineBizEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineCommand) {
      res["OnlineCommand"] = onlineCommand ? boost::any(onlineCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineCommand") != m.end() && !m["OnlineCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["OnlineCommand"].type()) {
        OnlineBizEntityRequestOnlineCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OnlineCommand"]));
        onlineCommand = make_shared<OnlineBizEntityRequestOnlineCommand>(model1);
      }
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~OnlineBizEntityRequest() = default;
};
class OnlineBizEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> onlineCommandShrink{};
  shared_ptr<long> opTenantId{};

  OnlineBizEntityShrinkRequest() {}

  explicit OnlineBizEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineCommandShrink) {
      res["OnlineCommand"] = boost::any(*onlineCommandShrink);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineCommand") != m.end() && !m["OnlineCommand"].empty()) {
      onlineCommandShrink = make_shared<string>(boost::any_cast<string>(m["OnlineCommand"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
  }


  virtual ~OnlineBizEntityShrinkRequest() = default;
};
class OnlineBizEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OnlineBizEntityResponseBody() {}

  explicit OnlineBizEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OnlineBizEntityResponseBody() = default;
};
class OnlineBizEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OnlineBizEntityResponseBody> body{};

  OnlineBizEntityResponse() {}

  explicit OnlineBizEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OnlineBizEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OnlineBizEntityResponseBody>(model1);
      }
    }
  }


  virtual ~OnlineBizEntityResponse() = default;
};
class OperateInstanceRequestOperateCommandInstanceIdList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldInstanceIdList{};
  shared_ptr<string> id{};

  OperateInstanceRequestOperateCommandInstanceIdList() {}

  explicit OperateInstanceRequestOperateCommandInstanceIdList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldInstanceIdList) {
      res["FieldInstanceIdList"] = boost::any(*fieldInstanceIdList);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldInstanceIdList") != m.end() && !m["FieldInstanceIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldInstanceIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldInstanceIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldInstanceIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~OperateInstanceRequestOperateCommandInstanceIdList() = default;
};
class OperateInstanceRequestOperateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<OperateInstanceRequestOperateCommandInstanceIdList>> instanceIdList{};
  shared_ptr<string> operation{};
  shared_ptr<long> projectId{};

  OperateInstanceRequestOperateCommand() {}

  explicit OperateInstanceRequestOperateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIdList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceIdList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceIdList"] = boost::any(temp1);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIdList") != m.end() && !m["InstanceIdList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceIdList"].type()) {
        vector<OperateInstanceRequestOperateCommandInstanceIdList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceIdList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OperateInstanceRequestOperateCommandInstanceIdList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceIdList = make_shared<vector<OperateInstanceRequestOperateCommandInstanceIdList>>(expect1);
      }
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~OperateInstanceRequestOperateCommand() = default;
};
class OperateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<OperateInstanceRequestOperateCommand> operateCommand{};

  OperateInstanceRequest() {}

  explicit OperateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (operateCommand) {
      res["OperateCommand"] = operateCommand ? boost::any(operateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("OperateCommand") != m.end() && !m["OperateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["OperateCommand"].type()) {
        OperateInstanceRequestOperateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OperateCommand"]));
        operateCommand = make_shared<OperateInstanceRequestOperateCommand>(model1);
      }
    }
  }


  virtual ~OperateInstanceRequest() = default;
};
class OperateInstanceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> operateCommandShrink{};

  OperateInstanceShrinkRequest() {}

  explicit OperateInstanceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (operateCommandShrink) {
      res["OperateCommand"] = boost::any(*operateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("OperateCommand") != m.end() && !m["OperateCommand"].empty()) {
      operateCommandShrink = make_shared<string>(boost::any_cast<string>(m["OperateCommand"]));
    }
  }


  virtual ~OperateInstanceShrinkRequest() = default;
};
class OperateInstanceResponseBodyInstanceStatusList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> status{};

  OperateInstanceResponseBodyInstanceStatusList() {}

  explicit OperateInstanceResponseBodyInstanceStatusList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~OperateInstanceResponseBodyInstanceStatusList() = default;
};
class OperateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<vector<OperateInstanceResponseBodyInstanceStatusList>> instanceStatusList{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  OperateInstanceResponseBody() {}

  explicit OperateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (instanceStatusList) {
      vector<boost::any> temp1;
      for(auto item1:*instanceStatusList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceStatusList"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("InstanceStatusList") != m.end() && !m["InstanceStatusList"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceStatusList"].type()) {
        vector<OperateInstanceResponseBodyInstanceStatusList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceStatusList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OperateInstanceResponseBodyInstanceStatusList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceStatusList = make_shared<vector<OperateInstanceResponseBodyInstanceStatusList>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~OperateInstanceResponseBody() = default;
};
class OperateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateInstanceResponseBody> body{};

  OperateInstanceResponse() {}

  explicit OperateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~OperateInstanceResponse() = default;
};
class ParseBatchTaskDependencyRequestParseCommand : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<long> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<bool> includeAllInputTables{};
  shared_ptr<bool> needQueryLineages{};
  shared_ptr<string> operatorType{};
  shared_ptr<long> projectId{};

  ParseBatchTaskDependencyRequestParseCommand() {}

  explicit ParseBatchTaskDependencyRequestParseCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (includeAllInputTables) {
      res["IncludeAllInputTables"] = boost::any(*includeAllInputTables);
    }
    if (needQueryLineages) {
      res["NeedQueryLineages"] = boost::any(*needQueryLineages);
    }
    if (operatorType) {
      res["OperatorType"] = boost::any(*operatorType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<long>(boost::any_cast<long>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("IncludeAllInputTables") != m.end() && !m["IncludeAllInputTables"].empty()) {
      includeAllInputTables = make_shared<bool>(boost::any_cast<bool>(m["IncludeAllInputTables"]));
    }
    if (m.find("NeedQueryLineages") != m.end() && !m["NeedQueryLineages"].empty()) {
      needQueryLineages = make_shared<bool>(boost::any_cast<bool>(m["NeedQueryLineages"]));
    }
    if (m.find("OperatorType") != m.end() && !m["OperatorType"].empty()) {
      operatorType = make_shared<string>(boost::any_cast<string>(m["OperatorType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ParseBatchTaskDependencyRequestParseCommand() = default;
};
class ParseBatchTaskDependencyRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<ParseBatchTaskDependencyRequestParseCommand> parseCommand{};

  ParseBatchTaskDependencyRequest() {}

  explicit ParseBatchTaskDependencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (parseCommand) {
      res["ParseCommand"] = parseCommand ? boost::any(parseCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ParseCommand") != m.end() && !m["ParseCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParseCommand"].type()) {
        ParseBatchTaskDependencyRequestParseCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParseCommand"]));
        parseCommand = make_shared<ParseBatchTaskDependencyRequestParseCommand>(model1);
      }
    }
  }


  virtual ~ParseBatchTaskDependencyRequest() = default;
};
class ParseBatchTaskDependencyShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> parseCommandShrink{};

  ParseBatchTaskDependencyShrinkRequest() {}

  explicit ParseBatchTaskDependencyShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (parseCommandShrink) {
      res["ParseCommand"] = boost::any(*parseCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ParseCommand") != m.end() && !m["ParseCommand"].empty()) {
      parseCommandShrink = make_shared<string>(boost::any_cast<string>(m["ParseCommand"]));
    }
  }


  virtual ~ParseBatchTaskDependencyShrinkRequest() = default;
};
class ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldList{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> outputName{};
  shared_ptr<string> ownerName{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<string> tableName{};

  ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList() {}

  explicit ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (outputName) {
      res["OutputName"] = boost::any(*outputName);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("OutputName") != m.end() && !m["OutputName"].empty()) {
      outputName = make_shared<string>(boost::any_cast<string>(m["OutputName"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList() = default;
};
class ParseBatchTaskDependencyResponseBodyParseResultDependNodeList : public Darabonba::Model {
public:
  shared_ptr<string> nodeIoType{};
  shared_ptr<vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList>> scheduleNodeInfoList{};

  ParseBatchTaskDependencyResponseBodyParseResultDependNodeList() {}

  explicit ParseBatchTaskDependencyResponseBodyParseResultDependNodeList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIoType) {
      res["NodeIoType"] = boost::any(*nodeIoType);
    }
    if (scheduleNodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*scheduleNodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ScheduleNodeInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIoType") != m.end() && !m["NodeIoType"].empty()) {
      nodeIoType = make_shared<string>(boost::any_cast<string>(m["NodeIoType"]));
    }
    if (m.find("ScheduleNodeInfoList") != m.end() && !m["ScheduleNodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ScheduleNodeInfoList"].type()) {
        vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ScheduleNodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scheduleNodeInfoList = make_shared<vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeListScheduleNodeInfoList>>(expect1);
      }
    }
  }


  virtual ~ParseBatchTaskDependencyResponseBodyParseResultDependNodeList() = default;
};
class ParseBatchTaskDependencyResponseBodyParseResult : public Darabonba::Model {
public:
  shared_ptr<vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeList>> dependNodeList{};

  ParseBatchTaskDependencyResponseBodyParseResult() {}

  explicit ParseBatchTaskDependencyResponseBodyParseResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependNodeList) {
      vector<boost::any> temp1;
      for(auto item1:*dependNodeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DependNodeList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependNodeList") != m.end() && !m["DependNodeList"].empty()) {
      if (typeid(vector<boost::any>) == m["DependNodeList"].type()) {
        vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DependNodeList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ParseBatchTaskDependencyResponseBodyParseResultDependNodeList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dependNodeList = make_shared<vector<ParseBatchTaskDependencyResponseBodyParseResultDependNodeList>>(expect1);
      }
    }
  }


  virtual ~ParseBatchTaskDependencyResponseBodyParseResult() = default;
};
class ParseBatchTaskDependencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ParseBatchTaskDependencyResponseBodyParseResult> parseResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ParseBatchTaskDependencyResponseBody() {}

  explicit ParseBatchTaskDependencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (parseResult) {
      res["ParseResult"] = parseResult ? boost::any(parseResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ParseResult") != m.end() && !m["ParseResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ParseResult"].type()) {
        ParseBatchTaskDependencyResponseBodyParseResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ParseResult"]));
        parseResult = make_shared<ParseBatchTaskDependencyResponseBodyParseResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ParseBatchTaskDependencyResponseBody() = default;
};
class ParseBatchTaskDependencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ParseBatchTaskDependencyResponseBody> body{};

  ParseBatchTaskDependencyResponse() {}

  explicit ParseBatchTaskDependencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ParseBatchTaskDependencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ParseBatchTaskDependencyResponseBody>(model1);
      }
    }
  }


  virtual ~ParseBatchTaskDependencyResponse() = default;
};
class PausePhysicalNodeRequestPauseCommand : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nodeIdList{};
  shared_ptr<long> projectId{};

  PausePhysicalNodeRequestPauseCommand() {}

  explicit PausePhysicalNodeRequestPauseCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIdList) {
      res["NodeIdList"] = boost::any(*nodeIdList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIdList") != m.end() && !m["NodeIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~PausePhysicalNodeRequestPauseCommand() = default;
};
class PausePhysicalNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<PausePhysicalNodeRequestPauseCommand> pauseCommand{};

  PausePhysicalNodeRequest() {}

  explicit PausePhysicalNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pauseCommand) {
      res["PauseCommand"] = pauseCommand ? boost::any(pauseCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PauseCommand") != m.end() && !m["PauseCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["PauseCommand"].type()) {
        PausePhysicalNodeRequestPauseCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PauseCommand"]));
        pauseCommand = make_shared<PausePhysicalNodeRequestPauseCommand>(model1);
      }
    }
  }


  virtual ~PausePhysicalNodeRequest() = default;
};
class PausePhysicalNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> pauseCommandShrink{};

  PausePhysicalNodeShrinkRequest() {}

  explicit PausePhysicalNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (pauseCommandShrink) {
      res["PauseCommand"] = boost::any(*pauseCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PauseCommand") != m.end() && !m["PauseCommand"].empty()) {
      pauseCommandShrink = make_shared<string>(boost::any_cast<string>(m["PauseCommand"]));
    }
  }


  virtual ~PausePhysicalNodeShrinkRequest() = default;
};
class PausePhysicalNodeResponseBodyNodeOperateResultList : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> status{};

  PausePhysicalNodeResponseBodyNodeOperateResultList() {}

  explicit PausePhysicalNodeResponseBodyNodeOperateResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~PausePhysicalNodeResponseBodyNodeOperateResultList() = default;
};
class PausePhysicalNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<PausePhysicalNodeResponseBodyNodeOperateResultList>> nodeOperateResultList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PausePhysicalNodeResponseBody() {}

  explicit PausePhysicalNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeOperateResultList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOperateResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOperateResultList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeOperateResultList") != m.end() && !m["NodeOperateResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOperateResultList"].type()) {
        vector<PausePhysicalNodeResponseBodyNodeOperateResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOperateResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PausePhysicalNodeResponseBodyNodeOperateResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOperateResultList = make_shared<vector<PausePhysicalNodeResponseBodyNodeOperateResultList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PausePhysicalNodeResponseBody() = default;
};
class PausePhysicalNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PausePhysicalNodeResponseBody> body{};

  PausePhysicalNodeResponse() {}

  explicit PausePhysicalNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PausePhysicalNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PausePhysicalNodeResponseBody>(model1);
      }
    }
  }


  virtual ~PausePhysicalNodeResponse() = default;
};
class PublishObjectListRequestPublishCommand : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<long>> submitIdList{};

  PublishObjectListRequestPublishCommand() {}

  explicit PublishObjectListRequestPublishCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (submitIdList) {
      res["SubmitIdList"] = boost::any(*submitIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("SubmitIdList") != m.end() && !m["SubmitIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SubmitIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubmitIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      submitIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~PublishObjectListRequestPublishCommand() = default;
};
class PublishObjectListRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<PublishObjectListRequestPublishCommand> publishCommand{};

  PublishObjectListRequest() {}

  explicit PublishObjectListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (publishCommand) {
      res["PublishCommand"] = publishCommand ? boost::any(publishCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PublishCommand") != m.end() && !m["PublishCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishCommand"].type()) {
        PublishObjectListRequestPublishCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishCommand"]));
        publishCommand = make_shared<PublishObjectListRequestPublishCommand>(model1);
      }
    }
  }


  virtual ~PublishObjectListRequest() = default;
};
class PublishObjectListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> publishCommandShrink{};

  PublishObjectListShrinkRequest() {}

  explicit PublishObjectListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (publishCommandShrink) {
      res["PublishCommand"] = boost::any(*publishCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("PublishCommand") != m.end() && !m["PublishCommand"].empty()) {
      publishCommandShrink = make_shared<string>(boost::any_cast<string>(m["PublishCommand"]));
    }
  }


  virtual ~PublishObjectListShrinkRequest() = default;
};
class PublishObjectListResponseBodyPublishResult : public Darabonba::Model {
public:
  shared_ptr<vector<long>> submitIdList{};

  PublishObjectListResponseBodyPublishResult() {}

  explicit PublishObjectListResponseBodyPublishResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (submitIdList) {
      res["SubmitIdList"] = boost::any(*submitIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SubmitIdList") != m.end() && !m["SubmitIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["SubmitIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubmitIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      submitIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~PublishObjectListResponseBodyPublishResult() = default;
};
class PublishObjectListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<PublishObjectListResponseBodyPublishResult> publishResult{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PublishObjectListResponseBody() {}

  explicit PublishObjectListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (publishResult) {
      res["PublishResult"] = publishResult ? boost::any(publishResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PublishResult") != m.end() && !m["PublishResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["PublishResult"].type()) {
        PublishObjectListResponseBodyPublishResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PublishResult"]));
        publishResult = make_shared<PublishObjectListResponseBodyPublishResult>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PublishObjectListResponseBody() = default;
};
class PublishObjectListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PublishObjectListResponseBody> body{};

  PublishObjectListResponse() {}

  explicit PublishObjectListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PublishObjectListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PublishObjectListResponseBody>(model1);
      }
    }
  }


  virtual ~PublishObjectListResponse() = default;
};
class RemoveTenantMemberRequestRemoveCommand : public Darabonba::Model {
public:
  shared_ptr<string> sourceId{};

  RemoveTenantMemberRequestRemoveCommand() {}

  explicit RemoveTenantMemberRequestRemoveCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sourceId) {
      res["SourceId"] = boost::any(*sourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SourceId") != m.end() && !m["SourceId"].empty()) {
      sourceId = make_shared<string>(boost::any_cast<string>(m["SourceId"]));
    }
  }


  virtual ~RemoveTenantMemberRequestRemoveCommand() = default;
};
class RemoveTenantMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<RemoveTenantMemberRequestRemoveCommand> removeCommand{};

  RemoveTenantMemberRequest() {}

  explicit RemoveTenantMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (removeCommand) {
      res["RemoveCommand"] = removeCommand ? boost::any(removeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RemoveCommand") != m.end() && !m["RemoveCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemoveCommand"].type()) {
        RemoveTenantMemberRequestRemoveCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemoveCommand"]));
        removeCommand = make_shared<RemoveTenantMemberRequestRemoveCommand>(model1);
      }
    }
  }


  virtual ~RemoveTenantMemberRequest() = default;
};
class RemoveTenantMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> removeCommandShrink{};

  RemoveTenantMemberShrinkRequest() {}

  explicit RemoveTenantMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (removeCommandShrink) {
      res["RemoveCommand"] = boost::any(*removeCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RemoveCommand") != m.end() && !m["RemoveCommand"].empty()) {
      removeCommandShrink = make_shared<string>(boost::any_cast<string>(m["RemoveCommand"]));
    }
  }


  virtual ~RemoveTenantMemberShrinkRequest() = default;
};
class RemoveTenantMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveTenantMemberResponseBody() {}

  explicit RemoveTenantMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveTenantMemberResponseBody() = default;
};
class RemoveTenantMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTenantMemberResponseBody> body{};

  RemoveTenantMemberResponse() {}

  explicit RemoveTenantMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTenantMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTenantMemberResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTenantMemberResponse() = default;
};
class RemoveUserGroupMemberRequestRemoveCommand : public Darabonba::Model {
public:
  shared_ptr<string> userGroupId{};
  shared_ptr<vector<string>> userIdList{};

  RemoveUserGroupMemberRequestRemoveCommand() {}

  explicit RemoveUserGroupMemberRequestRemoveCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userIdList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~RemoveUserGroupMemberRequestRemoveCommand() = default;
};
class RemoveUserGroupMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<RemoveUserGroupMemberRequestRemoveCommand> removeCommand{};

  RemoveUserGroupMemberRequest() {}

  explicit RemoveUserGroupMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (removeCommand) {
      res["RemoveCommand"] = removeCommand ? boost::any(removeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RemoveCommand") != m.end() && !m["RemoveCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemoveCommand"].type()) {
        RemoveUserGroupMemberRequestRemoveCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemoveCommand"]));
        removeCommand = make_shared<RemoveUserGroupMemberRequestRemoveCommand>(model1);
      }
    }
  }


  virtual ~RemoveUserGroupMemberRequest() = default;
};
class RemoveUserGroupMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> removeCommandShrink{};

  RemoveUserGroupMemberShrinkRequest() {}

  explicit RemoveUserGroupMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (removeCommandShrink) {
      res["RemoveCommand"] = boost::any(*removeCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RemoveCommand") != m.end() && !m["RemoveCommand"].empty()) {
      removeCommandShrink = make_shared<string>(boost::any_cast<string>(m["RemoveCommand"]));
    }
  }


  virtual ~RemoveUserGroupMemberShrinkRequest() = default;
};
class RemoveUserGroupMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RemoveUserGroupMemberResponseBody() {}

  explicit RemoveUserGroupMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RemoveUserGroupMemberResponseBody() = default;
};
class RemoveUserGroupMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUserGroupMemberResponseBody> body{};

  RemoveUserGroupMemberResponse() {}

  explicit RemoveUserGroupMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUserGroupMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUserGroupMemberResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUserGroupMemberResponse() = default;
};
class ResumePhysicalNodeRequestResumeCommand : public Darabonba::Model {
public:
  shared_ptr<vector<string>> nodeIdList{};
  shared_ptr<long> projectId{};

  ResumePhysicalNodeRequestResumeCommand() {}

  explicit ResumePhysicalNodeRequestResumeCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeIdList) {
      res["NodeIdList"] = boost::any(*nodeIdList);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeIdList") != m.end() && !m["NodeIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~ResumePhysicalNodeRequestResumeCommand() = default;
};
class ResumePhysicalNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<ResumePhysicalNodeRequestResumeCommand> resumeCommand{};

  ResumePhysicalNodeRequest() {}

  explicit ResumePhysicalNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (resumeCommand) {
      res["ResumeCommand"] = resumeCommand ? boost::any(resumeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ResumeCommand") != m.end() && !m["ResumeCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResumeCommand"].type()) {
        ResumePhysicalNodeRequestResumeCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResumeCommand"]));
        resumeCommand = make_shared<ResumePhysicalNodeRequestResumeCommand>(model1);
      }
    }
  }


  virtual ~ResumePhysicalNodeRequest() = default;
};
class ResumePhysicalNodeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> env{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> resumeCommandShrink{};

  ResumePhysicalNodeShrinkRequest() {}

  explicit ResumePhysicalNodeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (resumeCommandShrink) {
      res["ResumeCommand"] = boost::any(*resumeCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ResumeCommand") != m.end() && !m["ResumeCommand"].empty()) {
      resumeCommandShrink = make_shared<string>(boost::any_cast<string>(m["ResumeCommand"]));
    }
  }


  virtual ~ResumePhysicalNodeShrinkRequest() = default;
};
class ResumePhysicalNodeResponseBodyNodeOperateResultList : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> status{};

  ResumePhysicalNodeResponseBodyNodeOperateResultList() {}

  explicit ResumePhysicalNodeResponseBodyNodeOperateResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ResumePhysicalNodeResponseBodyNodeOperateResultList() = default;
};
class ResumePhysicalNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<ResumePhysicalNodeResponseBodyNodeOperateResultList>> nodeOperateResultList{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ResumePhysicalNodeResponseBody() {}

  explicit ResumePhysicalNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (nodeOperateResultList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeOperateResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeOperateResultList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("NodeOperateResultList") != m.end() && !m["NodeOperateResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeOperateResultList"].type()) {
        vector<ResumePhysicalNodeResponseBodyNodeOperateResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeOperateResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ResumePhysicalNodeResponseBodyNodeOperateResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeOperateResultList = make_shared<vector<ResumePhysicalNodeResponseBodyNodeOperateResultList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResumePhysicalNodeResponseBody() = default;
};
class ResumePhysicalNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumePhysicalNodeResponseBody> body{};

  ResumePhysicalNodeResponse() {}

  explicit ResumePhysicalNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumePhysicalNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumePhysicalNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ResumePhysicalNodeResponse() = default;
};
class RevokeResourcePermissionRequestRevokeCommandResourceList : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};

  RevokeResourcePermissionRequestRevokeCommandResourceList() {}

  explicit RevokeResourcePermissionRequestRevokeCommandResourceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~RevokeResourcePermissionRequestRevokeCommandResourceList() = default;
};
class RevokeResourcePermissionRequestRevokeCommand : public Darabonba::Model {
public:
  shared_ptr<vector<string>> operateList{};
  shared_ptr<string> reason{};
  shared_ptr<vector<RevokeResourcePermissionRequestRevokeCommandResourceList>> resourceList{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> userId{};

  RevokeResourcePermissionRequestRevokeCommand() {}

  explicit RevokeResourcePermissionRequestRevokeCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operateList) {
      res["OperateList"] = boost::any(*operateList);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (resourceList) {
      vector<boost::any> temp1;
      for(auto item1:*resourceList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResourceList"] = boost::any(temp1);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperateList") != m.end() && !m["OperateList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OperateList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OperateList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      operateList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ResourceList") != m.end() && !m["ResourceList"].empty()) {
      if (typeid(vector<boost::any>) == m["ResourceList"].type()) {
        vector<RevokeResourcePermissionRequestRevokeCommandResourceList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResourceList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RevokeResourcePermissionRequestRevokeCommandResourceList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resourceList = make_shared<vector<RevokeResourcePermissionRequestRevokeCommandResourceList>>(expect1);
      }
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RevokeResourcePermissionRequestRevokeCommand() = default;
};
class RevokeResourcePermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<RevokeResourcePermissionRequestRevokeCommand> revokeCommand{};

  RevokeResourcePermissionRequest() {}

  explicit RevokeResourcePermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (revokeCommand) {
      res["RevokeCommand"] = revokeCommand ? boost::any(revokeCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RevokeCommand") != m.end() && !m["RevokeCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["RevokeCommand"].type()) {
        RevokeResourcePermissionRequestRevokeCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RevokeCommand"]));
        revokeCommand = make_shared<RevokeResourcePermissionRequestRevokeCommand>(model1);
      }
    }
  }


  virtual ~RevokeResourcePermissionRequest() = default;
};
class RevokeResourcePermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> revokeCommandShrink{};

  RevokeResourcePermissionShrinkRequest() {}

  explicit RevokeResourcePermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (revokeCommandShrink) {
      res["RevokeCommand"] = boost::any(*revokeCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("RevokeCommand") != m.end() && !m["RevokeCommand"].empty()) {
      revokeCommandShrink = make_shared<string>(boost::any_cast<string>(m["RevokeCommand"]));
    }
  }


  virtual ~RevokeResourcePermissionShrinkRequest() = default;
};
class RevokeResourcePermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  RevokeResourcePermissionResponseBody() {}

  explicit RevokeResourcePermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~RevokeResourcePermissionResponseBody() = default;
};
class RevokeResourcePermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeResourcePermissionResponseBody> body{};

  RevokeResourcePermissionResponse() {}

  explicit RevokeResourcePermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeResourcePermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeResourcePermissionResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeResourcePermissionResponse() = default;
};
class StopAdHocTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};
  shared_ptr<string> taskId{};

  StopAdHocTaskRequest() {}

  explicit StopAdHocTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~StopAdHocTaskRequest() = default;
};
class StopAdHocTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  StopAdHocTaskResponseBody() {}

  explicit StopAdHocTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StopAdHocTaskResponseBody() = default;
};
class StopAdHocTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopAdHocTaskResponseBody> body{};

  StopAdHocTaskResponse() {}

  explicit StopAdHocTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopAdHocTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopAdHocTaskResponseBody>(model1);
      }
    }
  }


  virtual ~StopAdHocTaskResponse() = default;
};
class SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> intervalUnit{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<string> startTime{};

  SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig() {}

  explicit SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (intervalUnit) {
      res["IntervalUnit"] = boost::any(*intervalUnit);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IntervalUnit") != m.end() && !m["IntervalUnit"].empty()) {
      intervalUnit = make_shared<string>(boost::any_cast<string>(m["IntervalUnit"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig() = default;
};
class SubmitBatchTaskRequestSubmitCommandParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SubmitBatchTaskRequestSubmitCommandParamList() {}

  explicit SubmitBatchTaskRequestSubmitCommandParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommandParamList() = default;
};
class SubmitBatchTaskRequestSubmitCommandSparkClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> sparkClientVersion{};

  SubmitBatchTaskRequestSubmitCommandSparkClientInfo() {}

  explicit SubmitBatchTaskRequestSubmitCommandSparkClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sparkClientVersion) {
      res["SparkClientVersion"] = boost::any(*sparkClientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SparkClientVersion") != m.end() && !m["SparkClientVersion"].empty()) {
      sparkClientVersion = make_shared<string>(boost::any_cast<string>(m["SparkClientVersion"]));
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommandSparkClientInfo() = default;
};
class SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod : public Darabonba::Model {
public:
  shared_ptr<long> periodOffset{};
  shared_ptr<string> periodType{};

  SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod() {}

  explicit SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodOffset) {
      res["PeriodOffset"] = boost::any(*periodOffset);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodOffset") != m.end() && !m["PeriodOffset"].empty()) {
      periodOffset = make_shared<long>(boost::any_cast<long>(m["PeriodOffset"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod() = default;
};
class SubmitBatchTaskRequestSubmitCommandUpStreamList : public Darabonba::Model {
public:
  shared_ptr<SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod> dependPeriod{};
  shared_ptr<string> dependStrategy{};
  shared_ptr<vector<string>> fieldList{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> periodDiff{};
  shared_ptr<bool> sourceNodeEnabled{};
  shared_ptr<string> sourceNodeId{};
  shared_ptr<string> sourceNodeOutputName{};
  shared_ptr<string> sourceTableName{};

  SubmitBatchTaskRequestSubmitCommandUpStreamList() {}

  explicit SubmitBatchTaskRequestSubmitCommandUpStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependPeriod) {
      res["DependPeriod"] = dependPeriod ? boost::any(dependPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependStrategy) {
      res["DependStrategy"] = boost::any(*dependStrategy);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (periodDiff) {
      res["PeriodDiff"] = boost::any(*periodDiff);
    }
    if (sourceNodeEnabled) {
      res["SourceNodeEnabled"] = boost::any(*sourceNodeEnabled);
    }
    if (sourceNodeId) {
      res["SourceNodeId"] = boost::any(*sourceNodeId);
    }
    if (sourceNodeOutputName) {
      res["SourceNodeOutputName"] = boost::any(*sourceNodeOutputName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependPeriod") != m.end() && !m["DependPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependPeriod"].type()) {
        SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependPeriod"]));
        dependPeriod = make_shared<SubmitBatchTaskRequestSubmitCommandUpStreamListDependPeriod>(model1);
      }
    }
    if (m.find("DependStrategy") != m.end() && !m["DependStrategy"].empty()) {
      dependStrategy = make_shared<string>(boost::any_cast<string>(m["DependStrategy"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PeriodDiff") != m.end() && !m["PeriodDiff"].empty()) {
      periodDiff = make_shared<long>(boost::any_cast<long>(m["PeriodDiff"]));
    }
    if (m.find("SourceNodeEnabled") != m.end() && !m["SourceNodeEnabled"].empty()) {
      sourceNodeEnabled = make_shared<bool>(boost::any_cast<bool>(m["SourceNodeEnabled"]));
    }
    if (m.find("SourceNodeId") != m.end() && !m["SourceNodeId"].empty()) {
      sourceNodeId = make_shared<string>(boost::any_cast<string>(m["SourceNodeId"]));
    }
    if (m.find("SourceNodeOutputName") != m.end() && !m["SourceNodeOutputName"].empty()) {
      sourceNodeOutputName = make_shared<string>(boost::any_cast<string>(m["SourceNodeOutputName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommandUpStreamList() = default;
};
class SubmitBatchTaskRequestSubmitCommand : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> comment{};
  shared_ptr<string> cronExpression{};
  shared_ptr<SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig> customScheduleConfig{};
  shared_ptr<string> engine{};
  shared_ptr<long> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeDescription{};
  shared_ptr<vector<string>> nodeOutputNameList{};
  shared_ptr<long> nodeStatus{};
  shared_ptr<vector<SubmitBatchTaskRequestSubmitCommandParamList>> paramList{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> pythonModuleList{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<SubmitBatchTaskRequestSubmitCommandSparkClientInfo> sparkClientInfo{};
  shared_ptr<vector<SubmitBatchTaskRequestSubmitCommandUpStreamList>> upStreamList{};

  SubmitBatchTaskRequestSubmitCommand() {}

  explicit SubmitBatchTaskRequestSubmitCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (customScheduleConfig) {
      res["CustomScheduleConfig"] = customScheduleConfig ? boost::any(customScheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeDescription) {
      res["NodeDescription"] = boost::any(*nodeDescription);
    }
    if (nodeOutputNameList) {
      res["NodeOutputNameList"] = boost::any(*nodeOutputNameList);
    }
    if (nodeStatus) {
      res["NodeStatus"] = boost::any(*nodeStatus);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pythonModuleList) {
      res["PythonModuleList"] = boost::any(*pythonModuleList);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (sparkClientInfo) {
      res["SparkClientInfo"] = sparkClientInfo ? boost::any(sparkClientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (upStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*upStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpStreamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CustomScheduleConfig") != m.end() && !m["CustomScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomScheduleConfig"].type()) {
        SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomScheduleConfig"]));
        customScheduleConfig = make_shared<SubmitBatchTaskRequestSubmitCommandCustomScheduleConfig>(model1);
      }
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeDescription") != m.end() && !m["NodeDescription"].empty()) {
      nodeDescription = make_shared<string>(boost::any_cast<string>(m["NodeDescription"]));
    }
    if (m.find("NodeOutputNameList") != m.end() && !m["NodeOutputNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeOutputNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeOutputNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeOutputNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      nodeStatus = make_shared<long>(boost::any_cast<long>(m["NodeStatus"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<SubmitBatchTaskRequestSubmitCommandParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitBatchTaskRequestSubmitCommandParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<SubmitBatchTaskRequestSubmitCommandParamList>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PythonModuleList") != m.end() && !m["PythonModuleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PythonModuleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PythonModuleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pythonModuleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("SparkClientInfo") != m.end() && !m["SparkClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SparkClientInfo"].type()) {
        SubmitBatchTaskRequestSubmitCommandSparkClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SparkClientInfo"]));
        sparkClientInfo = make_shared<SubmitBatchTaskRequestSubmitCommandSparkClientInfo>(model1);
      }
    }
    if (m.find("UpStreamList") != m.end() && !m["UpStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpStreamList"].type()) {
        vector<SubmitBatchTaskRequestSubmitCommandUpStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubmitBatchTaskRequestSubmitCommandUpStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upStreamList = make_shared<vector<SubmitBatchTaskRequestSubmitCommandUpStreamList>>(expect1);
      }
    }
  }


  virtual ~SubmitBatchTaskRequestSubmitCommand() = default;
};
class SubmitBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<SubmitBatchTaskRequestSubmitCommand> submitCommand{};

  SubmitBatchTaskRequest() {}

  explicit SubmitBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (submitCommand) {
      res["SubmitCommand"] = submitCommand ? boost::any(submitCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SubmitCommand") != m.end() && !m["SubmitCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubmitCommand"].type()) {
        SubmitBatchTaskRequestSubmitCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubmitCommand"]));
        submitCommand = make_shared<SubmitBatchTaskRequestSubmitCommand>(model1);
      }
    }
  }


  virtual ~SubmitBatchTaskRequest() = default;
};
class SubmitBatchTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> submitCommandShrink{};

  SubmitBatchTaskShrinkRequest() {}

  explicit SubmitBatchTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (submitCommandShrink) {
      res["SubmitCommand"] = boost::any(*submitCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SubmitCommand") != m.end() && !m["SubmitCommand"].empty()) {
      submitCommandShrink = make_shared<string>(boost::any_cast<string>(m["SubmitCommand"]));
    }
  }


  virtual ~SubmitBatchTaskShrinkRequest() = default;
};
class SubmitBatchTaskResponseBodySubmitResult : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<long> submitId{};

  SubmitBatchTaskResponseBodySubmitResult() {}

  explicit SubmitBatchTaskResponseBodySubmitResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (submitId) {
      res["SubmitId"] = boost::any(*submitId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("SubmitId") != m.end() && !m["SubmitId"].empty()) {
      submitId = make_shared<long>(boost::any_cast<long>(m["SubmitId"]));
    }
  }


  virtual ~SubmitBatchTaskResponseBodySubmitResult() = default;
};
class SubmitBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitBatchTaskResponseBodySubmitResult> submitResult{};
  shared_ptr<bool> success{};

  SubmitBatchTaskResponseBody() {}

  explicit SubmitBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (submitResult) {
      res["SubmitResult"] = submitResult ? boost::any(submitResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubmitResult") != m.end() && !m["SubmitResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubmitResult"].type()) {
        SubmitBatchTaskResponseBodySubmitResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SubmitResult"]));
        submitResult = make_shared<SubmitBatchTaskResponseBodySubmitResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitBatchTaskResponseBody() = default;
};
class SubmitBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitBatchTaskResponseBody> body{};

  SubmitBatchTaskResponse() {}

  explicit SubmitBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitBatchTaskResponse() = default;
};
class SyncDepartmentRequestSyncDepartmentCommandDepartmentList : public Darabonba::Model {
public:
  shared_ptr<string> departmentId{};
  shared_ptr<string> departmentName{};
  shared_ptr<string> parentDepartmentId{};

  SyncDepartmentRequestSyncDepartmentCommandDepartmentList() {}

  explicit SyncDepartmentRequestSyncDepartmentCommandDepartmentList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentId) {
      res["DepartmentId"] = boost::any(*departmentId);
    }
    if (departmentName) {
      res["DepartmentName"] = boost::any(*departmentName);
    }
    if (parentDepartmentId) {
      res["ParentDepartmentId"] = boost::any(*parentDepartmentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentId") != m.end() && !m["DepartmentId"].empty()) {
      departmentId = make_shared<string>(boost::any_cast<string>(m["DepartmentId"]));
    }
    if (m.find("DepartmentName") != m.end() && !m["DepartmentName"].empty()) {
      departmentName = make_shared<string>(boost::any_cast<string>(m["DepartmentName"]));
    }
    if (m.find("ParentDepartmentId") != m.end() && !m["ParentDepartmentId"].empty()) {
      parentDepartmentId = make_shared<string>(boost::any_cast<string>(m["ParentDepartmentId"]));
    }
  }


  virtual ~SyncDepartmentRequestSyncDepartmentCommandDepartmentList() = default;
};
class SyncDepartmentRequestSyncDepartmentCommand : public Darabonba::Model {
public:
  shared_ptr<vector<SyncDepartmentRequestSyncDepartmentCommandDepartmentList>> departmentList{};

  SyncDepartmentRequestSyncDepartmentCommand() {}

  explicit SyncDepartmentRequestSyncDepartmentCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentList) {
      vector<boost::any> temp1;
      for(auto item1:*departmentList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DepartmentList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentList") != m.end() && !m["DepartmentList"].empty()) {
      if (typeid(vector<boost::any>) == m["DepartmentList"].type()) {
        vector<SyncDepartmentRequestSyncDepartmentCommandDepartmentList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DepartmentList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SyncDepartmentRequestSyncDepartmentCommandDepartmentList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        departmentList = make_shared<vector<SyncDepartmentRequestSyncDepartmentCommandDepartmentList>>(expect1);
      }
    }
  }


  virtual ~SyncDepartmentRequestSyncDepartmentCommand() = default;
};
class SyncDepartmentRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<SyncDepartmentRequestSyncDepartmentCommand> syncDepartmentCommand{};

  SyncDepartmentRequest() {}

  explicit SyncDepartmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (syncDepartmentCommand) {
      res["SyncDepartmentCommand"] = syncDepartmentCommand ? boost::any(syncDepartmentCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SyncDepartmentCommand") != m.end() && !m["SyncDepartmentCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["SyncDepartmentCommand"].type()) {
        SyncDepartmentRequestSyncDepartmentCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SyncDepartmentCommand"]));
        syncDepartmentCommand = make_shared<SyncDepartmentRequestSyncDepartmentCommand>(model1);
      }
    }
  }


  virtual ~SyncDepartmentRequest() = default;
};
class SyncDepartmentShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> syncDepartmentCommandShrink{};

  SyncDepartmentShrinkRequest() {}

  explicit SyncDepartmentShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (syncDepartmentCommandShrink) {
      res["SyncDepartmentCommand"] = boost::any(*syncDepartmentCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SyncDepartmentCommand") != m.end() && !m["SyncDepartmentCommand"].empty()) {
      syncDepartmentCommandShrink = make_shared<string>(boost::any_cast<string>(m["SyncDepartmentCommand"]));
    }
  }


  virtual ~SyncDepartmentShrinkRequest() = default;
};
class SyncDepartmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SyncDepartmentResponseBody() {}

  explicit SyncDepartmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncDepartmentResponseBody() = default;
};
class SyncDepartmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncDepartmentResponseBody> body{};

  SyncDepartmentResponse() {}

  explicit SyncDepartmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncDepartmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncDepartmentResponseBody>(model1);
      }
    }
  }


  virtual ~SyncDepartmentResponse() = default;
};
class SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping : public Darabonba::Model {
public:
  shared_ptr<vector<string>> departmentIdList{};
  shared_ptr<string> sourceUserId{};

  SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping() {}

  explicit SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (departmentIdList) {
      res["DepartmentIdList"] = boost::any(*departmentIdList);
    }
    if (sourceUserId) {
      res["SourceUserId"] = boost::any(*sourceUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DepartmentIdList") != m.end() && !m["DepartmentIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DepartmentIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DepartmentIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      departmentIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceUserId") != m.end() && !m["SourceUserId"].empty()) {
      sourceUserId = make_shared<string>(boost::any_cast<string>(m["SourceUserId"]));
    }
  }


  virtual ~SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping() = default;
};
class SyncDepartmentUserRequestSyncDepartmentUserCommand : public Darabonba::Model {
public:
  shared_ptr<vector<SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping>> deptUserMapping{};

  SyncDepartmentUserRequestSyncDepartmentUserCommand() {}

  explicit SyncDepartmentUserRequestSyncDepartmentUserCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deptUserMapping) {
      vector<boost::any> temp1;
      for(auto item1:*deptUserMapping){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeptUserMapping"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeptUserMapping") != m.end() && !m["DeptUserMapping"].empty()) {
      if (typeid(vector<boost::any>) == m["DeptUserMapping"].type()) {
        vector<SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeptUserMapping"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deptUserMapping = make_shared<vector<SyncDepartmentUserRequestSyncDepartmentUserCommandDeptUserMapping>>(expect1);
      }
    }
  }


  virtual ~SyncDepartmentUserRequestSyncDepartmentUserCommand() = default;
};
class SyncDepartmentUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<SyncDepartmentUserRequestSyncDepartmentUserCommand> syncDepartmentUserCommand{};

  SyncDepartmentUserRequest() {}

  explicit SyncDepartmentUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (syncDepartmentUserCommand) {
      res["SyncDepartmentUserCommand"] = syncDepartmentUserCommand ? boost::any(syncDepartmentUserCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SyncDepartmentUserCommand") != m.end() && !m["SyncDepartmentUserCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["SyncDepartmentUserCommand"].type()) {
        SyncDepartmentUserRequestSyncDepartmentUserCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SyncDepartmentUserCommand"]));
        syncDepartmentUserCommand = make_shared<SyncDepartmentUserRequestSyncDepartmentUserCommand>(model1);
      }
    }
  }


  virtual ~SyncDepartmentUserRequest() = default;
};
class SyncDepartmentUserShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> syncDepartmentUserCommandShrink{};

  SyncDepartmentUserShrinkRequest() {}

  explicit SyncDepartmentUserShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (syncDepartmentUserCommandShrink) {
      res["SyncDepartmentUserCommand"] = boost::any(*syncDepartmentUserCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("SyncDepartmentUserCommand") != m.end() && !m["SyncDepartmentUserCommand"].empty()) {
      syncDepartmentUserCommandShrink = make_shared<string>(boost::any_cast<string>(m["SyncDepartmentUserCommand"]));
    }
  }


  virtual ~SyncDepartmentUserShrinkRequest() = default;
};
class SyncDepartmentUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  SyncDepartmentUserResponseBody() {}

  explicit SyncDepartmentUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncDepartmentUserResponseBody() = default;
};
class SyncDepartmentUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncDepartmentUserResponseBody> body{};

  SyncDepartmentUserResponse() {}

  explicit SyncDepartmentUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncDepartmentUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncDepartmentUserResponseBody>(model1);
      }
    }
  }


  virtual ~SyncDepartmentUserResponse() = default;
};
class UpdateAdHocFileRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> fileId{};
  shared_ptr<long> projectId{};

  UpdateAdHocFileRequestUpdateCommand() {}

  explicit UpdateAdHocFileRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateAdHocFileRequestUpdateCommand() = default;
};
class UpdateAdHocFileRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateAdHocFileRequestUpdateCommand> updateCommand{};

  UpdateAdHocFileRequest() {}

  explicit UpdateAdHocFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateAdHocFileRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateAdHocFileRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateAdHocFileRequest() = default;
};
class UpdateAdHocFileShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateAdHocFileShrinkRequest() {}

  explicit UpdateAdHocFileShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateAdHocFileShrinkRequest() = default;
};
class UpdateAdHocFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateAdHocFileResponseBody() {}

  explicit UpdateAdHocFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateAdHocFileResponseBody() = default;
};
class UpdateAdHocFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAdHocFileResponseBody> body{};

  UpdateAdHocFileResponse() {}

  explicit UpdateAdHocFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAdHocFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAdHocFileResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAdHocFileResponse() = default;
};
class UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> interval{};
  shared_ptr<string> intervalUnit{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<string> startTime{};

  UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig() {}

  explicit UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (intervalUnit) {
      res["IntervalUnit"] = boost::any(*intervalUnit);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("IntervalUnit") != m.end() && !m["IntervalUnit"].empty()) {
      intervalUnit = make_shared<string>(boost::any_cast<string>(m["IntervalUnit"]));
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig() = default;
};
class UpdateBatchTaskRequestUpdateCommandParamList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateBatchTaskRequestUpdateCommandParamList() {}

  explicit UpdateBatchTaskRequestUpdateCommandParamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommandParamList() = default;
};
class UpdateBatchTaskRequestUpdateCommandSparkClientInfo : public Darabonba::Model {
public:
  shared_ptr<string> sparkClientVersion{};

  UpdateBatchTaskRequestUpdateCommandSparkClientInfo() {}

  explicit UpdateBatchTaskRequestUpdateCommandSparkClientInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sparkClientVersion) {
      res["SparkClientVersion"] = boost::any(*sparkClientVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SparkClientVersion") != m.end() && !m["SparkClientVersion"].empty()) {
      sparkClientVersion = make_shared<string>(boost::any_cast<string>(m["SparkClientVersion"]));
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommandSparkClientInfo() = default;
};
class UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod : public Darabonba::Model {
public:
  shared_ptr<long> periodOffset{};
  shared_ptr<string> periodType{};

  UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod() {}

  explicit UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (periodOffset) {
      res["PeriodOffset"] = boost::any(*periodOffset);
    }
    if (periodType) {
      res["PeriodType"] = boost::any(*periodType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PeriodOffset") != m.end() && !m["PeriodOffset"].empty()) {
      periodOffset = make_shared<long>(boost::any_cast<long>(m["PeriodOffset"]));
    }
    if (m.find("PeriodType") != m.end() && !m["PeriodType"].empty()) {
      periodType = make_shared<string>(boost::any_cast<string>(m["PeriodType"]));
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod() = default;
};
class UpdateBatchTaskRequestUpdateCommandUpStreamList : public Darabonba::Model {
public:
  shared_ptr<UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod> dependPeriod{};
  shared_ptr<string> dependStrategy{};
  shared_ptr<vector<string>> fieldList{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> periodDiff{};
  shared_ptr<bool> sourceNodeEnabled{};
  shared_ptr<string> sourceNodeId{};
  shared_ptr<string> sourceNodeOutputName{};
  shared_ptr<string> sourceTableName{};

  UpdateBatchTaskRequestUpdateCommandUpStreamList() {}

  explicit UpdateBatchTaskRequestUpdateCommandUpStreamList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dependPeriod) {
      res["DependPeriod"] = dependPeriod ? boost::any(dependPeriod->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dependStrategy) {
      res["DependStrategy"] = boost::any(*dependStrategy);
    }
    if (fieldList) {
      res["FieldList"] = boost::any(*fieldList);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (periodDiff) {
      res["PeriodDiff"] = boost::any(*periodDiff);
    }
    if (sourceNodeEnabled) {
      res["SourceNodeEnabled"] = boost::any(*sourceNodeEnabled);
    }
    if (sourceNodeId) {
      res["SourceNodeId"] = boost::any(*sourceNodeId);
    }
    if (sourceNodeOutputName) {
      res["SourceNodeOutputName"] = boost::any(*sourceNodeOutputName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DependPeriod") != m.end() && !m["DependPeriod"].empty()) {
      if (typeid(map<string, boost::any>) == m["DependPeriod"].type()) {
        UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DependPeriod"]));
        dependPeriod = make_shared<UpdateBatchTaskRequestUpdateCommandUpStreamListDependPeriod>(model1);
      }
    }
    if (m.find("DependStrategy") != m.end() && !m["DependStrategy"].empty()) {
      dependStrategy = make_shared<string>(boost::any_cast<string>(m["DependStrategy"]));
    }
    if (m.find("FieldList") != m.end() && !m["FieldList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FieldList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FieldList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PeriodDiff") != m.end() && !m["PeriodDiff"].empty()) {
      periodDiff = make_shared<long>(boost::any_cast<long>(m["PeriodDiff"]));
    }
    if (m.find("SourceNodeEnabled") != m.end() && !m["SourceNodeEnabled"].empty()) {
      sourceNodeEnabled = make_shared<bool>(boost::any_cast<bool>(m["SourceNodeEnabled"]));
    }
    if (m.find("SourceNodeId") != m.end() && !m["SourceNodeId"].empty()) {
      sourceNodeId = make_shared<string>(boost::any_cast<string>(m["SourceNodeId"]));
    }
    if (m.find("SourceNodeOutputName") != m.end() && !m["SourceNodeOutputName"].empty()) {
      sourceNodeOutputName = make_shared<string>(boost::any_cast<string>(m["SourceNodeOutputName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommandUpStreamList() = default;
};
class UpdateBatchTaskRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> cronExpression{};
  shared_ptr<UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig> customScheduleConfig{};
  shared_ptr<string> dataSourceCatalog{};
  shared_ptr<string> dataSourceId{};
  shared_ptr<string> dataSourceSchema{};
  shared_ptr<string> engine{};
  shared_ptr<long> fileId{};
  shared_ptr<string> name{};
  shared_ptr<string> nodeDescription{};
  shared_ptr<vector<string>> nodeOutputNameList{};
  shared_ptr<long> nodeStatus{};
  shared_ptr<vector<UpdateBatchTaskRequestUpdateCommandParamList>> paramList{};
  shared_ptr<long> priority{};
  shared_ptr<long> projectId{};
  shared_ptr<vector<string>> pythonModuleList{};
  shared_ptr<string> schedulePeriod{};
  shared_ptr<UpdateBatchTaskRequestUpdateCommandSparkClientInfo> sparkClientInfo{};
  shared_ptr<long> taskType{};
  shared_ptr<vector<UpdateBatchTaskRequestUpdateCommandUpStreamList>> upStreamList{};

  UpdateBatchTaskRequestUpdateCommand() {}

  explicit UpdateBatchTaskRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (customScheduleConfig) {
      res["CustomScheduleConfig"] = customScheduleConfig ? boost::any(customScheduleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataSourceCatalog) {
      res["DataSourceCatalog"] = boost::any(*dataSourceCatalog);
    }
    if (dataSourceId) {
      res["DataSourceId"] = boost::any(*dataSourceId);
    }
    if (dataSourceSchema) {
      res["DataSourceSchema"] = boost::any(*dataSourceSchema);
    }
    if (engine) {
      res["Engine"] = boost::any(*engine);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeDescription) {
      res["NodeDescription"] = boost::any(*nodeDescription);
    }
    if (nodeOutputNameList) {
      res["NodeOutputNameList"] = boost::any(*nodeOutputNameList);
    }
    if (nodeStatus) {
      res["NodeStatus"] = boost::any(*nodeStatus);
    }
    if (paramList) {
      vector<boost::any> temp1;
      for(auto item1:*paramList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ParamList"] = boost::any(temp1);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (pythonModuleList) {
      res["PythonModuleList"] = boost::any(*pythonModuleList);
    }
    if (schedulePeriod) {
      res["SchedulePeriod"] = boost::any(*schedulePeriod);
    }
    if (sparkClientInfo) {
      res["SparkClientInfo"] = sparkClientInfo ? boost::any(sparkClientInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (upStreamList) {
      vector<boost::any> temp1;
      for(auto item1:*upStreamList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UpStreamList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("CustomScheduleConfig") != m.end() && !m["CustomScheduleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomScheduleConfig"].type()) {
        UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomScheduleConfig"]));
        customScheduleConfig = make_shared<UpdateBatchTaskRequestUpdateCommandCustomScheduleConfig>(model1);
      }
    }
    if (m.find("DataSourceCatalog") != m.end() && !m["DataSourceCatalog"].empty()) {
      dataSourceCatalog = make_shared<string>(boost::any_cast<string>(m["DataSourceCatalog"]));
    }
    if (m.find("DataSourceId") != m.end() && !m["DataSourceId"].empty()) {
      dataSourceId = make_shared<string>(boost::any_cast<string>(m["DataSourceId"]));
    }
    if (m.find("DataSourceSchema") != m.end() && !m["DataSourceSchema"].empty()) {
      dataSourceSchema = make_shared<string>(boost::any_cast<string>(m["DataSourceSchema"]));
    }
    if (m.find("Engine") != m.end() && !m["Engine"].empty()) {
      engine = make_shared<string>(boost::any_cast<string>(m["Engine"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeDescription") != m.end() && !m["NodeDescription"].empty()) {
      nodeDescription = make_shared<string>(boost::any_cast<string>(m["NodeDescription"]));
    }
    if (m.find("NodeOutputNameList") != m.end() && !m["NodeOutputNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NodeOutputNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeOutputNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeOutputNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      nodeStatus = make_shared<long>(boost::any_cast<long>(m["NodeStatus"]));
    }
    if (m.find("ParamList") != m.end() && !m["ParamList"].empty()) {
      if (typeid(vector<boost::any>) == m["ParamList"].type()) {
        vector<UpdateBatchTaskRequestUpdateCommandParamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ParamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchTaskRequestUpdateCommandParamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        paramList = make_shared<vector<UpdateBatchTaskRequestUpdateCommandParamList>>(expect1);
      }
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
    if (m.find("PythonModuleList") != m.end() && !m["PythonModuleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PythonModuleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PythonModuleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pythonModuleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SchedulePeriod") != m.end() && !m["SchedulePeriod"].empty()) {
      schedulePeriod = make_shared<string>(boost::any_cast<string>(m["SchedulePeriod"]));
    }
    if (m.find("SparkClientInfo") != m.end() && !m["SparkClientInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SparkClientInfo"].type()) {
        UpdateBatchTaskRequestUpdateCommandSparkClientInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SparkClientInfo"]));
        sparkClientInfo = make_shared<UpdateBatchTaskRequestUpdateCommandSparkClientInfo>(model1);
      }
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<long>(boost::any_cast<long>(m["TaskType"]));
    }
    if (m.find("UpStreamList") != m.end() && !m["UpStreamList"].empty()) {
      if (typeid(vector<boost::any>) == m["UpStreamList"].type()) {
        vector<UpdateBatchTaskRequestUpdateCommandUpStreamList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UpStreamList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchTaskRequestUpdateCommandUpStreamList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        upStreamList = make_shared<vector<UpdateBatchTaskRequestUpdateCommandUpStreamList>>(expect1);
      }
    }
  }


  virtual ~UpdateBatchTaskRequestUpdateCommand() = default;
};
class UpdateBatchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateBatchTaskRequestUpdateCommand> updateCommand{};

  UpdateBatchTaskRequest() {}

  explicit UpdateBatchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateBatchTaskRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateBatchTaskRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateBatchTaskRequest() = default;
};
class UpdateBatchTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateBatchTaskShrinkRequest() {}

  explicit UpdateBatchTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateBatchTaskShrinkRequest() = default;
};
class UpdateBatchTaskResponseBodyUpdateResult : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};

  UpdateBatchTaskResponseBodyUpdateResult() {}

  explicit UpdateBatchTaskResponseBodyUpdateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
  }


  virtual ~UpdateBatchTaskResponseBodyUpdateResult() = default;
};
class UpdateBatchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<UpdateBatchTaskResponseBodyUpdateResult> updateResult{};

  UpdateBatchTaskResponseBody() {}

  explicit UpdateBatchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (updateResult) {
      res["UpdateResult"] = updateResult ? boost::any(updateResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("UpdateResult") != m.end() && !m["UpdateResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateResult"].type()) {
        UpdateBatchTaskResponseBodyUpdateResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateResult"]));
        updateResult = make_shared<UpdateBatchTaskResponseBodyUpdateResult>(model1);
      }
    }
  }


  virtual ~UpdateBatchTaskResponseBody() = default;
};
class UpdateBatchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBatchTaskResponseBody> body{};

  UpdateBatchTaskResponse() {}

  explicit UpdateBatchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBatchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBatchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBatchTaskResponse() = default;
};
class UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columnList{};
  shared_ptr<string> env{};
  shared_ptr<bool> fullTable{};
  shared_ptr<string> name{};

  UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList() {}

  explicit UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnList) {
      res["ColumnList"] = boost::any(*columnList);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fullTable) {
      res["FullTable"] = boost::any(*fullTable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ColumnList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columnList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FullTable") != m.end() && !m["FullTable"].empty()) {
      fullTable = make_shared<bool>(boost::any_cast<bool>(m["FullTable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList() = default;
};
class UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> columnList{};
  shared_ptr<string> env{};
  shared_ptr<bool> fullTable{};
  shared_ptr<string> name{};

  UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList() {}

  explicit UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnList) {
      res["ColumnList"] = boost::any(*columnList);
    }
    if (env) {
      res["Env"] = boost::any(*env);
    }
    if (fullTable) {
      res["FullTable"] = boost::any(*fullTable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnList") != m.end() && !m["ColumnList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ColumnList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ColumnList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      columnList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Env") != m.end() && !m["Env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["Env"]));
    }
    if (m.find("FullTable") != m.end() && !m["FullTable"].empty()) {
      fullTable = make_shared<bool>(boost::any_cast<bool>(m["FullTable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList() = default;
};
class UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList>> inputLineageList{};
  shared_ptr<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList>> outputLineageList{};

  UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList() {}

  explicit UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inputLineageList) {
      vector<boost::any> temp1;
      for(auto item1:*inputLineageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InputLineageList"] = boost::any(temp1);
    }
    if (outputLineageList) {
      vector<boost::any> temp1;
      for(auto item1:*outputLineageList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OutputLineageList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InputLineageList") != m.end() && !m["InputLineageList"].empty()) {
      if (typeid(vector<boost::any>) == m["InputLineageList"].type()) {
        vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InputLineageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inputLineageList = make_shared<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListInputLineageList>>(expect1);
      }
    }
    if (m.find("OutputLineageList") != m.end() && !m["OutputLineageList"].empty()) {
      if (typeid(vector<boost::any>) == m["OutputLineageList"].type()) {
        vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OutputLineageList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outputLineageList = make_shared<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupListOutputLineageList>>(expect1);
      }
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList() = default;
};
class UpdateBatchTaskUdfLineagesRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList>> lineageGroupList{};
  shared_ptr<long> projectId{};

  UpdateBatchTaskUdfLineagesRequestUpdateCommand() {}

  explicit UpdateBatchTaskUdfLineagesRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (lineageGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*lineageGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LineageGroupList"] = boost::any(temp1);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("LineageGroupList") != m.end() && !m["LineageGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["LineageGroupList"].type()) {
        vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LineageGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lineageGroupList = make_shared<vector<UpdateBatchTaskUdfLineagesRequestUpdateCommandLineageGroupList>>(expect1);
      }
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesRequestUpdateCommand() = default;
};
class UpdateBatchTaskUdfLineagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateBatchTaskUdfLineagesRequestUpdateCommand> updateCommand{};

  UpdateBatchTaskUdfLineagesRequest() {}

  explicit UpdateBatchTaskUdfLineagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateBatchTaskUdfLineagesRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateBatchTaskUdfLineagesRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesRequest() = default;
};
class UpdateBatchTaskUdfLineagesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateBatchTaskUdfLineagesShrinkRequest() {}

  explicit UpdateBatchTaskUdfLineagesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesShrinkRequest() = default;
};
class UpdateBatchTaskUdfLineagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateBatchTaskUdfLineagesResponseBody() {}

  explicit UpdateBatchTaskUdfLineagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesResponseBody() = default;
};
class UpdateBatchTaskUdfLineagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBatchTaskUdfLineagesResponseBody> body{};

  UpdateBatchTaskUdfLineagesResponse() {}

  explicit UpdateBatchTaskUdfLineagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBatchTaskUdfLineagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBatchTaskUdfLineagesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBatchTaskUdfLineagesResponse() = default;
};
class UpdateBizEntityRequestUpdateCommandBizObject : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<long> parentId{};
  shared_ptr<vector<long>> refBizEntityIdList{};

  UpdateBizEntityRequestUpdateCommandBizObject() {}

  explicit UpdateBizEntityRequestUpdateCommandBizObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateBizEntityRequestUpdateCommandBizObject() = default;
};
class UpdateBizEntityRequestUpdateCommandBizProcess : public Darabonba::Model {
public:
  shared_ptr<vector<long>> bizEventEntityIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerUserId{};
  shared_ptr<vector<long>> preBizProcessIdList{};
  shared_ptr<vector<long>> refBizEntityIdList{};

  UpdateBizEntityRequestUpdateCommandBizProcess() {}

  explicit UpdateBizEntityRequestUpdateCommandBizProcess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizEventEntityIdList) {
      res["BizEventEntityIdList"] = boost::any(*bizEventEntityIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerUserId) {
      res["OwnerUserId"] = boost::any(*ownerUserId);
    }
    if (preBizProcessIdList) {
      res["PreBizProcessIdList"] = boost::any(*preBizProcessIdList);
    }
    if (refBizEntityIdList) {
      res["RefBizEntityIdList"] = boost::any(*refBizEntityIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizEventEntityIdList") != m.end() && !m["BizEventEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["BizEventEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["BizEventEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      bizEventEntityIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerUserId") != m.end() && !m["OwnerUserId"].empty()) {
      ownerUserId = make_shared<string>(boost::any_cast<string>(m["OwnerUserId"]));
    }
    if (m.find("PreBizProcessIdList") != m.end() && !m["PreBizProcessIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["PreBizProcessIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PreBizProcessIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      preBizProcessIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("RefBizEntityIdList") != m.end() && !m["RefBizEntityIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RefBizEntityIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RefBizEntityIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      refBizEntityIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateBizEntityRequestUpdateCommandBizProcess() = default;
};
class UpdateBizEntityRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<UpdateBizEntityRequestUpdateCommandBizObject> bizObject{};
  shared_ptr<UpdateBizEntityRequestUpdateCommandBizProcess> bizProcess{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<long> id{};
  shared_ptr<string> type{};

  UpdateBizEntityRequestUpdateCommand() {}

  explicit UpdateBizEntityRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizObject) {
      res["BizObject"] = bizObject ? boost::any(bizObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizProcess) {
      res["BizProcess"] = bizProcess ? boost::any(bizProcess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizObject") != m.end() && !m["BizObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizObject"].type()) {
        UpdateBizEntityRequestUpdateCommandBizObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizObject"]));
        bizObject = make_shared<UpdateBizEntityRequestUpdateCommandBizObject>(model1);
      }
    }
    if (m.find("BizProcess") != m.end() && !m["BizProcess"].empty()) {
      if (typeid(map<string, boost::any>) == m["BizProcess"].type()) {
        UpdateBizEntityRequestUpdateCommandBizProcess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BizProcess"]));
        bizProcess = make_shared<UpdateBizEntityRequestUpdateCommandBizProcess>(model1);
      }
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateBizEntityRequestUpdateCommand() = default;
};
class UpdateBizEntityRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateBizEntityRequestUpdateCommand> updateCommand{};

  UpdateBizEntityRequest() {}

  explicit UpdateBizEntityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateBizEntityRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateBizEntityRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateBizEntityRequest() = default;
};
class UpdateBizEntityShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateBizEntityShrinkRequest() {}

  explicit UpdateBizEntityShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateBizEntityShrinkRequest() = default;
};
class UpdateBizEntityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateBizEntityResponseBody() {}

  explicit UpdateBizEntityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBizEntityResponseBody() = default;
};
class UpdateBizEntityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBizEntityResponseBody> body{};

  UpdateBizEntityResponse() {}

  explicit UpdateBizEntityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBizEntityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBizEntityResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBizEntityResponse() = default;
};
class UpdateBizUnitRequestUpdateCommandBizUnitAccountList : public Darabonba::Model {
public:
  shared_ptr<string> userId{};

  UpdateBizUnitRequestUpdateCommandBizUnitAccountList() {}

  explicit UpdateBizUnitRequestUpdateCommandBizUnitAccountList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateBizUnitRequestUpdateCommandBizUnitAccountList() = default;
};
class UpdateBizUnitRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateBizUnitRequestUpdateCommandBizUnitAccountList>> bizUnitAccountList{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> icon{};
  shared_ptr<string> name{};

  UpdateBizUnitRequestUpdateCommand() {}

  explicit UpdateBizUnitRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizUnitAccountList) {
      vector<boost::any> temp1;
      for(auto item1:*bizUnitAccountList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BizUnitAccountList"] = boost::any(temp1);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (icon) {
      res["Icon"] = boost::any(*icon);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizUnitAccountList") != m.end() && !m["BizUnitAccountList"].empty()) {
      if (typeid(vector<boost::any>) == m["BizUnitAccountList"].type()) {
        vector<UpdateBizUnitRequestUpdateCommandBizUnitAccountList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BizUnitAccountList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBizUnitRequestUpdateCommandBizUnitAccountList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bizUnitAccountList = make_shared<vector<UpdateBizUnitRequestUpdateCommandBizUnitAccountList>>(expect1);
      }
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Icon") != m.end() && !m["Icon"].empty()) {
      icon = make_shared<string>(boost::any_cast<string>(m["Icon"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateBizUnitRequestUpdateCommand() = default;
};
class UpdateBizUnitRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateBizUnitRequestUpdateCommand> updateCommand{};

  UpdateBizUnitRequest() {}

  explicit UpdateBizUnitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateBizUnitRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateBizUnitRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateBizUnitRequest() = default;
};
class UpdateBizUnitShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateBizUnitShrinkRequest() {}

  explicit UpdateBizUnitShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateBizUnitShrinkRequest() = default;
};
class UpdateBizUnitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateBizUnitResponseBody() {}

  explicit UpdateBizUnitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateBizUnitResponseBody() = default;
};
class UpdateBizUnitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBizUnitResponseBody> body{};

  UpdateBizUnitResponse() {}

  explicit UpdateBizUnitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBizUnitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBizUnitResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBizUnitResponse() = default;
};
class UpdateDataDomainRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<string> abbreviation{};
  shared_ptr<long> bizUnitId{};
  shared_ptr<long> dataDomainId{};
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> name{};
  shared_ptr<long> parentId{};

  UpdateDataDomainRequestUpdateCommand() {}

  explicit UpdateDataDomainRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abbreviation) {
      res["Abbreviation"] = boost::any(*abbreviation);
    }
    if (bizUnitId) {
      res["BizUnitId"] = boost::any(*bizUnitId);
    }
    if (dataDomainId) {
      res["DataDomainId"] = boost::any(*dataDomainId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parentId) {
      res["ParentId"] = boost::any(*parentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Abbreviation") != m.end() && !m["Abbreviation"].empty()) {
      abbreviation = make_shared<string>(boost::any_cast<string>(m["Abbreviation"]));
    }
    if (m.find("BizUnitId") != m.end() && !m["BizUnitId"].empty()) {
      bizUnitId = make_shared<long>(boost::any_cast<long>(m["BizUnitId"]));
    }
    if (m.find("DataDomainId") != m.end() && !m["DataDomainId"].empty()) {
      dataDomainId = make_shared<long>(boost::any_cast<long>(m["DataDomainId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ParentId") != m.end() && !m["ParentId"].empty()) {
      parentId = make_shared<long>(boost::any_cast<long>(m["ParentId"]));
    }
  }


  virtual ~UpdateDataDomainRequestUpdateCommand() = default;
};
class UpdateDataDomainRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateDataDomainRequestUpdateCommand> updateCommand{};

  UpdateDataDomainRequest() {}

  explicit UpdateDataDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateDataDomainRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateDataDomainRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateDataDomainRequest() = default;
};
class UpdateDataDomainShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateDataDomainShrinkRequest() {}

  explicit UpdateDataDomainShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateDataDomainShrinkRequest() = default;
};
class UpdateDataDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataDomainResponseBody() {}

  explicit UpdateDataDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataDomainResponseBody() = default;
};
class UpdateDataDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataDomainResponseBody> body{};

  UpdateDataDomainResponse() {}

  explicit UpdateDataDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataDomainResponse() = default;
};
class UpdateDataSourceBasicInfoRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  UpdateDataSourceBasicInfoRequestUpdateCommand() {}

  explicit UpdateDataSourceBasicInfoRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateDataSourceBasicInfoRequestUpdateCommand() = default;
};
class UpdateDataSourceBasicInfoRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateDataSourceBasicInfoRequestUpdateCommand> updateCommand{};

  UpdateDataSourceBasicInfoRequest() {}

  explicit UpdateDataSourceBasicInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateDataSourceBasicInfoRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateDataSourceBasicInfoRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceBasicInfoRequest() = default;
};
class UpdateDataSourceBasicInfoShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateDataSourceBasicInfoShrinkRequest() {}

  explicit UpdateDataSourceBasicInfoShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateDataSourceBasicInfoShrinkRequest() = default;
};
class UpdateDataSourceBasicInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataSourceBasicInfoResponseBody() {}

  explicit UpdateDataSourceBasicInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataSourceBasicInfoResponseBody() = default;
};
class UpdateDataSourceBasicInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataSourceBasicInfoResponseBody> body{};

  UpdateDataSourceBasicInfoResponse() {}

  explicit UpdateDataSourceBasicInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceBasicInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceBasicInfoResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceBasicInfoResponse() = default;
};
class UpdateDataSourceConfigRequestUpdateCommandConfigItemList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateDataSourceConfigRequestUpdateCommandConfigItemList() {}

  explicit UpdateDataSourceConfigRequestUpdateCommandConfigItemList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateDataSourceConfigRequestUpdateCommandConfigItemList() = default;
};
class UpdateDataSourceConfigRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateDataSourceConfigRequestUpdateCommandConfigItemList>> configItemList{};
  shared_ptr<long> id{};

  UpdateDataSourceConfigRequestUpdateCommand() {}

  explicit UpdateDataSourceConfigRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItemList) {
      vector<boost::any> temp1;
      for(auto item1:*configItemList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConfigItemList"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItemList") != m.end() && !m["ConfigItemList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConfigItemList"].type()) {
        vector<UpdateDataSourceConfigRequestUpdateCommandConfigItemList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConfigItemList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDataSourceConfigRequestUpdateCommandConfigItemList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configItemList = make_shared<vector<UpdateDataSourceConfigRequestUpdateCommandConfigItemList>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~UpdateDataSourceConfigRequestUpdateCommand() = default;
};
class UpdateDataSourceConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateDataSourceConfigRequestUpdateCommand> updateCommand{};

  UpdateDataSourceConfigRequest() {}

  explicit UpdateDataSourceConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateDataSourceConfigRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateDataSourceConfigRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceConfigRequest() = default;
};
class UpdateDataSourceConfigShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateDataSourceConfigShrinkRequest() {}

  explicit UpdateDataSourceConfigShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateDataSourceConfigShrinkRequest() = default;
};
class UpdateDataSourceConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateDataSourceConfigResponseBody() {}

  explicit UpdateDataSourceConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateDataSourceConfigResponseBody() = default;
};
class UpdateDataSourceConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDataSourceConfigResponseBody> body{};

  UpdateDataSourceConfigResponse() {}

  explicit UpdateDataSourceConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDataSourceConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDataSourceConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDataSourceConfigResponse() = default;
};
class UpdateFileDirectoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> directory{};
  shared_ptr<long> fileId{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  UpdateFileDirectoryRequest() {}

  explicit UpdateFileDirectoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (directory) {
      res["Directory"] = boost::any(*directory);
    }
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Directory") != m.end() && !m["Directory"].empty()) {
      directory = make_shared<string>(boost::any_cast<string>(m["Directory"]));
    }
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateFileDirectoryRequest() = default;
};
class UpdateFileDirectoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFileDirectoryResponseBody() {}

  explicit UpdateFileDirectoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFileDirectoryResponseBody() = default;
};
class UpdateFileDirectoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileDirectoryResponseBody> body{};

  UpdateFileDirectoryResponse() {}

  explicit UpdateFileDirectoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileDirectoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileDirectoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileDirectoryResponse() = default;
};
class UpdateFileNameRequest : public Darabonba::Model {
public:
  shared_ptr<long> fileId{};
  shared_ptr<string> name{};
  shared_ptr<long> opTenantId{};
  shared_ptr<long> projectId{};

  UpdateFileNameRequest() {}

  explicit UpdateFileNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileId) {
      res["FileId"] = boost::any(*fileId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileId") != m.end() && !m["FileId"].empty()) {
      fileId = make_shared<long>(boost::any_cast<long>(m["FileId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<long>(boost::any_cast<long>(m["ProjectId"]));
    }
  }


  virtual ~UpdateFileNameRequest() = default;
};
class UpdateFileNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateFileNameResponseBody() {}

  explicit UpdateFileNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateFileNameResponseBody() = default;
};
class UpdateFileNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileNameResponseBody> body{};

  UpdateFileNameResponse() {}

  explicit UpdateFileNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileNameResponse() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnDesc{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnDesc) {
      res["ColumnDesc"] = boost::any(*columnDesc);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnDesc") != m.end() && !m["ColumnDesc"].empty()) {
      columnDesc = make_shared<string>(boost::any_cast<string>(m["ColumnDesc"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions : public Darabonba::Model {
public:
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> operator_{};
  shared_ptr<vector<boost::any>> subConditions{};
  shared_ptr<string> type{};
  shared_ptr<vector<string>> values{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (subConditions) {
      res["SubConditions"] = boost::any(*subConditions);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("SubConditions") != m.end() && !m["SubConditions"].empty()) {
      vector<boost::any> toVec1;
      if (typeid(vector<boost::any>) == m["SubConditions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SubConditions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<boost::any>(item));
        }
      }
      subConditions = make_shared<vector<boost::any>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts : public Darabonba::Model {
public:
  shared_ptr<string> accountId{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountId) {
      res["AccountId"] = boost::any(*accountId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountId") != m.end() && !m["AccountId"].empty()) {
      accountId = make_shared<string>(boost::any_cast<string>(m["AccountId"]));
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts>> accounts{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["AccountType"] = boost::any(*accountType);
    }
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountType") != m.end() && !m["AccountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["AccountType"]));
    }
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingListAccounts>>(expect1);
      }
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandRules : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions>> expressions{};
  shared_ptr<bool> isDelete{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> scopeType{};
  shared_ptr<long> status{};
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList>> userMappingList{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandRules() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expressions) {
      vector<boost::any> temp1;
      for(auto item1:*expressions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Expressions"] = boost::any(temp1);
    }
    if (isDelete) {
      res["IsDelete"] = boost::any(*isDelete);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    if (scopeType) {
      res["ScopeType"] = boost::any(*scopeType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userMappingList) {
      vector<boost::any> temp1;
      for(auto item1:*userMappingList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserMappingList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Expressions") != m.end() && !m["Expressions"].empty()) {
      if (typeid(vector<boost::any>) == m["Expressions"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Expressions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        expressions = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesExpressions>>(expect1);
      }
    }
    if (m.find("IsDelete") != m.end() && !m["IsDelete"].empty()) {
      isDelete = make_shared<bool>(boost::any_cast<bool>(m["IsDelete"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
    if (m.find("ScopeType") != m.end() && !m["ScopeType"].empty()) {
      scopeType = make_shared<string>(boost::any_cast<string>(m["ScopeType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UserMappingList") != m.end() && !m["UserMappingList"].empty()) {
      if (typeid(vector<boost::any>) == m["UserMappingList"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserMappingList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userMappingList = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRulesUserMappingList>>(expect1);
      }
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandRules() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommandTables : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> mappingColumnName{};
  shared_ptr<string> resourceId{};

  UpdateRowPermissionRequestUpdateRowPermissionCommandTables() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommandTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (mappingColumnName) {
      res["MappingColumnName"] = boost::any(*mappingColumnName);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("MappingColumnName") != m.end() && !m["MappingColumnName"].empty()) {
      mappingColumnName = make_shared<string>(boost::any_cast<string>(m["MappingColumnName"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommandTables() = default;
};
class UpdateRowPermissionRequestUpdateRowPermissionCommand : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns>> mappingColumns{};
  shared_ptr<string> rowPermissionDesc{};
  shared_ptr<long> rowPermissionId{};
  shared_ptr<string> rowPermissionName{};
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRules>> rules{};
  shared_ptr<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandTables>> tables{};

  UpdateRowPermissionRequestUpdateRowPermissionCommand() {}

  explicit UpdateRowPermissionRequestUpdateRowPermissionCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mappingColumns) {
      vector<boost::any> temp1;
      for(auto item1:*mappingColumns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MappingColumns"] = boost::any(temp1);
    }
    if (rowPermissionDesc) {
      res["RowPermissionDesc"] = boost::any(*rowPermissionDesc);
    }
    if (rowPermissionId) {
      res["RowPermissionId"] = boost::any(*rowPermissionId);
    }
    if (rowPermissionName) {
      res["RowPermissionName"] = boost::any(*rowPermissionName);
    }
    if (rules) {
      vector<boost::any> temp1;
      for(auto item1:*rules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Rules"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MappingColumns") != m.end() && !m["MappingColumns"].empty()) {
      if (typeid(vector<boost::any>) == m["MappingColumns"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MappingColumns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mappingColumns = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandMappingColumns>>(expect1);
      }
    }
    if (m.find("RowPermissionDesc") != m.end() && !m["RowPermissionDesc"].empty()) {
      rowPermissionDesc = make_shared<string>(boost::any_cast<string>(m["RowPermissionDesc"]));
    }
    if (m.find("RowPermissionId") != m.end() && !m["RowPermissionId"].empty()) {
      rowPermissionId = make_shared<long>(boost::any_cast<long>(m["RowPermissionId"]));
    }
    if (m.find("RowPermissionName") != m.end() && !m["RowPermissionName"].empty()) {
      rowPermissionName = make_shared<string>(boost::any_cast<string>(m["RowPermissionName"]));
    }
    if (m.find("Rules") != m.end() && !m["Rules"].empty()) {
      if (typeid(vector<boost::any>) == m["Rules"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Rules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        rules = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandRules>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<UpdateRowPermissionRequestUpdateRowPermissionCommandTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRowPermissionRequestUpdateRowPermissionCommandTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<UpdateRowPermissionRequestUpdateRowPermissionCommandTables>>(expect1);
      }
    }
  }


  virtual ~UpdateRowPermissionRequestUpdateRowPermissionCommand() = default;
};
class UpdateRowPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateRowPermissionRequestUpdateRowPermissionCommand> updateRowPermissionCommand{};

  UpdateRowPermissionRequest() {}

  explicit UpdateRowPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateRowPermissionCommand) {
      res["UpdateRowPermissionCommand"] = updateRowPermissionCommand ? boost::any(updateRowPermissionCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateRowPermissionCommand") != m.end() && !m["UpdateRowPermissionCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateRowPermissionCommand"].type()) {
        UpdateRowPermissionRequestUpdateRowPermissionCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateRowPermissionCommand"]));
        updateRowPermissionCommand = make_shared<UpdateRowPermissionRequestUpdateRowPermissionCommand>(model1);
      }
    }
  }


  virtual ~UpdateRowPermissionRequest() = default;
};
class UpdateRowPermissionShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateRowPermissionCommandShrink{};

  UpdateRowPermissionShrinkRequest() {}

  explicit UpdateRowPermissionShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateRowPermissionCommandShrink) {
      res["UpdateRowPermissionCommand"] = boost::any(*updateRowPermissionCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateRowPermissionCommand") != m.end() && !m["UpdateRowPermissionCommand"].empty()) {
      updateRowPermissionCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateRowPermissionCommand"]));
    }
  }


  virtual ~UpdateRowPermissionShrinkRequest() = default;
};
class UpdateRowPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateRowPermissionResponseBody() {}

  explicit UpdateRowPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateRowPermissionResponseBody() = default;
};
class UpdateRowPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRowPermissionResponseBody> body{};

  UpdateRowPermissionResponse() {}

  explicit UpdateRowPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRowPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRowPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRowPermissionResponse() = default;
};
class UpdateTenantMemberRequestUpdateCommandMemberList : public Darabonba::Model {
public:
  shared_ptr<string> dingNumber{};
  shared_ptr<string> mail{};
  shared_ptr<string> mobilePhone{};
  shared_ptr<vector<string>> roleList{};
  shared_ptr<string> userId{};

  UpdateTenantMemberRequestUpdateCommandMemberList() {}

  explicit UpdateTenantMemberRequestUpdateCommandMemberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dingNumber) {
      res["DingNumber"] = boost::any(*dingNumber);
    }
    if (mail) {
      res["Mail"] = boost::any(*mail);
    }
    if (mobilePhone) {
      res["MobilePhone"] = boost::any(*mobilePhone);
    }
    if (roleList) {
      res["RoleList"] = boost::any(*roleList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DingNumber") != m.end() && !m["DingNumber"].empty()) {
      dingNumber = make_shared<string>(boost::any_cast<string>(m["DingNumber"]));
    }
    if (m.find("Mail") != m.end() && !m["Mail"].empty()) {
      mail = make_shared<string>(boost::any_cast<string>(m["Mail"]));
    }
    if (m.find("MobilePhone") != m.end() && !m["MobilePhone"].empty()) {
      mobilePhone = make_shared<string>(boost::any_cast<string>(m["MobilePhone"]));
    }
    if (m.find("RoleList") != m.end() && !m["RoleList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RoleList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RoleList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      roleList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UpdateTenantMemberRequestUpdateCommandMemberList() = default;
};
class UpdateTenantMemberRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTenantMemberRequestUpdateCommandMemberList>> memberList{};

  UpdateTenantMemberRequestUpdateCommand() {}

  explicit UpdateTenantMemberRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberList) {
      vector<boost::any> temp1;
      for(auto item1:*memberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MemberList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      if (typeid(vector<boost::any>) == m["MemberList"].type()) {
        vector<UpdateTenantMemberRequestUpdateCommandMemberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MemberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTenantMemberRequestUpdateCommandMemberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        memberList = make_shared<vector<UpdateTenantMemberRequestUpdateCommandMemberList>>(expect1);
      }
    }
  }


  virtual ~UpdateTenantMemberRequestUpdateCommand() = default;
};
class UpdateTenantMemberRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateTenantMemberRequestUpdateCommand> updateCommand{};

  UpdateTenantMemberRequest() {}

  explicit UpdateTenantMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateTenantMemberRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateTenantMemberRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateTenantMemberRequest() = default;
};
class UpdateTenantMemberShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateTenantMemberShrinkRequest() {}

  explicit UpdateTenantMemberShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateTenantMemberShrinkRequest() = default;
};
class UpdateTenantMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateTenantMemberResponseBody() {}

  explicit UpdateTenantMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateTenantMemberResponseBody() = default;
};
class UpdateTenantMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTenantMemberResponseBody> body{};

  UpdateTenantMemberResponse() {}

  explicit UpdateTenantMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTenantMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTenantMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTenantMemberResponse() = default;
};
class UpdateUserGroupRequestUpdateCommand : public Darabonba::Model {
public:
  shared_ptr<vector<string>> adminUserIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  UpdateUserGroupRequestUpdateCommand() {}

  explicit UpdateUserGroupRequestUpdateCommand(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminUserIdList) {
      res["AdminUserIdList"] = boost::any(*adminUserIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminUserIdList") != m.end() && !m["AdminUserIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AdminUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AdminUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      adminUserIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateUserGroupRequestUpdateCommand() = default;
};
class UpdateUserGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<UpdateUserGroupRequestUpdateCommand> updateCommand{};

  UpdateUserGroupRequest() {}

  explicit UpdateUserGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommand) {
      res["UpdateCommand"] = updateCommand ? boost::any(updateCommand->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateCommand"].type()) {
        UpdateUserGroupRequestUpdateCommand model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateCommand"]));
        updateCommand = make_shared<UpdateUserGroupRequestUpdateCommand>(model1);
      }
    }
  }


  virtual ~UpdateUserGroupRequest() = default;
};
class UpdateUserGroupShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> opTenantId{};
  shared_ptr<string> updateCommandShrink{};

  UpdateUserGroupShrinkRequest() {}

  explicit UpdateUserGroupShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (updateCommandShrink) {
      res["UpdateCommand"] = boost::any(*updateCommandShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UpdateCommand") != m.end() && !m["UpdateCommand"].empty()) {
      updateCommandShrink = make_shared<string>(boost::any_cast<string>(m["UpdateCommand"]));
    }
  }


  virtual ~UpdateUserGroupShrinkRequest() = default;
};
class UpdateUserGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateUserGroupResponseBody() {}

  explicit UpdateUserGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateUserGroupResponseBody() = default;
};
class UpdateUserGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserGroupResponseBody> body{};

  UpdateUserGroupResponse() {}

  explicit UpdateUserGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserGroupResponse() = default;
};
class UpdateUserGroupSwitchRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<long> opTenantId{};
  shared_ptr<string> userGroupId{};

  UpdateUserGroupSwitchRequest() {}

  explicit UpdateUserGroupSwitchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (opTenantId) {
      res["OpTenantId"] = boost::any(*opTenantId);
    }
    if (userGroupId) {
      res["UserGroupId"] = boost::any(*userGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("OpTenantId") != m.end() && !m["OpTenantId"].empty()) {
      opTenantId = make_shared<long>(boost::any_cast<long>(m["OpTenantId"]));
    }
    if (m.find("UserGroupId") != m.end() && !m["UserGroupId"].empty()) {
      userGroupId = make_shared<string>(boost::any_cast<string>(m["UserGroupId"]));
    }
  }


  virtual ~UpdateUserGroupSwitchRequest() = default;
};
class UpdateUserGroupSwitchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  UpdateUserGroupSwitchResponseBody() {}

  explicit UpdateUserGroupSwitchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<bool>(boost::any_cast<bool>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateUserGroupSwitchResponseBody() = default;
};
class UpdateUserGroupSwitchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserGroupSwitchResponseBody> body{};

  UpdateUserGroupSwitchResponse() {}

  explicit UpdateUserGroupSwitchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserGroupSwitchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserGroupSwitchResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserGroupSwitchResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddTenantMembersResponse addTenantMembersWithOptions(shared_ptr<AddTenantMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTenantMembersResponse addTenantMembers(shared_ptr<AddTenantMembersRequest> request);
  AddTenantMembersBySourceUserResponse addTenantMembersBySourceUserWithOptions(shared_ptr<AddTenantMembersBySourceUserRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTenantMembersBySourceUserResponse addTenantMembersBySourceUser(shared_ptr<AddTenantMembersBySourceUserRequest> request);
  AddUserGroupMemberResponse addUserGroupMemberWithOptions(shared_ptr<AddUserGroupMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUserGroupMemberResponse addUserGroupMember(shared_ptr<AddUserGroupMemberRequest> request);
  CheckDataSourceConnectivityResponse checkDataSourceConnectivityWithOptions(shared_ptr<CheckDataSourceConnectivityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckDataSourceConnectivityResponse checkDataSourceConnectivity(shared_ptr<CheckDataSourceConnectivityRequest> request);
  CheckDataSourceConnectivityByIdResponse checkDataSourceConnectivityByIdWithOptions(shared_ptr<CheckDataSourceConnectivityByIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckDataSourceConnectivityByIdResponse checkDataSourceConnectivityById(shared_ptr<CheckDataSourceConnectivityByIdRequest> request);
  CheckResourcePermissionResponse checkResourcePermissionWithOptions(shared_ptr<CheckResourcePermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckResourcePermissionResponse checkResourcePermission(shared_ptr<CheckResourcePermissionRequest> request);
  CreateAdHocFileResponse createAdHocFileWithOptions(shared_ptr<CreateAdHocFileRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAdHocFileResponse createAdHocFile(shared_ptr<CreateAdHocFileRequest> request);
  CreateBatchTaskResponse createBatchTaskWithOptions(shared_ptr<CreateBatchTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBatchTaskResponse createBatchTask(shared_ptr<CreateBatchTaskRequest> request);
  CreateBizEntityResponse createBizEntityWithOptions(shared_ptr<CreateBizEntityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBizEntityResponse createBizEntity(shared_ptr<CreateBizEntityRequest> request);
  CreateBizUnitResponse createBizUnitWithOptions(shared_ptr<CreateBizUnitRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBizUnitResponse createBizUnit(shared_ptr<CreateBizUnitRequest> request);
  CreateDataDomainResponse createDataDomainWithOptions(shared_ptr<CreateDataDomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataDomainResponse createDataDomain(shared_ptr<CreateDataDomainRequest> request);
  CreateDataServiceApiResponse createDataServiceApiWithOptions(shared_ptr<CreateDataServiceApiRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataServiceApiResponse createDataServiceApi(shared_ptr<CreateDataServiceApiRequest> request);
  CreateDataSourceResponse createDataSourceWithOptions(shared_ptr<CreateDataSourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataSourceResponse createDataSource(shared_ptr<CreateDataSourceRequest> request);
  CreateDirectoryResponse createDirectoryWithOptions(shared_ptr<CreateDirectoryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDirectoryResponse createDirectory(shared_ptr<CreateDirectoryRequest> request);
  CreateNodeSupplementResponse createNodeSupplementWithOptions(shared_ptr<CreateNodeSupplementRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateNodeSupplementResponse createNodeSupplement(shared_ptr<CreateNodeSupplementRequest> request);
  CreatePipelineNodeResponse createPipelineNodeWithOptions(shared_ptr<CreatePipelineNodeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelineNodeResponse createPipelineNode(shared_ptr<CreatePipelineNodeRequest> request);
  CreateRowPermissionResponse createRowPermissionWithOptions(shared_ptr<CreateRowPermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRowPermissionResponse createRowPermission(shared_ptr<CreateRowPermissionRequest> request);
  CreateStreamBatchJobMappingResponse createStreamBatchJobMappingWithOptions(shared_ptr<CreateStreamBatchJobMappingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStreamBatchJobMappingResponse createStreamBatchJobMapping(shared_ptr<CreateStreamBatchJobMappingRequest> request);
  CreateUserGroupResponse createUserGroupWithOptions(shared_ptr<CreateUserGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserGroupResponse createUserGroup(shared_ptr<CreateUserGroupRequest> request);
  DeleteAdHocFileResponse deleteAdHocFileWithOptions(shared_ptr<DeleteAdHocFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAdHocFileResponse deleteAdHocFile(shared_ptr<DeleteAdHocFileRequest> request);
  DeleteBatchTaskResponse deleteBatchTaskWithOptions(shared_ptr<DeleteBatchTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBatchTaskResponse deleteBatchTask(shared_ptr<DeleteBatchTaskRequest> request);
  DeleteBizEntityResponse deleteBizEntityWithOptions(shared_ptr<DeleteBizEntityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBizEntityResponse deleteBizEntity(shared_ptr<DeleteBizEntityRequest> request);
  DeleteBizUnitResponse deleteBizUnitWithOptions(shared_ptr<DeleteBizUnitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBizUnitResponse deleteBizUnit(shared_ptr<DeleteBizUnitRequest> request);
  DeleteDataDomainResponse deleteDataDomainWithOptions(shared_ptr<DeleteDataDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataDomainResponse deleteDataDomain(shared_ptr<DeleteDataDomainRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteDirectoryResponse deleteDirectoryWithOptions(shared_ptr<DeleteDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDirectoryResponse deleteDirectory(shared_ptr<DeleteDirectoryRequest> request);
  DeleteRowPermissionResponse deleteRowPermissionWithOptions(shared_ptr<DeleteRowPermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRowPermissionResponse deleteRowPermission(shared_ptr<DeleteRowPermissionRequest> request);
  DeleteUserGroupResponse deleteUserGroupWithOptions(shared_ptr<DeleteUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserGroupResponse deleteUserGroup(shared_ptr<DeleteUserGroupRequest> request);
  ExecuteAdHocTaskResponse executeAdHocTaskWithOptions(shared_ptr<ExecuteAdHocTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteAdHocTaskResponse executeAdHocTask(shared_ptr<ExecuteAdHocTaskRequest> request);
  ExecuteManualNodeResponse executeManualNodeWithOptions(shared_ptr<ExecuteManualNodeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExecuteManualNodeResponse executeManualNode(shared_ptr<ExecuteManualNodeRequest> request);
  FixDataResponse fixDataWithOptions(shared_ptr<FixDataRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FixDataResponse fixData(shared_ptr<FixDataRequest> request);
  GetAccountByRowPermissionIdResponse getAccountByRowPermissionIdWithOptions(shared_ptr<GetAccountByRowPermissionIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAccountByRowPermissionIdResponse getAccountByRowPermissionId(shared_ptr<GetAccountByRowPermissionIdRequest> request);
  GetAdHocFileResponse getAdHocFileWithOptions(shared_ptr<GetAdHocFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAdHocFileResponse getAdHocFile(shared_ptr<GetAdHocFileRequest> request);
  GetAdHocTaskLogResponse getAdHocTaskLogWithOptions(shared_ptr<GetAdHocTaskLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAdHocTaskLogResponse getAdHocTaskLog(shared_ptr<GetAdHocTaskLogRequest> request);
  GetAdHocTaskResultResponse getAdHocTaskResultWithOptions(shared_ptr<GetAdHocTaskResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAdHocTaskResultResponse getAdHocTaskResult(shared_ptr<GetAdHocTaskResultRequest> request);
  GetAlertEventResponse getAlertEventWithOptions(shared_ptr<GetAlertEventRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAlertEventResponse getAlertEvent(shared_ptr<GetAlertEventRequest> request);
  GetBatchTaskInfoResponse getBatchTaskInfoWithOptions(shared_ptr<GetBatchTaskInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchTaskInfoResponse getBatchTaskInfo(shared_ptr<GetBatchTaskInfoRequest> request);
  GetBatchTaskInfoByVersionResponse getBatchTaskInfoByVersionWithOptions(shared_ptr<GetBatchTaskInfoByVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchTaskInfoByVersionResponse getBatchTaskInfoByVersion(shared_ptr<GetBatchTaskInfoByVersionRequest> request);
  GetBatchTaskUdfLineagesResponse getBatchTaskUdfLineagesWithOptions(shared_ptr<GetBatchTaskUdfLineagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchTaskUdfLineagesResponse getBatchTaskUdfLineages(shared_ptr<GetBatchTaskUdfLineagesRequest> request);
  GetBatchTaskVersionsResponse getBatchTaskVersionsWithOptions(shared_ptr<GetBatchTaskVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchTaskVersionsResponse getBatchTaskVersions(shared_ptr<GetBatchTaskVersionsRequest> request);
  GetBizEntityInfoResponse getBizEntityInfoWithOptions(shared_ptr<GetBizEntityInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBizEntityInfoResponse getBizEntityInfo(shared_ptr<GetBizEntityInfoRequest> request);
  GetBizEntityInfoByVersionResponse getBizEntityInfoByVersionWithOptions(shared_ptr<GetBizEntityInfoByVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBizEntityInfoByVersionResponse getBizEntityInfoByVersion(shared_ptr<GetBizEntityInfoByVersionRequest> request);
  GetBizUnitInfoResponse getBizUnitInfoWithOptions(shared_ptr<GetBizUnitInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBizUnitInfoResponse getBizUnitInfo(shared_ptr<GetBizUnitInfoRequest> request);
  GetClusterQueueInfoByEnvResponse getClusterQueueInfoByEnvWithOptions(shared_ptr<GetClusterQueueInfoByEnvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterQueueInfoByEnvResponse getClusterQueueInfoByEnv(shared_ptr<GetClusterQueueInfoByEnvRequest> request);
  GetDataDomainInfoResponse getDataDomainInfoWithOptions(shared_ptr<GetDataDomainInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDataDomainInfoResponse getDataDomainInfo(shared_ptr<GetDataDomainInfoRequest> request);
  GetDevObjectDependencyResponse getDevObjectDependencyWithOptions(shared_ptr<GetDevObjectDependencyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDevObjectDependencyResponse getDevObjectDependency(shared_ptr<GetDevObjectDependencyRequest> request);
  GetDirectoryTreeResponse getDirectoryTreeWithOptions(shared_ptr<GetDirectoryTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDirectoryTreeResponse getDirectoryTree(shared_ptr<GetDirectoryTreeRequest> request);
  GetInstanceDownStreamResponse getInstanceDownStreamWithOptions(shared_ptr<GetInstanceDownStreamRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceDownStreamResponse getInstanceDownStream(shared_ptr<GetInstanceDownStreamRequest> request);
  GetInstanceUpDownStreamResponse getInstanceUpDownStreamWithOptions(shared_ptr<GetInstanceUpDownStreamRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceUpDownStreamResponse getInstanceUpDownStream(shared_ptr<GetInstanceUpDownStreamRequest> request);
  GetLatestSubmitDetailResponse getLatestSubmitDetailWithOptions(shared_ptr<GetLatestSubmitDetailRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLatestSubmitDetailResponse getLatestSubmitDetail(shared_ptr<GetLatestSubmitDetailRequest> request);
  GetMyRolesResponse getMyRolesWithOptions(shared_ptr<GetMyRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMyRolesResponse getMyRoles(shared_ptr<GetMyRolesRequest> request);
  GetMyTenantsResponse getMyTenantsWithOptions(shared_ptr<GetMyTenantsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMyTenantsResponse getMyTenants(shared_ptr<GetMyTenantsRequest> request);
  GetNodeUpDownStreamResponse getNodeUpDownStreamWithOptions(shared_ptr<GetNodeUpDownStreamRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNodeUpDownStreamResponse getNodeUpDownStream(shared_ptr<GetNodeUpDownStreamRequest> request);
  GetOperationSubmitStatusResponse getOperationSubmitStatusWithOptions(shared_ptr<GetOperationSubmitStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOperationSubmitStatusResponse getOperationSubmitStatus(shared_ptr<GetOperationSubmitStatusRequest> request);
  GetPhysicalInstanceResponse getPhysicalInstanceWithOptions(shared_ptr<GetPhysicalInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalInstanceResponse getPhysicalInstance(shared_ptr<GetPhysicalInstanceRequest> request);
  GetPhysicalInstanceLogResponse getPhysicalInstanceLogWithOptions(shared_ptr<GetPhysicalInstanceLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalInstanceLogResponse getPhysicalInstanceLog(shared_ptr<GetPhysicalInstanceLogRequest> request);
  GetPhysicalNodeResponse getPhysicalNodeWithOptions(shared_ptr<GetPhysicalNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalNodeResponse getPhysicalNode(shared_ptr<GetPhysicalNodeRequest> request);
  GetPhysicalNodeByOutputNameResponse getPhysicalNodeByOutputNameWithOptions(shared_ptr<GetPhysicalNodeByOutputNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalNodeByOutputNameResponse getPhysicalNodeByOutputName(shared_ptr<GetPhysicalNodeByOutputNameRequest> request);
  GetPhysicalNodeContentResponse getPhysicalNodeContentWithOptions(shared_ptr<GetPhysicalNodeContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalNodeContentResponse getPhysicalNodeContent(shared_ptr<GetPhysicalNodeContentRequest> request);
  GetPhysicalNodeOperationLogResponse getPhysicalNodeOperationLogWithOptions(shared_ptr<GetPhysicalNodeOperationLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetPhysicalNodeOperationLogResponse getPhysicalNodeOperationLog(shared_ptr<GetPhysicalNodeOperationLogRequest> request);
  GetProjectProduceUserResponse getProjectProduceUserWithOptions(shared_ptr<GetProjectProduceUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectProduceUserResponse getProjectProduceUser(shared_ptr<GetProjectProduceUserRequest> request);
  GetQueueEngineVersionByEnvResponse getQueueEngineVersionByEnvWithOptions(shared_ptr<GetQueueEngineVersionByEnvRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQueueEngineVersionByEnvResponse getQueueEngineVersionByEnv(shared_ptr<GetQueueEngineVersionByEnvRequest> request);
  GetSparkLocalClientInfoResponse getSparkLocalClientInfoWithOptions(shared_ptr<GetSparkLocalClientInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSparkLocalClientInfoResponse getSparkLocalClientInfo(shared_ptr<GetSparkLocalClientInfoRequest> request);
  GetSupplementDagrunResponse getSupplementDagrunWithOptions(shared_ptr<GetSupplementDagrunRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSupplementDagrunResponse getSupplementDagrun(shared_ptr<GetSupplementDagrunRequest> request);
  GetSupplementDagrunInstanceResponse getSupplementDagrunInstanceWithOptions(shared_ptr<GetSupplementDagrunInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSupplementDagrunInstanceResponse getSupplementDagrunInstance(shared_ptr<GetSupplementDagrunInstanceRequest> request);
  GetTableColumnLineageByTaskIdResponse getTableColumnLineageByTaskIdWithOptions(shared_ptr<GetTableColumnLineageByTaskIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTableColumnLineageByTaskIdResponse getTableColumnLineageByTaskId(shared_ptr<GetTableColumnLineageByTaskIdRequest> request);
  GetTableLineageByTaskIdResponse getTableLineageByTaskIdWithOptions(shared_ptr<GetTableLineageByTaskIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTableLineageByTaskIdResponse getTableLineageByTaskId(shared_ptr<GetTableLineageByTaskIdRequest> request);
  GetUserBySourceIdResponse getUserBySourceIdWithOptions(shared_ptr<GetUserBySourceIdRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserBySourceIdResponse getUserBySourceId(shared_ptr<GetUserBySourceIdRequest> request);
  GetUserGroupResponse getUserGroupWithOptions(shared_ptr<GetUserGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserGroupResponse getUserGroup(shared_ptr<GetUserGroupRequest> request);
  GetUsersResponse getUsersWithOptions(shared_ptr<GetUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUsersResponse getUsers(shared_ptr<GetUsersRequest> request);
  GrantResourcePermissionResponse grantResourcePermissionWithOptions(shared_ptr<GrantResourcePermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantResourcePermissionResponse grantResourcePermission(shared_ptr<GrantResourcePermissionRequest> request);
  ListAddableRolesResponse listAddableRolesWithOptions(shared_ptr<ListAddableRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAddableRolesResponse listAddableRoles(shared_ptr<ListAddableRolesRequest> request);
  ListAddableUsersResponse listAddableUsersWithOptions(shared_ptr<ListAddableUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAddableUsersResponse listAddableUsers(shared_ptr<ListAddableUsersRequest> request);
  ListAlertEventsResponse listAlertEventsWithOptions(shared_ptr<ListAlertEventsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertEventsResponse listAlertEvents(shared_ptr<ListAlertEventsRequest> request);
  ListAlertNotificationsResponse listAlertNotificationsWithOptions(shared_ptr<ListAlertNotificationsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertNotificationsResponse listAlertNotifications(shared_ptr<ListAlertNotificationsRequest> request);
  ListApiByAppResponse listApiByAppWithOptions(shared_ptr<ListApiByAppRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApiByAppResponse listApiByApp(shared_ptr<ListApiByAppRequest> request);
  ListAuthorizedDataServiceApiDetailsResponse listAuthorizedDataServiceApiDetailsWithOptions(shared_ptr<ListAuthorizedDataServiceApiDetailsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAuthorizedDataServiceApiDetailsResponse listAuthorizedDataServiceApiDetails(shared_ptr<ListAuthorizedDataServiceApiDetailsRequest> request);
  ListBizEntitiesResponse listBizEntitiesWithOptions(shared_ptr<ListBizEntitiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBizEntitiesResponse listBizEntities(shared_ptr<ListBizEntitiesRequest> request);
  ListBizUnitsResponse listBizUnitsWithOptions(shared_ptr<ListBizUnitsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBizUnitsResponse listBizUnits(shared_ptr<ListBizUnitsRequest> request);
  ListDataDomainsResponse listDataDomainsWithOptions(shared_ptr<ListDataDomainsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataDomainsResponse listDataDomains(shared_ptr<ListDataDomainsRequest> request);
  ListDataSourceWithConfigResponse listDataSourceWithConfigWithOptions(shared_ptr<ListDataSourceWithConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourceWithConfigResponse listDataSourceWithConfig(shared_ptr<ListDataSourceWithConfigRequest> request);
  ListFilesResponse listFilesWithOptions(shared_ptr<ListFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListFilesResponse listFiles(shared_ptr<ListFilesRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListNodeDownStreamResponse listNodeDownStreamWithOptions(shared_ptr<ListNodeDownStreamRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodeDownStreamResponse listNodeDownStream(shared_ptr<ListNodeDownStreamRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<ListNodesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<ListNodesRequest> request);
  ListPublishRecordsResponse listPublishRecordsWithOptions(shared_ptr<ListPublishRecordsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPublishRecordsResponse listPublishRecords(shared_ptr<ListPublishRecordsRequest> request);
  ListResourcePermissionOperationLogResponse listResourcePermissionOperationLogWithOptions(shared_ptr<ListResourcePermissionOperationLogRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcePermissionOperationLogResponse listResourcePermissionOperationLog(shared_ptr<ListResourcePermissionOperationLogRequest> request);
  ListResourcePermissionsResponse listResourcePermissionsWithOptions(shared_ptr<ListResourcePermissionsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListResourcePermissionsResponse listResourcePermissions(shared_ptr<ListResourcePermissionsRequest> request);
  ListRowPermissionResponse listRowPermissionWithOptions(shared_ptr<ListRowPermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRowPermissionResponse listRowPermission(shared_ptr<ListRowPermissionRequest> request);
  ListRowPermissionByUserIdResponse listRowPermissionByUserIdWithOptions(shared_ptr<ListRowPermissionByUserIdRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRowPermissionByUserIdResponse listRowPermissionByUserId(shared_ptr<ListRowPermissionByUserIdRequest> request);
  ListSubmitRecordsResponse listSubmitRecordsWithOptions(shared_ptr<ListSubmitRecordsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSubmitRecordsResponse listSubmitRecords(shared_ptr<ListSubmitRecordsRequest> request);
  ListTenantMembersResponse listTenantMembersWithOptions(shared_ptr<ListTenantMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTenantMembersResponse listTenantMembers(shared_ptr<ListTenantMembersRequest> request);
  ListUserGroupMembersResponse listUserGroupMembersWithOptions(shared_ptr<ListUserGroupMembersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserGroupMembersResponse listUserGroupMembers(shared_ptr<ListUserGroupMembersRequest> request);
  ListUserGroupsResponse listUserGroupsWithOptions(shared_ptr<ListUserGroupsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserGroupsResponse listUserGroups(shared_ptr<ListUserGroupsRequest> request);
  OfflineBatchTaskResponse offlineBatchTaskWithOptions(shared_ptr<OfflineBatchTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OfflineBatchTaskResponse offlineBatchTask(shared_ptr<OfflineBatchTaskRequest> request);
  OfflineBizEntityResponse offlineBizEntityWithOptions(shared_ptr<OfflineBizEntityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OfflineBizEntityResponse offlineBizEntity(shared_ptr<OfflineBizEntityRequest> request);
  OnlineBizEntityResponse onlineBizEntityWithOptions(shared_ptr<OnlineBizEntityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OnlineBizEntityResponse onlineBizEntity(shared_ptr<OnlineBizEntityRequest> request);
  OperateInstanceResponse operateInstanceWithOptions(shared_ptr<OperateInstanceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateInstanceResponse operateInstance(shared_ptr<OperateInstanceRequest> request);
  ParseBatchTaskDependencyResponse parseBatchTaskDependencyWithOptions(shared_ptr<ParseBatchTaskDependencyRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ParseBatchTaskDependencyResponse parseBatchTaskDependency(shared_ptr<ParseBatchTaskDependencyRequest> request);
  PausePhysicalNodeResponse pausePhysicalNodeWithOptions(shared_ptr<PausePhysicalNodeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PausePhysicalNodeResponse pausePhysicalNode(shared_ptr<PausePhysicalNodeRequest> request);
  PublishObjectListResponse publishObjectListWithOptions(shared_ptr<PublishObjectListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PublishObjectListResponse publishObjectList(shared_ptr<PublishObjectListRequest> request);
  RemoveTenantMemberResponse removeTenantMemberWithOptions(shared_ptr<RemoveTenantMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTenantMemberResponse removeTenantMember(shared_ptr<RemoveTenantMemberRequest> request);
  RemoveUserGroupMemberResponse removeUserGroupMemberWithOptions(shared_ptr<RemoveUserGroupMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUserGroupMemberResponse removeUserGroupMember(shared_ptr<RemoveUserGroupMemberRequest> request);
  ResumePhysicalNodeResponse resumePhysicalNodeWithOptions(shared_ptr<ResumePhysicalNodeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumePhysicalNodeResponse resumePhysicalNode(shared_ptr<ResumePhysicalNodeRequest> request);
  RevokeResourcePermissionResponse revokeResourcePermissionWithOptions(shared_ptr<RevokeResourcePermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeResourcePermissionResponse revokeResourcePermission(shared_ptr<RevokeResourcePermissionRequest> request);
  StopAdHocTaskResponse stopAdHocTaskWithOptions(shared_ptr<StopAdHocTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopAdHocTaskResponse stopAdHocTask(shared_ptr<StopAdHocTaskRequest> request);
  SubmitBatchTaskResponse submitBatchTaskWithOptions(shared_ptr<SubmitBatchTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitBatchTaskResponse submitBatchTask(shared_ptr<SubmitBatchTaskRequest> request);
  SyncDepartmentResponse syncDepartmentWithOptions(shared_ptr<SyncDepartmentRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncDepartmentResponse syncDepartment(shared_ptr<SyncDepartmentRequest> request);
  SyncDepartmentUserResponse syncDepartmentUserWithOptions(shared_ptr<SyncDepartmentUserRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncDepartmentUserResponse syncDepartmentUser(shared_ptr<SyncDepartmentUserRequest> request);
  UpdateAdHocFileResponse updateAdHocFileWithOptions(shared_ptr<UpdateAdHocFileRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAdHocFileResponse updateAdHocFile(shared_ptr<UpdateAdHocFileRequest> request);
  UpdateBatchTaskResponse updateBatchTaskWithOptions(shared_ptr<UpdateBatchTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBatchTaskResponse updateBatchTask(shared_ptr<UpdateBatchTaskRequest> request);
  UpdateBatchTaskUdfLineagesResponse updateBatchTaskUdfLineagesWithOptions(shared_ptr<UpdateBatchTaskUdfLineagesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBatchTaskUdfLineagesResponse updateBatchTaskUdfLineages(shared_ptr<UpdateBatchTaskUdfLineagesRequest> request);
  UpdateBizEntityResponse updateBizEntityWithOptions(shared_ptr<UpdateBizEntityRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBizEntityResponse updateBizEntity(shared_ptr<UpdateBizEntityRequest> request);
  UpdateBizUnitResponse updateBizUnitWithOptions(shared_ptr<UpdateBizUnitRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBizUnitResponse updateBizUnit(shared_ptr<UpdateBizUnitRequest> request);
  UpdateDataDomainResponse updateDataDomainWithOptions(shared_ptr<UpdateDataDomainRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataDomainResponse updateDataDomain(shared_ptr<UpdateDataDomainRequest> request);
  UpdateDataSourceBasicInfoResponse updateDataSourceBasicInfoWithOptions(shared_ptr<UpdateDataSourceBasicInfoRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceBasicInfoResponse updateDataSourceBasicInfo(shared_ptr<UpdateDataSourceBasicInfoRequest> request);
  UpdateDataSourceConfigResponse updateDataSourceConfigWithOptions(shared_ptr<UpdateDataSourceConfigRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDataSourceConfigResponse updateDataSourceConfig(shared_ptr<UpdateDataSourceConfigRequest> request);
  UpdateFileDirectoryResponse updateFileDirectoryWithOptions(shared_ptr<UpdateFileDirectoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileDirectoryResponse updateFileDirectory(shared_ptr<UpdateFileDirectoryRequest> request);
  UpdateFileNameResponse updateFileNameWithOptions(shared_ptr<UpdateFileNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileNameResponse updateFileName(shared_ptr<UpdateFileNameRequest> request);
  UpdateRowPermissionResponse updateRowPermissionWithOptions(shared_ptr<UpdateRowPermissionRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRowPermissionResponse updateRowPermission(shared_ptr<UpdateRowPermissionRequest> request);
  UpdateTenantMemberResponse updateTenantMemberWithOptions(shared_ptr<UpdateTenantMemberRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTenantMemberResponse updateTenantMember(shared_ptr<UpdateTenantMemberRequest> request);
  UpdateUserGroupResponse updateUserGroupWithOptions(shared_ptr<UpdateUserGroupRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserGroupResponse updateUserGroup(shared_ptr<UpdateUserGroupRequest> request);
  UpdateUserGroupSwitchResponse updateUserGroupSwitchWithOptions(shared_ptr<UpdateUserGroupSwitchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserGroupSwitchResponse updateUserGroupSwitch(shared_ptr<UpdateUserGroupSwitchRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Dataphin-public20230630

#endif
